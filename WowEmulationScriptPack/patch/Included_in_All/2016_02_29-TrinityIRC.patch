From d11398f2600edc545d2ecb9532aca080347925a4 Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Mon, 29 Feb 2016 09:42:59 -0600
Subject: [PATCH] 2016_02_29-TrinityIRC

---
 .../TriniIRC/World_TrinityChat.sql                 |   81 +
 src/server/game/CMakeLists.txt                     |    3 +
 src/server/game/Chat/Channels/Channel.cpp          |    4 +
 src/server/game/Chat/Chat.cpp                      |   40 +
 src/server/game/Chat/Chat.h                        |    3 +
 src/server/game/Entities/Player/Player.cpp         |   22 +
 src/server/game/Entities/Player/Player.h           |    3 +-
 src/server/game/Events/GameEventMgr.cpp            |    7 +
 src/server/game/Handlers/AuctionHouseHandler.cpp   |    4 +-
 src/server/game/Handlers/ChatHandler.cpp           |    3 +-
 src/server/game/TriniChat/IRCClient.cpp            |  135 ++
 src/server/game/TriniChat/IRCClient.h              |  291 +++
 src/server/game/TriniChat/IRCCmd.cpp               |  857 +++++++
 src/server/game/TriniChat/IRCCmd.h                 |  144 ++
 src/server/game/TriniChat/IRCCmde.cpp              | 2353 ++++++++++++++++++++
 src/server/game/TriniChat/IRCFunc.h                |  292 +++
 src/server/game/TriniChat/IRCIO.cpp                |  529 +++++
 src/server/game/TriniChat/IRCLog.cpp               |   81 +
 src/server/game/TriniChat/IRCLog.h                 |   40 +
 src/server/game/TriniChat/IRCSock.cpp              |  160 ++
 src/server/game/TriniChat/MCS_OnlinePlayers.cpp    |   94 +
 src/server/game/TriniChat/MCS_OnlinePlayers.h      |   38 +
 src/server/game/World/World.cpp                    |  190 +-
 src/server/game/World/World.h                      |    4 +
 src/server/scripts/CMakeLists.txt                  |    1 +
 src/server/scripts/Commands/cs_message.cpp         |   20 +
 src/server/worldserver/CMakeLists.txt              |    5 +
 src/server/worldserver/CommandLine/CliRunnable.cpp |    9 +
 src/server/worldserver/Main.cpp                    |   35 +
 src/server/worldserver/worldserver.conf.dist       |  278 ++-
 30 files changed, 5719 insertions(+), 7 deletions(-)
 create mode 100644 sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql
 create mode 100644 src/server/game/TriniChat/IRCClient.cpp
 create mode 100644 src/server/game/TriniChat/IRCClient.h
 create mode 100644 src/server/game/TriniChat/IRCCmd.cpp
 create mode 100644 src/server/game/TriniChat/IRCCmd.h
 create mode 100644 src/server/game/TriniChat/IRCCmde.cpp
 create mode 100644 src/server/game/TriniChat/IRCFunc.h
 create mode 100644 src/server/game/TriniChat/IRCIO.cpp
 create mode 100644 src/server/game/TriniChat/IRCLog.cpp
 create mode 100644 src/server/game/TriniChat/IRCLog.h
 create mode 100644 src/server/game/TriniChat/IRCSock.cpp
 create mode 100644 src/server/game/TriniChat/MCS_OnlinePlayers.cpp
 create mode 100644 src/server/game/TriniChat/MCS_OnlinePlayers.h

diff --git a/sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql b/sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql
new file mode 100644
index 0000000..48dd18e
--- /dev/null
+++ b/sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql
@@ -0,0 +1,81 @@
+/**
+* Table structure for irc_commands
+*/
+DROP TABLE IF EXISTS `irc_commands`;
+CREATE TABLE `irc_commands` (
+  `Command` varchar(10) NOT NULL default '',
+  `Description` varchar(350) default NULL,
+  `gmlevel` tinyint(3) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`Command`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='IRC Module System';
+
+/**
+* Records
+*/
+INSERT INTO `irc_commands` VALUES ('acct', '[acct <Player> <(un)lock/email/pass/rename/gmlevel>] : Perform Action To <Player> Account.', '3');
+INSERT INTO `irc_commands` VALUES ('ban', '[ban <Player/IP> <ip/acct/unban/reason>] : Ban/Unban <Player>', '3');
+INSERT INTO `irc_commands` VALUES ('chan', '[chan <op/deop/voice/devoice> <*IRC Nick*>] : Set Mode On Yourself, If <IRC Nick> Is Specified Then Set mode On Nick.', '3');
+INSERT INTO `irc_commands` VALUES ('char', '[char <Player> <mailcheat/taxicheat/maxskill/setskill/combatstop/quest/mod>] : Perform Action To Character.', '3');
+INSERT INTO `irc_commands` VALUES ('fun', '[fun <Player> <Sound/Say>] : Do Selected Fun Action To <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('help', '[help Command] : Use No Paramaters For List Of Available Commands.', '0');
+INSERT INTO `irc_commands` VALUES ('inchan', '[inchan <Channel>] : Display Users In Selected In Game <Channel>', '0');
+INSERT INTO `irc_commands` VALUES ('info', '[info] : Display Server Info. (Number Of Players Online/Max Since Last Restart/Uptime)', '0');
+INSERT INTO `irc_commands` VALUES ('item', '[item <Player> <add> <ItemID/[ItemName]> <Amount>] : Additem To <Player>, Use <ItemID> Or <[Exact Item Name]>.', '3');
+INSERT INTO `irc_commands` VALUES ('jail', '[jail <Player> <release/Reason>] : Jail Selected <Player> For <Reason>. Using release As <Reason> Releases Player.', '3');
+INSERT INTO `irc_commands` VALUES ('kick', '[kick <Player> <Reason>] : Kick <Player> For <Reason>.', '3');
+INSERT INTO `irc_commands` VALUES ('kill', '[kill <Player> <Reason>] : Kill <Player> For <Reason>.', '3');
+INSERT INTO `irc_commands` VALUES ('level', '[level <Player> <NewLevel>] : Level <Player> To <NewLevel>. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('login', '[login <UserName> <Password>] : Login To TriniChat Admin Mode.  (Must Be Done In A PM)', '0');
+INSERT INTO `irc_commands` VALUES ('logout', '[logout] : Logout Of TriniChat Admin Mode.', '0');
+INSERT INTO `irc_commands` VALUES ('lookup', '[lookup <acct/char/creature/faction/go/item/quest/skill/spell/tele> <ID/Name>] : ', '3');
+INSERT INTO `irc_commands` VALUES ('money', '[money <Player> <(-)Money>] : Give Money To <Player>, Use - To Take Money. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('mute', '[mute <Player> <release/TimeInMins> <Reason>] : Mute Player For Reason, For <TimeInMins>. Using release As Time Releases Player. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('online', '[online] : Display All Users Logged In Game.', '0');
+INSERT INTO `irc_commands` VALUES ('pm', '[pm <Player> <Message>] : Whisper <Player> In WoW <Message>.', '3');
+INSERT INTO `irc_commands` VALUES ('reload', '[reload] : Reload TriniChat Config Options And Security Level From DataBase.', '3');
+INSERT INTO `irc_commands` VALUES ('restart', '[restart] : Restart TriniChat, NOT Trinity Core World Server Itself. Forces Reconnection To IRC Server.', '3');
+INSERT INTO `irc_commands` VALUES ('revive', '[revive <Player>] : Revive <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('saveall', '[saveall] : Forces Trinity Core To Save All Players.', '3');
+INSERT INTO `irc_commands` VALUES ('server', '[server setmotd [<motd>]/flusharenapoints]', '3');
+INSERT INTO `irc_commands` VALUES ('shutdown', '[shutdown <TimeInSeconds>] : Shuts The Server Down In <TimeInSeconds>, Use 0 For Immediate Shut Down', '3');
+INSERT INTO `irc_commands` VALUES ('spell', '[spell <Player> <Cast/Learn/UnLearn> <SpellID>] : Make <Player> <Learn> Or <UnLearn> A Spell, Or <Cast> A Spell On A <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('sysmsg', '[sysmsg <a/n/e/add/del/list> <Message>] : Broadcasts A System Message. (a-Broadcast System Message)(n-Broadcast Notify Message)(e-Event Message)', '3');
+INSERT INTO `irc_commands` VALUES ('tele', '[tele <Player> <l/c/r/to/cr/go/homebind> <Loc.Name/MAPID X Y Z/Recall/Player/Creature GUID/Gameobject GUID>] : Teleport Player To Location, Coords, Recall Location, Another Player, Creature or Gameobject. (l-Location)(c-Coords)', '3');
+INSERT INTO `irc_commands` VALUES ('top', '[top <accttime/chartime/money> <limit>] : Display top stats for given option. Only GM Higher Than Config Option Can Use Limit.', '3');
+INSERT INTO `irc_commands` VALUES ('who', '[who] : Displays Users Currently Logged In To TriniChat.', '1');
+
+/**
+* Table structure for irc_inchan
+*/
+DROP TABLE IF EXISTS `irc_inchan`;
+CREATE TABLE `irc_inchan` (
+  `guid` int(11) unsigned NOT NULL default '0' COMMENT 'Global Unique Identifier',
+  `name` varchar(12) NOT NULL default '',
+  `channel` varchar(15) NOT NULL default '',
+  PRIMARY KEY  (`guid`,`channel`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='IRC Module System';
+
+/**
+* Records
+*/
+
+/**
+* Table structure for irc_autoannounce
+*/
+DROP TABLE IF EXISTS `irc_autoannounce`;
+CREATE TABLE `irc_autoannounce` (
+  `id` int(11) NOT NULL auto_increment,
+  `message` longtext NOT NULL,
+  `addedby` varchar(12) NOT NULL default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='IRC Module System';
+
+/**
+* Records
+*/
+INSERT INTO `irc_autoannounce` VALUES ('1', 'Welcome to IRC Channel', '');
+
+DELETE FROM `trinity_string` WHERE entry IN (6610,6611,6612);
+INSERT INTO `trinity_string` VALUES ('6610', '|cffff0000[System Message]: %s|r', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('6611', '|cffff0000[Server Event]: %s|r', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('6612', '|cffff0000[Automatic]: %s|r', null, null, null, null, null, null, null, null);
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 4d41fbc..31057e8 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -46,6 +46,7 @@ file(GLOB_RECURSE sources_Spells Spells/*.cpp Spells/*.h)
 file(GLOB_RECURSE sources_Texts Texts/*.cpp Texts/*.h)
 file(GLOB_RECURSE sources_Tools Tools/*.cpp Tools/*.h)
 file(GLOB_RECURSE sources_Tickets Tickets/*.cpp Tickets/*.h)
+file(GLOB_RECURSE sources_TriniChat TriniChat/*.cpp TriniChat/*.h)
 file(GLOB_RECURSE sources_Warden Warden/*.cpp Warden/*.h)
 file(GLOB_RECURSE sources_Weather Weather/*.cpp Weather/*.h)
 file(GLOB_RECURSE sources_World World/*.cpp World/*.h)
@@ -95,6 +96,7 @@ set(game_STAT_SRCS
   ${sources_Skills}
   ${sources_Spells}
   ${sources_Texts}
+  ${sources_TriniChat}
   ${sources_Tools}
   ${sources_Tickets}
   ${sources_Warden}
@@ -168,6 +170,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Texts
   ${CMAKE_CURRENT_SOURCE_DIR}/Tickets
   ${CMAKE_CURRENT_SOURCE_DIR}/Tools
+  ${CMAKE_CURRENT_SOURCE_DIR}/TriniChat
   ${CMAKE_CURRENT_SOURCE_DIR}/Warden
   ${CMAKE_CURRENT_SOURCE_DIR}/Warden/Modules
   ${CMAKE_CURRENT_SOURCE_DIR}/Weather
diff --git a/src/server/game/Chat/Channels/Channel.cpp b/src/server/game/Chat/Channels/Channel.cpp
index 0875cee..7d1a183 100644
--- a/src/server/game/Chat/Channels/Channel.cpp
+++ b/src/server/game/Chat/Channels/Channel.cpp
@@ -24,6 +24,7 @@
 #include "DatabaseEnv.h"
 #include "AccountMgr.h"
 #include "Player.h"
+#include "IRCClient.h"
 
 Channel::Channel(std::string const& name, uint32 channelId, uint32 team):
     _announce(true),
@@ -209,6 +210,8 @@ void Channel::JoinChannel(Player* player, std::string const& pass)
 
     JoinNotify(guid);
 
+    sIRC->Handle_WoW_Channel(_name, ObjectAccessor::FindPlayer(guid), CHANNEL_JOIN);
+
     // Custom channel handling
     if (!IsConstant())
     {
@@ -259,6 +262,7 @@ void Channel::LeaveChannel(Player* player, bool send)
         SendToAll(&data);
     }
 
+    sIRC->Handle_WoW_Channel(_name, ObjectAccessor::FindPlayer(guid), CHANNEL_LEAVE);
     LeaveNotify(guid);
 
     if (!IsConstant())
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index aa0f6ce..b1f09dd 100644
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -312,6 +312,14 @@ bool ChatHandler::ExecuteCommandInTable(std::vector<ChatCommand> const& table, c
                     areaId, areaName.c_str(), zoneName.c_str(),
                     (player->GetSelectedUnit()) ? player->GetSelectedUnit()->GetName().c_str() : "",
                     guid.ToString().c_str());
+                if ((sIRC->logmask & 2) != 0)
+                    {
+                        std::string logchan = "#";
+                        logchan += sIRC->logchan;
+                        std::stringstream ss;
+                        ss << sIRC->iLog.GetLogDateTimeStr() << ": [ " << player->GetName() << "(" << GetSession()->GetSecurity() << ") ] Used Command: [ " << fullcmd << " ] Target Guid: [" << guid.ToString().c_str() << "]";
+                        sIRC->Send_IRC_Channel(logchan,ss.str().c_str(), true, "LOG");
+                    }
             }
         }
         // some commands have custom error messages. Don't send the default one in these cases.
@@ -859,6 +867,38 @@ char* ChatHandler::extractKeyFromLink(char* text, char const* const* linkTypes,
     return NULL;
 }
 
+char const *fmtstring(char const *format, ...)
+{
+    va_list        argptr;
+    #define    MAX_FMT_STRING    32000
+    static char        temp_buffer[MAX_FMT_STRING];
+    static char        string[MAX_FMT_STRING];
+    static int        index = 0;
+    char    *buf;
+    int len;
+
+    va_start(argptr, format);
+    vsnprintf(temp_buffer,MAX_FMT_STRING, format, argptr);
+    va_end(argptr);
+
+    len = strlen(temp_buffer);
+
+    if (len >= MAX_FMT_STRING)
+        return "ERROR";
+
+    if (len + index >= MAX_FMT_STRING-1)
+    {
+        index = 0;
+    }
+
+    buf = &string[index];
+    memcpy(buf, temp_buffer, len+1);
+
+    index += len + 1;
+
+    return buf;
+}
+
 GameObject* ChatHandler::GetNearbyGameObject()
 {
     if (!m_session)
diff --git a/src/server/game/Chat/Chat.h b/src/server/game/Chat/Chat.h
index 7ce0792..dcbf0a5 100644
--- a/src/server/game/Chat/Chat.h
+++ b/src/server/game/Chat/Chat.h
@@ -23,6 +23,7 @@
 #include "StringFormat.h"
 #include "WorldSession.h"
 #include "RBAC.h"
+#include "../TriniChat/IRCClient.h"
 
 #include <vector>
 
@@ -182,4 +183,6 @@ class CliHandler : public ChatHandler
         Print* m_print;
 };
 
+char const *fmtstring(char const *format, ...);
+
 #endif
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 7190a80..e5d1343 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -32,6 +32,7 @@
 #include "ChannelMgr.h"
 #include "CharacterDatabaseCleaner.h"
 #include "Chat.h"
+#include "IRCClient.h"
 #include "Common.h"
 #include "ConditionMgr.h"
 #include "CreatureAI.h"
@@ -2705,6 +2706,15 @@ void Player::UninviteFromGroup()
             delete group;
         }
     }
+  //TODO: FIXME
+    if (sIRC->ajoin == 1)
+    {
+        QueryResult result = WorldDatabase.PQuery("SELECT `name` FROM `irc_inchan` WHERE `name` = '%s'", GetName().c_str());
+        if (!result)
+        {
+            sIRC->AutoJoinChannel(this);
+        }
+    }
 }
 
 void Player::RemoveFromGroup(Group* group, ObjectGuid guid, RemoveMethod method /* = GROUP_REMOVEMETHOD_DEFAULT*/, ObjectGuid kicker /* = ObjectGuid::Empty */, const char* reason /* = NULL */)
@@ -2842,6 +2852,17 @@ void Player::GiveLevel(uint8 level)
     InitTaxiNodesForLevel();
     InitGlyphsForLevel();
 
+  if ((sIRC->BOTMASK & 64) != 0 && sIRC->Status.size() > 0)
+    {
+        char  temp [5];
+        sprintf(temp, "%u", level);
+        std::string plevel = temp;
+        std::string pname = GetName();
+        std::string ircchan = "#";
+        ircchan += sIRC->Status;
+        sIRC->Send_IRC_Channel(ircchan, "\00311["+pname+"] : Has Reached Level: "+plevel, true);
+    }
+
     UpdateAllStats();
 
     if (sWorld->getBoolConfig(CONFIG_ALWAYS_MAXSKILL)) // Max weapon skill when leveling up
@@ -20501,6 +20522,7 @@ void Player::PetSpellInitialize()
     //Cooldowns
     pet->GetSpellHistory()->WritePacket<Pet>(data);
 
+
     GetSession()->SendPacket(&data);
 }
 
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index f59994d..931528d 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -2621,7 +2621,8 @@ class Player : public Unit, public GridObject<Player>
         // 32
         // 33
         // 34
-        // 35
+    public :
+        QuestStatusSaveMap m_RewardedQuestsSave2;
         // 36
         // 37
         // 38
diff --git a/src/server/game/Events/GameEventMgr.cpp b/src/server/game/Events/GameEventMgr.cpp
index 79584c6..3ca1ebe 100644
--- a/src/server/game/Events/GameEventMgr.cpp
+++ b/src/server/game/Events/GameEventMgr.cpp
@@ -28,6 +28,7 @@
 #include "BattlegroundMgr.h"
 #include "UnitAI.h"
 #include "GameObjectAI.h"
+#include "IRCClient.h"
 
 bool GameEventMgr::CheckOneGameEvent(uint16 entry) const
 {
@@ -1087,6 +1088,12 @@ void GameEventMgr::ApplyNewEvent(uint16 event_id)
     uint8 announce = mGameEvent[event_id].announce;
     if (announce == 1 || (announce == 2 && sWorld->getBoolConfig(CONFIG_EVENT_ANNOUNCE)))
         sWorld->SendWorldText(LANG_EVENTMESSAGE, mGameEvent[event_id].description.c_str());
+       if ((sIRC->BOTMASK & 256) != 0 && sIRC->anchn.size() > 0)
+             {
+                 std::string ircchan = "#";
+                 ircchan += sIRC->anchn;
+                 sIRC->Send_IRC_Channel(ircchan, sIRC->MakeMsg("\00304,08\037/!\\\037\017\00304 Game Event \00304,08\037/!\\\037\017 %s", "%s", mGameEvent[event_id].description.c_str()), true);
+             }
 
     TC_LOG_INFO("gameevent", "GameEvent %u \"%s\" started.", event_id, mGameEvent[event_id].description.c_str());
 
diff --git a/src/server/game/Handlers/AuctionHouseHandler.cpp b/src/server/game/Handlers/AuctionHouseHandler.cpp
index efe0526..4e744dc 100644
--- a/src/server/game/Handlers/AuctionHouseHandler.cpp
+++ b/src/server/game/Handlers/AuctionHouseHandler.cpp
@@ -28,6 +28,7 @@
 #include "UpdateMask.h"
 #include "Util.h"
 #include "AccountMgr.h"
+#include "IRCClient.h"
 
 //void called when player click on auctioneer npc
 void WorldSession::HandleAuctionHelloOpcode(WorldPacket& recvData)
@@ -597,7 +598,8 @@ void WorldSession::HandleAuctionRemoveItem(WorldPacket& recvData)
     SendAuctionCommandResult(auction->Id, AUCTION_CANCEL, ERR_AUCTION_OK);
 
     // Now remove the auction
-
+    uint32 item;
+    recvData >> item;
     player->SaveInventoryAndGoldToDB(trans);
     auction->DeleteFromDB(trans);
     CharacterDatabase.CommitTransaction(trans);
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index f7fd9c8..4bcbbe8 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -41,7 +41,7 @@
 // Prepatch by LordPsyan
 // 61
 // 62
-// 63
+#include "IRCClient.h"
 // 64
 // 65
 // 66
@@ -453,6 +453,7 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 
             if (ChannelMgr* cMgr = ChannelMgr::forTeam(sender->GetTeam()))
             {
+                sIRC->Send_WoW_IRC(sender, channel, msg);
                 if (Channel* chn = cMgr->GetChannel(channel, sender))
                 {
                     sScriptMgr->OnPlayerChat(sender, type, lang, msg, chn);
diff --git a/src/server/game/TriniChat/IRCClient.cpp b/src/server/game/TriniChat/IRCClient.cpp
new file mode 100644
index 0000000..3c4b643
--- /dev/null
+++ b/src/server/game/TriniChat/IRCClient.cpp
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "MapManager.h"
+#include "Player.h"
+
+#ifdef WIN32
+    #define Delay(x) Sleep(x)
+#else
+    #define Delay(x) sleep(x / 1000)
+#endif
+// IRCClient Constructor
+IRCClient::IRCClient()
+{
+    for (int i = 0;i > 5;i++)
+        sIRC->Script_Lock[i] = false;
+}
+// IRCClient Destructor
+IRCClient::~IRCClient(){}
+
+void TrinityChatThread()
+{
+    //call irc bot
+    IRCClient* a = nullptr;
+    // run the bot within a thread
+    a->run();
+}
+
+// ZThread Entry This function is called when the thread is created in Master.cpp (trinitycore)
+void IRCClient::run()
+{
+//    iLog.WriteLog(" %s : ****** TrinityCore With TriniChat Has Been Started ******", iLog.GetLogDateTimeStr().c_str());
+
+    // before we begin we wait a few
+    // mangos is still starting up.
+    std::this_thread::sleep_for(std::chrono::milliseconds(500));
+    std::stringstream ss(sIRC->_bot_names);
+    string temp = "";
+    uint8 counter = 0;
+    for(uint8 i=0;i<sIRC->_bot_names.length();i++)
+    {
+        if(sIRC->_bot_names[i] == ',')
+        {
+            sIRC->_ignore_bots[counter] = temp;
+            temp = "";
+            counter++;
+        }
+        else
+        {
+            temp += sIRC->_bot_names[i];
+        }
+    }
+    // check for hanging name
+    sIRC->_ignore_bots[counter] = temp;
+    TC_LOG_INFO("server.loading", ">> TrinityChat Ignore Bots set.");
+    TC_LOG_ERROR("misc", "\n%s\n%s\n%s\n%s",
+        "***************************************",
+        "**   TriniChat2 Threaded IRC Client   **",
+        "**     With Enhanced GM Control.     **",
+        "***************************************");
+    TC_LOG_ERROR("misc", "****** TriniChat: %s ********", sIRC->_Mver.c_str());
+    int cCount = 1;
+    // Clean Up MySQL Tables
+    TC_LOG_ERROR("misc", "*** TriniChat: Cleaning Up Inchan Table*");
+    WorldDatabase.PExecute("DELETE FROM `irc_inchan`");
+    sIRC->_Max_Script_Inst = 0;
+    // Create a loop to keep the thread running untill active is set to false
+    while (sIRC->Active && !World::IsStopped())
+    {
+        // Initialize socket library
+        if (this->InitSock())
+        {
+            // Connect To The IRC Server
+            TC_LOG_ERROR("misc", "*** TriniChat: Connecting to %s Try # %d ******", sIRC->_Host.c_str(), cCount);
+           if (this->Connect(sIRC->_Host.c_str(), sIRC->_Port))
+           {
+               // On connection success reset the connection counter
+               cCount = 0;
+               TC_LOG_ERROR("misc", "*** TriniChat: Connected And Logging In*");
+                // Login to the IRC server
+                if (this->Login(sIRC->_Nick, sIRC->_User, sIRC->_Pass))
+                {
+                    TC_LOG_ERROR("misc", "*** TriniChat: Logged In And Running!! *");
+                    // While we are connected to the irc server keep listening for data on the socket
+                    while (sIRC->Connected && !World::IsStopped()){ sIRC->SockRecv(); }
+                }
+                TC_LOG_ERROR("misc", "*** TriniChat: Connection To IRC Server Lost! ***");
+            }
+            // When an error occures or connection lost cleanup
+            Disconnect();
+            // Increase the connection counter
+            cCount++;
+            // if MAX_CONNECT_ATTEMPT is reached stop trying
+            if (sIRC->_MCA != 0 && cCount == sIRC->_MCA)
+                sIRC->Active = false;
+            // If we need to reattempt a connection wait WAIT_CONNECT_TIME milli seconds before we try again
+            if (sIRC->Active)
+            {
+                std::this_thread::sleep_for(std::chrono::milliseconds(_wct));
+            }
+        }
+        else
+        {
+            // Socket could not initialize cancel
+            sIRC->Active = false;
+            TC_LOG_ERROR("misc", "** TriniChat: Could not initialize socket");
+        }
+    }
+    while (!World::IsStopped()){};
+}
+
+std::string IRCClient::GetChatLine(int nItem)
+{
+    return sIRC->ILINES[nItem];
+}
diff --git a/src/server/game/TriniChat/IRCClient.h b/src/server/game/TriniChat/IRCClient.h
new file mode 100644
index 0000000..a2e9327
--- /dev/null
+++ b/src/server/game/TriniChat/IRCClient.h
@@ -0,0 +1,291 @@
+/*
+* Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+*
+* Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#ifndef _IRC_CLIENT_H
+#define _IRC_CLIENT_H
+
+#include <boost/asio/io_service.hpp>
+#include <boost/asio/strand.hpp>
+#include "boost/thread.hpp"
+//#include "Player.h"
+#include "IRCLog.h"
+#include "IRCCmd.h"
+
+using namespace std;
+// The maximum ammount of channels used, must be >= config option
+#define MAX_CONF_CHANNELS 10
+#define MAX_CHAT_LINES 10
+#define MAX_CONF_BOTS 10
+// time we need to wait before we try another connecton attempt
+// Default is 30 seconds
+#define MAX_SCRIPT_INST 10
+// CLINES is used for the default chatlines
+// By using the GetChatLine function its easier and faster
+// to receieve the line you need.
+enum CLINES
+{
+    IRC_WOW = 0,
+    WOW_IRC = 1,
+    JOIN_WOW = 2,
+    JOIN_IRC = 3,
+    LEAVE_WOW = 4,
+    LEAVE_IRC = 5,
+    CHANGE_NICK = 6
+};
+// CACTION is used by the Handle_WoW_Channel function
+// this function is called in channel.h when a player
+// joins or leave a channel inside the client.
+enum CACTION
+{
+    CHANNEL_JOIN,
+    CHANNEL_LEAVE,
+};
+
+enum script_Names
+{
+    MCS_Players_Online = 0,
+};
+
+void TrinityChatThread();
+
+// IRCClient main class
+class IRCClient
+{
+
+public:
+    // IRCClient Constructor
+    IRCClient();
+    // IRCClient Destructor
+    ~IRCClient();
+    // ZThread Entry
+    void run();
+    static IRCClient* instance(boost::asio::io_service* ioService = nullptr)
+    {
+        static IRCClient instance;
+
+        if (ioService != nullptr)
+        {
+            instance._ioService = ioService;
+            instance._strand = new boost::asio::strand(*ioService);
+        }
+
+        return &instance;
+    }
+    // Send a message to the specified IRC channel
+    void Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix = false, std::string nType = "PRIVMSG");
+public:
+    // AH Function
+    void AHCancel(uint64 itmid, std::string itmnme, std::string plname, uint32 faction);
+    //bool BeenToGMI(float posx, float posy, std::string player, std::string from);
+    // IRCClient active
+    bool Active;
+    // Connected to IRC
+    bool Connected;
+    // Socket indentifier
+    int SOCKET;
+    fd_set sfdset;
+    // Send data to IRC, in addition the endline is added \n
+    bool SendIRC(std::string data);
+    // This function is called in ChatHandler.cpp and processes the chat from game to IRC
+    void Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg);
+    // Sends a message to all players on the specified channel
+    void Send_WoW_Channel(const char *channel, std::string chat);
+    // Send a system message to all players
+    void Send_WoW_System(std::string Message);
+    // Send a message to the specified IRC channel
+    //void Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix = false, std::string nType = "PRIVMSG");
+    // Sends a message to all IRC Channels
+    void Send_IRC_Channels(std::string sMsg);
+    std::string MakeMsg(std::string msg, std::string var, std::string val)
+    {
+        std::size_t start = msg.find(var);
+        if (start != std::string::npos)
+            msg.replace(start, var.length(), val);
+        return msg;
+    }
+    void Send_WoW_Player(string sPlayer, string sMsg);
+    void Send_WoW_Player(Player *plr, string sMsg);
+
+    // This function is called in Channel.cpp and processes Join/leave messages
+    void Handle_WoW_Channel(std::string Channel, Player *plr, int nAction);
+    void ResetIRC();
+public:
+    void AutoJoinChannel(Player *plr);
+
+public:
+    bool Script_Lock[5];
+    bool _AmiOp;
+
+public:
+    string _Mver;
+    // IRC Server host
+    string _Host;
+    // IRC Server Port
+    int _Port;
+    // IRC Username
+    string _User;
+    // IRC Password
+    string _Pass;
+    // IRC Nickname
+    string _Nick;
+    //Password for in-game channel
+    std::string _irc_pass[MAX_CONF_CHANNELS];
+    // Authentication type
+    int _Auth;
+    string _Auth_Nick;
+    // IRC Connect code
+    string _ICC;
+    // IRC Default channel
+    string _defchan;
+    // IRC Leave Default channel
+    int _ldefc;
+    // Wait Connect Time
+    int _wct;
+    // Check if staff chat is enabled
+    int _staffLink;
+    // IRC Default Staff channel
+    string _staffChan;
+    // String that contains bot names
+    string _bot_names;
+    // Number of bots to ignore
+    string _ignore_bots[MAX_CONF_BOTS];
+    // Ticket Channel
+    string ticann;
+    // Ticket Channel Password
+    string ticannpw;
+    // Status Channel
+    string Status;
+    // Status Channel Password
+    string Statuspw;
+    // Announce Channel
+    string anchn;
+    // Announce Channel Password
+    string anchnpw;
+    // Auto-announce timer
+    int autoanc;
+    // IRC Channel count
+    int _chan_count;
+    // IRC Channel list
+    // Array to store our IRC channels
+    // each element will corrospond
+    // with _wow_chan array below.
+    std::string _irc_chan[MAX_CONF_CHANNELS];
+    // Game Channel list
+    std::string _wow_chan[MAX_CONF_CHANNELS];
+    // AutoJoin Options
+    int ajoin;
+    string ajchan;
+    // Online Command Max Results
+    int onlrslt;
+    // Channel OnJoin/Restart/Kick Messages
+    string JoinMsg;
+    string RstMsg;
+    string kikmsg;
+    // Misc Options
+    string ojGM1;
+    string ojGM2;
+    string ojGM3;
+    string ojGM4;
+    string logfile;
+    string logchan;
+    string logchanpw;
+    int logmask;
+    int games;
+    int gmlog;
+    // IRC Commands Security Level
+    int CACCT;
+    int CBAN;
+    int CCHAN;
+    int CCHAR;
+    int CFUN;
+    int CHELP;
+    int CINCHAN;
+    int CINFO;
+    int CITEM;
+    int CJAIL;
+    int CKICK;
+    int _KILL;
+    int CLEVEL;
+    int CLOOKUP;
+    int CMONEY;
+    int CMUTE;
+    int CONLINE;
+    int CPM;
+    int CRECONNECT;
+    int CRELOAD;
+    int CREVIVE;
+    int CSAVEALL;
+    int CSERVERCMD;
+    int CSHUTDOWN;
+    int CSPELL;
+    int CSYSMSG;
+    int CTELE;
+    int CTOP;
+    int CPLAYER;
+    int CWHO;
+    // BotMask
+    int BOTMASK;
+    // TicketMask
+    int TICMASK;
+    // Max connect attempt
+    int _MCA;
+    // Auto rejoin when kicked from irc
+    int _autojoinkick;
+    // IRC Command prefix
+    string _cmd_prefx;
+    int _op_gm;
+    int _op_gm_lev;
+    // Array that contains our chatlines from the conf file
+    // To increase this value change the MAX_CHAT_LINE define above
+    // Make sure the number of elements must match your items
+    // (remeber this starts at 0 so 0..9 is 10 items)
+    // and that you load the line in the LoadConfig function.
+    string ILINES[MAX_CHAT_LINES];
+    string GetChatLine(int nItem);
+
+    int _Max_Script_Inst;
+    // MAX_SCRIPT_INST
+
+    IRCLog iLog;
+
+private:
+    // Returns default chatline based on enum CLINES
+    // Initialize socket library
+    bool InitSock();
+    // Connect to IRC Server
+    bool Connect(const char *cHost, int nPort);
+    // Login to IRC Server
+    bool Login(std::string sNick, std::string sUser, std::string sPass);
+    // Send raw data to IRC
+    bool SendData(const char *data);
+    // Disconnect from IRC and cleanup socket
+    void Disconnect();
+    // Processes the data receieved from IRC
+    void Handle_IRC(std::string sData);
+    // Receieves data from the socket.
+    void SockRecv();
+
+    // add boost ioservice
+    boost::asio::io_service* _ioService;
+    boost::asio::strand* _strand;
+};
+
+#define sIRC IRCClient::instance()
+#endif
diff --git a/src/server/game/TriniChat/IRCCmd.cpp b/src/server/game/TriniChat/IRCCmd.cpp
new file mode 100644
index 0000000..260dee9
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmd.cpp
@@ -0,0 +1,857 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCCmd.h"
+#include "IRCClient.h"
+#include "Database/DatabaseEnv.h"
+#include "ObjectMgr.h"
+#include "AccountMgr.h"
+#include "MapManager.h"
+#include "World.h"
+// Constructor
+IRCCmd::IRCCmd(){}
+// Destructor
+IRCCmd::~IRCCmd(){}
+
+std::string IRCCmd::MakeUpper(std::string Channel)
+{
+    std::string tmpchan = Channel;
+    std::transform(tmpchan.begin(), tmpchan.end(), tmpchan.begin(), towupper);
+    return tmpchan;
+}
+bool IRCCmd::ParamsValid(_CDATA *CD, int pCnt)
+{
+    CD->PCOUNT = pCnt;
+    if (CD->PARAMS.size() == 0)
+        return false;
+    return ValidParams(CD->PARAMS, pCnt);
+}
+
+int IRCCmd::ParamsValid(_CDATA *CD, int pCnt, int rLev)
+{
+    //CD->PCOUNT = pCnt;
+    if (!CanUse(CD->USER, rLev))
+        return E_AUTH;
+    else if (pCnt == 0)
+        return E_OK;
+    else if (CD->PARAMS.size() == 0)
+        return E_SIZE;
+    else if (!ValidParams(CD->PARAMS, pCnt))
+        return E_SIZE;
+    return E_OK;
+}
+
+// This function checks if chat from irc is a command or not
+// return true on yes and false on no
+bool IRCCmd::IsValid(std::string USER, std::string FROM, std::string CHAT, std::string TYPE)
+{
+    // If the first line of our chat is the command prefix we have a command
+    if (CHAT.substr(0, 1) == sIRC->_cmd_prefx && CHAT.size() > 1)
+    {
+        _CDATA CDATA;
+        bool cValid    = false;
+        bool AuthValid = true;
+        bool dontlog   = true;
+        std::string* _PARAMS = getArray(CHAT, 2);
+        CDATA.USER      = USER;
+        CDATA.FROM      = FROM;
+        CDATA.TYPE      = TYPE;
+        CDATA.PCOUNT    = 0;
+        CDATA.CMD       = MakeUpper(_PARAMS[0].substr(1, _PARAMS[0].size() - 1));
+        CDATA.PARAMS    = _PARAMS[1];
+        if (CDATA.CMD == "LOGIN")
+        {
+            if (FROM == sIRC->_Nick)
+            {
+                if (ParamsValid(&CDATA, 2))
+                    Handle_Login(&CDATA);
+                else
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"login <Player> <Password>)", true, "ERROR");
+            }
+            else
+                sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Please Send A PM To Login!", true, "ERROR");
+            if (GetLevel(USER) >= sIRC->gmlog)
+                dontlog = false;
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LOGOUT")
+        {
+            if (FROM == sIRC->_Nick)
+            {
+                Handle_Logout(&CDATA);
+            }
+            else
+                sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Please Send A PM To Logout!", true, "ERROR");
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ACCT")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CACCT))
+            {
+                case E_OK:
+                    Account_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"acct <Player> <(un)lock/email/pass/rename/gmlevel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "BAN")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CBAN))
+            {
+                case E_OK:
+                    Ban_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"ban <Player> <acct/ip>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "CHAN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC->CCHAN))
+            {
+                case E_OK:
+                    Chan_Control(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"chan <op> <IRC User>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "CHAR")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CCHAR))
+            {
+                case E_OK:
+                    Char_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"char <Player> <mailcheat/taxicheat/maxskill/setskill/quest/mod>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "FUN")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CFUN))
+            {
+                case E_OK:
+                    Fun_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"fun <Player> <Sound/Say>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "HELP")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CHELP))
+            {
+                case E_OK:
+                    Help_IRC(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"help <Command>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "INCHAN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC->CINCHAN))
+            {
+                case E_OK:
+                    Inchan_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"inchan <Channel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "INFO")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CINFO))
+            {
+                case E_OK:
+                    Info_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"info)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ITEM")
+        {
+            CDATA.PCOUNT = 3;
+            switch(ParamsValid(&CDATA, 2, sIRC->CITEM))
+            {
+                case E_OK:
+                    Item_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"item <Player> <add> <ItemID/[ItemName]> <Amount>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "JAIL")
+        {
+            CDATA.PCOUNT = 3;
+            switch(ParamsValid(&CDATA, 1, sIRC->CJAIL))
+            {
+                case E_OK:
+                    Jail_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"jail <Player> <release/Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "KICK")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC->CKICK))
+            {
+                case E_OK:
+                    Kick_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"kick <Player> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "KILL")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC->_KILL))
+            {
+                case E_OK:
+                    Kill_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"kill <Player> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LEVEL")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC->CLEVEL))
+            {
+                case E_OK:
+                    Level_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"level <Player> <NewLevel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LOOKUP")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC->CLOOKUP))
+            {
+                case E_OK:
+                    Lookup_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"lookup <acct/char/creature/faction/go/item/quest/skill/spell/tele> <ID/Name>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "MONEY")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC->CMONEY))
+            {
+                case E_OK:
+                    Money_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"money <Player> <(-)Money>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "MUTE")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CMUTE))
+            {
+                case E_OK:
+                    Mute_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"mute <Player> <release/TimeInMins> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ONLINE")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CONLINE))
+            {
+                case E_OK:
+                    Online_Players(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"online)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "PM")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CPM))
+            {
+                case E_OK:
+                    PM_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"pm <Player> <Message>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RELOAD")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CRELOAD))
+            {
+                case E_OK:
+                    sIRC->Send_IRC_Channels("Reloading Configuration Options.");
+                    sWorld->LoadConfigSettings(true);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RECONNECT")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CRECONNECT))
+            {
+                case E_OK:
+                    sIRC->Send_IRC_Channels(sIRC->RstMsg);
+                    sIRC->ResetIRC();
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RESTART")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CSHUTDOWN))
+            {
+                case E_OK:
+                    Restart_Trinity(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"server <setmotd/flusharenapoints/sec_number_for_restart>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "REVIVE")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC->CREVIVE))
+            {
+                case E_OK:
+                    Revive_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"revive <Player>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SAVEALL")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CSAVEALL))
+            {
+                case E_OK:
+                    Saveall_Player(&CDATA);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SERVER")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC->CSERVERCMD))
+            {
+                case E_OK:
+                    Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"server <setmotd/flusharenapoints>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SHUTDOWN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC->CSHUTDOWN))
+            {
+                case E_OK:
+                    Shutdown_Trinity(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"shutdown <TimeInSeconds>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SPELL")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CSPELL))
+            {
+                case E_OK:
+                    Spell_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"spell <Player> <Cast/Learn/UnLearn> <SpellID>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SYSMSG")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC->CSYSMSG))
+            {
+                case E_OK:
+                    Sysmsg_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"sysmsg <a/e/n/add/del/list> <Message>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "TELE")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CTELE))
+            {
+                case E_OK:
+                    Tele_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"tele <Player> <l/c/r/to/cr/go/homebind> <Loc.Name/MAPID X Y Z/Recall/Player/Creature GUID/GO GUID/Homebind>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "TOP")
+        {
+            CDATA.PCOUNT = 1;
+            switch(ParamsValid(&CDATA, 1, sIRC->CTOP))
+            {
+                case E_OK:
+                    Top_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"top <accttime/chartime/money> <limit>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "PLAYER")
+        {
+            CDATA.PCOUNT = 1;
+            switch(ParamsValid(&CDATA, 1, sIRC->CPLAYER))
+            {
+                case E_OK:
+                    Player_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"player <PLAYER>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "WHO")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CWHO))
+            {
+                case E_OK:
+                    Who_Logged(&CDATA);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        if (!AuthValid && IsLoggedIn(USER))
+            sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Access Denied! Your Security Level Is Too Low To Use This Command!", true, "ERROR");
+        if (cValid == false && (sIRC->BOTMASK & 4) != 0)
+            sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Unknown Command!", true, "ERROR");
+        if (cValid && dontlog)
+        {
+            sIRC->iLog.WriteLog(" %s : [ %s(%d) ] Used Command: [ %s ] With Parameters: [ %s ]", sIRC->iLog.GetLogDateTimeStr().c_str(), CDATA.USER.c_str(), GetLevel(USER), CDATA.CMD.c_str(), CDATA.PARAMS.c_str());
+            if ((sIRC->logmask & 1) != 0)
+            {
+                std::string logchan = "#";
+                logchan += sIRC->logchan;
+                std::stringstream ss;
+                ss << sIRC->iLog.GetLogDateTimeStr() << ": [ " << CDATA.USER << "(" << GetLevel(USER) << ") ] Used Command: [ " << CDATA.CMD << " ] With Parameters: [" << CDATA.PARAMS << " ]";
+                sIRC->Send_IRC_Channel(logchan, ss.str().c_str(), true);
+            }
+        }
+        return cValid;
+    }
+    return false;
+}
+
+bool IRCCmd::CanUse(std::string USER, int nLevel)
+{
+    if (IsLoggedIn(USER))
+    {
+        if (GetLevel(USER) >= nLevel)
+            return true;
+        else
+            return false;
+    }
+    else if (nLevel == 0)
+    {
+        return true;
+    }
+    else
+        sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : You Are Not Logged In!", true, "ERROR");
+    return false;
+}
+
+std::string IRCCmd::ChanOrPM(_CDATA *CD)
+{
+    if (CD->FROM == sIRC->_Nick)
+        return CD->USER;
+    else
+        return CD->FROM;
+}
+
+Player *IRCCmd::GetPlayer(std::string WHO)
+{
+    normalizePlayerName(WHO);
+    return ObjectAccessor::FindPlayerByName(WHO.c_str());
+}
+
+_client *IRCCmd::GetClient(std::string cname)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == cname)
+            return (*i);
+    }
+    return (NULL);
+}
+
+bool IRCCmd::IsLoggedIn(std::string USER)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == USER)
+            return true;
+    }
+    return false;
+}
+
+bool IRCCmd::AcctIsLoggedIn(std::string USER)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if (MakeUpper((*i)->UName) == MakeUpper(USER))
+            return true;
+    }
+    return false;
+}
+
+std::string IRCCmd::AcctIsBanned(std::string ACCT)
+{
+    uint32 acctid = AccountMgr::GetId(ACCT);
+    std::string banned = "NOTBANNED";
+    QueryResult result = LoginDatabase.PQuery("SELECT banreason FROM ip_banned WHERE ip=(SELECT last_ip FROM account WHERE id = '%i')", acctid);
+    if (result)
+    {
+        banned = (*result)[0].GetCString();
+
+        return "IP Banned. Reason:" + banned;
+    }
+    QueryResult result2 = LoginDatabase.PQuery("SELECT banreason FROM account_banned WHERE id='%i' AND active =1", acctid);
+    if (result2)
+    {
+        banned = (*result2)[0].GetCString();
+
+        return "Account Banned. Reason:" + banned;
+    }
+    return banned;
+}
+
+int IRCCmd::GetLevel(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+            return (*i)->GMLevel;
+    }
+    return 0;
+}
+
+int IRCCmd::AcctLevel(std::string plnme)
+{
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(plnme);
+    uint32 account_id = 0;
+    uint32 security = 0;
+    account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    security = AccountMgr::GetSecurity(account_id);
+    return security;
+}
+
+std::string IRCCmd::GetAccName(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+            return (*i)->UName;
+    }
+    return "";
+}
+
+std::string IRCCmd::GetNameFromAcct(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->UName == sName)
+            return (*i)->Name;
+    }
+    return "";
+}
+
+int IRCCmd::GetAcctIDFromName(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+        {
+            uint32 acct_id = 0;
+            acct_id = AccountMgr::GetId((*i)->UName.c_str());
+            return acct_id;
+        }
+    }
+    return 0;
+}
+
+std::string IRCCmd::GetAcctNameFromID(uint32 acctid)
+{
+    QueryResult result = LoginDatabase.PQuery("SELECT username FROM account WHERE id = '%d'", acctid);
+    if (result)
+    {
+        std::string name = (*result)[0].GetCString();
+
+        return name;
+    }
+
+    return "";
+}
+
+std::string IRCCmd::GetIPFromPlayer(std::string player)
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE name = '%s'", player.c_str());
+    if (result)
+    {
+        std::string acctid = (*result)[0].GetCString();
+
+        QueryResult result2 = LoginDatabase.PQuery("SELECT last_ip FROM account WHERE id = '%s'", acctid.c_str());
+        if (result2)
+        {
+            std::string ip = (*result2)[0].GetCString();
+
+            return ip;
+        }
+    }
+
+    return "";
+}
+
+std::string IRCCmd::SecToDay(std::string secons)
+{
+    unsigned int seconds = atoi(secons.c_str());
+    unsigned int days = seconds / 86400;
+    unsigned int hours = seconds / 3600 % 24;
+    unsigned int mins = seconds / 60 % 60;
+    char tottime[1000];
+    sprintf(tottime, "%iDays:%iHours:%iMinutes", days, hours, mins);
+
+    return tottime;
+}
+
+bool IRCCmd::ValidParams(std::string PARAMS, int nCount)
+{
+    if (nCount == 1 && PARAMS.size() == 0)
+        return false;
+    int pcount = 0;
+    int p = -1;
+    for (int i = 0;i < nCount;i++)
+    {
+        p = PARAMS.find(" ", p + 1);
+        if (p == -1)
+            break;
+        else
+            pcount++;
+    }
+    nCount--;
+    if (pcount >= nCount)
+        return true;
+    else
+        return false;
+}
+
+std::string* IRCCmd::getArray(std::string PARAMS, int nCount)
+{
+    std::string *array = new std::string[nCount];
+    if (PARAMS.size() > 0)
+    {
+        size_t ps = 0;
+        size_t pc = -1;
+        for (int i = 0;i < nCount;i++)
+        {
+            pc = PARAMS.find(" ", pc + 1);
+            if (i + 1 == nCount && nCount != 1)
+            {
+                if (ps > 0 && pc > 0)
+                    array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+            }
+            else
+                array[i] = PARAMS.substr(ps, pc - ps);
+            ps = pc + 1;
+        }
+    }
+    return array;
+}
+
+std::string IRCCmd::MakeMsg(const char *sLine, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, sLine);
+    vsnprintf(tmpoutp, 1024, sLine, ap);
+    va_end(ap);
+    std::string outp = tmpoutp;
+    return outp;
+}
diff --git a/src/server/game/TriniChat/IRCCmd.h b/src/server/game/TriniChat/IRCCmd.h
new file mode 100644
index 0000000..6921f8c
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmd.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CMD_H
+#define _IRC_CMD_H
+
+#define MAX_CLIENTS 50
+//include boost
+#include "boost/thread.hpp"
+#include "boost/date_time.hpp"
+#include "Common.h"
+#include "Player.h"
+#include "ObjectAccessor.h"
+#include "BattlegroundMgr.h"
+
+struct ChannelUser
+{
+    int UserType;
+    std::string Name;
+    std::string UName;
+    int UserLevel;
+};
+
+struct _client
+{
+    bool        LoggedIn;
+    std::string Name;
+    std::string UName;
+    int         GMLevel;
+};
+struct _CDATA
+{
+    std::string CMD;
+    std::string USER;
+    std::string FROM;
+    std::string PARAMS;
+    std::string TYPE;
+    int PCOUNT;
+};
+enum APVERR
+{
+    E_OK,
+    E_SIZE,
+    E_AUTH,
+    E_IVALID,
+};
+enum ESOUNDS
+{
+    S_ENTERWORLD    = 602,
+    S_QUESTFAILED   = 847,
+    S_INVITE        = 880,
+    S_LEVELUP       = 888,
+    S_COINSOUND     = 895,
+    S_WHISPER       = 3081,
+    S_STEALTH       = 3325,
+};
+class IRCCmd
+{
+    public:
+        IRCCmd();
+        ~IRCCmd();
+
+        void    Handle_Logout(_CDATA *CD);
+        bool    IsLoggedIn(std::string USER);
+        bool    IsValid(std::string USER, std::string FROM, std::string CHAT, std::string TYPE);
+        bool    AcctIsLoggedIn(std::string USER);
+        _client *GetClient(std::string cname);
+
+    public:
+        static std::string MakeMsg(const char *sLine, ...);
+        static std::string ChanOrPM(_CDATA *CD);
+        int AcctLevel(std::string plnme);
+        int GetLevel(std::string sName);
+        std::string MakeUpper(std::string Channel);
+        std::string  AcctIsBanned(std::string ACCT);
+        std::list<_client*> _CLIENTS;
+        Player* GetPlayer(std::string WHO);
+
+    private:
+        // TriniChat Commands
+        void    Handle_Login(_CDATA *CD);
+        void    Account_Player(_CDATA *CD);
+        void    Ban_Player(_CDATA *CD);
+        void    Chan_Control(_CDATA *CD);
+        void    Char_Player(_CDATA *CD);
+        void    Fun_Player(_CDATA *CD);
+        void    Help_IRC(_CDATA *CD);
+        void    Inchan_Server(_CDATA *CD);
+        void    Info_Server(_CDATA *CD);
+        void    Item_Player(_CDATA *CD);
+        void    Jail_Player(_CDATA *CD);
+        void    Kick_Player(_CDATA *CD);
+        void    Kill_Player(_CDATA *CD);
+        void    Player_Player(_CDATA *CD);
+        void    Lookup_Player(_CDATA *CD);
+        void    Level_Player(_CDATA *CD);
+        void    Money_Player(_CDATA *CD);
+        void    Mute_Player(_CDATA *CD);
+        void    Online_Players(_CDATA *CD);
+        void    PM_Player(_CDATA *CD);
+        void    Restart_Trinity(_CDATA *CD);
+        void    Revive_Player(_CDATA *CD);
+        void    Saveall_Player(_CDATA *CD);
+        void    Server(_CDATA *CD);
+        void    Shutdown_Trinity(_CDATA *CD);
+        void    Spell_Player(_CDATA *CD);
+        void    Sysmsg_Server(_CDATA *CD);
+        void    Tele_Player(_CDATA *CD);
+        void    Top_Player(_CDATA *CD);
+        void    Who_Logged(_CDATA *CD);
+        bool    CanUse(std::string USER, int nLevel);
+        bool    ValidParams(std::string PARAMS, int nCount = 1);
+        bool    ParamsValid(_CDATA *CD, int pCnt);
+        int     ParamsValid(_CDATA *CD, int pCnt, int rLev);
+        std::string GetAccName(std::string sName);
+        std::string GetNameFromAcct(std::string sName);
+        std::string GetAcctNameFromID(uint32 acctid);
+        std::string GetIPFromPlayer(std::string player);
+        std::string SecToDay(std::string secons);
+        int GetAcctIDFromName(std::string sName);
+        std::string* getArray(std::string PARAMS, int nCount = 1);
+};
+inline void MakeLower(std::string& str)
+{
+    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
+}
+#endif
diff --git a/src/server/game/TriniChat/IRCCmde.cpp b/src/server/game/TriniChat/IRCCmde.cpp
new file mode 100644
index 0000000..997bb8e
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmde.cpp
@@ -0,0 +1,2353 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCCmd.h"
+#include <iostream>
+#include "IRCClient.h"
+#include "MCS_OnlinePlayers.h"
+#include "WorldPacket.h"
+#include "Database/DatabaseEnv.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "World.h"
+#include "Guild.h"
+#include "ObjectMgr.h"
+#include "AccountMgr.h"
+#include "Language.h"
+#include "SpellAuras.h"
+#include "Config.h"
+#include "ReputationMgr.h"
+#include "ArenaTeamMgr.h"
+#include "GitRevision.h"
+
+#define Send_Player(p, m)           sIRC->Send_WoW_Player(p, m)
+#define Send_IRCA(c, m, b, t)       sIRC->Send_IRC_Channel(c, m, b, t)
+
+#ifdef WIN32
+#define Delay(x) Sleep(x)
+#else
+#define Delay(x) sleep(x / 1000)
+#endif
+
+void IRCCmd::Handle_Login(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    std::string isbanned = AcctIsBanned(_PARAMS[0]);
+    LoginDatabase.EscapeString(_PARAMS[0]);
+    LoginDatabase.EscapeString(_PARAMS[1]);
+    if (isbanned == "NOTBANNED")
+    {
+        if (!IsLoggedIn(CD->USER))
+        {
+            if (!AcctIsLoggedIn(_PARAMS[0].c_str()))
+            {
+                QueryResult result = LoginDatabase.PQuery("SELECT `gmlevel` FROM `account`, `account_access` WHERE `username`='%s' AND `account_access`.`id`=`account`.`id` AND `sha_pass_hash`=SHA1(CONCAT(UPPER(`username`),':',UPPER('%s')));", _PARAMS[0].c_str(), _PARAMS[1].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    int GMLevel = fields[0].GetUInt8();
+                    if (GMLevel >= 0)
+                    {
+                        _client *NewClient = new _client();
+                        NewClient->Name     = CD->USER;
+                        NewClient->UName    = MakeUpper(_PARAMS[0]);
+                        NewClient->GMLevel  = fields[0].GetUInt8();
+                        _CLIENTS.push_back(NewClient);
+                        Send_IRCA(CD->USER, MakeMsg("You Are Now Logged In As %s.", _PARAMS[0].c_str()), true, CD->TYPE);
+
+                        if (sIRC->_op_gm == 1 && GMLevel >= sIRC->_op_gm_lev)
+                        {
+                            for (int i=1;i < sIRC->_chan_count + 1;i++)
+                            sIRC->SendIRC("MODE #"+sIRC->_irc_chan[i]+" +o "+CD->USER);
+                        }
+                    }
+                }
+                else
+                    Send_IRCA(CD->USER, "Sorry, Your Username Or Password Is Incorrect. Please Try Again. ", true, "ERROR");
+            }
+            else
+                for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+                {
+                    if ((*i)->UName == _PARAMS[0])
+                        Send_IRCA(CD->USER, MakeMsg("%s Is Already Logged In With This Username. ", (*i)->Name.c_str()), true, "ERROR");
+                }
+        }
+        else
+            for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+            {
+                if ((*i)->Name == CD->USER)
+                    Send_IRCA(CD->USER, MakeMsg("You are already logged in as %s.", (*i)->UName.c_str()), true, "ERROR");
+            }
+    }
+    else
+         Send_IRCA(CD->USER, "Sorry, you are "+isbanned+" and can not log in.", true, "ERROR");
+}
+
+void IRCCmd::Handle_Logout(_CDATA *CD)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == CD->USER)
+        {
+            delete (*i);
+            i = _CLIENTS.erase(i);
+            Send_IRCA(CD->USER, "Successfully logged out", true, CD->TYPE);
+            return;
+        }
+    }
+    Send_IRCA(CD->USER, "Not logged in", true, "ERROR");
+}
+
+void IRCCmd::Account_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    int account_id = 0;
+    account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    if (account_id)
+    {
+        if (account_id == GetAcctIDFromName(CD->USER) || GetLevel(CD->USER) >= sIRC->_op_gm_lev)
+        {
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            if (_PARAMS[1] == "lock")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `locked` = '1' WHERE `id` = '%d'",account_id);
+                if (plr) Send_Player(plr, MakeMsg("Your Account Has Been Locked To Your Current IP By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Account Has Been Locked To Their Current IP Address.", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "unlock")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `locked` = '0' WHERE `id` = '%d'",account_id);
+                if (plr) Send_Player(plr, MakeMsg("Your Account Has Been UnLocked From The Associated IP By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Account Has Been UnLocked From The Associated IP Address.", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "email")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `email` = '%s' WHERE `id` = '%d'",_PARAMS[2].c_str() ,account_id);
+                if (plr) Send_Player(plr, MakeMsg("%s Has Changed Your EMail Adress To: %s", CD->USER.c_str(), _PARAMS[2].c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : EMail Address Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "pass")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `sha_pass_hash` = SHA1(CONCAT(UPPER(`username`),':',UPPER('%s'))) WHERE `id` = '%d'",_PARAMS[2].c_str() ,account_id);
+                if (plr) Send_Player(plr, MakeMsg("%s Has Changed Your Password To: %s", CD->USER.c_str(), _PARAMS[2].c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Password Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "rename")
+            {
+                if (plr)
+                {
+                    plr->SetAtLoginFlag(AT_LOGIN_RENAME);
+                    Send_Player(plr, MakeMsg("%s Has Requested You Change This Characters Name, Rename Will Be Forced On Next Login!", CD->USER.c_str()));
+                }
+                CharacterDatabase.PExecute("UPDATE `characters` SET `at_login` = `at_login` | '1' WHERE `guid` = '%u'", guid);
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Has Been Forced To Change Their Characters Name, Rename Will Be Forced On Next Login!", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "gmlevel")
+            {
+                const char *cgmlevel = _PARAMS[2].c_str();
+                if (GetLevel(CD->USER) >= atoi(cgmlevel))
+                {
+                    LoginDatabase.PExecute("UPDATE `account_access` SET `gmlevel` = '%s' WHERE `id` = '%d'", _PARAMS[2].c_str(), account_id);
+                    Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Has GM Level Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+                }
+                else
+                {
+                    Send_IRCA(CD->USER, "The Specified GM Level Is Higher Than Your GM Level.", true, "ERROR");
+                }
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "You Are Not A GM, You May Only Change Settings In Your Own Account.", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "No such player - account lookup failed", true, "ERROR");
+}
+
+void IRCCmd::Ban_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 4);
+    std::string duration = SecToDay (_PARAMS[3].c_str());
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (_PARAMS[1] == "ip")
+    {
+        std::string ip = GetIPFromPlayer(_PARAMS[0]);
+        if (_PARAMS[2] == "")
+            _PARAMS[2] = "No Reason";
+        if (ip != "")
+        {
+            sWorld->BanAccount(BAN_IP, ip.c_str(), _PARAMS[3].c_str(), _PARAMS[2], CD->USER);
+            if (Player* plr = GetPlayer(_PARAMS[0]))
+                plr->GetSession()->KickPlayer();
+            Send_IRCA(ChanOrPM(CD), MakeMsg("[%s] Has Had Their IP Address Banned. [%s] Reason: %s Duration: %s",_PARAMS[0].c_str() ,ip.c_str() , _PARAMS[2].c_str(), _PARAMS[3].c_str()), true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Can not locate IP-address for that charactername", true, "ERROR");
+    }
+    if (_PARAMS[1] == "acct")
+    {
+
+        if (_PARAMS[2] == "")
+            _PARAMS[2] = "No reason";
+        if (_PARAMS[3] == "")//set standard bantime to 1 day
+            _PARAMS[3] = "1d";
+        QueryResult result = LoginDatabase.PQuery("SELECT id FROM `account` WHERE username = '%s'", _PARAMS[0].c_str());
+        if (result)
+        {
+            sWorld->BanAccount(BAN_ACCOUNT, _PARAMS[0].c_str(), _PARAMS[3].c_str(), _PARAMS[2], CD->USER);
+            Send_IRCA(ChanOrPM(CD), MakeMsg("[%s] has been account-banned. Reason: %s Duration: %s",_PARAMS[0].c_str(), _PARAMS[2].c_str(), _PARAMS[3].c_str()),  true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Can not find any accounts for that accountname", true, "ERROR");
+
+    }
+    if (_PARAMS[1] == "unban")
+    {
+        std::string unbani = _PARAMS[0];
+        if (atoi(unbani.c_str()) > 0)
+        {
+            LoginDatabase.PExecute("DELETE FROM ip_banned WHERE ip = '%s'", _PARAMS[0].c_str());
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Removed From The IP Ban List.", _PARAMS[0].c_str()), true, CD->TYPE);
+        }
+        else
+        {
+            QueryResult result = LoginDatabase.PQuery("SELECT id FROM `account` WHERE username = '%s'", _PARAMS[0].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string id = fields[0].GetString();
+
+                LoginDatabase.PExecute("DELETE FROM account_banned WHERE id = %s", id.c_str());
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Removed From The Account Ban List.", _PARAMS[0].c_str()), true, CD->TYPE);
+
+            }
+            else
+                Send_IRCA(CD->USER, "I Cannot Locate An Account Or IP Address For The Paramaters Given.", true, "ERROR");
+        }
+    }
+}
+
+void IRCCmd::Char_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 5);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    Player* plr = ObjectAccessor::FindPlayer(guid);
+    if (plr)
+    {
+        if (_PARAMS[1] == "mapcheat")
+        {
+            bool explore = false;
+            if (_PARAMS[2] != "0")
+                explore = true;
+            for (uint8 i=0; i<64; i++)
+            {
+                if (_PARAMS[2] != "0")
+                    plr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0xFFFFFFFF);
+                else
+                    plr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0);
+            }
+            if (explore)
+            {
+                Send_Player(plr, MakeMsg("All Your Zones Have Been Set To Explored By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Now Explored All Zones.", true, CD->TYPE);
+            }
+            else
+            {
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Now Had All Zones Set To Un-Explored.", true, CD->TYPE);
+                Send_Player(plr, MakeMsg("All Your Zones Have Been Set To Un-Explored By: %s", CD->USER.c_str()));
+            }
+        }
+        if (_PARAMS[1] == "taxicheat")
+        {
+            if (_PARAMS[2] != "0")
+            {
+                plr->SetTaxiCheater(true);
+                Send_Player(plr, MakeMsg("Taxi Node Cheat Has Been Enabled By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Taxi Node Cheat Has Been Enabled.", true, CD->TYPE);
+            }
+            else
+            {
+                plr->SetTaxiCheater(false);
+                Send_Player(plr, MakeMsg("Taxi Node Cheat Has Been Disabled By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Taxi Node Cheat Has Been Disabled.", true, CD->TYPE);
+            }
+        }
+        if (_PARAMS[1] == "maxskill")
+        {
+            plr->UpdateSkillsToMaxSkillsForLevel();
+            Send_Player(plr, MakeMsg("Your Skills Have Been Maxed Out By: %s", CD->USER.c_str()));
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Skills Have Been Maxed Out.", true, CD->TYPE);
+        }
+        if (_PARAMS[1] == "setskill")
+        {
+            uint32 skill = atoi(_PARAMS[2].c_str());
+            uint32 step = atoi(_PARAMS[3].c_str());
+            uint32 level = atol(_PARAMS[4].c_str());
+            int32 max   = _PARAMS[5].c_str() ? atol (_PARAMS[5].c_str()) : plr->GetPureMaxSkillValue(skill);
+            SkillLineEntry const* skilllookup = sSkillLineStore.LookupEntry(skill);
+            //if skillid entered is not a number and greater then 0 then the command is being used wrong
+            if (skill > 0)
+            {
+                //does the skill even exist
+                if (skilllookup)
+                {
+                    //does player have the skill yet
+                    if (plr->GetSkillValue(skill))
+                    {
+                        plr->SetSkill(skill,step,level,max);
+                        Send_Player(plr, MakeMsg("Skill: %s Has Been Set To Level: %i Max: %i By: %s",skilllookup->name[0], level, max, CD->USER.c_str()));
+                        Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Had Skill: %s Set To Level: %d Max: %d",_PARAMS[0].c_str() , skilllookup->name[0], level, max), true, CD->TYPE);
+                    }
+                    else
+                        Send_IRCA(CD->USER, MakeMsg("Player Does Not Have The %s Skill Yet.", skilllookup->name[0]), true, "ERROR");
+                }
+                else
+                    Send_IRCA(CD->USER, "That Skill ID Does Not Exist.", true, "ERROR");
+            }
+            else
+                Send_IRCA(CD->USER, "The Skill ID Entered Is Invalid.", true, "ERROR");
+        }
+        if (_PARAMS[1] == "combatstop")
+        {
+            if (!plr->IsInCombat())
+            {
+                plr->CombatStop();
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Was Dropped From Combat",_PARAMS[0].c_str()), true, CD->TYPE);
+            }else
+            {
+                Send_IRCA(CD->USER, "Specified Player Is Not In Combat.", true, "ERROR");
+            }
+        }
+        if (_PARAMS[1] == "quest")
+        {
+            std::string s_param  = _PARAMS[3];
+            std::string QName = "";
+            char *args = (char*)s_param.c_str();
+            uint32 qId = 0;
+            if (args[0]=='[')
+            {
+                char* cQName = strtok((char*)args, "]");
+                if (cQName && cQName[0])
+                {
+                    QName = cQName+1;
+                    WorldDatabase.EscapeString(QName);
+                    QueryResult result = WorldDatabase.PQuery("SELECT id FROM quest_template WHERE name = '%s'", QName.c_str());
+                    if (!result)
+                    {
+                        Send_IRCA(CD->USER, "Quest Not Found!", true, "ERROR");
+                        return;
+                    }
+                    qId = result->Fetch()->GetUInt16();
+
+                }
+            }
+            else
+            {
+                qId = atoi(args);
+                QueryResult result = WorldDatabase.PQuery("SELECT title FROM quest_template WHERE id = '%d'", qId);
+                if (!result)
+                {
+                    Send_IRCA(CD->USER, "Quest Not Found!", true, "ERROR");
+                    return;
+                }
+                QName = result->Fetch()->GetString();
+
+            }
+            if (_PARAMS[2] == "add")
+            {
+                QueryResult item_max = WorldDatabase.PQuery("SELECT MAX(entry) FROM item_template");
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(qId);
+                for (uint32 id = 0; id < item_max->Fetch()->GetUInt32(); id++)
+                {
+                    ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(id);
+                    if (!pProto)
+                        continue;
+
+                    if (pProto->StartQuest == qId)
+                    {
+                        Send_IRCA(CD->USER, MakeMsg("This Quest Requires Activation By Item %d, Add It To The Player And Start Quest Manually.", pProto->ItemId),true, "ERROR");
+                    }
+                }
+
+                if (plr->CanAddQuest(pQuest, true))
+                {
+                    plr->AddQuest(pQuest, NULL);
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Had Quest [%s] Added To Quest Log.", _PARAMS[0].c_str(), QName.c_str()), true, "ERROR");
+                }
+                else
+                {
+                    Send_IRCA(CD->USER, "Cannot Add Quest To Player, He Either Has No Space Or He Already Has The Quest In His Quest Log.", true, "ERROR");
+                }
+            }
+            if (_PARAMS[2] == "complete")
+            {
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(qId);
+                if (plr->GetQuestStatus(qId) == QUEST_STATUS_NONE)
+                {
+                    Send_IRCA(CD->USER, "Player Does Not Have This Quest In Quest Log, Cannot Complete It.", true, "ERROR");
+                }
+                else
+                {
+                    for (uint8 x = 0; x < QUEST_OBJECTIVES_COUNT; ++x)
+                    {
+                        uint32 id = pQuest->RequiredItemId[x];
+                        uint32 count = pQuest->RequiredItemCount[x];
+                        if (!id || !count)
+                            continue;
+                        uint32 curItemCount = plr->GetItemCount(id,true);
+                        ItemPosCountVec dest;
+                        uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, id, count-curItemCount);
+                        if (msg == EQUIP_ERR_OK)
+                        {
+                            Item* item = plr->StoreNewItem(dest, id, true);
+                            plr->SendNewItem(item,count-curItemCount,true,false);
+                        }
+                    }
+
+                    for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+                    {
+                        uint32 creature = pQuest->RequiredNpcOrGo[i];
+                        uint32 creaturecount = pQuest->RequiredNpcOrGoCount[i];
+                        /*if (uint32 spell_id = pQuest->RequiredSpellCast[i])
+                        {
+                            for (uint16 z = 0; z < creaturecount; ++z)
+                                plr->CastedCreatureOrGO(creature,0,spell_id);
+                        }
+                        else */
+                        if (creature > 0)
+                        {
+                            if (CreatureTemplate const* cInfo = sObjectMgr->GetCreatureTemplate(creature))
+                                for (uint16 z = 0; z < creaturecount; ++z)
+                                    plr->KilledMonster(cInfo,ObjectGuid::Empty);
+                        }
+                        /*else if (creature < 0)
+                        {
+                            for (uint16 z = 0; z < creaturecount; ++z)
+                                plr->CastedCreatureOrGO(creature,0,0);
+                        }*/
+                    }
+
+                    if (uint32 repFaction = pQuest->GetRepObjectiveFaction())
+                    {
+                        uint32 repValue = pQuest->GetRepObjectiveValue();
+                        uint32 curRep = plr->GetReputationMgr().GetReputation(repFaction);
+                        if (curRep < repValue)
+                        {
+                            FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction);
+                            plr->GetReputationMgr().SetReputation(factionEntry,repValue);
+                        }
+                    }
+
+                    int32 ReqOrRewMoney = pQuest->GetRewOrReqMoney();
+                    if (ReqOrRewMoney < 0)
+                        plr->ModifyMoney(-ReqOrRewMoney);
+
+                    plr->CompleteQuest(qId);
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Quest [%s] Status Set To Complete.", _PARAMS[0].c_str(), QName.c_str()), true, CD->TYPE);
+                }
+            }
+        }
+        if (_PARAMS[1] == "mod")
+        {
+            /*if (_PARAMS[2] == "rep") TODO
+            {
+                uint32 factionId = atoi((char*)_PARAMS[3].c_str());
+                FactionEntry const *factionEntry = sFactionStore.LookupEntry(factionId);
+                if (!factionEntry)
+                {
+                    Send_IRCA(CD->USER, "No Faction With That Name Exists.", true, "ERROR");
+                }
+                else
+                {
+                    int32 amount = atol((char*)_PARAMS[4].c_str());
+                    if (amount > -39000 && amount < 43000)
+                    {
+                        plr->SetFactionReputation(factionId,amount);
+                        Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Reputation With Faction %s Set To %s.", _PARAMS[0].c_str(), _PARAMS[3].c_str(), _PARAMS[4].c_str()), true, CD->TYPE);
+                    }
+                    else
+                    {
+                        Send_IRCA(CD->USER, "Reputation Value Incorrect. Must Be Between -39000 and 43000.", true, "ERROR");
+                    }
+                }
+            }*/
+            if (_PARAMS[2] == "morph")
+            {
+                uint16 display_id = (uint16)atoi((char*)_PARAMS[3].c_str());
+                plr->SetDisplayId(display_id);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Morphed Into DisplayID: %s.", _PARAMS[0].c_str(), _PARAMS[3].c_str()), true, CD->TYPE);
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Valid Parameters Are: morph <displayid>, reputation <faction><value>.", true, "ERROR");
+            }
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "No Character With That Name Exists.", true, "ERROR");
+}
+
+void IRCCmd::Fun_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (_PARAMS[1] == "say")
+        {
+            plr->Say(_PARAMS[2], LANG_UNIVERSAL);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Was Forced To Say: "+_PARAMS[2]+".", true, CD->TYPE);
+        }
+        if (_PARAMS[1] == "sound")
+        {
+            uint32 sndid = atoi(_PARAMS[2].c_str());
+            plr->PlayDirectSound(sndid , plr->ToPlayer());
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Just Heard Sound ID: "+_PARAMS[2]+".", true, CD->TYPE);
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Player Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Help_IRC(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    QueryResult result = WorldDatabase.PQuery("SELECT `Command`, `Description`, `gmlevel` FROM `irc_commands`");
+    if (result)
+    {
+        if (IsLoggedIn(CD->USER))
+        {
+            if (_PARAMS[0] == "")
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_commands` WHERE `gmlevel` <= %u ORDER BY `Command`", GetLevel(CD->USER));
+                if (result)
+                {
+                    std::string output = "\002TriniChat IRC Commands:\017 ";
+                    for (uint64 i=0; i < result->GetRowCount(); i++)
+                    {
+                        Field *fields = result->Fetch();
+                        output += fields[0].GetString() + ", ";
+                        result->NextRow();
+                    }
+
+                    Send_IRCA(CD->USER, output, true, CD->TYPE.c_str());
+                }
+            }
+            else
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `irc_commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    if (fields[1].GetInt32() > GetLevel(CD->USER))
+                    {
+                        Send_IRCA(CD->USER, "You Do Not Have Access To That Command, So No Help Is Available.", true, CD->TYPE.c_str());
+                        return;
+                    }
+                    if (result)
+                    {
+                        std::string cmdhlp = fields[0].GetString();
+
+                        Send_IRCA(CD->USER, cmdhlp, true, CD->TYPE.c_str());
+                    }
+                }
+                else
+                    Send_IRCA(CD->USER, "No Such Command Exists, Please Check The Spelling And Try Again.", true, "ERROR");
+            }
+        }
+        else if (!IsLoggedIn(CD->USER))
+        {
+            if (_PARAMS[0] == "")
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_commands` WHERE `gmlevel` = 0 ORDER BY `Command`");
+                if (result)
+                {
+                    std::string output = "\002TriniChat IRC Commands:\017 ";
+                    for (uint64 i=0; i < result->GetRowCount(); i++)
+                    {
+                        Field *fields = result->Fetch();
+                        output += fields[0].GetString() + ", ";
+                        result->NextRow();
+                    }
+
+                    Send_IRCA(CD->USER, output, true, CD->TYPE.c_str());
+                    Send_IRCA(CD->USER, "You Are Currently Not Logged In, Please Login To See A Complete List Of Commands Available To You.", true, CD->TYPE.c_str());
+                }
+            }
+            else
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `irc_commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    if (fields[1].GetUInt32() > 0)
+                    {
+                        Send_IRCA(CD->USER, "You Do Not Have Access To That Command, So No Help Is Available.", true, CD->TYPE.c_str());
+                        return;
+                    }
+                    std::string cmdhlp = fields[0].GetString();
+
+                    Send_IRCA(CD->USER, cmdhlp, true, CD->TYPE.c_str());
+                }
+                else
+                    Send_IRCA(CD->USER, "No Such Command Exists, Please Check The Spelling And Try Again.", true, "ERROR");
+            }
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Database Error! Please Make Sure You Used irc_commands.sql, You Must Have A Table In Your World Database (irc_commands)!", true, "ERROR");
+}
+
+void IRCCmd::Inchan_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "")
+    {
+        Send_IRCA(CD->USER, "Syntax Error! ("+sIRC->_cmd_prefx+"inchan <ChannelName>)", true, "ERROR");
+        return;
+    }
+    QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_inchan` WHERE `channel` = '%s' ORDER BY `name`", _PARAMS[0].c_str());
+    if (result)
+    {
+        Field *fields = result->Fetch();
+        std::string output = "\0031Players In The \xF["+fields[2].GetString()+"] \0031Channel:\017 ";
+        for (uint64 i=0; i < result->GetRowCount(); i++)
+        {
+            output += fields[1].GetString() + ", ";
+            result->NextRow();
+        }
+
+        Send_IRCA(ChanOrPM(CD), output, true, CD->TYPE);
+    }
+    else
+        Send_IRCA(ChanOrPM(CD), "\0031No Players Are Currently In \xF["+_PARAMS[0]+"] \0031Channel!", true, CD->TYPE.c_str());
+}
+
+void IRCCmd::Info_Server(_CDATA *CD)
+{
+    char clientsNum [50];
+    sprintf(clientsNum, "%u", sWorld->GetActiveSessionCount());
+    char maxClientsNum [50];
+    sprintf(maxClientsNum, "%u", sWorld->GetMaxActiveSessionCount());
+    char ircupdt [50];
+    sprintf(ircupdt, "%u", sWorld->GetUpdateTime());
+    std::string str = secsToTimeString(sWorld->GetUptime());
+    std::string svnrev = GitRevision::GetFullVersion();
+
+    float rdm = (sConfigMgr->GetFloatDefault("Rate.Drop.Money", 1.0f));
+    float rxk = (sConfigMgr->GetFloatDefault("Rate.XP.Kill", 1.0f));
+    float rxq = (sConfigMgr->GetFloatDefault("Rate.XP.Quest", 1.0f));
+    Send_IRCA(ChanOrPM(CD), "\00310Number Of Players Online: \xF"+(std::string)clientsNum+" | \00310Max Since Last Restart: \xF"+(std::string)maxClientsNum+" |\00310 UpTime: \xF"+str, true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), "\00310Server: \xF"+svnrev+" |\00310 Update Time: \xF"+(std::string)ircupdt, true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Server Rates - \xF[Monster XP: %u][Quest XP: %u][Money Drop Rate: %u]", int(rxk), int(rxq), int(rdm)), true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), "\00310MotD: \xF"+(std::string)sWorld->GetMotd(), true, CD->TYPE);
+
+}
+
+void IRCCmd::Item_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+
+    normalizePlayerName(_PARAMS[0]);
+    Player *chr = GetPlayer(_PARAMS[0].c_str());
+    if (_PARAMS[1] == "add")
+    {
+        std::string s_param  = _PARAMS[2];
+
+        char *args = (char*)s_param.c_str();
+        uint32 itemId = 0;
+        if (args[0]=='[')
+        {
+            char* citemName = strtok((char*)args, "]");
+            if (citemName && citemName[0])
+            {
+                std::string itemName = citemName+1;
+                WorldDatabase.EscapeString(itemName);
+                QueryResult result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+                if (!result)
+                {
+                    Send_IRCA(CD->USER, "Item Not Found!", true, "ERROR");
+                    return;
+                }
+                itemId = result->Fetch()->GetUInt16();
+
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Syntax Error! ("+sIRC->_cmd_prefx+"item <Player> <add> [Exact Item Name] <Amount>)", true, "ERROR");
+                return;
+            }
+        }
+        else
+        {
+            std::string itemName = s_param;
+            WorldDatabase.EscapeString(itemName);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+            if (result)
+            {
+                itemId = result->Fetch()->GetUInt16();
+            }
+
+
+            char* cId = strtok(args, " ");
+            if (!cId)
+            {
+                Send_IRCA(CD->USER, "Syntax Error! ("+sIRC->_cmd_prefx+"item <Player> <add> <ItemID> <Amount>)", true, "ERROR");
+                return;
+            }
+            itemId = atol(cId);
+        }
+            char* ccount = strtok(NULL, " ");
+            int32 count = 1;
+            if (ccount) { count = atol(ccount); }
+            Player* plTarget = chr;
+        if (!plTarget)
+        {
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+            return;
+        }
+        //Subtract
+        if (count < 0)
+        {
+            plTarget->DestroyItemCount(itemId, -count, true, false);
+            char itemid2[255];
+            sprintf(itemid2,"%d",itemId);
+            std::string itake = " \00313["+ _PARAMS[0] +"] :\0031Has Had Item \xF" +itemid2+ " \0031Taken From Them!";
+            Send_IRCA(ChanOrPM(CD), itake, true, CD->TYPE);
+            return;
+        }
+        //Adding items
+        uint32 noSpaceForCount = 0;
+
+        // check space and find places
+        ItemPosCountVec dest;
+        uint8 msg = plTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count, &noSpaceForCount);
+        if (msg == EQUIP_ERR_INVENTORY_FULL)                   // convert to possibel store amount
+            count -= noSpaceForCount;
+        else if (msg != EQUIP_ERR_OK)                          // other error, can't add
+        {
+            char s_countForStore[255];
+            sprintf(s_countForStore,"%d",count);
+            std::string ierror = " \00313["+ _PARAMS[0] +"] : Could Not Create All Items! " +s_countForStore+ " Item(s) Were Not Created!";
+            Send_IRCA(ChanOrPM(CD), ierror, true, CD->TYPE);
+            return;
+        }
+        Item* item = plTarget->StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+        if (count > 0 && item)
+        {
+                plTarget->SendNewItem(item,count,true,false);
+                QueryResult result = WorldDatabase.PQuery("SELECT name FROM item_template WHERE entry = %d", itemId);
+                char* dbitemname = NULL;
+                if (result)
+                {
+                    dbitemname = (char*)result->Fetch()->GetCString();
+                }
+                std::string iinfo = " \00313[" + _PARAMS[0] + "] : Has Been Given Item "+dbitemname+". From: "+CD->USER.c_str()+".";
+                Send_IRCA(ChanOrPM(CD), iinfo, true, CD->TYPE);
+
+        }
+        if (noSpaceForCount > 0)
+        {
+            char s_countForStore[255];
+            sprintf(s_countForStore,"%d",noSpaceForCount);
+            std::string ierror = " \00313["+ _PARAMS[0] +"] : Could Not Create All Items! " +s_countForStore+ " Item(s) Were Not Created!";
+            Send_IRCA(ChanOrPM(CD), ierror, true, CD->TYPE);
+            return;
+        }
+    }
+    else
+    {
+        Send_IRCA(CD->USER, "Syntax Error! ("+sIRC->_cmd_prefx+"item <Player> <add> <ItemID> <Amount>)", true, "ERROR");
+        return;
+    }
+}
+
+void IRCCmd::Jail_Player(_CDATA *CD)
+{
+    if (ValidParams(CD->PARAMS, 1))
+    {
+        std::string* _PARAMS = getArray(CD->PARAMS, 2);
+        if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+        {
+            Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+            return;
+        }
+        if (Player *plr = GetPlayer(_PARAMS[0]))
+        {
+            std::string sReason = "";
+            if (_PARAMS[1] == "release")
+            {
+                float rposx, rposy, rposz, rposo = 0;
+                uint32 rmapid = 0;
+                CharacterDatabase.EscapeString(_PARAMS[0]);
+                QueryResult result = CharacterDatabase.PQuery("SELECT `mapId`, `posX`, `posY`, `posZ` FROM `character_homebind` WHERE `guid` = '" UI64FMTD "'", plr->GetGUID());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    rmapid = fields[0].GetUInt16();
+                    rposx = fields[1].GetFloat();
+                    rposy = fields[2].GetFloat();
+                    rposz = fields[3].GetFloat();
+
+                    plr->SetMovement(MOVE_UNROOT);
+                    plr->TeleportTo(rmapid, rposx, rposy, rposz, rposo);
+                    plr->RemoveAurasDueToSpell(42201);
+                    plr->RemoveAurasDueToSpell(23775);
+                    plr->RemoveAurasDueToSpell(9454);
+                    Send_Player(plr, MakeMsg("You Have Been Released By: %s.", CD->USER.c_str()));
+                    sReason = " \00313["+_PARAMS[0]+"] : Has Been Released By: "+CD->USER+".";
+                    Send_IRCA(ChanOrPM(CD), sReason, true, CD->TYPE);
+                }
+            }
+            else
+            {
+                if (_PARAMS[1] == "")
+                    _PARAMS[1] = "No Reason Given.";
+                plr->TeleportTo(13, 0, 0, 0, 0);
+                plr->SetMovement(MOVE_ROOT);
+                plr->CastSpell(plr, 42201, true);
+                plr->CastSpell(plr, 23775, true);
+                plr->CastSpell(plr, 9454, true);
+                Send_Player(plr, MakeMsg("You Have Been Jailed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+                sReason = " \00313["+_PARAMS[0]+"] : Has Been Jailed By: "+CD->USER+". Reason: "+_PARAMS[1]+".";
+                Send_IRCA(ChanOrPM(CD), sReason, true, CD->TYPE);
+            }
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+    }
+}
+
+void IRCCmd::Kick_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (_PARAMS[1] == "")
+        _PARAMS[1] = "No Reason Given.";
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        plr->GetSession()->KickPlayer();
+        Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been Kicked By: "+CD->USER+". Reason: "+_PARAMS[1]+".", true, CD->TYPE);
+        if (sWorld->getBoolConfig(CONFIG_SHOW_KICK_IN_WORLD))
+            sIRC->Send_WoW_System("Player|cffff0000 "+_PARAMS[0]+"|r kicked by|cffff0000 "+CD->USER+"|r. Reason:|cffff0000"+_PARAMS[1]+"|r.");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Kill_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->IsAlive())
+        {
+            plr->DealDamage(plr, plr->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            plr->SaveToDB();
+            if (_PARAMS[1] == "")
+                _PARAMS[1] = "No Reason Given.";
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Killed By: %s.", _PARAMS[0].c_str(), CD->USER.c_str()) +  +  + " Reason: "+_PARAMS[1]+".", true, CD->TYPE);
+            Send_Player(plr, MakeMsg("You Have Been Killed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Already Dead!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Player_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    uint32 plguid = atoi(_PARAMS[0].c_str());
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (sObjectMgr->GetPlayerGUIDByName(_PARAMS[0].c_str()))
+        plguid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0].c_str());
+    if (plguid > 0)
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, online, level,  xp, money, totalHonorPoints, totaltime FROM characters WHERE guid =%i", plguid);
+        uint32 latency = 0;
+        ObjectGuid plguidnew = ObjectGuid(HighGuid::Player, plguid);
+        Player *chr = ObjectAccessor::FindPlayer(plguidnew);
+        if (chr)
+        {
+            latency = chr->GetSession()->GetLatency();
+        }
+        char templatency [100];
+        sprintf(templatency, "%ums", latency);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string pguid = fields[0].GetString();
+            std::string pacct = fields[1].GetString();
+            std::string pname = fields[2].GetString();
+            uint32 praceid = fields[3].GetUInt32();
+            uint32 pclassid = fields[4].GetUInt32();
+            std::string ponline = (fields[5].GetInt32() == 1 ? "\x3\x30\x33Online" : "\x3\x30\x34Offline\xF");
+            std::string plevel = fields[6].GetString();
+            std::string pxp = fields[7].GetString();
+            unsigned int money = fields[8].GetInt32();
+            std::string honor = fields[9].GetString();
+            std::string totaltim = SecToDay(fields[10].GetString());
+
+            std::string sqlquery = "SELECT `gmlevel` FROM `account_access` WHERE `id` = '" + pacct + "';";
+            QueryResult gmresult = LoginDatabase.Query(sqlquery.c_str());
+            std::string pgmlvl = "0";
+            if (gmresult)
+            {
+                Field *fields2 = gmresult->Fetch();
+                pgmlvl = fields2[0].GetString();
+            }
+
+            if (uint32(atoi(plevel.c_str())) < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+                plevel += " (" + pxp + ")";
+            unsigned int gold = money / 10000;
+            unsigned int silv = (money % 10000) / 100;
+            unsigned int cop = (money % 10000) % 100;
+            char tempgold [100];
+            sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+            if (ponline == "\x3\x30\x33Online")
+            {
+                Player * plr = ObjectAccessor::FindPlayerByName(pname.c_str());
+                if (plr)
+                {
+                    AreaTableEntry const* area = sAreaTableStore.LookupEntry(plr->GetAreaId());
+                    ponline += " in " + (std::string) area->area_name[sWorld->GetDefaultDbcLocale()];
+                    if (area->zone != 0)
+                    {
+                        AreaTableEntry const* zone = sAreaTableStore.LookupEntry(area->zone);
+                        ponline += " (" + (std::string)zone->area_name[sWorld->GetDefaultDbcLocale()] + ")";
+                    }
+                }
+            }
+            std::string pinfo  = "\00310About Player: \xF"+pname+" |\00310 GM Level: \xF"+pgmlvl+" |\00310 AcctID: \xF"+pacct+" |\00310 CharID: \xF"+pguid+" |\00310 Played Time: \xF"+totaltim.c_str()+" |\00310 Latency: \xF"+templatency;
+            std::string pinfo2 = "\00310Race: \xF"+(std::string)GetRaceName(praceid, 0)+" |\00310 Class: \xF" + (std::string)GetClassName(pclassid, 0)+" |\00310 Level: \xF"+plevel+" |\00310 Money: \xF"+tempgold+"|\00310 Status: \xF"+ponline+" |\00310 Honor: \xF"+honor;
+            // pinfo3 = " :" + " \x2Honor Kills:\x2\x3\x31\x30 " + hk;
+            Send_IRCA(ChanOrPM(CD),pinfo , true, CD->TYPE);
+            Send_IRCA(ChanOrPM(CD),pinfo2 , true, CD->TYPE);
+            // Send_IRCA(ChanOrPM(CD),pinfo3 , true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Unknown Character ID. (GUID)" ,true, "ERROR");
+    }
+    else
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name FROM characters WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[0].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string items = "\x2 Character Search Results:\x3\x31\x30 ";
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string guid = fields[0].GetString();
+                std::string account = fields[1].GetString();
+                std::string name = fields[2].GetString();
+                MakeUpper(name);
+                items.append(name+"(Account:"+account+" - GUID:"+guid+")\0031 | \xF");
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Unknown Character. I Cant Find Any Characters With Those Search Terms." ,true, "ERROR");
+    }
+
+}
+
+void IRCCmd::Lookup_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (_PARAMS[0] == "acct")
+    {
+        uint32 acctid = atoi(_PARAMS[1].c_str());
+        if (AccountMgr::GetId(_PARAMS[1]))
+            acctid = AccountMgr::GetId(_PARAMS[1]);
+        if (acctid > 0)
+        {
+            std::string DateTime = "%a, %b %d, %Y - %h:%i%p";
+            QueryResult result = LoginDatabase.PQuery("SELECT `account`.`id`, username, last_ip, (SELECT banreason FROM account_banned WHERE `account`.`id` = id LIMIT 1) as banned, (SELECT banreason FROM ip_banned WHERE ip = last_ip) as bannedip,(SELECT active FROM account_banned WHERE `account`.`id` = id) as banactive, (SELECT( unbandate - unix_timestamp( now() ) ) FROM account_banned WHERE `account`.`id` = id) as remainingtime, DATE_FORMAT(last_login, '%s') FROM `account` WHERE `account`.`id` =%d" ,DateTime.c_str(), acctid);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 id = fields[0].GetUInt32();
+                std::string usrname = fields[1].GetString();
+                std::string lastip = fields[2].GetString();
+                std::string banreason = fields[3].GetString();
+                std::string banreasonip = fields[4].GetString();
+                uint32 banactive = (fields[5].GetInt32() == 1 ? 1 : 0);
+                std::string TimeLeft = SecToDay(fields[6].GetString());
+                std::string lastlogin = fields[7].GetString();
+
+                QueryResult chars = CharacterDatabase.PQuery("SELECT guid, name, (SELECT SUM(totaltime) FROM characters WHERE account = %d) AS tottime FROM characters WHERE account = %u", id, id);
+                std::string characters = "None";
+                std::string totaccttime = "Never Logged In";
+                if (chars)
+                {
+                    characters = "";
+                    Field *fields = chars->Fetch();
+                    totaccttime = SecToDay(fields[2].GetString());
+                    for (uint64 i=0; i < chars->GetRowCount(); i++)
+                    {
+                        std::string guid = fields[0].GetString();
+                        std::string charname = fields[1].GetString();
+                       characters.append(charname+"("+guid+"), ");
+                        chars->NextRow();
+                    }
+
+                }
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Username: \xF %s | \00310AccountID: \xF %d | \00310Last IP: \xF %s | \00310Last Login: \xF %s", usrname.c_str(), id, lastip.c_str(), lastlogin.c_str()), true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Total play time: \xF %s | \00310Characters:  \xF %s ", totaccttime.c_str(), characters.c_str()), true, CD->TYPE);
+                if (banreason.length() > 1)
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\0035Account banned : \xF %s | \0035Ban Active: \xF %u | \0035Ban Time: \xF %s", banreason.c_str(), banactive, TimeLeft.c_str()), true, CD->TYPE);
+                if (banreasonip.length() > 1)
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\0034This User Has An IP Ban. Ban Reason: %s", banreasonip.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Account ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = LoginDatabase.PQuery("SELECT id, username FROM `account` WHERE username LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string accts = "\002Account Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string acctid = fields[0].GetString();
+                    std::string acctname = fields[1].GetString();
+                    accts.append(acctname+"("+acctid+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), accts, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Username. I Cant Find Any Users With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "char")
+    {
+        uint32 plguid = atoi(_PARAMS[1].c_str());
+        if (sObjectMgr->GetPlayerGUIDByName(_PARAMS[1].c_str()))
+            plguid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[1].c_str());
+        if (plguid > 0)
+        {
+            QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, online, SUBSTRING_INDEX(SUBSTRING_INDEX(`level`, ' ' , 35), ' ' , -1) AS level,  SUBSTRING_INDEX(SUBSTRING_INDEX(`xp`, ' ' , 927), ' ' , -1) AS xp, SUBSTRING_INDEX(SUBSTRING_INDEX(money, ' ' , 1462), ' ' , -1) AS gold, SUBSTRING_INDEX(SUBSTRING_INDEX(`totalHonorPoints`, ' ' , 1454), ' ' , -1) AS Honor, totaltime FROM characters WHERE guid =%i", plguid);
+            uint32 latency = 0;
+            ObjectGuid plguidnew = ObjectGuid(HighGuid::Player, plguid);
+            Player *chr = ObjectAccessor::FindPlayer(plguidnew);
+            if (chr)
+            {
+                latency = chr->GetSession()->GetLatency();
+            }
+            char templatency [100];
+            sprintf(templatency, "%ums", latency);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string pguid = fields[0].GetString();
+                std::string pacct = fields[1].GetString();
+                std::string pname = fields[2].GetString();
+                uint32 praceid = fields[3].GetUInt32();
+                uint32 pclassid = fields[4].GetUInt32();
+                std::string ponline = (fields[5].GetInt32() == 1 ? "\x3\x30\x33Online" : "\x3\x30\x34Offline\xF");
+                std::string plevel = fields[6].GetString();
+                std::string pxp = fields[7].GetString();
+                unsigned int money = fields[8].GetInt32();
+                std::string honor = fields[9].GetString();
+                std::string totaltim = SecToDay(fields[10].GetString());
+
+                std::string sqlquery = "SELECT `gmlevel` FROM `account_access` WHERE `id` = '" + pacct + "';";
+                QueryResult gmresult = LoginDatabase.Query(sqlquery.c_str());
+                std::string pgmlvl = "0";
+                if (gmresult)
+                {
+                    Field *fields = result->Fetch();
+                    pgmlvl = fields[0].GetString();
+                }
+
+                ChrRacesEntry const* prace = sChrRacesStore.LookupEntry(praceid);
+                ChrClassesEntry const* pclass = sChrClassesStore.LookupEntry(pclassid);
+
+                if (uint32(atoi(plevel.c_str())) < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+                    plevel += " (" + pxp + ")";
+                unsigned int gold = money / 10000;
+                unsigned int silv = (money % 10000) / 100;
+                unsigned int cop = (money % 10000) % 100;
+                char tempgold [100];
+                sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+                if (ponline == "\x3\x30\x33Online")
+                {
+                    Player * plr = ObjectAccessor::FindPlayerByName(pname.c_str());
+                    if (plr)
+                    {
+                        AreaTableEntry const* area = sAreaTableStore.LookupEntry(plr->GetAreaId());
+                        ponline += " in " + (std::string) area->area_name[sWorld->GetDefaultDbcLocale()];
+                        if (area->zone != 0)
+                        {
+                            AreaTableEntry const* zone = sAreaTableStore.LookupEntry(area->zone);
+                            ponline += " (" + (std::string)zone->area_name[sWorld->GetDefaultDbcLocale()] + ")";
+                        }
+                    }
+                }
+                std::string pinfo  = "\x2 About Player:\x3\x31\x30 " +pname+ "\xF |\x2 GM Level:\x3\x31\x30 " +pgmlvl+ "\xF |\x2 AcctID:\x3\x31\x30 " +pacct+ "\xF |\x2 CharID:\x3\x31\x30 " +pguid+ " \xF |\x2 Played Time:\x2\x3\x31\x30 " +totaltim.c_str()+" \xF |\x2 Latency:\x2\x3\x31\x30 "+templatency;
+                std::string pinfo2 = "\x2 Race:\x2\x3\x31\x30 " + (std::string)prace->name[sWorld->GetDefaultDbcLocale()] + "\xF |\x2 Class:\x2\x3\x31\x30 " + (std::string)pclass->name[sWorld->GetDefaultDbcLocale()] + "\xF |\x2 Level:\x2\x3\x31\x30 " + plevel + "\xF |\x2 Money:\x2 " + tempgold + "\xF |\x2 Status:\x2 " + ponline;
+                // pinfo3 = " :" + " \x2Honor Kills:\x2\x3\x31\x30 " + hk;
+                Send_IRCA(ChanOrPM(CD),pinfo , true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD),pinfo2 , true, CD->TYPE);
+                // Send_IRCA(ChanOrPM(CD),pinfo3 , true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Character ID. (GUID)" ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name FROM characters WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\x2 Character Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string guid = fields[0].GetString();
+                    std::string account = fields[1].GetString();
+                    std::string name = fields[2].GetString();
+                    MakeUpper(name);
+                    items.append(name+"(Account:"+account+" - GUID:"+guid+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Character. I Cant Find Any Characters With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "creature")
+    {
+        std::string creature = _PARAMS[1];
+        if (atoi(creature.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name, minlevel,maxlevel, faction_A,  (SELECT count(guid) FROM creature WHERE id = '%s') as spawns FROM creature_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 entry = fields[0].GetUInt32();
+                std::string name = fields[1].GetString();
+                uint32 minlevel = fields[2].GetUInt32();
+                uint32 maxlevel = fields[3].GetUInt32();
+                uint32 faction = fields[4].GetUInt32();
+                uint32 spawns = fields[5].GetUInt32();
+
+
+               Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Name:\x3\x31\x30 %s \xF|\x2 CreatureID:\x3\x31\x30 %d", name.c_str(), entry), true, CD->TYPE);
+               Send_IRCA(ChanOrPM(CD), MakeMsg("\x2minlevel:\x3\x31\x30 %d \xF|\x2 maxlevel:\x3\x31\x30 %d \xF|\x2 Faction:\x3\x31\x30 %d \xF|\x2 Spawns:\x3\x31\x30 %d", minlevel, maxlevel, faction, spawns), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Creature ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM creature_template WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\002Creature Search Results:\x3\x31\x30 ";
+                //Send_IRCA(ChanOrPM(CD), "", true, CD->TYPE);
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string CreatureID = fields[0].GetString();
+                    std::string Name = fields[1].GetString();
+                    items.append(Name+"("+CreatureID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Creature. I Cant Find Any Creatures With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "faction")
+    {
+        std::string faction = _PARAMS[1];
+        if (atoi(faction.c_str()) > 0)
+        {
+            FactionEntry const *factionEntry = sFactionStore.LookupEntry(atoi(faction.c_str()));
+            if (factionEntry)
+            {
+                std::string name = factionEntry->name[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2 Faction:\x3\x31\x30 %s \xF|\x2 FactionID:\x3\x31\x30 %s",name.c_str(), faction.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown FactionID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string factions = "\002Faction Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sFactionStore.GetNumRows(); id++)
+            {
+                FactionEntry const *factionEntry = sFactionStore.LookupEntry(id);
+                if (factionEntry)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = factionEntry->name[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char factionid[100];
+                        sprintf(factionid, "%d", id);
+                        factions.append(name+"("+factionid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                factions.append("No Factions Found.");
+            Send_IRCA(ChanOrPM(CD), factions, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "go")
+    {
+        std::string gobject = _PARAMS[1];
+        if (atoi(gobject.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, type, displayId, name, faction, (SELECT count(*) FROM gameobject WHERE id = '%s') as spawns FROM gameobject_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 entry = fields[0].GetUInt32();
+                uint32 type = fields[1].GetUInt32();
+                uint32 modelid = fields[2].GetUInt32();
+                std::string name = fields[3].GetString();
+                uint32 faction = fields[4].GetUInt32();
+                uint32 spawns = fields[5].GetUInt32();
+
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2GO Name:\x3\x31\x30 %s \xF|\x2 GameobjectID:\x3\x31\x30 %d \xF|\x2 DisplayID:\x3\x31\x30 %d \xF|\x2 Spawns:\x3\x31\x30 %d", name.c_str(), entry, modelid, spawns), true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Type:\x3\x31\x30 %d \xF|\x2 Faction:\x3\x31\x30 %d", type, faction), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown GameObject ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM gameobject_template WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string gos = "\002Gameobject Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string GOID = fields[0].GetString();
+                    std::string GoName = fields[1].GetString();
+                    gos.append(GoName+"("+GOID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), gos, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Game Object. I Cant Find Any Game Object's With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "item")
+    {
+        std::string item = _PARAMS[1];
+        if (atoi(item.c_str()) > 0)
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name, displayid, (SELECT count(*) FROM creature_loot_template WHERE item = '%s') as loot FROM `item_template` WHERE entry = %s", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                QueryResult result2 = CharacterDatabase.PQuery("SELECT count(*) FROM `character_inventory` WHERE item_template = %s", _PARAMS[1].c_str());
+                Field *fields2 = result2->Fetch();
+                uint32 charcnt = fields2[0].GetUInt32();
+
+
+                uint32 ItemID = fields[0].GetUInt32();
+                std::string ItmName = fields[1].GetString();
+                uint32 DisplayID = fields[2].GetUInt32();
+                uint32 loots = 0;
+                loots = fields[3].GetUInt32();
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Item:\x3\x31\x30 %s \xF|\x2 ItemID:\x3\x31\x30 %d \xF|\x2 DisplayID:\x3\x31\x30 %d \xF|\x2 Owned By:\x3\x31\x30 %d players \xF|\x2 Dropped By:\x3\x31\x30 %d creatures", ItmName.c_str(), ItemID, DisplayID, charcnt, loots), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown ItemID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM `item_template` WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\002Item Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string ItemID = fields[0].GetString();
+                    std::string ItemName = fields[1].GetString();
+                    items.append(ItemName+"("+ItemID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Item. I Cant Find Any Items With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "quest")
+    {
+        std::string quest = _PARAMS[1];
+        if (atoi(quest.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT id, Title FROM quest_template WHERE id = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                QueryResult result2 = CharacterDatabase.PQuery("SELECT count(*) FROM character_queststatus WHERE quest = '%s' AND status = '1';", _PARAMS[1].c_str());
+                Field *fields2 = result2->Fetch();
+                uint32 status = fields2[0].GetUInt32();
+
+
+                Field *fields = result->Fetch();
+                uint32 entry = fields[0].GetUInt32();
+                std::string name = fields[1].GetString();
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Quest Name:\x3\x31\x30 %s \xF|\x2 QuestID:\x3\x31\x30 %d \xF|\x2 Completed:\x3\x31\x30 %d times", name.c_str(), entry, status), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Quest ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT id, Title FROM quest_template WHERE Title LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string quests = "\002Quest Search Results:\x3\x31\x30 ";
+                //Send_IRCA(ChanOrPM(CD), "", true, CD->TYPE);
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string QuestID = fields[0].GetString();
+                    std::string QuestName = fields[1].GetString();
+                    quests.append(QuestName+"("+QuestID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), quests, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Quest. I Cant Find Any Quest's With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "skill")
+    {
+        std::string skill = _PARAMS[1];
+        if (atoi(skill.c_str()) > 0)
+        {
+            SkillLineEntry const *skillInfo = sSkillLineStore.LookupEntry(atoi(skill.c_str()));
+            if (skillInfo)
+            {
+                std::string name = skillInfo->name[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Skill:\x3\x31\x30 %s \xF|\x2 SkillID:\x3\x31\x30 %s",name.c_str(), skill.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown SkillID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string skills = "\002Skill Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sSkillLineStore.GetNumRows(); id++)
+            {
+                SkillLineEntry const *skillInfo = sSkillLineStore.LookupEntry(id);
+                if (skillInfo)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = skillInfo->name[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char skillid[100];
+                        sprintf(skillid, "%d", id);
+                        skills.append(name+"("+skillid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                skills.append("No Skills Found.");
+            Send_IRCA(ChanOrPM(CD), skills, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "spell")
+    {
+        std::string spell = _PARAMS[1];
+        if (atoi(spell.c_str()) > 0)
+        {
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(atoi(spell.c_str()));
+            if (spellInfo)
+            {
+                std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Spell:\x3\x31\x30 %s \xF|\x2 SpellID:\x3\x31\x30 %s",name.c_str(), spell.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown SpellID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string spells = "\002Spell Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sSpellStore.GetNumRows(); id++)
+            {
+                SpellEntry const *spellInfo = sSpellStore.LookupEntry(id);
+                if (spellInfo)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char itemid[100];
+                        sprintf(itemid, "%d", id);
+                        spells.append(name+"("+itemid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                spells.append("No Spells Found.");
+            Send_IRCA(ChanOrPM(CD), spells, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "tele")
+    {
+        std::string tele = _PARAMS[1];
+        if (atoi(tele.c_str()) > 0)
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT * FROM `game_tele` WHERE id = %s", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 teleid = fields[0].GetUInt32();
+                uint32 pos_x = fields[1].GetUInt32();
+                uint32 pos_y = fields[2].GetUInt32();
+                uint32 pos_z = fields[3].GetUInt32();
+                uint32 oriet = fields[4].GetUInt32();
+                uint32 map = fields[5].GetUInt32();
+                std::string telname = fields[6].GetString();
+
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Tele Name:\x3\x31\x30 %s \xF|\x2 TeleID:\x3\x31\x30 %d \xF|\x2 Coordinates:\x3\x31\x30 [X: %d, Y: %d, Z: %d, MAP: %d, Orientation: %d]", telname.c_str(), teleid, pos_x, pos_y, pos_z, map, oriet), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Teleport Location ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT id, name FROM `game_tele` WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string teles = "\002Tele Location Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string TeleID = fields[0].GetString();
+                    std::string TeleName = fields[1].GetString();
+                    teles.append(TeleName+"("+TeleID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                Send_IRCA(ChanOrPM(CD), teles, true, CD->TYPE);
+
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Item. I Cant Find Any Items With Those Search Terms." ,true, "ERROR");
+        }
+    }
+}
+
+void IRCCmd::Level_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(player.c_str());
+    std::string s_newlevel  = _PARAMS[1];
+    uint8 i_newlvl = atoi(s_newlevel.c_str());
+    if (!guid)
+    {
+        Send_IRCA(CD->USER, "Player Not Found!", true, "ERROR");
+        return;
+    } else if (i_newlvl < 1 || i_newlvl > sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+    {
+        Send_IRCA(CD->USER, MakeMsg("Level Must Be Between 1 And %i!",sConfigMgr->GetIntDefault("MaxPlayerLevel", 80)), true, "ERROR");
+        return;
+    } else
+    {
+        Player *chr = ObjectAccessor::FindPlayer(guid);
+        ObjectGuid level = ObjectGuid::Empty;
+        int32 i_oldlvl = chr ? chr->getLevel() : Player::GetLevelFromDB(level);
+
+        if (chr)
+        {
+            chr->GiveLevel(i_newlvl);
+            chr->InitTalentForLevel();
+            chr->SetUInt32Value(PLAYER_XP,0);
+            WorldPacket data;
+            std::stringstream ss;
+            ChatHandler CH(chr->GetSession());
+            if (i_oldlvl == i_newlvl)
+                //CH.FillSystemMessageData(&data, "Your level progress has been reset.");
+                CH.BuildChatPacket(data, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, NULL, "Your level progress has been reset.");
+            else
+            if (i_oldlvl < i_newlvl)
+            {
+                          ss << "You have been leveled up" << i_newlvl-i_oldlvl;
+                          //CH.FillSystemMessageData(&data, ss.str().c_str());
+                          CH.BuildChatPacket(data, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, NULL, ss.str().c_str());
+                        }
+            else if (i_oldlvl > i_newlvl)
+                        {
+                         ss << "You have been leveled down" << i_newlvl-i_oldlvl;
+                         //CH.FillSystemMessageData(&data, ss.str().c_str());
+                         CH.BuildChatPacket(data, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, NULL, ss.str().c_str());
+                         chr->GetSession()->SendPacket(&data);
+                        }
+        }
+        else
+        {
+            Send_IRCA(CD->USER, "" + _PARAMS[0] + " Is Not Online! Setting new level in DB.", true, "ERROR");
+            CharacterDatabase.PExecute("UPDATE characters SET level = '%u', xp = 0 WHERE guid = '%u'", i_newlvl, guid);
+        }
+    }
+    Send_IRCA(ChanOrPM(CD), "\00313[" + _PARAMS[0]+ "] : Has Been Leveled To " + _PARAMS[1] + ". By: "+CD->USER+".", true, CD->TYPE);
+}
+
+void IRCCmd::Money_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(player.c_str());
+
+    std::string s_money  = _PARAMS[1];
+    int32 money = atoi(s_money.c_str());
+    unsigned int gold = money / 10000;
+    unsigned int silv = (money % 10000) / 100;
+    unsigned int cop = (money % 10000) % 100;
+    char tempgold [100];
+    sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+    if (!guid)
+    {
+        Send_IRCA(CD->USER, "Player Not Found!", true, "ERROR");
+        return;
+    }
+    else
+    {
+        Player *chr = ObjectAccessor::FindPlayer(guid);
+        uint32 moneyuser = 0;
+        if (chr)
+            moneyuser = chr->GetMoney();
+        else {
+        CharacterDatabase.EscapeString(player);
+        std::string sqlquery = "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(money, ' ' , 1462), ' ' , -1) AS `gold` FROM `characters` WHERE `name` = '"+player+"';";
+        QueryResult result = CharacterDatabase.Query(sqlquery.c_str());
+            Field *fields = result->Fetch();
+            moneyuser = fields[0].GetInt32();
+
+        }
+            int32 addmoney = money;
+            int32 newmoney = moneyuser + addmoney;
+            char s_newmoney[255];
+            sprintf(s_newmoney,"%d",newmoney);
+            if (addmoney < 0)
+            {
+                TC_LOG_ERROR("misc", "USER1: %i, ADD: %i, DIF: %i\\n", moneyuser, addmoney, newmoney);
+                if (newmoney <= 0)
+                {
+                    Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Had All Money Taken By: "+CD->USER.c_str()+".", true, CD->TYPE);
+                    if (chr)
+                    {
+                        chr->SetMoney(0);
+                        Send_Player(chr, MakeMsg("You Have Been Liquidated By: %s. Total Money Is Now 0.", CD->USER.c_str()));
+                    }
+                    else
+                        CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+                }
+                else
+                {
+                    Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Had ("+s_money+"\00313) Taken From Them By: "+CD->USER.c_str()+".", true, CD->TYPE);
+                    if (chr)
+                    {
+                        chr->SetMoney(newmoney);
+                        Send_Player(chr, MakeMsg("You Have Had %s Copper Taken From You By: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+                    }
+                    else
+                        CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+                }
+            }
+            else
+            {
+                Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Been Given ("+tempgold+"\00313) From: "+CD->USER.c_str()+".", true, CD->TYPE);
+                if (chr)
+                {
+                    chr->ModifyMoney(addmoney);
+                    Send_Player(chr, MakeMsg("You Have Been Given %s Copper. From: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+                }
+                else
+                    CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+            }
+    }
+}
+
+void IRCCmd::Mute_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    if (guid)
+    {
+        if (_PARAMS[1] == "release")
+        {
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            uint32 account_id = 0;
+            account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+            LoginDatabase.PExecute("UPDATE `account` SET `mutetime` = '0', `mutereason` = '', `muteby` = '' WHERE `id` = '%d'",account_id);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been UnMuted By: "+CD->USER+"." , true, CD->TYPE);
+            if (plr)
+            {
+                plr->GetSession()->m_muteTime = 0;
+                Send_Player(plr, MakeMsg("You Have Been UnMuted By: %s.", CD->USER.c_str()));
+            }
+        }
+        else
+        {
+            if (_PARAMS[2] == "")
+                _PARAMS[2] = "No Reason Given";
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            time_t mutetime = time(NULL) + atoi(_PARAMS[1].c_str())*60;
+            std::string By = "IRC:";
+            By += CD->USER.c_str();
+            uint32 account_id = 0;
+            account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+            if (plr)
+                plr->GetSession()->m_muteTime = mutetime;
+            PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_MUTE_TIME);
+            stmt->setInt64(0, mutetime);
+            stmt->setString(1, _PARAMS[2].c_str());
+            stmt->setString(2, By.c_str());
+            stmt->setUInt32(3, account_id);
+            LoginDatabase.Execute(stmt);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been Muted By: "+CD->USER+". For: "+_PARAMS[1]+" Minutes. Reason: "+_PARAMS[2] , true, CD->TYPE);
+            if (plr)
+                Send_Player(plr, MakeMsg("You Have Been Muted By: %s. For: %s Minutes. Reason: %s", CD->USER.c_str(), _PARAMS[1].c_str(), _PARAMS[2].c_str()));
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Player Does Not Exist!", true, "ERROR");
+}
+
+void IRCCmd::Online_Players(_CDATA *CD)
+{
+        sIRC->Script_Lock[MCS_Players_Online] = true;
+        boost::thread script([CD](){
+            mcs_OnlinePlayers mcs(CD);
+            mcs.run();
+        });
+}
+
+void IRCCmd::PM_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isAcceptWhispers())
+        {
+            std::string sMsg = MakeMsg("|cffFE87FD[<IRC>%s] Whispers: %s|r", CD->USER.c_str(), _PARAMS[1].c_str());
+            WorldPacket data(SMSG_MESSAGECHAT, 200);
+            data << (uint8)CHAT_MSG_SYSTEM;
+            data << (uint32)LANG_UNIVERSAL;
+            data << (uint64)plr->GetGUID();
+            data << (uint32)0;
+            data << (uint64)plr->GetGUID();
+            data << (uint32)(sMsg.length()+1);
+            data << sMsg;
+            data << (uint8)0;
+            plr->GetSession()->SendPacket(&data);
+            plr->PlayDirectSound(3081, plr->ToPlayer());
+            Send_IRCA(ChanOrPM(CD), "\00313To ["+_PARAMS[0]+"] : "+_PARAMS[1]+".", true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Is Not Accepting Private Messages!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Player not online!", true, "ERROR");
+}
+
+void IRCCmd::Restart_Trinity(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "cancel")
+    {
+        sWorld->ShutdownCancel();
+        Send_IRCA(ChanOrPM(CD), "\0034Server Restart Has Been Cancelled.", true, CD->TYPE);
+    }
+
+    int32 i_time = atoi(_PARAMS[0].c_str());
+    if (i_time < 0)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Please Enter A Number! And No Negative Numbers! "+_PARAMS[0]+" Seconds!?", true, CD->TYPE);
+        return;
+    }
+    if (i_time >= 1)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Requested Server To Restart In "+_PARAMS[0]+" Seconds!", true, CD->TYPE);
+        sWorld->ShutdownServ(i_time,SHUTDOWN_MASK_RESTART, RESTART_EXIT_CODE);
+        Delay(i_time*1000);
+        Send_IRCA(ChanOrPM(CD), "\0034Server Will Now Restart.. Be Back In A Flash!", true, CD->TYPE);
+    }
+}
+
+void IRCCmd::Revive_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isDead())
+        {
+            plr->ResurrectPlayer(0.5f);
+            plr->SpawnCorpseBones();
+            plr->SaveToDB();
+            sIRC->Send_IRC_Channel(ChanOrPM(CD), " \00313["+_PARAMS[0]+"] : Has Been Revived By: " + CD->USER, true, CD->TYPE);
+            Send_Player(plr, MakeMsg("You Have Been Revived By: %s.", CD->USER.c_str()));
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Dead!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Saveall_Player(_CDATA *CD)
+{
+    ObjectAccessor::SaveAllPlayers();
+    Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Saved All Players!", true, CD->TYPE);
+}
+
+void IRCCmd::Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (_PARAMS[0] == "setmotd")
+    {
+        sWorld->SetMotd(_PARAMS[1]);
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Set New Message Of The Day To: "+_PARAMS[1], true, CD->TYPE);
+    }
+    if (_PARAMS[0] == "flusharenapoints")
+    {
+        sArenaTeamMgr->DistributeArenaPoints();
+    }
+}
+
+void IRCCmd::Shutdown_Trinity(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "cancel")
+    {
+        sWorld->ShutdownCancel();
+        Send_IRCA(ChanOrPM(CD), "\0034Server Shutdown Has Been Cancelled.", true, CD->TYPE);
+    }
+
+    int32 i_time = atoi(_PARAMS[0].c_str());
+    if (i_time < 0)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Please Enter A Number! And No Negative Numbers! "+_PARAMS[0]+" Seconds!?", true, CD->TYPE);
+        return;
+    }
+    if (i_time >= 1)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Requested Server To Be Shut Down In "+_PARAMS[0]+" Seconds!", true, CD->TYPE);
+        sWorld->ShutdownServ(i_time, SHUTDOWN_MASK_IDLE , SHUTDOWN_EXIT_CODE);
+        Delay(i_time*1000);
+        Send_IRCA(ChanOrPM(CD), "\0034Server Will Now Shut Down.. Good Bye!", true, CD->TYPE);
+    }
+}
+
+void IRCCmd::Spell_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    uint32 spell = atoi(_PARAMS[2].c_str());
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (spellInfo)
+        {
+            std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+            if (_PARAMS[1] == "cast")
+            {
+                plr->CastSpell(plr, spell, true);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Had Spell "+name+" Casted On Them.", true, CD->TYPE);
+            }
+            if (_PARAMS[1] == "learn")
+            {
+                plr->LearnSpell(spell, true);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Learned Spell "+name+".", true, CD->TYPE);
+            }
+            if (_PARAMS[1] == "unlearn")
+            {
+                plr->RemoveSpell(spell);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Unlearned Spell "+name+".", true, CD->TYPE);
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "Incorrect Spell ID!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Player Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Sysmsg_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    std::string ircchan = "#";
+    ircchan += sIRC->anchn;
+    if (_PARAMS[0] == "a")
+    {
+        std::string str = _PARAMS[1];
+        std::string ancmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 System Message \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        sWorld->SendWorldText(6620,str.c_str());
+        sIRC->Send_IRC_Channel(ircchan, ancmsg, true);
+    }
+    else if (_PARAMS[0] == "e")
+    {
+        std::string str = _PARAMS[1];
+        std::string notstr = "[Server Event]: " + _PARAMS[1];
+        std::string notmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Server Event \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        WorldPacket data(SMSG_NOTIFICATION, (notstr.size()+1));
+        data << notstr;
+        WorldPacket data2(SMSG_PLAY_SOUND,32);
+        data2 << (uint32)1400;
+        sWorld->SendGlobalMessage(&data2);
+        sWorld->SendGlobalMessage(&data);
+        sWorld->SendWorldText(6621,str.c_str());
+        sIRC->Send_IRC_Channel(ircchan, notmsg, true);
+    }
+    else if (_PARAMS[0] == "n")
+    {
+        std::string str = "Global notify: " + _PARAMS[1];
+        std::string notmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Global Notify \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld->SendGlobalMessage(&data);
+        sIRC->Send_IRC_Channel(ircchan, notmsg, true);
+    }
+    else if (_PARAMS[0] == "gm")
+    {
+        std::string str = "GM Announcement: " + _PARAMS[1];
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld->SendGlobalGMMessage(&data);
+
+    }
+    else if (_PARAMS[0] == "add")
+    {
+        WorldDatabase.PExecute("INSERT INTO irc_autoannounce (message, addedby) VALUES ('%s', '%s')", _PARAMS[1].c_str(), CD->USER.c_str());
+        std::string str = _PARAMS[1];
+        std::string ancmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Automatic System Message \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        sWorld->SendWorldText(6622,str.c_str());
+        sIRC->Send_IRC_Channel(ircchan, ancmsg, true);
+    }
+    else if (_PARAMS[0] == "del")
+    {
+        WorldDatabase.PExecute("DELETE FROM irc_autoannounce WHERE id = %s", _PARAMS[1].c_str());
+        Send_IRCA(ChanOrPM(CD), MakeMsg("Deleted Automatic Announcement Message ID: %s", _PARAMS[1].c_str()), true, CD->TYPE);
+    }
+    else if (_PARAMS[0] == "list")
+    {
+        QueryResult result = WorldDatabase.PQuery("SELECT * FROM irc_autoannounce LIMIT 5;", _PARAMS[1].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string id = fields[0].GetString();
+                std::string message = fields[1].GetString();
+                std::string addedby = fields[2].GetString();
+                Send_IRCA(ChanOrPM(CD), MakeMsg("ID: %s - Added By: %s - Message: %s", id.c_str(), addedby.c_str(), message.c_str()), true, CD->TYPE);
+                result->NextRow();
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "No Auto Announce Messages Are In The Database.", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Please Use (a-Announce)(n-Notify)(e-Event) As Second Parameter!", true, "ERROR");
+}
+
+void IRCCmd::Tele_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 4);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    bool DoTeleport = false;
+    float pX, pY, pZ, pO = 0;
+    uint32 mapid = 0;
+    std::string rMsg = " Teleport Failed!";
+    std::string wMsg = "Invalid Tele Location";
+    Player* plr = GetPlayer(_PARAMS[0]);
+    if (plr)
+    {
+        if (plr->IsInFlight() || plr->IsInCombat())
+        {
+            Send_IRCA(CD->USER, MakeMsg("%s Is Busy And Cannot Be Teleported! They Could Be In Combat, Or Flying.",_PARAMS[0].c_str()), true, "ERROR");
+            return;
+        }
+    }
+    if (_PARAMS[1] == "l" || _PARAMS[1].size() > 2)
+    {
+        if (_PARAMS[1].size() > 1)
+            _PARAMS[2] = _PARAMS[1];
+        WorldDatabase.EscapeString(_PARAMS[2]);
+        QueryResult result = WorldDatabase.PQuery("SELECT position_x, position_y, position_z, orientation, map FROM game_tele WHERE name='%s';", _PARAMS[2].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            pX = fields[0].GetFloat();
+            pY = fields[1].GetFloat();
+            pZ = fields[2].GetFloat();
+            pO = fields[3].GetFloat();
+            mapid = fields[4].GetUInt16();
+
+            rMsg = MakeMsg(" \00313[%s] : Teleported To %s! By: %s.",
+                _PARAMS[0].c_str(),
+                _PARAMS[2].c_str(),
+                CD->USER.c_str());
+            wMsg = MakeMsg("You Have Been Teleported To %s By: %s.",
+                _PARAMS[2].c_str(),
+                CD->USER.c_str());
+            DoTeleport = true;
+        }
+        else
+        {
+            WorldDatabase.EscapeString(_PARAMS[2]);
+            QueryResult result = WorldDatabase.PQuery("SELECT name FROM game_tele WHERE name LIKE '%%%s%%' LIMIT 7;", _PARAMS[2].c_str());
+            if (result)
+            {
+                std::string telename = "<> ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    Field *fields = result->Fetch();
+                    telename.append(fields[0].GetString());
+                    result->NextRow();
+                    telename.append(" <> ");
+                }
+
+                Send_IRCA(CD->USER, "I Cannot Find Location: "+_PARAMS[2]+" . Perhaps One Of These Will Work For You.", true, "ERROR");
+                Send_IRCA(CD->USER, telename, true, "ERROR");
+                return;
+            }
+            else
+                Send_IRCA(CD->USER, "Location Not Found! Nothing Even Close Found!", true, "ERROR");
+                return;
+        }
+    }
+    else if (_PARAMS[1] == "c")
+    {
+        std::string* _PARAMSA = getArray(_PARAMS[2], 4);
+        pX = atof(_PARAMSA[1].c_str());
+        pY = atof(_PARAMSA[2].c_str());
+        pZ = atof(_PARAMSA[3].c_str());
+        mapid = atoi(_PARAMSA[0].c_str());
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMSA[0].c_str(),
+            _PARAMSA[1].c_str(),
+            _PARAMSA[2].c_str(),
+            _PARAMSA[3].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Have Been Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+            _PARAMSA[0].c_str(),
+            _PARAMSA[1].c_str(),
+            _PARAMSA[2].c_str(),
+            _PARAMSA[3].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+    }
+    else if (_PARAMS[1] == "r")
+    {
+        if (plr)
+        {
+            pX = plr->m_recallX;
+            pY = plr->m_recallY;
+            pZ = plr->m_recallZ;
+            pO = plr->m_recallO;
+            mapid = plr->m_recallMap;
+            rMsg = MakeMsg(" \00313[%s] : Has Been Recalled To Their Previous Location.",
+                _PARAMS[0].c_str());
+            wMsg = MakeMsg("You Have Been Recalled To Your Previous Location. By: %s",
+                CD->USER.c_str());
+            DoTeleport = true;
+        }
+        else
+        {
+            Send_IRCA(CD->USER, MakeMsg("\00313[%s] : Cannot Be Recalled, They Are Not Online.", _PARAMS[0].c_str()), true, "ERROR");
+            return;
+        }
+
+    }
+    else if (_PARAMS[1] == "to")
+    {
+        Player* plr2 = GetPlayer(_PARAMS[2]);
+        if (plr2)
+        {
+            plr2->GetContactPoint(plr, pX, pY, pZ);
+            mapid = plr2->GetMapId();
+        }
+        else
+        {
+            if (ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[2].c_str()))
+            {
+                bool in_flight;
+                Player::LoadPositionFromDB(mapid, pX, pY, pZ, pO, in_flight, guid);
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Second Player Not Found!", true, "ERROR");
+                return;
+            }
+        }
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Player: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+    }
+    else if (_PARAMS[1] == "cr")
+    {
+      QueryResult result = WorldDatabase.PQuery("SELECT position_x,position_y,position_z,orientation,map FROM creature WHERE guid ='%s' LIMIT 1", _PARAMS[2].c_str());
+      if (!result)
+      {
+          Send_IRCA(CD->USER, "Creature GUID not found", true, "ERROR");
+      }
+      else
+      {
+        Field *fields = result->Fetch();
+        pX = fields[0].GetFloat();
+        pY = fields[1].GetFloat();
+        pZ = fields[2].GetFloat();
+        pO = fields[3].GetFloat();
+        mapid = fields[4].GetUInt16();
+
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Creature: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+
+      }
+    }
+    else if (_PARAMS[1] == "go")
+    {
+      QueryResult result = WorldDatabase.PQuery("SELECT position_x,position_y,position_z,orientation,map FROM gameobject WHERE guid ='%s' LIMIT 1", _PARAMS[2].c_str());
+      if (!result)
+      {
+          Send_IRCA(CD->USER, "GO GUID not found", true, "ERROR");
+      }
+      else
+      {
+        Field *fields = result->Fetch();
+        pX = fields[0].GetFloat();
+        pY = fields[1].GetFloat();
+        pZ = fields[2].GetFloat();
+        pO = fields[3].GetFloat();
+        mapid = fields[4].GetUInt16();
+
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Gameobject: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+
+      }
+    }
+    else if (_PARAMS[1] == "homebind")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT posX,posY,posZ,mapId FROM `character_homebind` WHERE guid = '%d'", plr->GetGUID());
+        if (!result)
+        {
+          Send_IRCA(CD->USER, "Unexpected Error Loading Homebind Location", true, "ERROR");
+        }
+        else
+        {
+            Field *fields = result->Fetch();
+            pX = fields[0].GetFloat();
+            pY = fields[1].GetFloat();
+            pZ = fields[2].GetFloat();
+            pO = 1;
+            mapid = fields[3].GetUInt16();
+
+            rMsg = MakeMsg(" \00313[%s] : Teleported To Homebind Location By: %s.",
+                _PARAMS[0].c_str(),
+                CD->USER.c_str());
+            wMsg = MakeMsg("You Are Being Teleported To Your Homebind Location By: %s.",
+            CD->USER.c_str());
+            DoTeleport = true;
+
+        }
+
+    }
+    if (DoTeleport)
+    {
+        if (MapManager::IsValidMapCoord(mapid, pX ,pY ,pZ))
+        {
+                //if player is online teleport them in real time, if not set the DB to our coordinates.
+                if (plr)
+                {
+                    plr->SaveRecallPosition();
+                    plr->TeleportTo(mapid, pX, pY, pZ, pO);
+                    sIRC->Send_IRC_Channel(ChanOrPM(CD), rMsg, true, CD->TYPE);
+                    Send_Player(plr, wMsg);
+                }
+                else
+                {
+                    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+                    WorldLocation loc;
+                    loc.WorldRelocate(mapid,pX,pY,pZ,0.0f);
+                    sIRC->Send_IRC_Channel(ChanOrPM(CD), rMsg + " \0034*Offline Tele.* ", true, CD->TYPE);
+                }
+        }
+        else
+            Send_IRCA(CD->USER, "Invalid Location!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Invalid Paramaters, Please Try Again [ "+sIRC->_cmd_prefx+"help tele ] For More Information. ", true, "ERROR");
+}
+
+void IRCCmd::Top_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    uint32 limitr = 10;
+    if (atoi(_PARAMS[1].c_str()) > 0 && GetLevel(CD->USER) >= sIRC->_op_gm_lev)
+        limitr = atoi(_PARAMS[1].c_str());
+    if (_PARAMS[0] == "accttime")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT account, name, (SUM(totaltime)) AS combinetime FROM characters GROUP BY account ORDER BY combinetime DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Accounts By Played Time:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                uint32 account = fields[0].GetUInt32();
+                std::string PlName = GetAcctNameFromID(account);
+                std::string Time = SecToDay(fields[2].GetString());
+                uint32 rank = i+1;
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, PlName.c_str(), Time.c_str()));
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Accounts Returned." ,true, "ERROR");
+    }
+    if (_PARAMS[0] == "chartime")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT name, totaltime FROM characters ORDER BY totaltime DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Characters By Played Time:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string Name = fields[0].GetString();
+                std::string Time = SecToDay(fields[1].GetString());
+                uint32 rank = i+1;
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, Name.c_str(), Time.c_str()));
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Characters Returned." ,true, "ERROR");
+    }
+    if (_PARAMS[0] == "money")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT name, money FROM characters ORDER BY money DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Characters By Money:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string Name = fields[0].GetString();
+                unsigned int money = fields[1].GetInt32();
+
+                uint32 rank = i+1;
+
+                unsigned int gold = money / 10000;
+                unsigned int silv = (money % 10000) / 100;
+                unsigned int cop = (money % 10000) % 100;
+                char tempgold [100];
+                sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, Name.c_str(), tempgold));
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Characters Returned." ,true, "ERROR");
+    }
+
+}
+
+void IRCCmd::Chan_Control(_CDATA *CD)
+{
+
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+
+    if (CD->FROM == sIRC->_Nick)
+    {
+        Send_IRCA(CD->USER, "\0034[ERROR] : You Cannot Use This Command Through A PM Yet.", true, "ERROR");
+        return;
+    }
+
+    if (_PARAMS[0] == "op")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC->SendIRC("MODE "+CD->FROM+" +o "+_PARAMS[1]);
+        else
+            sIRC->SendIRC("MODE "+CD->FROM+" +o "+CD->USER);
+    }
+
+    if (_PARAMS[0] == "deop")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC->SendIRC("MODE "+CD->FROM+" -o "+_PARAMS[1]);
+        else
+            sIRC->SendIRC("MODE "+CD->FROM+" -o "+CD->USER);
+    }
+
+    if (_PARAMS[0] == "voice")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC->SendIRC("MODE "+CD->FROM+" +v "+_PARAMS[1]);
+        else
+            sIRC->SendIRC("MODE "+CD->FROM+" +v "+CD->USER);
+    }
+    if (_PARAMS[0] == "devoice")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC->SendIRC("MODE "+CD->FROM+" -v "+_PARAMS[1]);
+        else
+            sIRC->SendIRC("MODE "+CD->FROM+" -v "+CD->USER);
+    }
+};
+void IRCCmd::Who_Logged(_CDATA *CD)
+{
+    std::string OPS = "";
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        OPS.append(MakeMsg(" \002[GM:%d IRC: %s - WoW: %s]\002 ", (*i)->GMLevel, (*i)->Name.c_str(), (*i)->UName.c_str()));
+    }
+    Send_IRCA(ChanOrPM(CD), OPS, true, CD->TYPE);
+}
diff --git a/src/server/game/TriniChat/IRCFunc.h b/src/server/game/TriniChat/IRCFunc.h
new file mode 100644
index 0000000..f780dd7
--- /dev/null
+++ b/src/server/game/TriniChat/IRCFunc.h
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_FUNC
+#define _IRC_CLIENT_FUNC
+
+std::string GetUser(std::string szU)
+{
+    int pos = szU.find("!");
+    return szU.substr(0, pos);
+}
+// Delink will remove anything considered "non chat" from a string
+std::string Delink(std::string msg)
+{
+    std::size_t pos;
+
+        while((pos = msg.find("|Htrade")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hglyph")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hitem")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Henchant")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+        //msg.replace(find2, 2, "\x2");
+    }
+    while((pos = msg.find("|Hquest")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hspell")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Htalent")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hachievement")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Htrade")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    return msg;
+}
+
+// This function converts the characters used by the client to identify colour to IRC format.
+std::string WoWcol2IRC(std::string msg)
+{
+    std::size_t pos;
+    char IRCCol[17][6] = { "\xF", "\xF", "\x3\x31\x34", "\x3\x30\x33", "\x3\x31\x32", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x34", "\x3\x30\x34", "\x3\x31\x34", "\x3\x31\x32", "\x3\x30\x37", "\x3\x30\x34", "\x3\x30\x33", "\x3\x31\x32", "\x3\x31\x32", "\x3\x30\x37"};
+    char WoWCol[17][12] = { "|r", "|cffffffff", "|cff9d9d9d", "|cff1eff00", "|cff0070dd", "|cffa335ee", "|cffff8000", "|cffe6cc80", "|cffffd000", "|cff808080", "|cff71d5ff", "|cffffff00", "|cffff2020", "|cff40c040", "|cff4e96f7", "|cff71d5ff", "|cffff8040"};
+    for (int i=0; i<=15; i++)
+    {
+        while ((pos = msg.find(WoWCol[i])) != std::string::npos)
+        {
+            if (i == 0)
+                msg.replace(pos, 2, IRCCol[i]);
+            else
+                msg.replace(pos, 11, IRCCol[i]);
+        }
+    }
+    return msg;
+}
+
+// This function converts the characters used by IRC to identify colour to a format the client can understand.
+std::string IRCcol2WoW(std::string msg)
+{
+    std::size_t pos;
+    char IRCCol[18][4] = { "\x3\x30", "\x3\x31", "\x3\x32", "\x3\x33", "\x3\x34", "\x3\x35", "\x3\x36", "\x3\x37", "\x3\x38", "\x3\x39", "\x3\x31\x30", "\x3\x31\x31", "\x3\x31\x32", "\x3\x31\x33", "\x3\x31\x34", "\x3\x31\x35", "\x3\x30\x37", "\x3\x30\x37"};
+    char IRCCol2[10][4] = { "\x3\x30\x30", "\x3\x30\x31", "\x3\x30\x32", "\x3\x30\x33", "\x3\x30\x34", "\x3\x30\x35", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x38", "\x3\x30\x39"};
+    char WoWcol[18][12] = { "|cffffffff", "|cff000000", "|cff00007f", "|cff009300", "|cffff0000", "|cff7f0000", "|cff9c009c", "|cfffc9300", "|cffffff00", "|cff00fc00", "|cff009393", "|cff00ffff", "|cff0000fc", "|cffff00ff", "|cff7f7f7f", "|cffd2d2d2", "|cff808080", "|cff71d5ff"};
+    for (int i=15; i>=0; i--)
+    {
+        if (i<10)
+        {
+            while ((pos = msg.find(IRCCol2[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 2, WoWcol[i]);
+            }
+
+        }
+        else
+        {
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+        }
+
+        // Remove Bold, Reverse, Underline from IRC
+        char Checker[3][3] = {"\x2","\x16","\x1F"}; // This is the Hex part not Dec. In Decimal its (2,22,31)
+        for (int I=0; I < 3; I++)
+        {
+            while ((pos = msg.find(Checker[I])) != std::string::npos)
+            {
+                msg.replace(pos, 1, "");
+            }
+        }
+        // Finished Removing !
+
+    }
+
+    while ((pos = msg.find("\x3")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+    while ((pos = msg.find("\xF")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+
+    return msg;
+}
+
+// This function compares 2 strings
+int nocase_cmp(const string & s1, const string& s2)
+{
+    string::const_iterator it1=s1.begin();
+    string::const_iterator it2=s2.begin();
+
+    //stop when either string's end has been reached
+    while ((it1!=s1.end()) && (it2!=s2.end()))
+    {
+        if (::toupper(*it1) != ::toupper(*it2))              //letters differ?
+            // return -1 to indicate smaller than, 1 otherwise
+            return (::toupper(*it1)  < ::toupper(*it2)) ? -1 : 1;
+        //proceed to the next character in each string
+        ++it1;
+        ++it2;
+    }
+    size_t size1=s1.size(), size2=s2.size();                // cache lengths
+    //return -1,0 or 1 according to strings' lengths
+    if (size1==size2)
+        return 0;
+    return (size1<size2) ? -1 : 1;
+}
+
+std::string MakeMsgA(const char *sLine, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, sLine);
+    vsnprintf(tmpoutp, 1024, sLine, ap);
+    va_end(ap);
+    std::string outp = tmpoutp;
+    return outp;
+}
+
+std::string MakeMsgP(int CLINE, std::string Msg, Player *plr)
+{
+    std::string sMsg = sIRC->MakeMsg(sIRC->GetChatLine(CLINE), "$Msg", Msg);
+    if (plr->GetTeam() == 67)
+        sMsg = sIRC->MakeMsg(sMsg, "$Name", MakeMsgA("\0034%s\003", plr->GetName().c_str()));
+    else if (plr->GetTeam() == 469)
+        sMsg = sIRC->MakeMsg(sMsg, "$Name", MakeMsgA("\00312%s\003", plr->GetName().c_str()));
+    if (plr->isAFK())
+        sMsg = sIRC->MakeMsg(sMsg, "$Tag", "<AFK>");
+    else if (plr->isDND())
+        sMsg = sIRC->MakeMsg(sMsg, "$Tag", "<DND>");
+    else
+        sMsg = sIRC->MakeMsg(sMsg, "$Tag", "");
+    sMsg = sIRC->MakeMsg(sMsg, "$Level", MakeMsgA("%d", plr->getLevel()));
+    if (plr->getClass() == 1)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\0035WR\003"));
+    else if (plr->getClass() == 2)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\00313PA\003"));
+    else if (plr->getClass() == 3)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\0033HU\003"));
+    else if (plr->getClass() == 4)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\00310RO\003"));
+    else if (plr->getClass() == 5)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\00314PR\003"));
+    else if (plr->getClass() == 6)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\0034DK\003"));
+    else if (plr->getClass() == 7)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\00312SH\003"));
+    else if (plr->getClass() == 8)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\00311MA\003"));
+    else if (plr->getClass() == 9)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\0036WL\003"));
+    else if (plr->getClass() == 11)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\0037DR\003"));
+    sMsg = Delink(sMsg);
+    sMsg = WoWcol2IRC(sMsg);
+    return sMsg;
+}
+
+// This function checks if a channel exists in out configuration
+// TriniChat supports as many channels as you like
+bool Channel_Valid(std::string Channel)
+{
+    for (int i=1;i < sIRC->_chan_count + 1;i++)
+    {
+        if (nocase_cmp(sIRC->_wow_chan[i], Channel)==0)
+            return true;
+    }
+    return false;
+}
+
+std::string GetWoWChannel(std::string Channel)
+{
+    for (int i=1;i < sIRC->_chan_count + 1;i++)
+    {
+        if ("#" + sIRC->_irc_chan[i] == Channel)
+            return sIRC->_wow_chan[i];
+    }
+    return "";
+}
+
+std::string GetIRCChannel(std::string Channel)
+{
+    for (int i=1;i < sIRC->_chan_count + 1;i++)
+    {
+        if (sIRC->_wow_chan[i] == Channel)
+            return sIRC->_irc_chan[i];
+    }
+    return "";
+}
+
+std::string* getArray(std::string PARAMS, int nCount, std::string)
+{
+    std::string *array = new std::string[nCount];
+    if (PARAMS.size() > 0)
+    {
+        size_t ps = 0;
+        size_t pc = -1;
+        for (int i = 0;i < nCount;i++)
+        {
+            pc = PARAMS.find(" ", pc + 1);
+            if (i + 1 == nCount && nCount != 1)
+            {
+                if (ps > 0 && pc > 0)
+                    array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+            }
+            else
+                array[i] = PARAMS.substr(ps, pc - ps);
+            ps = pc + 1;
+        }
+    }
+    return array;
+}
+#endif
diff --git a/src/server/game/TriniChat/IRCIO.cpp b/src/server/game/TriniChat/IRCIO.cpp
new file mode 100644
index 0000000..efa1b0c
--- /dev/null
+++ b/src/server/game/TriniChat/IRCIO.cpp
@@ -0,0 +1,529 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#include "IRCCmd.h"
+#include "IRCFunc.h"
+#include "Language.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "ChannelMgr.h"
+#include "Config.h"
+#include "Channel.h"
+#include "World.h"
+
+IRCCmd Command;
+void IRCClient::Handle_IRC(std::string sData)
+{
+    // If first 5 chars are ERROR then something is wrong
+    // either link is being closed, nickserv ghost command, etc...
+    if (sData.substr(0, 5) == "ERROR")
+    {
+        Disconnect();
+        return;
+    }
+    if (sData.substr(0, 4) == "PING")
+    {
+        // if the first 4 characters contain PING
+        // the server is checking if we are still alive
+        // sen back PONG back plus whatever the server send with it
+        SendIRC("PONG " + sData.substr(4, sData.size() - 4));
+    }
+    else
+    {
+        // if the first line contains : its an irc message
+        // such as private messages channel join etc.
+        if (sData.substr(0, 1) == ":")
+        {
+            // find the spaces in the receieved line
+            size_t p1 = sData.find(" ");
+            size_t p2 = sData.find(" ", p1 + 1);
+            // because the irc protocol uses simple spaces
+            // to seperate data we can easy pick them out
+            // since we know the position of the spaces
+            std::string USR = sData.substr(1, p1 - 1);
+            std::string CMD = sData.substr(p1 + 1, p2 - p1 - 1);
+            // trasform the commands to lowercase to make sure they always match
+            std::transform(CMD.begin(), CMD.end(), CMD.begin(), towlower);
+            // Extract the username from the first part
+            std::string szUser = GetUser(USR);
+            // if we receieved the internet connect code
+            // we know for sure that were in and we can
+            // authenticate ourself.
+            if (CMD == sIRC->_ICC)
+            {
+                // _Auth is defined in trinitycore.conf (irc.auth)
+                // 0 do not authenticate
+                // 1 use nickserv
+                // 2 use quakenet
+                // aditionally you can provide you own authentication method here
+                switch(sIRC->_Auth)
+                {
+                    case 1:
+                        SendIRC("PRIVMSG nickserv :IDENTIFY " + sIRC->_Pass);
+                        break;
+                    case 2:
+                        SendIRC("PRIVMSG nickserv :IDENTIFY " + sIRC->_Auth_Nick + " " + sIRC->_Pass);
+                        break;
+                    case 3:
+                        SendIRC("PRIVMSG Q@CServe.quakenet.org :AUTH " + sIRC->_Nick + " " + sIRC->_Pass);
+                        break;
+                    case 4:
+                        SendIRC("PRIVMSG Q@CServe.quakenet.org :AUTH " + sIRC->_Auth_Nick + " " + sIRC->_Pass);
+                        break;
+                }
+                // if we join a default channel leave this now.
+                if (sIRC->_ldefc==1)
+                    SendIRC("PART #" + sIRC->_defchan);
+                // Loop thru the channel array and send a command to join them on IRC.
+                for (int i=1;i < sIRC->_chan_count + 1;i++)
+                {
+                        if (sIRC->_irc_pass[i].size() > 0)
+                                SendIRC("JOIN #" + sIRC->_irc_chan[i] + " " + sIRC->_irc_pass[i]);
+                        else
+                        SendIRC("JOIN #" + sIRC->_irc_chan[i]);
+                }
+                // See if there's a log channel available, if so: join it.
+                if (sIRC->logchan.size() > 0)
+                {
+                    if (sIRC->logchanpw.size() > 0)
+                        SendIRC("JOIN #" + sIRC->logchan + " " + sIRC->logchanpw);
+                    else
+                        SendIRC("JOIN #" + sIRC->logchan);
+                }
+                // See if there's a Status channel available, if so: join it.
+                if (sIRC->Status.size() > 0)
+                {
+                    if (sIRC->Statuspw.size() > 0)
+                        SendIRC("JOIN #" + sIRC->Status + " " + sIRC->Statuspw);
+                    else
+                        SendIRC("JOIN #" + sIRC->Status);
+                }
+                // See if there's a Ticket channel available, if so: join it.
+                if (sIRC->ticann.size() > 0)
+                {
+                    if (sIRC->ticannpw.size() > 0)
+                        SendIRC("JOIN #" + sIRC->ticann + " " + sIRC->ticannpw);
+                    else
+                        SendIRC("JOIN #" + sIRC->ticann);
+                }
+                // See if there's an Announce channel available, if so: join it.
+                if (sIRC->anchn.size() > 0)
+                {
+                    if (sIRC->anchnpw.size() > 0)
+                        SendIRC("JOIN #" + sIRC->anchn + " " + sIRC->anchnpw);
+                    else
+                        SendIRC("JOIN #" + sIRC->anchn);
+                }
+            }
+            // someone joined the channel this could be the bot or another user
+            if (CMD == "join")
+            {
+                size_t p = sData.find(":", p1);
+                std::string CHAN = sData.substr(p + 1, sData.size() - p - 2);
+                // if the user is us it means we join the channel
+                if ((szUser == sIRC->_Nick))
+                {
+                    // its us that joined the channel
+                    Send_IRC_Channel(CHAN, MakeMsg(MakeMsg(sIRC->JoinMsg, "$Ver", sIRC->_Mver.c_str()), "$Trigger", sIRC->_cmd_prefx.c_str()), true);
+                }
+                else
+                {
+                    // if the user is not us its someone else that joins
+                    // so we construct a message and send this to the clients.
+                    // TriniChat now uses Send_WoW_Channel to send to the client
+                    // this makes TriniChat handle the packets instead of previously the world.
+                    if ((sIRC->BOTMASK & 2) != 0)
+                        Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(JOIN_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN))));
+                }
+            }
+            // someone on irc left or quit the channel
+            if (CMD == "part" || CMD == "quit")
+            {
+                size_t p3 = sData.find(" ", p2 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                // Logout IRC Nick From TriniChat If User Leaves Or Quits IRC.
+                if (Command.IsLoggedIn(szUser))
+                {
+                    _CDATA CDATA;
+                    CDATA.USER      = szUser;
+                    Command.Handle_Logout(&CDATA);
+                }
+                // Construct a message and inform the clients on the same channel.
+                if ((sIRC->BOTMASK & 2) != 0)
+                    Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(LEAVE_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN))));
+            }
+            // someone changed their nick
+            if (CMD == "nick" && (sIRC->BOTMASK & 128) != 0)
+            {
+                MakeMsg(MakeMsg(GetChatLine(CHANGE_NICK), "$Name", szUser), "$NewName", sData.substr(sData.find(":", p2) + 1));
+                // If the user is logged in and changes their nick
+                // then we want to either log them out or update
+                // their nick in the bot. I chose to update the bots user list.
+                if (Command.IsLoggedIn(szUser))
+                {
+                    std::string NewNick = sData.substr(sData.find(":", p2) + 1);
+                    // On freenode I noticed the server sends an extra character
+                    // at the end of the string, so we need to erase the last
+                    // character of the string. if you have a problem with getting
+                    // the last letter of your nick erased, then remove the - 1.
+                    NewNick.erase(NewNick.length() - 1, 1);
+
+                    for (std::list<_client*>::iterator i=Command._CLIENTS.begin(); i!=Command._CLIENTS.end();i++)
+                    {
+                        if ((*i)->Name == szUser)
+                        {
+                            (*i)->Name     = NewNick;
+                            sIRC->Send_IRC_Channel(NewNick.c_str(), "I Noticed You Changed Your Nick, I Have Updated My Internal Database Accordingly.", true, "NOTICE");
+
+                            // Figure why not output to the logfile, makes tracing problems easier.
+                            sIRC->iLog.WriteLog(" %s : %s Changed Nick To: %s", sIRC->iLog.GetLogDateTimeStr().c_str(), szUser.c_str(), NewNick.c_str());
+                        }
+                    }
+                }
+
+            }
+            // someone was kicked from irc
+            if (CMD == "kick")
+            {
+                // extract the details
+                size_t p3 = sData.find(" ", p2 + 1);
+                size_t p4 = sData.find(" ", p3 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                std::string WHO = sData.substr(p3 + 1, p4 - p3 - 1);
+                std::string BY = sData.substr(p4 + 1, sData.size() - p4 - 1);
+                // if the one kicked was us
+                if (WHO == sIRC->_Nick)
+                {
+                    // and autojoin is enabled
+                    // return to the channel
+                    if (sIRC->_autojoinkick == 1)
+                    {
+                        SendIRC("JOIN " + CHAN);
+                        Send_IRC_Channel(CHAN, sIRC->kikmsg, true);
+                    }
+                }
+                else
+                {
+                    // if it is not us who was kicked we need to inform the clients someone
+                    // was removed from the channel
+                    // construct a message and send it to the players.
+                    Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), "<IRC>[" + WHO + "]: Was Kicked From " + CHAN + " By: " + szUser);
+                }
+            }
+            // a private chat message was receieved.
+            if (CMD == "privmsg" || CMD == "notice")
+            {
+                // extract the values
+                size_t p = sData.find(" ", p2 + 1);
+                std::string FROM = sData.substr(p2 + 1, p - p2 - 1);
+                std::string CHAT = sData.substr(p + 2, sData.size() - p - 3);
+                // if this is our username it means we recieved a PM
+                if (FROM == sIRC->_Nick)
+                {
+                    if (CHAT.find("\001VERSION\001") < CHAT.size())
+                    {
+                        Send_IRC_Channel(szUser, MakeMsg("\001VERSION TriniChat %s ?2008-2009 |Death|, Cybrax, Machiavelli\001", "%s" , sIRC->_Mver.c_str()), true, "PRIVMSG");
+                    }
+                    // a pm is required for certain commands
+                    // such as login. to validate the command
+                    // we send it to the command class wich handles
+                    // evrything else.
+                    Command.IsValid(szUser, FROM, CHAT, CMD);
+                }
+                else
+                {
+                    // if our name is not in it, it means we receieved chat on one of the channels
+                    // magchat is in. the first thing we do is check if it is a command or not
+                    if (!Command.IsValid(szUser, FROM, CHAT, CMD))
+                    {
+                        std::string fixStaffChan = "#"+sIRC->_staffChan;
+                        bool ignored = false;
+                        switch(sIRC->_staffLink)
+                        {
+                            case 1:
+                                if(fixStaffChan == FROM)
+                                {
+                                    for(uint8 i = 0;i<MAX_CONF_BOTS; i++)
+                                    {
+                                        if(sIRC->_ignore_bots[i] != "")
+                                        {
+                                            if(Command.MakeUpper(sIRC->_ignore_bots[i]) == Command.MakeUpper(szUser))
+                                                ignored = true;
+                                        }
+                                    }
+                                    if(!ignored)
+                                    {
+                                        szUser = "<IRC>"+szUser;
+                                        //setup gm chat
+                                        sWorld->SendGMText(LANG_GM_ANNOUNCE_COLOR, szUser.c_str(), CHAT.c_str());
+                                    }
+                                }
+                                else
+                                {
+                                    for(uint8 i = 0;i<MAX_CONF_BOTS; i++)
+                                    {
+                                        if(sIRC->_ignore_bots[i] != "")
+                                        {
+                                            if(Command.MakeUpper(sIRC->_ignore_bots[i]) == Command.MakeUpper(szUser))
+                                                ignored = true;
+                                        }
+                                    }
+                                    if(!ignored)
+                                    {
+                                        Send_WoW_Channel(GetWoWChannel(FROM).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(IRC_WOW), "$Name", szUser), "$Msg", CHAT)));
+                                    }
+                                }
+                                break;
+                            case 0:
+                                Send_WoW_Channel(GetWoWChannel(FROM).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(IRC_WOW), "$Name", szUser), "$Msg", CHAT)));
+                                break;
+                        }
+                    }
+                    // if we indeed receieved a command we do not want to display this to the players
+                    // so only incanse the isvalid command returns false it will be sent to all player.
+                    // the isvalid function will automaitcly process the command on true.
+                }
+            }
+            if (CMD == "mode")
+            {
+                // extract the mode details
+                size_t p3 = sData.find(" ", p2 + 1);
+                size_t p4 = sData.find(" ", p3 + 1);
+                size_t p5 = sData.find(" ", p4 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                std::string MODE = sData.substr(p3 + 1, p4 - p3 - 1);
+                std::string NICK = sData.substr(p4 + 1, p5 - p4 - 1);
+                _AmiOp = false;
+                //A mode was changed on us
+                if (NICK.c_str() == sIRC->_Nick)
+                    _AmiOp = true;
+
+            }
+        }
+    }
+}
+
+// This function is called in Channel.h
+// based on nAction it will inform the people on
+// irc when someone leaves one of the game channels.
+// nAction is based on the struct CACTION
+void IRCClient::Handle_WoW_Channel(std::string Channel, Player *plr, int nAction)
+{
+    // make sure that we are connected
+    if (sIRC->Connected && (sIRC->BOTMASK & 1)!= 0)
+    {
+        if (Channel_Valid(Channel))
+        {
+            std::string GMRank = "";
+            std::string pname = plr->GetName().c_str();
+            bool DoGMAnnounce = false;
+            if (plr->GetSession()->GetSecurity() > 0 && (sIRC->BOTMASK & 8)!= 0)
+                DoGMAnnounce = true;
+            if (plr->IsGameMaster() && (sIRC->BOTMASK & 16)!= 0)
+                DoGMAnnounce = true;
+            if (DoGMAnnounce)
+            {
+                switch(plr->GetSession()->GetSecurity())    //switch case to determine what rank the "gm" is
+                {
+                    case SEC_PLAYER: GMRank = ""; break;
+                    case SEC_MODERATOR: GMRank = "\0037" + sIRC->ojGM1; break;
+                    case SEC_GAMEMASTER: GMRank = "\0037" + sIRC->ojGM2; break;
+                    case SEC_ADMINISTRATOR: GMRank = "\0037" + sIRC->ojGM3; break;
+                    case SEC_CONSOLE: GMRank = "\0037" + sIRC->ojGM4; break;
+                }
+            }
+            std::string ChatTag = "";
+            switch (plr->GetTeam())
+            {
+                case 67:ChatTag.append("\0034");break;      //horde
+                case 469:ChatTag.append("\00312");break;    //alliance
+            }
+            std::string query = "INSERT INTO `irc_inchan` VALUES (%d,'"+pname+"','"+Channel+"')";
+            std::string lchan = "DELETE FROM `irc_inchan` WHERE `guid` = %d AND `channel` = '"+Channel+"'";
+            switch(nAction)
+            {
+                case CHANNEL_JOIN:
+                    Send_IRC_Channel(GetIRCChannel(Channel), MakeMsg(MakeMsg(MakeMsg(GetChatLine(JOIN_WOW), "$Name", ChatTag + plr->GetName().c_str()), "$Channel", Channel), "$GM", GMRank));
+                    WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+                    WorldDatabase.PExecute(query.c_str(), plr->GetGUID());
+                    break;
+                case CHANNEL_LEAVE:
+                    Send_IRC_Channel(GetIRCChannel(Channel), MakeMsg(MakeMsg(MakeMsg(GetChatLine(LEAVE_WOW), "$Name", ChatTag + plr->GetName().c_str()), "$Channel", Channel), "$GM", GMRank));
+                    WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+                    break;
+            }
+        }
+    }
+}
+
+// This function sends chat to a irc channel or user
+// to prevent the # beeing appended to send a msg to a user
+// set the NoPrefix to true
+void IRCClient::Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix, std::string nType)
+{
+    std::string mType = "PRIVMSG";
+    if (Command.MakeUpper(nType.c_str()) == "NOTICE")
+        mType = "NOTICE";
+    if (Command.MakeUpper(nType.c_str()) == "ERROR" && (sIRC->BOTMASK & 32)!= 0)
+        mType = "NOTICE";
+    if (sIRC->Connected)
+    {
+        if (NoPrefix)
+            SendIRC(mType + " " + sChannel + " :" + sMsg);
+        else
+            SendIRC(mType + " #" + sChannel + " :" + sMsg);
+    }
+}
+
+// This function sends a message to all irc channels
+// that TriniChat has in its configuration
+void IRCClient::Send_IRC_Channels(std::string sMsg)
+{
+    for (int i=1;i < sIRC->_chan_count + 1;i++)
+        Send_IRC_Channel(sIRC->_irc_chan[i], sMsg);
+}
+
+// This function is called in ChatHandler.cpp, any channel chat from wow will come
+// to this function, validates the channel and constructs a message that is send to IRC
+void IRCClient::Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg)
+{
+    // Check if the channel exist in our configuration
+    if (Channel_Valid(Channel) && Msg.substr(0, 1) != ".")
+        Send_IRC_Channel(GetIRCChannel(Channel), MakeMsgP(WOW_IRC, Msg, plr));
+}
+
+void IRCClient::Send_WoW_Player(std::string sPlayer, std::string sMsg)
+{
+    normalizePlayerName(sPlayer);
+    if (Player* plr = ObjectAccessor::FindPlayerByName(sPlayer.c_str()))
+        Send_WoW_Player(plr, sMsg);
+}
+
+void IRCClient::Send_WoW_Player(Player *plr, string sMsg)
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    data << (uint8)CHAT_MSG_SYSTEM;
+    data << (uint32)LANG_UNIVERSAL;
+    data << (uint64)plr->GetGUID();
+    data << (uint32)0;
+    data << (uint64)plr->GetGUID();
+    data << (uint32)(sMsg.length()+1);
+    data << sMsg;
+    data << (uint8)0;
+    plr->GetSession()->SendPacket(&data);
+}
+
+// This function will construct and send a packet to all players
+// on the given channel ingame. (previuosly found in world.cpp)
+// it loops thru all sessions and checks if they are on the channel
+// if so construct a packet and send it.
+void IRCClient::Send_WoW_Channel(const char *channel, std::string chat)
+{
+    if (!(strlen(channel) > 0))
+        return;
+
+    #ifdef USE_UTF8
+        std::string chat2 = chat;
+        if (ConvertUTF8(chat2.c_str(), chat2))
+            chat = chat2;
+    #endif
+
+    HashMapHolder<Player>::MapType const& m = ObjectAccessor::GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            if (ChannelMgr* cMgr = ChannelMgr::forTeam(itr->second->GetSession()->GetPlayer()->GetTeam()))
+            {
+                if (cMgr->GetChannel(channel, itr->second->GetSession()->GetPlayer()))
+                {
+                    WorldPacket data;
+                    data.Initialize(SMSG_MESSAGECHAT);
+                    data << (uint8)CHAT_MSG_CHANNEL;
+                    data << (uint32)LANG_UNIVERSAL;
+                    data << (uint64)0;
+                    data << (uint32)0;
+                    data << channel;
+                    data << (uint64)0;
+                    data << (uint32) (strlen(chat.c_str()) + 1);
+                    data << IRCcol2WoW(chat.c_str());
+                    data << (uint8)0;
+                    itr->second->GetSession()->SendPacket(&data);
+                }
+            }
+        }
+    }
+}
+
+void IRCClient::Send_WoW_System(std::string Message)
+{
+    HashMapHolder<Player>::MapType const& m = ObjectAccessor::GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            WorldPacket data;
+            data.Initialize(CHAT_MSG_SYSTEM);
+            data << (uint8)CHAT_MSG_SYSTEM;
+            data << (uint32)LANG_UNIVERSAL;
+            data << (uint64)0;
+            data << (uint32)0;
+            data << (uint64)0;
+            data << (uint32) (strlen(Message.c_str()) + 1);
+            data << Message.c_str();
+            data << (uint8)0;
+            itr->second->GetSession()->SendPacket(&data);
+        }
+    }
+}
+void IRCClient::ResetIRC()
+{
+    SendData("QUIT");
+    Disconnect();
+}
+
+#define CHAT_INVITE_NOTICE 0x18
+
+// this function should be called on player login Player::AddToWorld
+void IRCClient::AutoJoinChannel(Player *plr)
+{
+    // this will work if at least 1 player is logged in regrdless if he is on the channel or not
+    // the first person that login empty server is the one with bad luck and wont be invited,
+    // if at least 1 player is online the player will be inited to the chanel
+
+    std::string m_name = sIRC->ajchan;
+    WorldPacket data;
+    data.Initialize(SMSG_CHANNEL_NOTIFY, 1+m_name.size()+1);
+    data << uint8(CHAT_INVITE_NOTICE);
+    data << m_name.c_str();
+
+    HashMapHolder<Player>::MapType const& m = ObjectAccessor::GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            data << uint64(itr->second->GetGUID());
+            break;
+        }
+    }
+    plr->GetSession()->SendPacket(&data);
+}
diff --git a/src/server/game/TriniChat/IRCLog.cpp b/src/server/game/TriniChat/IRCLog.cpp
new file mode 100644
index 0000000..5fa5f32
--- /dev/null
+++ b/src/server/game/TriniChat/IRCLog.cpp
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCLog.h"
+#include "Config.h"
+#include "IRCClient.h"
+#include <stdarg.h>
+#include "World.h"
+
+IRCLog::IRCLog()
+{
+    std::string logsDir = sConfigMgr->GetStringDefault("LogsDir","");
+    std::string ircLogName = logsDir + "/IRC_";
+    std::string ircLogTimestamp = GetLogDateStr();
+        ircLogName += ircLogTimestamp +".log";
+    ircLogfile.open (ircLogName.c_str(), std::ios::app);
+}
+
+IRCLog::~IRCLog()
+{
+    ircLogfile.close();
+}
+// Was added because using the time for logs is very annoying... one log per day.. much cleaner looking..
+std::string IRCLog::GetLogDateStr() const
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    char buf[20];
+    snprintf(buf,20,"%04d-%02d-%02d",aTm->tm_year+1900,aTm->tm_mon+1,aTm->tm_mday);
+    return std::string(buf);
+}
+
+std::string IRCLog::GetLogDateTimeStr() const
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    char buf[30];
+    snprintf(buf,30,"[ %04d-%02d-%02d ] [ %02d:%02d:%02d ]",aTm->tm_year+1900,aTm->tm_mon+1,aTm->tm_mday,aTm->tm_hour,aTm->tm_min,aTm->tm_sec);
+    return std::string(buf);
+}
+
+void IRCLog::WriteLog(const char *what, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, what);
+    vsnprintf(tmpoutp, 1024, what, ap);
+    va_end(ap);
+    ircLogfile << tmpoutp;
+    ircLogfile << "\n";
+    ircLogfile.flush();
+}
diff --git a/src/server/game/TriniChat/IRCLog.h b/src/server/game/TriniChat/IRCLog.h
new file mode 100644
index 0000000..ac6dff0
--- /dev/null
+++ b/src/server/game/TriniChat/IRCLog.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_LOG_H
+#define _IRC_LOG_H
+
+#include "Common.h"
+#include <fstream>
+
+class IRCLog
+{
+    public:
+        IRCLog();
+        ~IRCLog();
+
+    public:
+        void WriteLog(const char *what, ...);
+        std::string GetLogDateStr() const;
+        std::string GetLogDateTimeStr() const;
+    private:
+        std::ofstream ircLogfile;
+};
+#endif
diff --git a/src/server/game/TriniChat/IRCSock.cpp b/src/server/game/TriniChat/IRCSock.cpp
new file mode 100644
index 0000000..e3bde2b
--- /dev/null
+++ b/src/server/game/TriniChat/IRCSock.cpp
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#define MAXDATASIZE 512
+#include <fcntl.h>
+
+#include <stdio.h>
+#include <sys/types.h>
+
+
+#define _UNICODE
+
+#ifdef _MBCS
+#undef _MBCS
+#endif
+
+bool IRCClient::InitSock()
+{
+    #ifdef _WIN32
+    WSADATA wsaData;                                        //WSAData
+    if (WSAStartup(MAKEWORD(2,0),&wsaData) != 0)
+    {
+        TC_LOG_ERROR("misc", "IRC Error: Winsock Initialization Error");
+        return false;
+    }
+    #endif
+    if ((sIRC->SOCKET = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
+    {
+        TC_LOG_ERROR("misc", "IRC Error: Socket Error");
+        return false;
+    }
+    int on = 1;
+    if (setsockopt (sIRC->SOCKET, SOL_SOCKET, SO_REUSEADDR, (const char*) &on, sizeof (on)) == -1)
+    {
+        TC_LOG_ERROR("misc", "IRC Error: Invalid Socket");
+        return false;
+    }
+    #ifdef _WIN32
+    u_long iMode = 0;
+    ioctlsocket(sIRC->SOCKET, FIONBIO, &iMode);
+    #else
+    fcntl(sIRC->SOCKET, F_SETFL, O_NONBLOCK);                // set to non-blocking
+    fcntl(sIRC->SOCKET, F_SETFL, O_ASYNC);                   // set to asynchronous I/O
+    #endif
+    return true;
+}
+
+bool IRCClient::Connect(const char *cHost, int nPort)
+{
+    sIRC->Connected = false;
+    struct hostent *he;
+    if ((he=gethostbyname(cHost)) == NULL)
+    {
+        TC_LOG_ERROR("misc", "IRCLIENT: Could not resolve host: %s", cHost);
+        return false;
+    }
+    struct sockaddr_in their_addr;
+    their_addr.sin_family = AF_INET;
+    their_addr.sin_port = htons(nPort);
+    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+    memset(&(their_addr.sin_zero), '\0', 8);
+    if (::connect(sIRC->SOCKET, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == -1)
+    {
+        TC_LOG_ERROR("misc", "IRCLIENT: Cannot connect to %s", cHost);
+        return false;
+    }
+    sIRC->Connected = true;
+    return true;
+}
+
+bool IRCClient::Login(std::string sNick, std::string sUser, std::string sPass)
+{
+    char hostname[128];
+    gethostname(hostname, sizeof(hostname));
+    if (SendIRC("HELLO"))
+        if (SendIRC("PASS " + sPass))
+            if (SendIRC("NICK " + sNick))
+                if (SendIRC("USER " + sUser + " " + (std::string)hostname + " TriniChat :TriniChat "+sIRC->_Mver.c_str()))
+                    return true;
+    return false;
+}
+
+bool IRCClient::SendData(const char *data)
+{
+    if (sIRC->Connected)
+    {
+        if (send(sIRC->SOCKET, data, strlen(data), 0) == -1)
+        {
+            TC_LOG_ERROR("misc", "IRC Error: Socket Receieve ** \n");
+            return false;
+        }
+    }
+    return true;
+}
+
+bool IRCClient::SendIRC(std::string data)
+{
+    std::string RealData = data + "\n";
+    return SendData(RealData.c_str());
+}
+
+void IRCClient::Disconnect()
+{
+    if (sIRC->SOCKET)
+    {
+        #ifdef _WIN32
+        closesocket(sIRC->SOCKET);
+        #else
+        close(sIRC->SOCKET);
+        #endif
+    }
+}
+
+void IRCClient::SockRecv()
+{
+    char szBuffer[MAXDATASIZE];
+
+    memset(szBuffer, 0, MAXDATASIZE);
+
+    int nBytesRecv = ::recv(sIRC->SOCKET, szBuffer, MAXDATASIZE - 1, 0);
+    if (nBytesRecv == -1)
+    {
+        TC_LOG_ERROR("misc", "Connection lost.");
+        sIRC->Connected = false;
+    }
+    else
+    {
+        if (-1 == nBytesRecv)
+        {
+            TC_LOG_ERROR("misc", "Error occurred while receiving from socket.");
+        }
+        else
+        {
+            std::string reply;
+            std::istringstream iss(szBuffer);
+            while (getline(iss, reply))
+            {
+                Handle_IRC(reply);
+            }
+        }
+    }
+}
diff --git a/src/server/game/TriniChat/MCS_OnlinePlayers.cpp b/src/server/game/TriniChat/MCS_OnlinePlayers.cpp
new file mode 100644
index 0000000..5bc8074
--- /dev/null
+++ b/src/server/game/TriniChat/MCS_OnlinePlayers.cpp
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "MCS_OnlinePlayers.h"
+
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "Config.h"
+#include "WorldSession.h"
+
+mcs_OnlinePlayers::mcs_OnlinePlayers() { CD = NULL; }
+
+mcs_OnlinePlayers::mcs_OnlinePlayers(_CDATA *_CD)
+{
+    //create a new instance of data struct and copy its data
+    CD = new _CDATA();
+    CD->CMD = _CD->CMD;
+    CD->FROM = _CD->FROM;
+    CD->PARAMS = _CD->PARAMS;
+    CD->PCOUNT = _CD->PCOUNT;
+    CD->USER = _CD->USER;
+    CD->TYPE = _CD->TYPE;
+}
+
+mcs_OnlinePlayers::~mcs_OnlinePlayers()
+{
+    if (CD)
+        delete CD;
+}
+
+void mcs_OnlinePlayers::run()
+{
+    int OnlineCount = 0;
+    std::string IRCOut = "";
+    HashMapHolder<Player>::MapType const& m = ObjectAccessor::GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            OnlineCount++;
+            Player *plr = itr->second->GetSession()->GetPlayer();
+            std::string ChatTag = " ";
+            switch(plr->GetSession()->GetSecurity())
+            {
+                case SEC_PLAYER: ChatTag.append(""); break;
+                case SEC_MODERATOR: ChatTag.append("\0037" + sIRC->ojGM1); break;
+                case SEC_GAMEMASTER: ChatTag.append("\0037" + sIRC->ojGM2); break;
+                case SEC_ADMINISTRATOR: ChatTag.append("\0037" + sIRC->ojGM3); break;
+                case SEC_CONSOLE: ChatTag.append("\0037" + sIRC->ojGM4); break;
+            }
+            if (plr->isAFK())
+                ChatTag.append("\002\0037<AFK>\003\002");
+            else if (plr->isDND())
+                ChatTag.append("\002\0037<DND>\003\002");
+            switch (plr->GetTeam())
+            {
+                case 67:ChatTag.append("\0034");break;      //horde
+                case 469:ChatTag.append("\00312");break;    //alliance
+            }
+
+            IRCOut.append(IRCCmd::MakeMsg("%s\002%s\003\017\002(%d)\002\017", ChatTag.c_str(), plr->GetName().c_str(), plr->getLevel()));
+
+            // after XX players have been added to the string
+            // output to irc and reset for the next XX
+            if (OnlineCount % sIRC->onlrslt == 0)
+            {
+                sIRC->Send_IRC_Channel(IRCCmd::ChanOrPM(CD), IRCCmd::MakeMsg("\002 %s", IRCOut.c_str()), true, CD->TYPE.c_str());
+                IRCOut = "";
+                std::this_thread::sleep_for(std::chrono::milliseconds(1000));
+            }
+        }
+    }
+    // Remainder in IRCOUT && Total plyersonline
+    sIRC->Send_IRC_Channel(IRCCmd::ChanOrPM(CD), IRCCmd::MakeMsg("\002Players Online(%d):\017 %s", OnlineCount, IRCOut.c_str()), true, CD->TYPE);
+
+    sIRC->Script_Lock[MCS_Players_Online] = false;
+}
diff --git a/src/server/game/TriniChat/MCS_OnlinePlayers.h b/src/server/game/TriniChat/MCS_OnlinePlayers.h
new file mode 100644
index 0000000..700d730
--- /dev/null
+++ b/src/server/game/TriniChat/MCS_OnlinePlayers.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_ONLINE
+#define _IRC_CLIENT_ONLINE
+
+#include "IRCClient.h"
+#include "IRCCmd.h"
+
+class mcs_OnlinePlayers
+{
+    public:
+        mcs_OnlinePlayers();
+        mcs_OnlinePlayers(_CDATA *_CD);
+        ~mcs_OnlinePlayers();
+        void run();
+    public:
+        _CDATA *CD;
+};
+
+#endif
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index f904f30..7f5bd5d 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -67,7 +67,7 @@
 // Prepatch by LordPsyan
 // 01
 // 02
-// 03
+#include "IRCClient.h"
 // 04
 // 05
 // 06
@@ -1372,6 +1372,168 @@ void World::LoadConfigSettings(bool reload)
     // call ScriptMgr if we're reloading the configuration
     if (reload)
         sScriptMgr->OnConfigLoad(reload);
+    sScriptMgr->OnConfigLoad(reload);
+
+    // IRC Configurations.
+    int ConfCnt = 0;
+    sIRC->_chan_count = 0;
+    if (sConfigMgr->GetIntDefault("irc.active", 1) == 1)
+      sIRC->Active = true;
+    else
+      sIRC->Active = false;
+
+    sIRC->_Host = sConfigMgr->GetStringDefault("irc.host", "irc.freenode.net");
+    if (sIRC->_Host.size() > 0)
+        ConfCnt++;
+    sIRC->_Mver = "Version 4.1";
+    sIRC->_Port = sConfigMgr->GetIntDefault("irc.port", 6667);
+    sIRC->_User = sConfigMgr->GetStringDefault("irc.user", "TriniChat");
+    sIRC->_Pass = sConfigMgr->GetStringDefault("irc.pass", "Services Password");
+    sIRC->_Nick = sConfigMgr->GetStringDefault("irc.nick", "TriniChat");
+    sIRC->_Auth = sConfigMgr->GetIntDefault("irc.auth", 0);
+    sIRC->_Auth_Nick = sConfigMgr->GetStringDefault("irc.auth.nick", "AuthNick");
+    sIRC->_ICC = sConfigMgr->GetStringDefault("irc.icc", "001");
+    sIRC->_defchan = sConfigMgr->GetStringDefault("irc.defchan", "lobby");
+    sIRC->_ldefc = sConfigMgr->GetIntDefault("irc.ldef", 0);
+    sIRC->_wct = sConfigMgr->GetIntDefault("irc.wct", 30000);
+    sIRC->ajoin = sConfigMgr->GetIntDefault("irc.ajoin", 0);
+    sIRC->_staffLink = sConfigMgr->GetIntDefault("irc.staff_link", 1);
+    sIRC->_staffChan = sConfigMgr->GetStringDefault("irc.staff_chan", "staff");
+    sIRC->_bot_names = sConfigMgr->GetStringDefault("irc.ignore_bots", "");
+    sIRC->ajchan = sConfigMgr->GetStringDefault("irc.ajchan", "world");
+    sIRC->onlrslt = sConfigMgr->GetIntDefault("irc.online.result", 10);
+    sIRC->BOTMASK = sConfigMgr->GetIntDefault("Botmask", 0);
+    sIRC->TICMASK = sConfigMgr->GetIntDefault("Ticketmask", 0);
+    sIRC->logfile = sConfigMgr->GetStringDefault("irc.logfile.prefix", "IRC_");
+    sIRC->logmask = sConfigMgr->GetIntDefault("irc.logmask", 0);
+    sIRC->logchan = sConfigMgr->GetStringDefault("irc.logchannel","");
+    sIRC->logchanpw = sConfigMgr->GetStringDefault("irc.logchannelpw","");
+    for (int i = 1; i < MAX_CONF_CHANNELS;i++)
+    {
+        std::ostringstream ss;
+        ss << i;
+        std::string ci = "irc.chan_" + ss.str();
+        std::string pw = "irc.pass_" + ss.str();
+        std::string t_chan = sConfigMgr->GetStringDefault(ci.c_str(), "");
+        if (t_chan.size() > 0)
+        {
+            sIRC->_chan_count++;
+            sIRC->_irc_chan[sIRC->_chan_count] = t_chan;
+            sIRC->_irc_pass[sIRC->_chan_count] = sConfigMgr->GetStringDefault(pw.c_str(), t_chan.c_str());
+            ci = "wow.chan_" + ss.str();
+            sIRC->_wow_chan[sIRC->_chan_count] = sConfigMgr->GetStringDefault(ci.c_str(), t_chan.c_str());
+        }
+    }
+    sIRC->JoinMsg = sConfigMgr->GetStringDefault("irc.joinmsg", "TriniChat $Ver for Trinitycore 3.3.x");
+    sIRC->RstMsg  = sConfigMgr->GetStringDefault("irc.rstmsg", "TriniChat Is Restarting, I Will Be Right Back!");
+    sIRC->kikmsg = sConfigMgr->GetStringDefault("irc.kickmsg", "Do Not Kick Me Again, Severe Actions Will Be Taken!");
+
+    // IRC LINES
+    sIRC->ILINES[WOW_IRC] = sConfigMgr->GetStringDefault("chat.wow_irc", "\003<WoW>[\002$Name($Level)\002\003] $Msg");
+    sIRC->ILINES[IRC_WOW] = sConfigMgr->GetStringDefault("chat.irc_wow", "\003<IRC>[$Name]: $Msg");
+    sIRC->ILINES[JOIN_WOW] = sConfigMgr->GetStringDefault("chat.join_wow", "\00312>>\00304 $Name \003Joined The Channel!");
+    sIRC->ILINES[JOIN_IRC] = sConfigMgr->GetStringDefault("chat.join_irc", "\003[$Name]: Has Joined IRC!");
+    sIRC->ILINES[LEAVE_WOW] = sConfigMgr->GetStringDefault("chat.leave_wow", "\00312<<\00304 $Name \003Left The Channel!");
+    sIRC->ILINES[LEAVE_IRC] = sConfigMgr->GetStringDefault("chat.leave_irc", "\003[$Name]: Has Left IRC!");
+    sIRC->ILINES[CHANGE_NICK] = sConfigMgr->GetStringDefault("chat.change_nick", "\003<> $Name Is Now Known As $NewName!");
+
+    // TriniChat Options
+    sIRC->_MCA = sConfigMgr->GetIntDefault("irc.maxattempt", 10);
+    sIRC->_autojoinkick = sConfigMgr->GetIntDefault("irc.autojoin_kick", 1);
+    sIRC->_cmd_prefx = sConfigMgr->GetStringDefault("irc.command_prefix", ".");
+
+    sIRC->_op_gm = sConfigMgr->GetIntDefault("irc.op_gm_login", 0);
+    sIRC->_op_gm_lev = sConfigMgr->GetIntDefault("irc.op_gm_level", 3);
+
+    // Misc Options
+    sIRC->games = sConfigMgr->GetIntDefault("irc.fun.games", 0);
+    sIRC->gmlog = sConfigMgr->GetIntDefault("irc.gmlog", 1);
+    sIRC->Status = sConfigMgr->GetStringDefault("irc.StatusChannel", "");
+    sIRC->Statuspw = sConfigMgr->GetStringDefault("irc.StatusChannelPW","");
+    sIRC->anchn = sConfigMgr->GetStringDefault("irc.AnnounceChannel", "");
+    sIRC->anchnpw = sConfigMgr->GetStringDefault("irc.AnnounceChannelPW","");
+    sIRC->ticann = sConfigMgr->GetStringDefault("irc.Tickets", "");
+    sIRC->ticannpw = sConfigMgr->GetStringDefault("irc.TicketsPW","");
+    sIRC->autoanc = sConfigMgr->GetIntDefault("irc.auto.announce", 30);
+    sIRC->ojGM1 = sConfigMgr->GetStringDefault("irc.gm1", "[Moderator]");
+    sIRC->ojGM2 = sConfigMgr->GetStringDefault("irc.gm2", "[GameMaster]");
+    sIRC->ojGM3 = sConfigMgr->GetStringDefault("irc.gm3", "[Developer]");
+    sIRC->ojGM4 = sConfigMgr->GetStringDefault("irc.gm4", "[Owner]");
+    // REQUIRED GM LEVEL
+    QueryResult result = WorldDatabase.PQuery("SELECT `Command`, `gmlevel` FROM `irc_commands` ORDER BY `Command`");
+    if (result)
+    {
+        Field *fields = result->Fetch();
+        for (uint64 i=0; i < result->GetRowCount(); i++)
+        {
+            //TODO: ELSEIF? STRCMP?
+            std::string command = fields[0].GetCString();
+            uint32 gmlvl = fields[1].GetUInt32();
+            if (command == "acct") sIRC->CACCT = gmlvl;
+            if (command == "ban") sIRC->CBAN = gmlvl;
+            if (command == "char") sIRC->CCHAN = gmlvl;
+            if (command == "char") sIRC->CCHAR = gmlvl;
+            if (command == "fun") sIRC->CFUN = gmlvl;
+            if (command == "help") sIRC->CHELP = gmlvl;
+            if (command == "inchan") sIRC->CINCHAN = gmlvl;
+            if (command == "info") sIRC->CINFO = gmlvl;
+            if (command == "item") sIRC->CITEM = gmlvl;
+            if (command == "jail") sIRC->CJAIL = gmlvl;
+            if (command == "kick") sIRC->CKICK = gmlvl;
+            if (command == "kill") sIRC->_KILL = gmlvl;
+            if (command == "level") sIRC->CLEVEL = gmlvl;
+            if (command == "lookup") sIRC->CLOOKUP = gmlvl;
+            if (command == "money") sIRC->CMONEY = gmlvl;
+            if (command == "mute") sIRC->CMUTE = gmlvl;
+            if (command == "online") sIRC->CONLINE = gmlvl;
+            if (command == "pm") sIRC->CPM = gmlvl;
+            if (command == "reconnect") sIRC->CRECONNECT = gmlvl;
+            if (command == "reload") sIRC->CRELOAD = gmlvl;
+            if (command == "restart") sIRC->CSHUTDOWN = gmlvl;
+            if (command == "revive") sIRC->CREVIVE = gmlvl;
+            if (command == "saveall") sIRC->CSAVEALL = gmlvl;
+            if (command == "server") sIRC->CSERVERCMD = gmlvl;
+            if (command == "shutdown") sIRC->CSHUTDOWN = gmlvl;
+            if (command == "spell") sIRC->CSPELL = gmlvl;
+            if (command == "sysmsg") sIRC->CSYSMSG = gmlvl;
+            if (command == "tele") sIRC->CTELE = gmlvl;
+            if (command == "top") sIRC->CTOP = gmlvl;
+            if (command == "who") sIRC->CWHO = gmlvl;
+            result->NextRow();
+        }
+    }
+    else
+    {
+        sIRC->CACCT     = 3;
+        sIRC->CBAN      = 3;
+        sIRC->CCHAN     = 3;
+        sIRC->CCHAR     = 3;
+        sIRC->CFUN      = 3;
+        sIRC->CHELP     = 3;
+        sIRC->CINCHAN   = 3;
+        sIRC->CINFO     = 3;
+        sIRC->CITEM     = 3;
+        sIRC->CJAIL     = 3;
+        sIRC->CKICK     = 3;
+        sIRC->_KILL     = 3;
+        sIRC->CLEVEL    = 3;
+        sIRC->CLOOKUP   = 3;
+        sIRC->CMONEY    = 3;
+        sIRC->CMUTE     = 3;
+        sIRC->CONLINE   = 3;
+        sIRC->CPM       = 3;
+        sIRC->CRECONNECT= 3;
+        sIRC->CRELOAD   = 3;
+        sIRC->CREVIVE   = 3;
+        sIRC->CSAVEALL  = 3;
+        sIRC->CSERVERCMD= 3;
+        sIRC->CSHUTDOWN = 3;
+        sIRC->CSPELL    = 3;
+        sIRC->CSYSMSG   = 3;
+        sIRC->CTELE     = 3;
+        sIRC->CTOP      = 3;
+        sIRC->CWHO      = 3;
+    }
 }
 
 extern void LoadGameObjectModelList(std::string const& dataPath);
@@ -1397,6 +1559,7 @@ void World::SetInitialWorldSettings()
 
     ///- Initialize config settings
     LoadConfigSettings();
+    TC_LOG_ERROR("misc" "Loading TrinityCore configuration settings...","");
 
     ///- Initialize Allowed Security Level
     LoadDBAllowedSecurityLevel();
@@ -1861,6 +2024,9 @@ void World::SetInitialWorldSettings()
     LoginDatabase.PExecute("INSERT INTO uptime (realmid, starttime, uptime, revision) VALUES(%u, %u, 0, '%s')",
                             realmID, uint32(m_startTime), GitRevision::GetFullVersion());       // One-time query
 
+    static uint32 autoanc = 1;
+    autoanc = sIRC->autoanc;
+
     m_timers[WUPDATE_WEATHERS].SetInterval(1*IN_MILLISECONDS);
     m_timers[WUPDATE_AUCTIONS].SetInterval(MINUTE*IN_MILLISECONDS);
     m_timers[WUPDATE_AUCTIONS_PENDING].SetInterval(250);
@@ -1878,6 +2044,8 @@ void World::SetInitialWorldSettings()
 
     m_timers[WUPDATE_PINGDB].SetInterval(getIntConfig(CONFIG_DB_PING_INTERVAL)*MINUTE*IN_MILLISECONDS);    // Mysql ping time in minutes
 
+    m_timers[WUPDATE_AUTOANC].SetInterval(autoanc*MINUTE*1000);
+
     //to set mailtimer to return mails every day between 4 and 5 am
     //mailtimer is increased when updating auctions
     //one second is 1000 -(tested on win system)
@@ -2261,6 +2429,12 @@ void World::Update(uint32 diff)
         WorldDatabase.KeepAlive();
     }
 
+    if (m_timers[WUPDATE_AUTOANC].Passed())
+    {
+        m_timers[WUPDATE_AUTOANC].Reset();
+        SendRNDBroadcastIRC();
+    }
+
     // update the instance reset times
     sInstanceSaveMgr->Update();
 
@@ -2878,6 +3052,20 @@ void World::SendAutoBroadcast()
     TC_LOG_DEBUG("misc", "AutoBroadcast: '%s'", msg.c_str());
 }
 
+void World::SendRNDBroadcastIRC()
+{
+    std::string msg;
+    QueryResult result = WorldDatabase.PQuery("SELECT `message` FROM `irc_autoannounce` ORDER BY RAND() LIMIT 1");
+    if (!result)
+        return;
+    msg = result->Fetch()[0].GetString();
+
+    sWorld->SendWorldText(6612,msg.c_str());
+    std::string ircchan = "#";
+    ircchan += sIRC->anchn;
+    sIRC->Send_IRC_Channel(ircchan, sIRC->MakeMsg("\00304,08\037/!\\\037\017\00304 Automatic System Message \00304,08\037/!\\\037\017 %s", "%s", msg.c_str()), true);
+}
+
 void World::UpdateRealmCharCount(uint32 accountId)
 {
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_COUNT);
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 492a3bd..0bdf25c 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -76,6 +76,7 @@ enum WorldTimers
     WUPDATE_EVENTS,
     WUPDATE_CLEANDB,
     WUPDATE_AUTOBROADCAST,
+    WUPDATE_AUTOANC,
     WUPDATE_MAILBOXQUEUE,
     WUPDATE_DELETECHARS,
     WUPDATE_AHBOT,
@@ -673,6 +674,9 @@ class World
         void AddSession(WorldSession* s);
         void SendAutoBroadcast();
         bool RemoveSession(uint32 id);
+
+        void SendRNDBroadcastIRC();
+
         /// Get the number of current active sessions
         void UpdateMaxSessionCounters();
         const SessionMap& GetAllSessions() const { return m_sessions; }
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index ea0b058..7132d31 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -128,6 +128,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
   ${CMAKE_SOURCE_DIR}/src/server/game/Texts
+  ${CMAKE_SOURCE_DIR}/src/server/game/TriniChat
   ${CMAKE_SOURCE_DIR}/src/server/game/Tickets
   ${CMAKE_SOURCE_DIR}/src/server/game/Tools
   ${CMAKE_SOURCE_DIR}/src/server/game/Warden
diff --git a/src/server/scripts/Commands/cs_message.cpp b/src/server/scripts/Commands/cs_message.cpp
index 69ff04f..9fdfad5 100644
--- a/src/server/scripts/Commands/cs_message.cpp
+++ b/src/server/scripts/Commands/cs_message.cpp
@@ -28,6 +28,7 @@ EndScriptData */
 #include "Language.h"
 #include "Player.h"
 #include "ObjectMgr.h"
+#include "IRCClient.h"
 
 class message_commandscript : public CommandScript
 {
@@ -123,6 +124,12 @@ public:
             name = session->GetPlayer()->GetName();
 
         sWorld->SendGMText(LANG_GM_ANNOUNCE_COLOR, name.c_str(), args);
+        //send to irc
+        if(sIRC->_staffLink == 1)
+        {
+            std::string sMsg = "[<WoW>"+name+"]: "+args;
+            sIRC->Send_IRC_Channel(sIRC->_staffChan, sMsg, false, "PRIVMSG");
+        }
         return true;
     }
     // global announce
@@ -131,6 +138,13 @@ public:
         if (!*args)
             return false;
 
+        if ((sIRC->BOTMASK & 256) != 0 && sIRC->anchn.size() > 0)
+        {
+            std::string ircchan = "#";
+            ircchan += sIRC->anchn;
+            sIRC->Send_IRC_Channel(ircchan, sIRC->MakeMsg("\00304,08\037/!\\\037\017\00304 System Message \00304,08\037/!\\\037\017 %s", "%s", args), true);
+        }
+
         char buff[2048];
         sprintf(buff, handler->GetTrinityString(LANG_SYSTEMMESSAGE), args);
         sWorld->SendServerMessage(SERVER_MSG_STRING, buff);
@@ -150,6 +164,12 @@ public:
     {
         if (!*args)
             return false;
+        if ((sIRC->BOTMASK & 256) != 0 && sIRC->anchn.size() > 0)
+        {
+            std::string ircchan = "#";
+            ircchan += sIRC->anchn;
+            sIRC->Send_IRC_Channel(ircchan, sIRC->MakeMsg("\00304,08\037/!\\\037\017\00304 Global Notify \00304,08\037/!\\\037\017 %s", "%s", args), true);
+        }
 
         std::string str = handler->GetTrinityString(LANG_GLOBAL_NOTIFY);
         str += args;
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
index 9949598..5da5d93 100644
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -78,11 +78,14 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item/Container
   ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
   ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Pet
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Player
   ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
   ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
   ${CMAKE_SOURCE_DIR}/src/server/game/Globals
   ${CMAKE_SOURCE_DIR}/src/server/game/Grids
   ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Groups
   ${CMAKE_SOURCE_DIR}/src/server/game/Handlers
   ${CMAKE_SOURCE_DIR}/src/server/game/Instances
   ${CMAKE_SOURCE_DIR}/src/server/game/Loot
@@ -95,7 +98,9 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Scripting
   ${CMAKE_SOURCE_DIR}/src/server/game/Server
   ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
+  ${CMAKE_SOURCE_DIR}/src/server/game/TriniChat
   ${CMAKE_SOURCE_DIR}/src/server/game/Weather
   ${CMAKE_SOURCE_DIR}/src/server/game/World
   ${CMAKE_SOURCE_DIR}/src/server/shared
diff --git a/src/server/worldserver/CommandLine/CliRunnable.cpp b/src/server/worldserver/CommandLine/CliRunnable.cpp
index 9936143..c3bbbd4 100644
--- a/src/server/worldserver/CommandLine/CliRunnable.cpp
+++ b/src/server/worldserver/CommandLine/CliRunnable.cpp
@@ -28,6 +28,7 @@
 #include "CliRunnable.h"
 #include "Log.h"
 #include "Util.h"
+#include "IRCClient.h"
 
 #if PLATFORM != PLATFORM_WINDOWS
 #include <readline/readline.h>
@@ -108,6 +109,14 @@ void commandFinished(void*, bool /*success*/)
     printf("TC> ");
     fflush(stdout);
 }
+//Reconnect TriniChat to IRC server via CLI command
+bool HandleIRCRelogCommand(bool, const char *args)
+{
+    TC_LOG_ERROR("misc" "TriniChat is dropping from IRC Server","");
+    sIRC->ResetIRC();
+    TC_LOG_ERROR("misc" "TriniChat is reconnecting to IRC Server","");
+    return true;
+}
 
 #ifdef linux
 // Non-blocking keypress detector, when return pressed, return 1, else always return 0
diff --git a/src/server/worldserver/Main.cpp b/src/server/worldserver/Main.cpp
index 53c5f25..192e465 100644
--- a/src/server/worldserver/Main.cpp
+++ b/src/server/worldserver/Main.cpp
@@ -49,8 +49,10 @@
 #include "WorldSocketMgr.h"
 #include "DatabaseLoader.h"
 #include "AppenderDB.h"
+#include "../../game/TriniChat/IRCClient.h"
 
 using namespace boost::program_options;
+#include "IRCClient.h"
 
 #ifndef _TRINITY_CORE_CONFIG
     #define _TRINITY_CORE_CONFIG  "worldserver.conf"
@@ -216,6 +218,15 @@ extern int main(int argc, char** argv)
         soapThread = new std::thread(TCSoapThread, sConfigMgr->GetStringDefault("SOAP.IP", "127.0.0.1"), uint16(sConfigMgr->GetIntDefault("SOAP.Port", 7878)));
     }
 
+    // Start up TriniChat
+    boost::thread* triniChatThread = nullptr;
+    if (sIRC->Active == 1)
+    {
+        triniChatThread = new boost::thread(TrinityChatThread);
+    }
+    else
+        TC_LOG_ERROR("misc", "*** TriniChat Is Disabled. *");
+
     // Launch the worldserver listener socket
     uint16 worldPort = uint16(sWorld->getIntConfig(CONFIG_PORT_WORLD));
     std::string worldListener = sConfigMgr->GetStringDefault("BindIP", "0.0.0.0");
@@ -270,6 +281,18 @@ extern int main(int argc, char** argv)
 
     delete raAcceptor;
 
+    // Clean TrinityChat
+    if (triniChatThread != nullptr)
+    {
+        // for some reason on win32 "sIRC->Active && !World::IsStopped()" fail to go false in time and the thread is stalled
+        // so we make sure the condition to live will fail from here, since we are shutting down...
+        sIRC->Active = 0;
+        triniChatThread->join();
+        delete triniChatThread;
+    }
+
+    if (raAcceptor != nullptr)
+        delete raAcceptor;
     ///- Clean database before leaving
     ClearOnlineAccounts();
 
@@ -277,6 +300,7 @@ extern int main(int argc, char** argv)
 
     TC_LOG_INFO("server.worldserver", "Halting process...");
 
+
     ShutdownCLIThread(cliThread);
 
     OpenSSLCrypto::threadsCleanup();
@@ -456,6 +480,17 @@ bool StartDB()
     if (!loader.Load())
         return false;
 
+
+
+
+
+
+
+
+
+
+
+
     ///- Get the realm Id from the configuration file
     realmID = sConfigMgr->GetIntDefault("RealmID", 0);
     if (!realmID)
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 4837a24..0cf8dca 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2677,9 +2677,6 @@ CharDelete.Heroic.MinLevel = 0
 
 CharDelete.KeepDays = 30
 
-#
-###################################################################################################
-
 ###################################################################################################
 # CUSTOM SERVER OPTIONS
 #
@@ -3370,6 +3367,8 @@ AuctionHouseBot.Buyer.Recheck.Interval = 20
 #
 ###################################################################################################
 
+
+
 ###################################################################################################
 # LOGGING SYSTEM SETTINGS
 #
@@ -3566,6 +3565,279 @@ PacketSpoof.BanDuration = 86400
 #
 ###################################################################################################
 
+#########################################################
+# TriniChat IRC BOT For Trinity Core Configuration File #
+#########################################################
+# irc.active
+# Enable TriniChat Addon
+# Default: 1 - Enable
+# 0 - Disable
+#
+irc.active = 1
+
+##################################################
+# irc.icc
+# IRC connect code
+# Default: 001 - Welcome To Network msg
+# 375 - Beginning Of MOTD
+# 376 - End Of MOTD
+#
+irc.icc = 001
+
+##################################################
+# irc.host
+# IRC server to have TriniChat connect to
+#
+irc.host = "irc.xxxx.net"
+
+##################################################
+# irc.port
+# IRC server port to use
+#
+irc.port = "1337"
+
+##################################################
+# irc.user
+# The username to have TriniChat use to connect to the IRC server
+# irc.nick
+# IRC nickname to be used by the bot
+# irc.pass
+# The password to be used to identify to NickServ (IRC NickName Enforcement Services)
+#
+irc.user = "Trini_Chat"
+irc.nick = "Trini_Chat"
+irc.pass = "ServicesPass"
+
+##################################################
+# irc.auth
+# IRC Authentication Method
+# Default: 0 - Disable
+# 1 - NickServ - Normal Method - PRIVMSG NickServ :IDENTIFY Password
+# 2 - NickServ - Alternate Method To Identify To A Different Nick - PRIVMSG NickServ :IDENTIFY irc.auth.nick Password
+# 3 - QuakeNet - Normal Method - PRIVMSG Q@CServe.quakenet.org :AUTH irc.nick Password
+# 4 - QuakeNet - Alternate Method To Identify To A Different Nick - PRIVMSG Q@CServe.quakenet.org :AUTH irc.auth.nick Password
+# irc.auth.nick
+# IRC Nickname to use if Auth method 2 or 4 is used
+#
+irc.auth = 0
+irc.auth.nick = "AuthNick"
+
+##################################################
+# irc.ldef
+# Leave a defined IRC channel on server connect
+# Default: 0 - Disable
+# 1 - Enable
+# irc.defchan
+# IRC channel to leave on server connect if irc.ldef is on
+#
+irc.ldef = 0
+irc.defchan = "lobby"
+
+##################################################
+# irc.wct
+# Time to wait before (re)attemptimg connection to IRC server
+# Default: 30000 - (30 Seconds)
+# irc.maxattempt
+# Maximum attempts to try IRC server
+# Default: 20
+#
+irc.wct = 30000
+irc.maxattempt = 20
+
+##################################################
+# irc.auto.announce
+# Time to wait in Minutes to announce random messages from database.
+# Default: 30 - (30 Minutes)
+#
+irc.auto.announce = 30
+
+##################################################
+# irc.autojoin_kick
+# Autojoin IRC channel if kicked
+# Default: 1 - Enable
+# 0 - Disable
+#
+irc.autojoin_kick = 1
+
+##################################################
+# irc.command_prefix
+# IRC command prefix
+# Example: (.)online all
+#
+irc.command_prefix = "\"
+
+##################################################
+# irc.joinmsg
+# irc.rstmsg
+# irc.kickmsg
+# TriniChat bot join/restart/kick messages
+#
+irc.joinmsg = "Trinity Core With TriniChat $Ver Is Up And Running! Command Trigger Is: $Trigger"
+irc.rstmsg = "TriniChat Is Restarting, I Will Be Right Back."
+irc.kickmsg = "Do Not Kick Me Again, Severe Actions Will Be Taken!"
+
+##################################################
+# irc.chan_#
+# wow.chan_#
+# IRC and WOW channels to link. Leave # out of IRC channel. Both channels _ARE_ case sensitive
+# NOTE: you can have more than 1 IRC channel linked to wow channels, as in example:
+# Example: irc.chan_1 = "Trinity"
+# irc.chan_2 = "trinity2"
+# wow.chan_1 = "world"
+# wow.chan_2 = "LookingForGroup"
+# irc.pass_#
+# Passwords for said IRC channels (IRC server side)
+# Example:
+# irc.pass_1 = "password" password for irc channel #1
+# irc.pass_2 = "password2" password for irc channel #2
+irc.chan_1 = "ircchan"
+wow.chan_1 = "world"
+irc.pass_1 = "pass"
+
+##################################################
+# irc.staff_link
+# if set to 1 will link gm name announce to irc channel
+# Default: 0
+# irc.staff_chan
+# Print IRC messages to GM Name Announce and Gm Name Announce to IRC Channel
+# Default: "staff"
+# irc.ignore_bots
+# enter nicks of bots to ignore seprated by commas
+# Default: ""
+#
+irc.staff_link = 0
+irc.staff_chan = "staff"
+irc.ignore_bots = ""
+
+##################################################
+# irc.StatusChannel
+# Channel Name To Display Status Messages In (AuctionHouse, Levels, Deaths, Etc)
+# Default: ""
+# irc.AnnounceChannel
+# Channel Name To Display Announcements In (Announces, Notifies, Event)
+# Default: ""
+# irc.Tickets
+# Channel Name To Display Ticket Announcment in (Create, Edit, Closed, lag Reports)
+# Default: ""
+# Note: Botmask : Enable Ticket Announment must be activ
+#
+irc.StatusChannel = ""
+irc.StatusChannelPW = ""
+irc.AnnounceChannel = ""
+irc.AnnounceChannelPW = ""
+irc.Tickets = ""
+irc.TicketsPW = ""
+
+##################################################
+# irc.op_gm_login
+# Op The GM In All Channels The Bot Is On When They Log In To TriniChat
+# Default: 0 - Disable
+# 1 - Enable
+# irc.op_gm_level
+# The Minimum GM Level Required To Have The Bot Op The User
+# Default: 3 - GM Level 3
+#
+irc.op_gm_login = 0
+irc.op_gm_level = 3
+
+##################################################
+# irc.ajoin (Experimental/Under Development)
+# Force players to autojoin a WOW in game channel
+# Atleast one player must be in the channel on server start, and atleast one person online for invite to work
+# Default: 0 - Disable
+# 1 - Enable
+# irc.ajchan
+# Channel to join if above is Enabled.
+#
+irc.ajoin = 1
+irc.ajchan = "world"
+
+##################################################
+# irc.online.result
+# Maximum number of results per line for the online command
+#
+irc.online.result = 30
+
+##################################################
+# chat.*** (Defineable Strings) (maybe more in future)
+# wow_* - String is displayed in IRC channel
+# irc_* - String is displayed in WOW channel
+# Options: $Name, $Level, $Class, $Msg, $GM (not all options work in every string)
+#
+chat.wow_irc = "<WoW>[$Name($Level)[$Class]] $Msg"
+chat.irc_wow = "<IRC>[$Name]: $Msg"
+chat.join_wow = "12>>04 $GM$Name Joined The $Channel Channel!"
+chat.join_irc = "[$Name]: Has Joined IRC!"
+chat.leave_wow = "12<<04 $GM$Name Left The $Channel Channel!"
+chat.leave_irc = "[$Name]: Has Left IRC!"
+chat.change_nick = "<> $Name Is Now Known As $NewName!"
+
+##################################################
+# Botmask
+# This defines what the bot announces, if its 0 everything is disabled
+# simply add the values of the elements you want to create this mask.
+# Example: WoW join/leaves are 1 and IRC join/leaves are 2, if you want both of these active then the BotMask is 3.
+# (1)Display WoW Chan Join/Leaves In IRC
+# (2)Display IRC Chan Join/Leaves/NickChanges In WoW
+# (4)Display Unknown Command Message When Trigger Is Used And No Command Exists
+# (8)Announce Security Level > 0 As GM At Login
+# (16)Announce GM In GM ON State AS GM At Login
+# (32)Return Errors To Notice. (If disabled then default is Private Message)
+# (64)Display WoW Status Messages (Levels/Deaths)
+# (128)Display Nick Changes From IRC In WOW
+# (256)Display WoW Announces/Notifies In IRC
+# (512)Do Not Let Players Use Commands On Higher GM Level Players
+# (1024)Enable AuctionHouse Announcements !!DISSABLED!!
+#
+Botmask = 1023
+
+##################################################
+# irc.gmlog
+# Minimum GM level to not show login/pass info in IRC logs
+# irc.logfile.prefix
+# The prefix of the IRC logfile. Directories can be added here.
+# Example: "IRC/IRC_" outputs IRC_YYYY-MM-DD.log to the IRC subdirectory in your logs dir
+# irc.logchannel
+# Specefies the channel where logged output gets broadcasted.
+# Default: "" (none)
+# irc.logchannelpw
+# The password for the log channel.
+# irc.logmask
+# Bitmask, see Botmask for explanation. Determines what gets logged to the logchannel.
+# (0) Do not broadcast into logchannel.
+# (1) Broadcast IRC Commands into logchannel.
+# (2) Broadcast Ingame GM Commands into logchannel.
+# (3) Broadcast both IRC Commands and GM Commands into logchannel.
+irc.gmlog = 1
+irc.logfile.prefix = "IRC_"
+irc.logchannel = "testlog"
+irc.logchannelpw = ""
+irc.logmask = 3
+
+##################################################
+# irc.fun.games (Experimental/Under Development)
+# Enable TriniChat Games
+# Default: 0 - Disable
+# 1 - Enable
+#
+irc.fun.games = 0
+
+##################################################
+# irc.gm#
+# GM tag to append to (GM onjoin / online command) IRC color codes are acceptable
+#
+irc.gm1 = "[VIP]"
+irc.gm2 = "[Donator]"
+irc.gm3 = "[Bug Tracker]"
+irc.gm4 = "[Moderator]"
+irc.gm5 = "[Game Master]"
+irc.gm6 = "[Admin]"
+irc.gm7 = "[Developer]"
+irc.gm8 = "[Owner]"
+
+#
+###################################################################################################
+
 #
 # Prepatch by LordPsyan.
 # See http://www.realmsofwarcraft.com/bb for forums and information.
-- 
2.1.4

