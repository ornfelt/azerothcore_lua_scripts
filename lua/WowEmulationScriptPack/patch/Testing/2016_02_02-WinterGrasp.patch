From a5fc421e2fae25bceabc76dc6314ba9c6d281c89 Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Tue, 2 Feb 2016 07:54:49 -0600
Subject: [PATCH] 2016_02_02-WinterGrasp

---
 .../Wintergrasp/OutDoorPvPWG_auth.sql              |   20 +
 .../Wintergrasp/OutdoorPvPWG_characters.sql        |    6 +
 .../Wintergrasp/OutdoorPvPWG_world.sql             |  163 ++
 .../Wintergrasp/OutdoorPvPWG_world_bunners.sql     |  179 ++
 src/server/game/Accounts/RBAC.h                    |    8 +-
 src/server/game/Battlefield/BattlefieldMgr.cpp     |    6 +-
 .../game/Battlefield/Zones/BattlefieldWG.cpp       | 1561 --------------
 src/server/game/Battlefield/Zones/BattlefieldWG.h  | 1187 ----------
 src/server/game/CMakeLists.txt                     |    1 +
 src/server/game/Entities/Creature/Creature.cpp     |   12 +
 src/server/game/Entities/GameObject/GameObject.cpp |    5 +
 src/server/game/Entities/Player/Player.cpp         |    8 +-
 src/server/game/Entities/Player/Player.h           |    2 +-
 src/server/game/Entities/Vehicle/Vehicle.cpp       |   26 +
 src/server/game/Entities/Vehicle/Vehicle.h         |    2 +
 src/server/game/Globals/ObjectMgr.cpp              |   46 +
 src/server/game/Globals/ObjectMgr.h                |    2 +
 src/server/game/Handlers/BattleGroundHandler.cpp   |    2 +
 src/server/game/Handlers/CharacterHandler.cpp      |   20 +-
 src/server/game/Handlers/MiscHandler.cpp           |   20 +
 src/server/game/Miscellaneous/Language.h           |   23 +
 src/server/game/OutdoorPvP/OutdoorPvP.h            |    5 +-
 src/server/game/Scripting/ScriptLoader.cpp         |    6 +
 src/server/game/Spells/Spell.cpp                   |   11 +
 src/server/game/Spells/SpellEffects.cpp            |   18 +
 src/server/game/Spells/SpellMgr.cpp                |   26 +-
 src/server/game/World/World.cpp                    |   51 +-
 src/server/game/World/World.h                      |   34 +-
 src/server/scripts/CMakeLists.txt                  |    2 +-
 src/server/scripts/Commands/cs_wintergrasp.cpp     |  199 ++
 src/server/scripts/Northrend/CMakeLists.txt        |    2 +-
 .../VaultOfArchavon/instance_vault_of_archavon.cpp |   12 +
 src/server/scripts/Northrend/wintergrasp.cpp       |  439 ++++
 src/server/scripts/Northrend/zone_wintergrasp.cpp  |  643 ------
 src/server/scripts/OutdoorPvP/CMakeLists.txt       |    2 +
 src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp     | 2278 ++++++++++++++++++++
 src/server/scripts/OutdoorPvP/OutdoorPvPWG.h       |  347 +++
 src/server/worldserver/worldserver.conf.dist       |  132 +-
 38 files changed, 4048 insertions(+), 3458 deletions(-)
 create mode 100644 sql/TrinityCore-Patches/Wintergrasp/OutDoorPvPWG_auth.sql
 create mode 100644 sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_characters.sql
 create mode 100644 sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_world.sql
 create mode 100644 sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_world_bunners.sql
 delete mode 100644 src/server/game/Battlefield/Zones/BattlefieldWG.cpp
 delete mode 100644 src/server/game/Battlefield/Zones/BattlefieldWG.h
 create mode 100644 src/server/scripts/Commands/cs_wintergrasp.cpp
 create mode 100644 src/server/scripts/Northrend/wintergrasp.cpp
 delete mode 100644 src/server/scripts/Northrend/zone_wintergrasp.cpp
 create mode 100644 src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
 create mode 100644 src/server/scripts/OutdoorPvP/OutdoorPvPWG.h

diff --git a/sql/TrinityCore-Patches/Wintergrasp/OutDoorPvPWG_auth.sql b/sql/TrinityCore-Patches/Wintergrasp/OutDoorPvPWG_auth.sql
new file mode 100644
index 0000000..f0c2022
--- /dev/null
+++ b/sql/TrinityCore-Patches/Wintergrasp/OutDoorPvPWG_auth.sql
@@ -0,0 +1,20 @@
+DELETE FROM `rbac_permissions` WHERE `id` IN (1910,1911,1912,1913,1914,1915,1916);
+INSERT INTO `rbac_permissions` (`id`, `name`) VALUES
+(1910, 'Command: wg'),
+(1911, 'Command: wg enable'),
+(1912, 'Command: wg start'),
+(1913, 'Command: wg status'),
+(1914, 'Command: wg stop'),
+(1915, 'Command: wg switch'),
+(1916, 'Command: wg timer');
+
+DELETE FROM `rbac_linked_permissions` WHERE `linkedid` IN (1910,1911,1912,1913,1914,1915,1916);
+INSERT INTO `rbac_linked_permissions` (`id`,`linkedId`) VALUES
+(193, 1910),
+(193, 1911),
+(193, 1912),
+(193, 1913),
+(193, 1914),
+(193, 1915),
+(193, 1916);
+
diff --git a/sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_characters.sql b/sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_characters.sql
new file mode 100644
index 0000000..c521a1e
--- /dev/null
+++ b/sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_characters.sql
@@ -0,0 +1,6 @@
+/*WorldStates Characters DB*/
+DELETE FROM worldstates WHERE entry IN (31001,31002,31003,31004);
+INSERT INTO `worldstates` VALUES ('31001', '0', 'WG war status');
+INSERT INTO `worldstates` VALUES ('31002', '0', 'WG clock');
+INSERT INTO `worldstates` VALUES ('31003', '0', 'WG Fortress Defender');
+INSERT INTO `worldstates` VALUES ('31004', '0', 'WG TEMP Battle Control Faction');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_world.sql b/sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_world.sql
new file mode 100644
index 0000000..4ad7733
--- /dev/null
+++ b/sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_world.sql
@@ -0,0 +1,163 @@
+/*NOTE! Included Cyrillic Fonts - open it in UTF8 coding*/
+
+SET NAMES 'utf8';
+
+DELETE FROM `trinity_string` WHERE entry IN (756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,780,781,782,783);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES
+('756', 'Battle begins!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'Битва началась'),
+('757', '%s has successfully defended the fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s успешно защитил(а) крепость!'),
+('758', '%s has taken over the fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s захватил(а) крепость'),
+('759', 'The %s siege workshop has been damaged by the %s!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('760', 'The %s siege workshop has been destroyed by the %s!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('761', 'The %s tower has been damaged!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s башня повреждена'),
+('762', 'The %s tower has been destroyed!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s башня уничтожена!'),
+('763', 'Wintergrasp fortress is under attack!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('764', 'Wintergrasp is now under the control of the %s.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('765', 'Wintergrasp timer set to %s.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('766', 'Wintergrasp battle started.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('767', 'Wintergrasp battle finished.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('768', 'Wintergrasp info: %s controlled. Timer: %s. Wartime: %s. Number of Players: (Horde: %u, Alliance: %u)', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('769', 'Wintergrasp outdoorPvP is disabled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('770', 'Wintergrasp outdoorPvP is enabled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('771', 'You have reached Rank 1: Corporal', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'Вы достигли Ранга 1: Капрал'),
+('772', 'You have reached Rank 2: First Lieutenant', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'Вы достигли Ранга 2: Лейтенант'),
+('780', 'Before the Battle of  Wintergrasp left 30 minutes!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'До битвы на  Озере Ледяных Оков осталось 30 минут!'),
+('781', 'Before the Battle of  Wintergrasp left 10 minutes! Portal from Dalaran will work at begin of the battle.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'До битвы на  Озере Ледяных Оков осталось 10 минут! Портал с Даларана начнет работу во время боя.'),
+('782', 'The battle for Wintergrasp  has stopped! Not enough defenders. Wintergrasp Fortress remains  Attackers.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'Битва за Озеро Ледяных Оков Остановлена. Не хватает защитников. Крепость переходит атакующей  стороне.'),
+('783', 'The battle for Wintergrasp  has stopped! Not enough attackers. Wintergrasp Fortress remains  Defenders.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'Битва за Озеро Ледяных Оков Остановлена. Не хватает нападающих. Крепость остается защитникам.');
+
+DELETE FROM `command` WHERE NAME IN ('wg','wg enable','wg start','wg status','wg stop','wg switch','wg timer');
+INSERT INTO `command` (`name`, `permission`, `help`) VALUES
+('wg', '1910', 'Syntax: .wg $subcommand.'),
+('wg enable', '1911', 'Syntax: .wg enable [on/off] Enable/Disable Wintergrasp outdoorPvP.'),
+('wg start', '1912', 'Syntax: .wg start\r\nForce Wintergrasp battle start.'),
+('wg status', '1913', 'Syntax: .wg status\r\nWintergrasp info, defender, timer, wartime.'),
+('wg stop', '1914', 'Syntax: .wg stop\r\nForce Wintergrasp battle stop (No rewards).'),
+('wg switch', '1915', 'Syntax: .wg switch\r\nSwitchs Wintergrasp defender team.'),
+('wg timer', '1916', 'Syntax: .wg timer $minutes\r\nChange the current timer. Min value = 1, Max value 60 (Wartime), 1440 (Not Wartime)');
+
+/* WG scriptname */
+DELETE FROM `outdoorpvp_template` WHERE TypeId=7;
+INSERT INTO `outdoorpvp_template` (`TypeId`, `ScriptName`, `comment`) VALUES 
+('7', 'outdoorpvp_wg', 'Wintergrasp');
+
+/* Teleport WG SPELLs*/
+DELETE FROM `spell_target_position` WHERE id IN ('59096', '58632', '58633');
+INSERT INTO `spell_target_position` (`id`, `MapID`, `PositionX`, `PositionY`, `PositionZ`, `Orientation`) VALUES
+('59096', '571', '4561.58', '2835.33', '389.79', '0.34'),
+('58632', '571', '5025.71', '3673.41', '362.687', '0'),
+('58633', '571', '5094.67', '2170.33', '365.601', '0');
+
+/* Defender's Portal Activate Proper Spell */
+DELETE FROM `spell_linked_spell` WHERE spell_trigger=54640;
+INSERT INTO `spell_linked_spell` (`spell_trigger`, `spell_effect`, `type`, `comment`) VALUES 
+('54640','54643','0','Defender\'s Portal Activate Proper Spell');
+
+/* Protect players from catching by Druid Cyclone at graveyard which removes immunity after disappear */
+DELETE FROM `spell_linked_spell` WHERE spell_trigger=58729;
+INSERT INTO `spell_linked_spell` VALUES (58729, -33786, 2, 'Spiritual Immunity: Protect From Cyclone (now Immune always)');
+
+/*Spirit healer add spiritguide flag FIX for ressurection*/
+UPDATE creature_template SET npcflag=npcflag|32768 WHERE entry IN (31841,31842);
+
+/* Creature template */
+UPDATE creature_template SET faction = '1802' WHERE entry IN (30499,28312,28319);
+UPDATE creature_template SET faction = '1801' WHERE entry IN (30400,32629,32627);
+
+/* Demolisher Engineer script */
+UPDATE `creature_template` SET `ScriptName` = 'npc_demolisher_engineerer' WHERE `entry` IN (30400,30499);
+
+/* Wintergrasp Battle-Mage */
+DELETE FROM `creature` WHERE `id` IN (32170, 32169);
+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`,`npcflag`,`unit_flags`,`dynamicflags`) VALUES
+(NULL, 32170, 571, 1, 65535, 27801, 5917.69, 584.167, 660.49, 5.17983, 300, 0, 0, 504000, 440700, 0, 0, 0, 0),
+(NULL, 32170, 571, 1, 65535, 2796, 5939.59, 556.516, 640.001, 2.70112, 300, 0, 0, 504000, 440700, 0, 0, 0, 0),
+(NULL, 32169, 571, 1, 65535, 0, 5698.38, 777.562, 647.852, 5.56938, 900, 0, 0, 504000, 440700, 0, 0, 0, 0);
+
+UPDATE `creature_template` SET `ScriptName`='npc_wg_ally_battle_mage' WHERE `entry`=32169;
+UPDATE `creature_template` SET `ScriptName`='npc_wg_horde_battle_mage' WHERE `entry`=32170;
+
+/* Portal Dalaran->WG */
+DELETE FROM `gameobject` WHERE `id`=193772;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(NULL, 193772, 571, 1, 64, 5924.11, 573.387, 661.087, 4.43208, 0, 0, 0.798953, -0.601393, 300, 0, 1),
+(NULL, 193772, 571, 1, 65535, 5686.57, 772.921, 647.754, 5.62225, 0, 0, 0.324484, -0.945891, 600, 0, 1),
+(NULL, 193772, 571, 1, 65535, 5930.82, 548.961, 640.632, 1.88506, 0, 0, 0.809047, 0.587744, 300, 0, 1);
+
+/* Vehicle Teleporter */
+UPDATE `gameobject_template` SET `type` = 6, `faction` = 0, `data2` = 10, `data3` = 54643, `ScriptName` = 'go_wg_veh_teleporter' WHERE `entry` = 192951;
+
+/* Workshop */
+UPDATE `gameobject_template` SET `faction` = 35 WHERE `entry` IN (192028,192029,192030,192031,192032,192033);
+
+/* Towers */
+UPDATE `gameobject_template` SET `faction` = 0, `flags` = 6553632 WHERE `entry` IN (190356,190357,190358);
+
+/* Titan Relic remove */
+DELETE FROM `gameobject` WHERE `id`=192829;
+
+/* Temp removed gameobject stopping you getting to the relic
+* 194323 - [Wintergrasp Keep Collision Wall X:5396.209961 Y:2840.010010 Z:432.268005 MapId:571
+* 194162 - [Doodad_WG_Keep_Door01_collision01 X:5397.109863 Y:2841.540039 Z:425.901001 MapId:571]*/
+DELETE FROM gameobject WHERE id IN ('194323', '194162');
+
+/* spell target for build vehicles */
+DELETE FROM `conditions` WHERE ConditionValue2=27852;
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`, `SourceGroup`, `SourceEntry`, `ElseGroup`, `ConditionTypeOrReference`, `ConditionValue1`, `ConditionValue2`, `ConditionValue3`, `ErrorTextId`, `ScriptName`, `Comment`) VALUES
+(13, 0, 49899, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56575, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56661, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56663, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56665, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56667, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56669, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 61408, 0, 18, 1, 27852, 0, 0, '', NULL);
+
+/*WG Spell area Data For wg antifly */
+DELETE FROM `spell_area` WHERE spell IN (58730, 57940, 58045);
+INSERT INTO `spell_area` (`spell`, `area`, `quest_start`, `quest_end`, `aura_spell`, `racemask`, `gender`, `autocast`) VALUES
+(58730, 4197, 0, 0, 0, 0, 2, 1),
+(58730, 4584, 0, 0, 0, 0, 2, 1),
+(58730, 4581, 0, 0, 0, 0, 2, 1),
+(58730, 4585, 0, 0, 0, 0, 2, 1),
+(58730, 4612, 0, 0, 0, 0, 2, 1),
+(58730, 4582, 0, 0, 0, 0, 2, 1),
+(58730, 4611, 0, 0, 0, 0, 2, 1),
+(58730, 4578, 0, 0, 0, 0, 2, 1),
+(58730, 4576, 0, 0, 0, 0, 2, 1),
+(58730, 4538, 0, 0, 0, 0, 2, 1),
+(57940, 65, 0, 0, 0, 0, 2, 1),
+(57940, 66, 0, 0, 0, 0, 2, 1),
+(57940, 67, 0, 0, 0, 0, 2, 1),
+(57940, 206, 0, 0, 0, 0, 2, 1),
+(57940, 210, 0, 0, 0, 0, 2, 1),
+(57940, 394, 0, 0, 0, 0, 2, 1),
+(57940, 395, 0, 0, 0, 0, 2, 1),
+(57940, 1196, 0, 0, 0, 0, 2, 1),
+(57940, 2817, 0, 0, 0, 0, 2, 1),
+(57940, 3456, 0, 0, 0, 0, 2, 1),
+(57940, 3477, 0, 0, 0, 0, 2, 1),
+(57940, 3537, 0, 0, 0, 0, 2, 1),
+(57940, 3711, 0, 0, 0, 0, 2, 1),
+(57940, 4100, 0, 0, 0, 0, 2, 1),
+(57940, 4196, 0, 0, 0, 0, 2, 1),
+(57940, 4228, 0, 0, 0, 0, 2, 1),
+(57940, 4264, 0, 0, 0, 0, 2, 1),
+(57940, 4265, 0, 0, 0, 0, 2, 1),
+(57940, 4272, 0, 0, 0, 0, 2, 1),
+(57940, 4273, 0, 0, 0, 0, 2, 1),
+(57940, 4395, 0, 0, 0, 0, 2, 1),
+(57940, 4415, 0, 0, 0, 0, 2, 1),
+(57940, 4416, 0, 0, 0, 0, 2, 1),
+(57940, 4493, 0, 0, 0, 0, 2, 1),
+(57940, 4494, 0, 0, 0, 0, 2, 1),
+(57940, 4603, 0, 0, 0, 0, 2, 1),
+(58045, 4197, 0, 0, 0, 0, 2, 1);
+
+/* Spell target conditions for spawning WG siege machines in proper place while building it */
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=13 AND `SourceEntry` IN (56575,56661,56663,61408);
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`, `SourceGroup`, `SourceEntry`, `SourceId`, `ElseGroup`, `ConditionTypeOrReference`, `ConditionTarget`, `ConditionValue1`, `ConditionValue2`, `ConditionValue3`, `NegativeCondition`, `ErrorTextId`, `ScriptName`, `Comment`) VALUES
+(13, 1, 56575, 0, 0, 31, 0, 3, 27852, 0, 0, 0, '', NULL),
+(13, 1, 56661, 0, 0, 31, 0, 3, 27852, 0, 0, 0, '', NULL),
+(13, 1, 56663, 0, 0, 31, 0, 3, 27852, 0, 0, 0, '', NULL),
+(13, 1, 61408, 0, 0, 31, 0, 3, 27852, 0, 0, 0, '', NULL);
diff --git a/sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_world_bunners.sql b/sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_world_bunners.sql
new file mode 100644
index 0000000..c9ea9fa
--- /dev/null
+++ b/sql/TrinityCore-Patches/Wintergrasp/OutdoorPvPWG_world_bunners.sql
@@ -0,0 +1,179 @@
+DELETE FROM gameobject WHERE 
+       id IN (192317,192335,192313,192316,192332,192331,192330,192329,192487,192310,192314,192308,192309,192324,192326,192312,192325,192304,187433,193984,193983,192377,192321,192318,192322,192320,192269,192273,192274,192277,192278,192280,192283,192284,192285,192289,192290,192336,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,192357,192358,192359,192360,192361,192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192378,192379,192406,192407,192414,192416,192417,192418,192429,192433,192434,192435,192458,192459,192460,192461,192488,192501,192254,192255,192688,192686,180398,193764,193762,192319,192287,192323,192305,192286,192334,192307,192306,192328,192252,192253,192292,192299,192327,192267,192449,192450) 
+          AND map=571;
+INSERT INTO `gameobject` VALUES (NULL, 192317, 571, 1, 385, 5363.39, 2781.28, 435.634, 1.58825, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192335, 571, 1, 385, 5363.72, 2763.25, 445.023, -1.54462, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192313, 571, 1, 1, 5392.65, 3037.11, 433.713, -1.52716, 0, 0, -0.691512, 0.722365, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192316, 571, 1, 385, 5322.01, 2781.13, 435.673, 1.57952, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192332, 571, 1, 1, 5289.46, 2704.68, 435.875, -0.017451, 0, 0, -0.00872539, 0.999962, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192331, 571, 1, 1, 5350.95, 2640.36, 435.408, 1.5708, 0, 0, 0.707108, 0.707106, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192330, 571, 1, 1, 5392.27, 2639.74, 435.331, 1.50971, 0, 0, 0.685183, 0.728371, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192329, 571, 1, 1, 5350.88, 2622.72, 444.686, -1.5708, 0, 0, -0.707108, 0.707106, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 1, 5278.38, 2613.83, 432.721, -1.58825, 0, 0, -0.713251, 0.700909, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 1, 5260.82, 2631.8, 433.324, 3.05433, 0, 0, 0.999048, 0.0436174, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192310, 571, 1, 1, 5271.8, 2704.87, 445.183, -3.13286, 0, 0, -0.99999, 0.00436634, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192314, 571, 1, 1, 5236.27, 2739.46, 444.992, -1.59698, 0, 0, -0.716303, 0.697789, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 1, 5163.78, 2729.68, 432.009, -1.58825, 0, 0, -0.713251, 0.700909, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192308, 571, 1, 1, 5237.07, 2757.03, 435.796, 1.51844, 0, 0, 0.688356, 0.725373, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192309, 571, 1, 1, 5235.34, 2924.34, 435.04, -1.5708, 0, 0, -0.707108, 0.707106, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 1, 5262.54, 3047.95, 430.979, 3.10665, 0, 0, 0.999847, 0.0174704, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 1, 5163.13, 2952.59, 433.503, 1.53589, 0, 0, 0.694658, 0.71934, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192324, 571, 1, 1, 5235.19, 2942, 443.948, 1.58825, 0, 0, 0.713251, 0.700909, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192326, 571, 1, 1, 5272.73, 2976.55, 443.81, 3.12412, 0, 0, 0.999962, 0.00873622, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192312, 571, 1, 1, 5352.37, 3037.09, 435.252, -1.5708, 0, 0, -0.707108, 0.707106, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192325, 571, 1, 1, 5290.35, 2976.56, 435.221, 0.017452, 0, 0, 0.00872589, 0.999962, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192304, 571, 1, 385, 5397.76, 2873.08, 455.321, 3.10665, 0, 0, 0.999847, 0.0174704, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 187433, 571, 1, 1, 2832.84, 6184.45, 84.6827, -2.58308, 0, 0, 0, 0, 300, 100, 1);
+INSERT INTO `gameobject` VALUES (NULL, 187433, 571, 1, 1, 2835.96, 6180.37, 84.6827, 1.50098, 0, 0, 0, 0, 180, 100, 1);
+INSERT INTO `gameobject` VALUES (NULL, 187433, 571, 1, 1, 2830.12, 6188.96, 84.6827, -0.855211, 0, 0, 0, 0, 300, 100, 1);
+INSERT INTO `gameobject` VALUES (NULL, 187433, 571, 1, 1, 2831.88, 6188.72, 84.6827, -1.65806, 0, 0, 0, 0, 300, 100, 1);
+INSERT INTO `gameobject` VALUES (NULL, 193984, 571, 1, 1, 7647.47, 2055.55, 599.399, -0.279252, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 193984, 571, 1, 1, 7647.42, 2065.23, 599.308, 0.279252, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 193984, 571, 1, 1, 7609.86, 2055.53, 599.494, -2.86234, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 193984, 571, 1, 1, 7610.18, 2065.31, 599.426, 2.87979, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 193983, 571, 1, 1, 7906.95, 2053.04, 599.626, -0.296705, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 193983, 571, 1, 1, 7907.01, 2063.02, 599.587, 0.261798, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 193983, 571, 1, 1, 7870.43, 2053.35, 599.669, -2.87979, 0, 0, 0, 0, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 193983, 571, 1, 1, 7870.36, 2063.25, 599.628, 2.86234, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192377, 571, 1, 1, 5414.19, 3069.8, 415.187, 1.64061, 0, 0, 0, 0, 5, 100, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192321, 571, 1, 385, 5288.85, 2861.82, 435.591, 0.026179, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192318, 571, 1, 385, 5322.25, 2898.95, 435.643, -1.57952, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192322, 571, 1, 385, 5322.89, 2917.14, 445.154, 1.56207, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192320, 571, 1, 385, 5289.05, 2820.23, 435.674, 0, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192269, 571, 1, 1, 4526.46, 2810.18, 391.2, -2.99322, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192273, 571, 1, 1, 4417.94, 2324.81, 371.577, 3.08051, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192274, 571, 1, 1, 4424.15, 3286.54, 371.546, 3.12412, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192277, 571, 1, 1, 4572.93, 3475.52, 363.009, 1.42244, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192278, 571, 1, 1, 4433.9, 3534.14, 360.275, -1.85005, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192280, 571, 1, 1, 4857.97, 3335.44, 368.881, -2.94959, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192283, 571, 1, 1, 5006.34, 3280.4, 371.163, 2.22529, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192284, 571, 1, 65, 5372.48, 2862.5, 409.049, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192285, 571, 1, 65, 5371.49, 2820.8, 409.177, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192289, 571, 1, 1, 4778.19, 2438.06, 345.644, -2.94088, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192290, 571, 1, 1, 5024.57, 2532.75, 344.023, -1.93732, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192336, 571, 1, 1, 5154.49, 2862.15, 445.012, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192338, 571, 1, 65, 5397.76, 2873.08, 455.461, 3.10665, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192339, 571, 1, 65, 5397.39, 2809.33, 455.344, 3.10665, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192349, 571, 1, 1, 5155.31, 2820.74, 444.979, -3.13286, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192350, 571, 1, 1, 5270.69, 2861.78, 445.058, -3.11539, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192351, 571, 1, 1, 5271.28, 2820.16, 445.201, -3.13286, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192352, 571, 1, 1, 5173.02, 2820.93, 435.72, 0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192353, 571, 1, 1, 5172.11, 2862.57, 435.721, 0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192354, 571, 1, 1, 5288.41, 2861.79, 435.721, 0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192355, 571, 1, 1, 5288.92, 2820.22, 435.721, 0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192356, 571, 1, 1, 5237.07, 2757.03, 435.796, 1.51844, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192357, 571, 1, 1, 5235.34, 2924.34, 435.04, -1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192358, 571, 1, 65, 5322.23, 2899.43, 435.808, -1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192359, 571, 1, 65, 5364.35, 2899.4, 435.839, -1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192360, 571, 1, 65, 5352.37, 3037.09, 435.252, -1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192361, 571, 1, 65, 5392.65, 3037.11, 433.713, -1.52716, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192362, 571, 1, 65, 5322.12, 2763.61, 444.974, -1.55334, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192363, 571, 1, 65, 5363.61, 2763.39, 445.024, -1.54462, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192364, 571, 1, 1, 5350.88, 2622.72, 444.686, -1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192366, 571, 1, 1, 5236.27, 2739.46, 444.992, -1.59698, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192367, 571, 1, 1, 5271.8, 2704.87, 445.183, -3.13286, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192368, 571, 1, 65, 5289.46, 2704.68, 435.875, -0.017451, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192369, 571, 1, 1, 5350.95, 2640.36, 435.408, 1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192370, 571, 1, 1, 5392.27, 2639.74, 435.331, 1.50971, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192371, 571, 1, 65, 5364.29, 2916.94, 445.331, 1.57952, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192372, 571, 1, 65, 5322.86, 2916.95, 445.154, 1.56207, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192373, 571, 1, 1, 5290.35, 2976.56, 435.221, 0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192374, 571, 1, 1, 5272.94, 2976.55, 444.492, 3.12412, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192375, 571, 1, 1, 5235.19, 2941.9, 444.278, 1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192378, 571, 1, 65, 5322.02, 2781.13, 435.811, 1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192379, 571, 1, 65, 5363.42, 2781.03, 435.763, 1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192406, 571, 1, 1, 4438.3, 3361.08, 371.568, -0.017451, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192407, 571, 1, 1, 4448.17, 3235.63, 370.412, -1.56207, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192414, 571, 1, 1, 4387.62, 2719.57, 389.935, -1.54462, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192416, 571, 1, 1, 4408.57, 2422.61, 377.179, 1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192417, 571, 1, 1, 4416.59, 2414.08, 377.196, 0, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192418, 571, 1, 1, 4417.25, 2301.14, 377.214, 0.026179, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192429, 571, 1, 1, 4464.12, 2855.45, 406.111, 0.829032, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192433, 571, 1, 1, 4401.63, 3377.46, 363.365, 1.55334, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192434, 571, 1, 1, 5041.61, 3294.4, 382.15, -1.63188, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192435, 571, 1, 1, 4855.63, 3297.62, 376.739, -3.13286, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192458, 571, 1, 1, 4811.4, 2441.9, 358.207, -2.0333, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192459, 571, 1, 1, 4805.67, 2407.48, 358.191, 1.78023, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192460, 571, 1, 1, 5004.35, 2486.36, 358.449, 2.17294, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192461, 571, 1, 1, 4983.28, 2503.09, 358.177, -0.427603, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 1, 5160.34, 2798.61, 430.769, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 1, 5158.81, 2883.13, 431.618, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 1, 5278.38, 2613.83, 433.409, -1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 1, 5260.82, 2631.8, 433.324, 3.05433, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 1, 5163.13, 2952.59, 433.503, 1.53589, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 1, 5145.11, 2935, 433.386, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 1, 5262.54, 3047.95, 432.055, 3.10665, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 1, 5146.04, 2747.21, 433.584, 3.07177, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 1, 5163.78, 2729.68, 433.394, -1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192501, 571, 1, 1, 4398.82, 2804.7, 429.792, -1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192501, 571, 1, 1, 4416, 2822.67, 429.851, -0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192501, 571, 1, 1, 4559.11, 3606.22, 419.999, -1.48353, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192501, 571, 1, 1, 4539.42, 3622.49, 420.034, -3.07177, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192501, 571, 1, 1, 4555.26, 3641.65, 419.974, 1.67551, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192501, 571, 1, 1, 4574.87, 3625.91, 420.079, 0.087266, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192501, 571, 1, 1, 4466.79, 1960.42, 459.144, 1.15192, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192501, 571, 1, 1, 4475.35, 1937.03, 459.07, -0.436332, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192501, 571, 1, 1, 4451.76, 1928.1, 459.076, -2.00713, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192501, 571, 1, 1, 4442.99, 1951.9, 459.093, 2.74016, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192254, 571, 1, 1, 5154.46, 2828.94, 409.189, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192255, 571, 1, 1, 5154.52, 2853.31, 409.183, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192688, 571, 1, 1, 5916.1, 566.209, 639.625, -2.72271, 0, 0, 0, 1, 180, 100, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192686, 571, 1, 1, 5664.81, 791.002, 653.698, -0.663223, 0, 0, 0, 1, 180, 100, 1);
+INSERT INTO `gameobject` VALUES (NULL, 180398, 571, 1, 1, 5665.02, 790.2, 653.698, -0.610864, 0, 0, 0, 1, 180, 100, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 256, 4855.63, 3297.62, 376.281, -3.13286, 0, 0, -0.99999, 0.00436634, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192290, 571, 1, 256, 4526.46, 2810.18, 391.2, -2.99322, 0, 0, -0.997249, 0.0741182, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 256, 4517.75, 2717.23, 387.812, -1.53589, 0, 0, -0.694658, 0.71934, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 256, 4475.35, 1937.03, 459.07, -0.436332, 0, 0, -0.216439, 0.976296, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 256, 4451.76, 1928.1, 459.076, -2.00713, 0, 0, -0.843392, 0.537299, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 256, 4442.99, 1951.9, 459.093, 2.74016, 0, 0, 0.979924, 0.199371, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 256, 4466.8, 1960.44, 459.841, 1.15192, 0, 0, 0.54464, 0.83867, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 256, 5041.61, 3294.4, 382.15, -1.63188, 0, 0, -0.72837, 0.685184, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192278, 571, 1, 256, 5006.34, 3280.4, 371.163, 2.22529, 0, 0, 0.896872, 0.442291, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192278, 571, 1, 256, 4857.97, 3335.44, 368.881, -2.94959, 0, 0, -0.995395, 0.0958539, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192290, 571, 1, 256, 4433.9, 3534.14, 360.275, -1.85005, 0, 0, -0.798636, 0.601815, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192290, 571, 1, 256, 4572.93, 3475.52, 363.009, 1.42244, 0, 0, 0.652758, 0.757566, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 256, 4555.26, 3641.65, 419.974, 1.67551, 0, 0, 0.743143, 0.669133, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 256, 4574.87, 3625.91, 420.079, 0.087266, 0, 0, 0.0436192, 0.999048, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 256, 4559.11, 3606.22, 419.999, -1.48353, 0, 0, -0.67559, 0.737277, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 256, 4539.42, 3622.49, 420.034, -3.07177, 0, 0, -0.999391, 0.0349043, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192290, 571, 1, 256, 4401.63, 3377.46, 363.365, 1.55334, 0, 0, 0.700908, 0.713252, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 256, 4448.17, 3235.63, 370.412, -1.56207, 0, 0, -0.704015, 0.710185, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192488, 571, 1, 256, 4438.3, 3361.08, 371.299, -0.017451, 0, 0, -0.00872539, 0.999962, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192290, 571, 1, 256, 4424.15, 3286.54, 371.546, 3.12412, 0, 0, 0.999962, 0.00873622, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192461, 571, 1, 1, 4416.03, 2822.68, 430.475, -0.017452, 0, 0, -0.00872589, 0.999962, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192461, 571, 1, 1, 4464.12, 2855.45, 406.111, 0.829032, 0, 0, 0.402747, 0.915311, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192461, 571, 1, 1, 4398.82, 2804.7, 429.792, -1.58825, 0, 0, -0.713251, 0.700909, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192461, 571, 1, 1, 4408.57, 2422.61, 377.179, 1.58825, 0, 0, 0.713251, 0.700909, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192461, 571, 1, 1, 4416.59, 2414.08, 377.13, 0, 0, 0, 0, 1, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192461, 571, 1, 1, 4417.25, 2301.14, 377.214, 0.026179, 0, 0, 0.0130891, 0.999914, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192418, 571, 1, 1, 4805.67, 2407.48, 358.191, 1.78023, 0, 0, 0.777144, 0.629323, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192418, 571, 1, 1, 4811.4, 2441.9, 358.207, -2.0333, 0, 0, -0.85035, 0.526218, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192273, 571, 1, 1, 4778.19, 2438.06, 345.644, -2.94088, 0, 0, -0.994969, 0.100188, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192273, 571, 1, 1, 5024.57, 2532.75, 344.023, -1.93732, 0, 0, -0.824127, 0.566404, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192418, 571, 1, 1, 5004.35, 2486.36, 358.449, 2.17294, 0, 0, 0.884989, 0.465612, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192418, 571, 1, 1, 4983.28, 2503.09, 358.177, -0.427603, 0, 0, -0.212176, 0.977231, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192290, 571, 1, 1, 4417.94, 2324.81, 371.577, 3.08051, 0, 0, 0.999534, 0.0305366, 300, 0, 1);
+INSERT INTO `gameobject` VALUES (NULL, 193764, 571, 1, 1, 7625.87, 2060.05, 604.27, 0.07854, 0, 0, 0.99999, 0.004363, 180, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 193762, 571, 1, 1, 7625.66, 2060.04, 604.195, -3.05428, 0, 0, 0.99999, 0.004363, 180, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192319, 571, 1, 385, 5364.3, 2899.22, 435.691, -1.55334, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192287, 571, 1, 385, 5372.42, 2862.48, 409.366, 3.14159, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192323, 571, 1, 385, 5364.28, 2917.26, 445.332, 1.58825, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192305, 571, 1, 385, 5397.31, 2809.26, 455.102, 3.13286, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192286, 571, 1, 385, 5371.45, 2820.79, 409.427, 3.12412, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192334, 571, 1, 385, 5322.17, 2763.2, 444.974, -1.56207, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192307, 571, 1, 385, 5271.16, 2820.11, 445.109, -3.13286, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192306, 571, 1, 385, 5270.56, 2861.68, 444.917, -3.12412, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 385, 5160.28, 2798.6, 430.604, -3.12412, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 385, 5146.04, 2747.3, 433.527, 3.12412, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192328, 571, 1, 385, 5173.13, 2820.96, 435.658, 0.026179, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192252, 571, 1, 385, 5154.37, 2853.23, 409.183, 3.14159, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192253, 571, 1, 385, 5154.42, 2828.93, 409.189, 3.14159, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192292, 571, 1, 385, 5154.35, 2862.08, 445.01, 3.14159, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192299, 571, 1, 385, 5155.22, 2820.63, 444.979, -3.11539, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192327, 571, 1, 385, 5172.34, 2862.57, 435.658, 0, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 385, 5158.71, 2882.9, 431.274, 3.14159, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192487, 571, 1, 385, 5145.11, 2934.95, 433.255, -3.10665, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192267, 571, 1, 385, 4452.76, 2639.14, 358.444, 1.67552, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192449, 571, 1, 385, 4517.75, 2717.23, 387.812, -1.53589, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES (NULL, 192450, 571, 1, 385, 4387.59, 2719.9, 390.201, -1.51843, 0, 0, 0, 1, 300, 255, 1);
+
diff --git a/src/server/game/Accounts/RBAC.h b/src/server/game/Accounts/RBAC.h
index 3c3e838..c24848d 100644
--- a/src/server/game/Accounts/RBAC.h
+++ b/src/server/game/Accounts/RBAC.h
@@ -714,7 +714,13 @@ enum RBACPermissions
     // 12
     // 13
     // 14
-    // 15
+    RBAC_PERM_COMMAND_WG                                    = 1910,
+    RBAC_PERM_COMMAND_WG_STATUS                             = 1911,
+    RBAC_PERM_COMMAND_WG_ENABLE                             = 1912,
+    RBAC_PERM_COMMAND_WG_START                              = 1913,
+    RBAC_PERM_COMMAND_WG_STOP                               = 1914,
+    RBAC_PERM_COMMAND_WG_SWITCH                             = 1915,
+    RBAC_PERM_COMMAND_WG_TIMER                              = 1916,
     // 16
     // 17
     // 18
diff --git a/src/server/game/Battlefield/BattlefieldMgr.cpp b/src/server/game/Battlefield/BattlefieldMgr.cpp
index e4c10d6..082d65a 100644
--- a/src/server/game/Battlefield/BattlefieldMgr.cpp
+++ b/src/server/game/Battlefield/BattlefieldMgr.cpp
@@ -16,7 +16,8 @@
  */
 
 #include "BattlefieldMgr.h"
-#include "BattlefieldWG.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 #include "Player.h"
 
 BattlefieldMgr::BattlefieldMgr()
@@ -34,6 +35,7 @@ BattlefieldMgr::~BattlefieldMgr()
 
 void BattlefieldMgr::InitBattlefield()
 {
+/*
     Battlefield* wg = new BattlefieldWG();
     // respawn, init variables
     if (!wg->SetupBattlefield())
@@ -46,7 +48,7 @@ void BattlefieldMgr::InitBattlefield()
         _battlefieldSet.push_back(wg);
         TC_LOG_INFO("bg.battlefield", "Battlefield: Wintergrasp successfully initiated.");
     }
-
+*/
     /*
     For Cataclysm: Tol Barad
     Battlefield* tb = new BattlefieldTB;
diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.cpp b/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
deleted file mode 100644
index 3c9bf40..0000000
--- a/src/server/game/Battlefield/Zones/BattlefieldWG.cpp
+++ /dev/null
@@ -1,1561 +0,0 @@
-/*
- * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-/// @todo Implement proper support for vehicle+player teleportation
-/// @todo Use spell victory/defeat in wg instead of RewardMarkOfHonor() && RewardHonor
-/// @todo Add proper implement of achievement
-
-#include "BattlefieldWG.h"
-#include "AchievementMgr.h"
-#include "CreatureTextMgr.h"
-#include "Battleground.h"
-#include "MapManager.h"
-#include "ObjectMgr.h"
-#include "Opcodes.h"
-#include "Player.h"
-#include "SpellAuras.h"
-#include "TemporarySummon.h"
-#include "WorldSession.h"
-
-BattlefieldWG::~BattlefieldWG()
-{
-    for (WintergraspWorkshop* workshop : Workshops)
-        delete workshop;
-
-    for (BfWGGameObjectBuilding* building : BuildingsInZone)
-        delete building;
-}
-
-bool BattlefieldWG::SetupBattlefield()
-{
-    m_TypeId = BATTLEFIELD_WG;                              // See enum BattlefieldTypes
-    m_BattleId = BATTLEFIELD_BATTLEID_WG;
-    m_ZoneId = BATTLEFIELD_WG_ZONEID;
-    m_MapId = BATTLEFIELD_WG_MAPID;
-    m_Map = sMapMgr->FindMap(m_MapId, 0);
-
-    InitStalker(BATTLEFIELD_WG_NPC_STALKER, WintergraspStalkerPos);
-
-    m_MaxPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MAX);
-    m_IsEnabled = sWorld->getBoolConfig(CONFIG_WINTERGRASP_ENABLE);
-    m_MinPlayer = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN);
-    m_MinLevel = sWorld->getIntConfig(CONFIG_WINTERGRASP_PLR_MIN_LVL);
-    m_BattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_BATTLETIME) * MINUTE * IN_MILLISECONDS;
-    m_NoWarBattleTime = sWorld->getIntConfig(CONFIG_WINTERGRASP_NOBATTLETIME) * MINUTE * IN_MILLISECONDS;
-    m_RestartAfterCrash = sWorld->getIntConfig(CONFIG_WINTERGRASP_RESTART_AFTER_CRASH) * MINUTE * IN_MILLISECONDS;
-
-    m_TimeForAcceptInvite = 20;
-    m_StartGroupingTimer = 15 * MINUTE * IN_MILLISECONDS;
-    m_StartGrouping = false;
-
-    m_tenacityStack = 0;
-
-    KickPosition.Relocate(5728.117f, 2714.346f, 697.733f, 0);
-    KickPosition.m_mapId = m_MapId;
-
-    RegisterZone(m_ZoneId);
-
-    m_Data32.resize(BATTLEFIELD_WG_DATA_MAX);
-
-    m_saveTimer = 60000;
-
-    // Init GraveYards
-    SetGraveyardNumber(BATTLEFIELD_WG_GRAVEYARD_MAX);
-
-    // Load from db
-    if ((sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) == 0) && (sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) == 0)
-            && (sWorld->getWorldState(ClockWorldState[0]) == 0))
-    {
-        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, uint64(false));
-        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, uint64(urand(0, 1)));
-        sWorld->setWorldState(ClockWorldState[0], uint64(m_NoWarBattleTime));
-    }
-
-    m_isActive = sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) != 0;
-    m_DefenderTeam = TeamId(sWorld->getWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER));
-
-    m_Timer = sWorld->getWorldState(ClockWorldState[0]);
-    if (m_isActive)
-    {
-        m_isActive = false;
-        m_Timer = m_RestartAfterCrash;
-    }
-
-    for (uint8 i = 0; i < BATTLEFIELD_WG_GRAVEYARD_MAX; i++)
-    {
-        BfGraveyardWG* graveyard = new BfGraveyardWG(this);
-
-        // When between games, the graveyard is controlled by the defending team
-        if (WGGraveYard[i].startcontrol == TEAM_NEUTRAL)
-            graveyard->Initialize(m_DefenderTeam, WGGraveYard[i].gyid);
-        else
-            graveyard->Initialize(WGGraveYard[i].startcontrol, WGGraveYard[i].gyid);
-
-        graveyard->SetTextId(WGGraveYard[i].textid);
-        m_GraveyardList[i] = graveyard;
-    }
-
-
-    // Spawn workshop creatures and gameobjects
-    for (uint8 i = 0; i < WG_MAX_WORKSHOP; i++)
-    {
-        WintergraspWorkshop* workshop = new WintergraspWorkshop(this, i);
-        if (i < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
-            workshop->GiveControlTo(GetAttackerTeam(), true);
-        else
-            workshop->GiveControlTo(GetDefenderTeam(), true);
-
-        // Note: Capture point is added once the gameobject is created.
-        Workshops.insert(workshop);
-    }
-
-    // Spawn NPCs in the defender's keep, both Horde and Alliance
-    for (uint8 i = 0; i < WG_MAX_KEEP_NPC; i++)
-    {
-        // Horde npc
-        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entryHorde, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_HORDE))
-            KeepCreature[TEAM_HORDE].insert(creature->GetGUID());
-        // Alliance npc
-        if (Creature* creature = SpawnCreature(WGKeepNPC[i].entryAlliance, WGKeepNPC[i].x, WGKeepNPC[i].y, WGKeepNPC[i].z, WGKeepNPC[i].o, TEAM_ALLIANCE))
-            KeepCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
-    }
-
-    // Hide NPCs from the Attacker's team in the keep
-    for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
-        if (Creature* creature = GetCreature(*itr))
-            HideNpc(creature);
-
-    // Spawn Horde NPCs outside the keep
-    for (uint8 i = 0; i < WG_OUTSIDE_ALLIANCE_NPC; i++)
-        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entryHorde, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_HORDE))
-            OutsideCreature[TEAM_HORDE].insert(creature->GetGUID());
-
-    // Spawn Alliance NPCs outside the keep
-    for (uint8 i = WG_OUTSIDE_ALLIANCE_NPC; i < WG_MAX_OUTSIDE_NPC; i++)
-        if (Creature* creature = SpawnCreature(WGOutsideNPC[i].entryAlliance, WGOutsideNPC[i].x, WGOutsideNPC[i].y, WGOutsideNPC[i].z, WGOutsideNPC[i].o, TEAM_ALLIANCE))
-            OutsideCreature[TEAM_ALLIANCE].insert(creature->GetGUID());
-
-    // Hide units outside the keep that are defenders
-    for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
-        if (Creature* creature = GetCreature(*itr))
-            HideNpc(creature);
-
-    // Spawn turrets and hide them per default
-    for (uint8 i = 0; i < WG_MAX_TURRET; i++)
-    {
-        Position towerCannonPos = WGTurret[i].GetPosition();
-        if (Creature* creature = SpawnCreature(NPC_WINTERGRASP_TOWER_CANNON, towerCannonPos, TEAM_ALLIANCE))
-        {
-            CanonList.insert(creature->GetGUID());
-            HideNpc(creature);
-        }
-    }
-
-    // Spawn all gameobjects
-    for (uint8 i = 0; i < WG_MAX_OBJ; i++)
-    {
-        if (GameObject* go = SpawnGameObject(WGGameObjectBuilding[i].entry, WGGameObjectBuilding[i].x, WGGameObjectBuilding[i].y, WGGameObjectBuilding[i].z, WGGameObjectBuilding[i].o))
-        {
-            BfWGGameObjectBuilding* b = new BfWGGameObjectBuilding(this, WGGameObjectBuilding[i].type, WGGameObjectBuilding[i].WorldState);
-            b->Init(go);
-            if (!IsEnabled() && go->GetEntry() == GO_WINTERGRASP_VAULT_GATE)
-                go->SetDestructibleState(GO_DESTRUCTIBLE_DESTROYED);
-            BuildingsInZone.insert(b);
-        }
-    }
-
-    // Spawning portal defender
-    for (uint8 i = 0; i < WG_MAX_TELEPORTER; i++)
-    {
-        if (GameObject* go = SpawnGameObject(WGPortalDefenderData[i].entry, WGPortalDefenderData[i].x, WGPortalDefenderData[i].y, WGPortalDefenderData[i].z, WGPortalDefenderData[i].o))
-        {
-            DefenderPortalList.insert(go->GetGUID());
-            go->SetFaction(WintergraspFaction[GetDefenderTeam()]);
-        }
-    }
-
-    UpdateCounterVehicle(true);
-    return true;
-}
-
-bool BattlefieldWG::Update(uint32 diff)
-{
-    bool m_return = Battlefield::Update(diff);
-    if (m_saveTimer <= diff)
-    {
-        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_ACTIVE, m_isActive);
-        sWorld->setWorldState(BATTLEFIELD_WG_WORLD_STATE_DEFENDER, m_DefenderTeam);
-        sWorld->setWorldState(ClockWorldState[0], m_Timer);
-        m_saveTimer = 60 * IN_MILLISECONDS;
-    }
-    else
-        m_saveTimer -= diff;
-
-    return m_return;
-}
-
-void BattlefieldWG::OnBattleStart()
-{
-    // Spawn titan relic
-    if (GameObject* relic = SpawnGameObject(GO_WINTERGRASP_TITAN_S_RELIC, 5440.0f, 2840.8f, 430.43f, 0))
-    {
-        // Update faction of relic, only attacker can click on
-        relic->SetFaction(WintergraspFaction[GetAttackerTeam()]);
-        // Set in use (not allow to click on before last door is broken)
-        relic->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
-        m_titansRelicGUID = relic->GetGUID();
-    }
-    else
-        TC_LOG_ERROR("bg.battlefield", "WG: Failed to spawn titan relic.");
-
-
-    // Update tower visibility and update faction
-    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
-    {
-        if (Creature* creature = GetCreature(*itr))
-        {
-            ShowNpc(creature, true);
-            creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
-        }
-    }
-
-    // Rebuild all wall
-    for (BfWGGameObjectBuilding* building : BuildingsInZone)
-    {
-        building->Rebuild();
-        building->UpdateTurretAttack(false);
-    }
-
-    SetData(BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT, 0);
-    SetData(BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF, 0);
-    SetData(BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT, 0);
-    SetData(BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF, 0);
-
-    // Update graveyard (in no war time all graveyard is to deffender, in war time, depend of base)
-    for (WintergraspWorkshop* workshop : Workshops)
-        workshop->UpdateGraveyardAndWorkshop();
-
-    for (uint8 team = 0; team < 2; ++team)
-        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-        {
-            // Kick player in orb room, TODO: offline player ?
-            if (Player* player = ObjectAccessor::FindPlayer(*itr))
-            {
-                float x, y, z;
-                player->GetPosition(x, y, z);
-                if (5500 > x && x > 5392 && y < 2880 && y > 2800 && z < 480)
-                    player->TeleportTo(571, 5349.8686f, 2838.481f, 409.240f, 0.046328f);
-                SendInitWorldStatesTo(player);
-            }
-        }
-    // Initialize vehicle counter
-    UpdateCounterVehicle(true);
-    // Send start warning to all players
-    SendWarning(BATTLEFIELD_WG_TEXT_START_BATTLE);
-}
-
-void BattlefieldWG::UpdateCounterVehicle(bool init)
-{
-    if (init)
-    {
-        SetData(BATTLEFIELD_WG_DATA_VEHICLE_H, 0);
-        SetData(BATTLEFIELD_WG_DATA_VEHICLE_A, 0);
-    }
-    SetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H, 0);
-    SetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A, 0);
-
-    for (WintergraspWorkshop* workshop : Workshops)
-    {
-        if (workshop->GetTeamControl() == TEAM_ALLIANCE)
-            UpdateData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A, 4);
-        else if (workshop->GetTeamControl() == TEAM_HORDE)
-            UpdateData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H, 4);
-    }
-
-    UpdateVehicleCountWG();
-}
-
-void BattlefieldWG::OnBattleEnd(bool endByTimer)
-{
-    // Remove relic
-    if (m_titansRelicGUID)
-        if (GameObject* relic = GetGameObject(m_titansRelicGUID))
-            relic->RemoveFromWorld();
-    m_titansRelicGUID.Clear();
-
-    // Remove turret
-    for (GuidSet::const_iterator itr = CanonList.begin(); itr != CanonList.end(); ++itr)
-    {
-        if (Creature* creature = GetCreature(*itr))
-        {
-            if (!endByTimer)
-                creature->setFaction(WintergraspFaction[GetDefenderTeam()]);
-            HideNpc(creature);
-        }
-    }
-
-    if (!endByTimer) // One player triggered the relic
-    {
-        // Change all npc in keep
-        for (GuidSet::const_iterator itr = KeepCreature[GetAttackerTeam()].begin(); itr != KeepCreature[GetAttackerTeam()].end(); ++itr)
-            if (Creature* creature = GetCreature(*itr))
-                HideNpc(creature);
-
-        for (GuidSet::const_iterator itr = KeepCreature[GetDefenderTeam()].begin(); itr != KeepCreature[GetDefenderTeam()].end(); ++itr)
-            if (Creature* creature = GetCreature(*itr))
-                ShowNpc(creature, true);
-
-        // Change all npc out of keep
-        for (GuidSet::const_iterator itr = OutsideCreature[GetDefenderTeam()].begin(); itr != OutsideCreature[GetDefenderTeam()].end(); ++itr)
-            if (Creature* creature = GetCreature(*itr))
-                HideNpc(creature);
-
-        for (GuidSet::const_iterator itr = OutsideCreature[GetAttackerTeam()].begin(); itr != OutsideCreature[GetAttackerTeam()].end(); ++itr)
-            if (Creature* creature = GetCreature(*itr))
-                ShowNpc(creature, true);
-    }
-
-    // Update all graveyard, control is to defender when no wartime
-    for (uint8 i = 0; i < BATTLEFIELD_WG_GY_HORDE; i++)
-        if (BfGraveyard* graveyard = GetGraveyardById(i))
-            graveyard->GiveControlTo(GetDefenderTeam());
-
-    for (GuidSet::const_iterator itr = m_KeepGameObject[GetDefenderTeam()].begin(); itr != m_KeepGameObject[GetDefenderTeam()].end(); ++itr)
-        if (GameObject* object = GetGameObject(*itr))
-            object->SetRespawnTime(RESPAWN_IMMEDIATELY);
-
-    for (GuidSet::const_iterator itr = m_KeepGameObject[GetAttackerTeam()].begin(); itr != m_KeepGameObject[GetAttackerTeam()].end(); ++itr)
-        if (GameObject* object = GetGameObject(*itr))
-            object->SetRespawnTime(RESPAWN_ONE_DAY);
-
-    // Update portal defender faction
-    for (GuidSet::const_iterator itr = DefenderPortalList.begin(); itr != DefenderPortalList.end(); ++itr)
-        if (GameObject* portal = GetGameObject(*itr))
-            portal->SetFaction(WintergraspFaction[GetDefenderTeam()]);
-
-    // Saving data
-    for (BfWGGameObjectBuilding* building : BuildingsInZone)
-        building->Save();
-
-    for (WintergraspWorkshop* workshop : Workshops)
-        workshop->Save();
-
-    for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
-    {
-        if (Player* player = ObjectAccessor::FindPlayer(*itr))
-        {
-            player->CastSpell(player, SPELL_ESSENCE_OF_WINTERGRASP, true);
-            player->CastSpell(player, SPELL_VICTORY_REWARD, true);
-            // Send Wintergrasp victory achievement
-            DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG, player);
-            // Award achievement for succeeding in Wintergrasp in 10 minutes or less
-            if (!endByTimer && GetTimer() <= 10000)
-                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WIN_WG_TIMER_10, player);
-        }
-    }
-
-    for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
-        if (Player* player = ObjectAccessor::FindPlayer(*itr))
-            player->CastSpell(player, SPELL_DEFEAT_REWARD, true);
-
-    for (uint8 team = 0; team < 2; ++team)
-    {
-        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
-            if (Player* player = ObjectAccessor::FindPlayer(*itr))
-                RemoveAurasFromPlayer(player);
-
-        m_PlayersInWar[team].clear();
-
-        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-            if (Creature* creature = GetCreature(*itr))
-                if (creature->IsVehicle())
-                    creature->DespawnOrUnsummon();
-
-        m_vehicles[team].clear();
-    }
-
-    if (!endByTimer)
-    {
-        for (uint8 team = 0; team < 2; ++team)
-        {
-            for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-            {
-                if (Player* player = ObjectAccessor::FindPlayer(*itr))
-                {
-                    player->RemoveAurasDueToSpell(m_DefenderTeam == TEAM_ALLIANCE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player->GetGUID());
-                    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
-                }
-            }
-        }
-    }
-
-    if (!endByTimer) // win alli/horde
-        SendWarning(GetDefenderTeam() == TEAM_ALLIANCE ? BATTLEFIELD_WG_TEXT_FORTRESS_CAPTURE_ALLIANCE : BATTLEFIELD_WG_TEXT_FORTRESS_CAPTURE_HORDE);
-    else // defend alli/horde
-        SendWarning(GetDefenderTeam() == TEAM_ALLIANCE ? BATTLEFIELD_WG_TEXT_FORTRESS_DEFEND_ALLIANCE : BATTLEFIELD_WG_TEXT_FORTRESS_DEFEND_HORDE);
-}
-
-// *******************************************************
-// ******************* Reward System *********************
-// *******************************************************
-void BattlefieldWG::DoCompleteOrIncrementAchievement(uint32 achievement, Player* player, uint8 /*incrementNumber*/)
-{
-    AchievementEntry const* achievementEntry = sAchievementMgr->GetAchievement(achievement);
-
-    if (!achievementEntry)
-        return;
-
-    switch (achievement)
-    {
-        case ACHIEVEMENTS_WIN_WG_100:
-        {
-            // player->UpdateAchievementCriteria();
-        }
-        default:
-        {
-            if (player)
-                player->CompletedAchievement(achievementEntry);
-            break;
-        }
-    }
-
-}
-
-void BattlefieldWG::OnStartGrouping()
-{
-    SendWarning(BATTLEFIELD_WG_TEXT_START_GROUPING);
-}
-
-uint8 BattlefieldWG::GetSpiritGraveyardId(uint32 areaId) const
-{
-    switch (areaId)
-    {
-        case AREA_WINTERGRASP_FORTRESS:
-            return BATTLEFIELD_WG_GY_KEEP;
-        case AREA_THE_SUNKEN_RING:
-            return BATTLEFIELD_WG_GY_WORKSHOP_NE;
-        case AREA_THE_BROKEN_TEMPLATE:
-            return BATTLEFIELD_WG_GY_WORKSHOP_NW;
-        case AREA_WESTPARK_WORKSHOP:
-            return BATTLEFIELD_WG_GY_WORKSHOP_SW;
-        case AREA_EASTPARK_WORKSHOP:
-            return BATTLEFIELD_WG_GY_WORKSHOP_SE;
-        case AREA_WINTERGRASP:
-            return BATTLEFIELD_WG_GY_ALLIANCE;
-        case AREA_THE_CHILLED_QUAGMIRE:
-            return BATTLEFIELD_WG_GY_HORDE;
-        default:
-            TC_LOG_ERROR("bg.battlefield", "BattlefieldWG::GetSpiritGraveyardId: Unexpected Area Id %u", areaId);
-            break;
-    }
-
-    return 0;
-}
-
-void BattlefieldWG::OnCreatureCreate(Creature* creature)
-{
-    // Accessing to db spawned creatures
-    switch (creature->GetEntry())
-    {
-        case NPC_DWARVEN_SPIRIT_GUIDE:
-        case NPC_TAUNKA_SPIRIT_GUIDE:
-        {
-            TeamId teamId = (creature->GetEntry() == NPC_DWARVEN_SPIRIT_GUIDE ? TEAM_ALLIANCE : TEAM_HORDE);
-            uint8 graveyardId = GetSpiritGraveyardId(creature->GetAreaId());
-            if (m_GraveyardList[graveyardId])
-                m_GraveyardList[graveyardId]->SetSpirit(creature, teamId);
-            break;
-        }
-    }
-
-    // untested code - not sure if it is valid.
-    if (IsWarTime())
-    {
-        switch (creature->GetEntry())
-        {
-            case NPC_WINTERGRASP_SIEGE_ENGINE_ALLIANCE:
-            case NPC_WINTERGRASP_SIEGE_ENGINE_HORDE:
-            case NPC_WINTERGRASP_CATAPULT:
-            case NPC_WINTERGRASP_DEMOLISHER:
-            {
-                if (!creature->ToTempSummon() || !creature->ToTempSummon()->GetSummonerGUID() || !ObjectAccessor::FindPlayer(creature->ToTempSummon()->GetSummonerGUID()))
-                {
-                    creature->DespawnOrUnsummon();
-                    return;
-                }
-
-                Player* creator = ObjectAccessor::FindPlayer(creature->ToTempSummon()->GetSummonerGUID());
-                TeamId team = creator->GetTeamId();
-
-                if (team == TEAM_HORDE)
-                {
-                    if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_H) < GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H))
-                    {
-                        UpdateData(BATTLEFIELD_WG_DATA_VEHICLE_H, 1);
-                        creature->AddAura(SPELL_HORDE_FLAG, creature);
-                        m_vehicles[team].insert(creature->GetGUID());
-                        UpdateVehicleCountWG();
-                    }
-                    else
-                    {
-                        creature->DespawnOrUnsummon();
-                        return;
-                    }
-                }
-                else
-                {
-                    if (GetData(BATTLEFIELD_WG_DATA_VEHICLE_A) < GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A))
-                    {
-                        UpdateData(BATTLEFIELD_WG_DATA_VEHICLE_A, 1);
-                        creature->AddAura(SPELL_ALLIANCE_FLAG, creature);
-                        m_vehicles[team].insert(creature->GetGUID());
-                        UpdateVehicleCountWG();
-                    }
-                    else
-                    {
-                        creature->DespawnOrUnsummon();
-                        return;
-                    }
-                }
-
-                creature->CastSpell(creator, SPELL_GRAB_PASSENGER, true);
-                break;
-            }
-        }
-    }
-}
-
-void BattlefieldWG::OnCreatureRemove(Creature* /*creature*/)
-{
-/* possibly can be used later
-    if (IsWarTime())
-    {
-        switch (creature->GetEntry())
-        {
-            case NPC_WINTERGRASP_SIEGE_ENGINE_ALLIANCE:
-            case NPC_WINTERGRASP_SIEGE_ENGINE_HORDE:
-            case NPC_WINTERGRASP_CATAPULT:
-            case NPC_WINTERGRASP_DEMOLISHER:
-            {
-                uint8 team;
-                if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
-                    team = TEAM_ALLIANCE;
-                else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
-                    team = TEAM_HORDE;
-                else
-                    return;
-
-                m_vehicles[team].erase(creature->GetGUID());
-                if (team == TEAM_HORDE)
-                    UpdateData(BATTLEFIELD_WG_DATA_VEHICLE_H, -1);
-                else
-                    UpdateData(BATTLEFIELD_WG_DATA_VEHICLE_A, -1);
-                UpdateVehicleCountWG();
-
-                break;
-            }
-        }
-    }*/
-}
-
-void BattlefieldWG::OnGameObjectCreate(GameObject* go)
-{
-    uint8 workshopId = 0;
-
-    switch (go->GetEntry())
-    {
-        case GO_WINTERGRASP_FACTORY_BANNER_NE:
-            workshopId = BATTLEFIELD_WG_WORKSHOP_NE;
-            break;
-        case GO_WINTERGRASP_FACTORY_BANNER_NW:
-            workshopId = BATTLEFIELD_WG_WORKSHOP_NW;
-            break;
-        case GO_WINTERGRASP_FACTORY_BANNER_SE:
-            workshopId = BATTLEFIELD_WG_WORKSHOP_SE;
-            break;
-        case GO_WINTERGRASP_FACTORY_BANNER_SW:
-            workshopId = BATTLEFIELD_WG_WORKSHOP_SW;
-            break;
-        default:
-            return;
-    }
-
-    for (WintergraspWorkshop* workshop : Workshops)
-    {
-        if (workshop->GetId() == workshopId)
-        {
-            WintergraspCapturePoint* capturePoint = new WintergraspCapturePoint(this, GetAttackerTeam());
-
-            capturePoint->SetCapturePointData(go);
-            capturePoint->LinkToWorkshop(workshop);
-            AddCapturePoint(capturePoint);
-            break;
-        }
-    }
-}
-
-// Called when player kill a unit in wg zone
-void BattlefieldWG::HandleKill(Player* killer, Unit* victim)
-{
-    if (killer == victim)
-        return;
-
-    bool again = false;
-    TeamId killerTeam = killer->GetTeamId();
-
-    if (victim->GetTypeId() == TYPEID_PLAYER)
-    {
-        for (GuidSet::const_iterator itr = m_PlayersInWar[killerTeam].begin(); itr != m_PlayersInWar[killerTeam].end(); ++itr)
-            if (Player* player = ObjectAccessor::FindPlayer(*itr))
-                if (player->GetDistance2d(killer) < 40)
-                    PromotePlayer(player);
-        return;
-    }
-
-    for (GuidSet::const_iterator itr = KeepCreature[GetOtherTeam(killerTeam)].begin();
-         itr != KeepCreature[GetOtherTeam(killerTeam)].end(); ++itr)
-    {
-        if (Creature* creature = GetCreature(*itr))
-        {
-            if (victim->GetEntry() == creature->GetEntry() && !again)
-            {
-                again = true;
-                for (GuidSet::const_iterator iter = m_PlayersInWar[killerTeam].begin(); iter != m_PlayersInWar[killerTeam].end(); ++iter)
-                    if (Player* player = ObjectAccessor::FindPlayer(*iter))
-                        if (player->GetDistance2d(killer) < 40.0f)
-                            PromotePlayer(player);
-            }
-        }
-    }
-    /// @todoRecent PvP activity worldstate
-}
-
-bool BattlefieldWG::FindAndRemoveVehicleFromList(Unit* vehicle)
-{
-    for (uint32 itr = 0; itr < 2; ++itr)
-    {
-        if (m_vehicles[itr].find(vehicle->GetGUID()) != m_vehicles[itr].end())
-        {
-            m_vehicles[itr].erase(vehicle->GetGUID());
-            if (itr == TEAM_HORDE)
-                UpdateData(BATTLEFIELD_WG_DATA_VEHICLE_H, -1);
-            else
-                UpdateData(BATTLEFIELD_WG_DATA_VEHICLE_A, -1);
-            return true;
-        }
-    }
-    return false;
-}
-
-void BattlefieldWG::OnUnitDeath(Unit* unit)
-{
-    if (IsWarTime())
-        if (unit->IsVehicle())
-            if (FindAndRemoveVehicleFromList(unit))
-                UpdateVehicleCountWG();
-}
-
-// Update rank for player
-void BattlefieldWG::PromotePlayer(Player* killer)
-{
-    if (!m_isActive)
-        return;
-    // Updating rank of player
-    if (Aura* auraRecruit = killer->GetAura(SPELL_RECRUIT))
-    {
-        if (auraRecruit->GetStackAmount() >= 5)
-        {
-            killer->RemoveAura(SPELL_RECRUIT);
-            killer->CastSpell(killer, SPELL_CORPORAL, true);
-            if (Creature* stalker = GetCreature(StalkerGuid))
-                sCreatureTextMgr->SendChat(stalker, BATTLEFIELD_WG_TEXT_RANK_CORPORAL, killer, CHAT_MSG_ADDON, LANG_ADDON, TEXT_RANGE_NORMAL, 0, TEAM_OTHER, false, killer);
-        }
-        else
-            killer->CastSpell(killer, SPELL_RECRUIT, true);
-    }
-    else if (Aura* auraCorporal = killer->GetAura(SPELL_CORPORAL))
-    {
-        if (auraCorporal->GetStackAmount() >= 5)
-        {
-            killer->RemoveAura(SPELL_CORPORAL);
-            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
-            if (Creature* stalker = GetCreature(StalkerGuid))
-                sCreatureTextMgr->SendChat(stalker, BATTLEFIELD_WG_TEXT_RANK_FIRST_LIEUTENANT, killer, CHAT_MSG_ADDON, LANG_ADDON, TEXT_RANGE_NORMAL, 0, TEAM_OTHER, false, killer);
-        }
-        else
-            killer->CastSpell(killer, SPELL_CORPORAL, true);
-    }
-}
-
-void BattlefieldWG::RemoveAurasFromPlayer(Player* player)
-{
-    player->RemoveAurasDueToSpell(SPELL_RECRUIT);
-    player->RemoveAurasDueToSpell(SPELL_CORPORAL);
-    player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-    player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-    player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-    player->RemoveAurasDueToSpell(SPELL_TENACITY);
-    player->RemoveAurasDueToSpell(SPELL_ESSENCE_OF_WINTERGRASP);
-    player->RemoveAurasDueToSpell(SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA);
-}
-
-void BattlefieldWG::OnPlayerJoinWar(Player* player)
-{
-    RemoveAurasFromPlayer(player);
-
-    player->CastSpell(player, SPELL_RECRUIT, true);
-
-    if (player->GetZoneId() != m_ZoneId)
-    {
-        if (player->GetTeamId() == GetDefenderTeam())
-            player->TeleportTo(571, 5345, 2842, 410, 3.14f);
-        else
-        {
-            if (player->GetTeamId() == TEAM_HORDE)
-                player->TeleportTo(571, 5025.857422f, 3674.628906f, 362.737122f, 4.135169f);
-            else
-                player->TeleportTo(571, 5101.284f, 2186.564f, 373.549f, 3.812f);
-        }
-    }
-
-    UpdateTenacity();
-
-    if (player->GetTeamId() == GetAttackerTeam())
-    {
-        if (GetData(BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT) < 3)
-            player->SetAuraStack(SPELL_TOWER_CONTROL, player, 3 - GetData(BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT));
-    }
-    else
-    {
-        if (GetData(BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT) > 0)
-           player->SetAuraStack(SPELL_TOWER_CONTROL, player, GetData(BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT));
-    }
-    SendInitWorldStatesTo(player);
-}
-
-void BattlefieldWG::OnPlayerLeaveWar(Player* player)
-{
-    // Remove all aura from WG /// @todo false we can go out of this zone on retail and keep Rank buff, remove on end of WG
-    if (!player->GetSession()->PlayerLogout())
-    {
-        if (Creature* vehicle = player->GetVehicleCreatureBase())   // Remove vehicle of player if he go out.
-            vehicle->DespawnOrUnsummon();
-
-        RemoveAurasFromPlayer(player);
-    }
-
-    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
-    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
-    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
-    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
-}
-
-void BattlefieldWG::OnPlayerLeaveZone(Player* player)
-{
-    if (!m_isActive)
-        RemoveAurasFromPlayer(player);
-
-    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT);
-    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT);
-    player->RemoveAurasDueToSpell(SPELL_HORDE_CONTROL_PHASE_SHIFT);
-    player->RemoveAurasDueToSpell(SPELL_ALLIANCE_CONTROL_PHASE_SHIFT);
-}
-
-void BattlefieldWG::OnPlayerEnterZone(Player* player)
-{
-    if (!m_isActive)
-        RemoveAurasFromPlayer(player);
-
-    player->AddAura(m_DefenderTeam == TEAM_HORDE ? SPELL_HORDE_CONTROL_PHASE_SHIFT : SPELL_ALLIANCE_CONTROL_PHASE_SHIFT, player);
-    // Send worldstate to player
-    SendInitWorldStatesTo(player);
-}
-
-uint32 BattlefieldWG::GetData(uint32 data) const
-{
-    switch (data)
-    {
-        // Used to determine when the phasing spells must be cast
-        // See: SpellArea::IsFitToRequirements
-        case AREA_THE_SUNKEN_RING:
-        case AREA_THE_BROKEN_TEMPLATE:
-        case AREA_WESTPARK_WORKSHOP:
-        case AREA_EASTPARK_WORKSHOP:
-            // Graveyards and Workshops are controlled by the same team.
-            if (BfGraveyard const* graveyard = GetGraveyardById(GetSpiritGraveyardId(data)))
-                return graveyard->GetControlTeamId();
-            break;
-        default:
-            break;
-    }
-
-    return Battlefield::GetData(data);
-}
-
-
-void BattlefieldWG::FillInitialWorldStates(WorldPacket& data)
-{
-    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ATTACKER) << uint32(GetAttackerTeam());
-    data << uint32(BATTLEFIELD_WG_WORLD_STATE_DEFENDER) << uint32(GetDefenderTeam());
-    data << uint32(BATTLEFIELD_WG_WORLD_STATE_ACTIVE) << uint32(IsWarTime() ? 0 : 1); // Note: cleanup these two, their names look awkward
-    data << uint32(BATTLEFIELD_WG_WORLD_STATE_SHOW_WORLDSTATE) << uint32(IsWarTime() ? 1 : 0);
-
-    for (uint32 i = 0; i < 2; ++i)
-        data << ClockWorldState[i] << uint32(time(NULL) + (m_Timer / 1000));
-
-    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
-    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H);
-    data << uint32(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A) << uint32(GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
-    data << uint32(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A) << GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A);
-
-    for (BfWGGameObjectBuilding* building : BuildingsInZone)
-        building->FillInitialWorldStates(data);
-
-    for (WintergraspWorkshop* workshop : Workshops)
-        workshop->FillInitialWorldStates(data);
-}
-
-void BattlefieldWG::SendInitWorldStatesTo(Player* player)
-{
-    WorldPacket data(SMSG_INIT_WORLD_STATES, 4 + 4 + 4 + 2 + (BuildingsInZone.size() * 8) + (Workshops.size() * 8));
-
-    data << uint32(m_MapId);
-    data << uint32(m_ZoneId);
-    data << uint32(0);                                              // AreaId
-    data << uint16(10 + BuildingsInZone.size() + Workshops.size()); // Number of fields
-
-    FillInitialWorldStates(data);
-
-    player->SendDirectMessage(&data);
-}
-
-void BattlefieldWG::SendInitWorldStatesToAll()
-{
-    for (uint8 team = 0; team < 2; team++)
-        for (GuidSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-            if (Player* player = ObjectAccessor::FindPlayer(*itr))
-                SendInitWorldStatesTo(player);
-}
-
-void BattlefieldWG::BrokenWallOrTower(TeamId /*team*/)
-{
-// might be some use for this in the future. old code commented out below. KL
-/*    if (team == GetDefenderTeam())
-    {
-        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
-        {
-            if (Player* player = ObjectAccessor::FindPlayer(*itr))
-                IncrementQuest(player, WGQuest[player->GetTeamId()][2], true);
-        }
-    }*/
-}
-
-// Called when a tower is broke
-void BattlefieldWG::UpdatedDestroyedTowerCount(TeamId team)
-{
-    // Destroy an attack tower
-    if (team == GetAttackerTeam())
-    {
-        // Update counter
-        UpdateData(BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT, -1);
-        UpdateData(BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT, 1);
-
-        // Remove buff stack on attackers
-        for (GuidSet::const_iterator itr = m_PlayersInWar[GetAttackerTeam()].begin(); itr != m_PlayersInWar[GetAttackerTeam()].end(); ++itr)
-            if (Player* player = ObjectAccessor::FindPlayer(*itr))
-                player->RemoveAuraFromStack(SPELL_TOWER_CONTROL);
-
-        // Add buff stack to defenders
-        for (GuidSet::const_iterator itr = m_PlayersInWar[GetDefenderTeam()].begin(); itr != m_PlayersInWar[GetDefenderTeam()].end(); ++itr)
-            if (Player* player = ObjectAccessor::FindPlayer(*itr))
-            {
-                player->CastSpell(player, SPELL_TOWER_CONTROL, true);
-                DoCompleteOrIncrementAchievement(ACHIEVEMENTS_WG_TOWER_DESTROY, player);
-            }
-
-        // If all three south towers are destroyed (ie. all attack towers), remove ten minutes from battle time
-        if (GetData(BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT) == 3)
-        {
-            if (int32(m_Timer - 600000) < 0)
-                m_Timer = 0;
-            else
-                m_Timer -= 600000;
-            SendInitWorldStatesToAll();
-        }
-    }
-    else
-    {
-        UpdateData(BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF, -1);
-        UpdateData(BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF, 1);
-    }
-}
-
-void BattlefieldWG::ProcessEvent(WorldObject* obj, uint32 eventId)
-{
-    if (!obj || !IsWarTime())
-        return;
-
-    // We handle only gameobjects here
-    GameObject* go = obj->ToGameObject();
-    if (!go)
-        return;
-
-    // On click on titan relic
-    if (go->GetEntry() == GO_WINTERGRASP_TITAN_S_RELIC)
-    {
-        if (CanInteractWithRelic())
-            EndBattle(false);
-        else if (GameObject* relic = GetRelic())
-            relic->SetRespawnTime(RESPAWN_IMMEDIATELY);
-    }
-
-    // if destroy or damage event, search the wall/tower and update worldstate/send warning message
-    for (BfWGGameObjectBuilding* building : BuildingsInZone)
-    {
-        if (go->GetGUID() == building->GetGUID())
-        {
-            if (GameObject* buildingGo = GetGameObject(building->GetGUID()))
-            {
-                if (buildingGo->GetGOInfo()->building.damagedEvent == eventId)
-                    building->Damaged();
-                else if (buildingGo->GetGOInfo()->building.destroyedEvent == eventId)
-                    building->Destroyed();
-                break;
-            }
-        }
-    }
-}
-
-// Called when a tower is damaged, used for honor reward calcul
-void BattlefieldWG::UpdateDamagedTowerCount(TeamId team)
-{
-    if (team == GetAttackerTeam())
-        UpdateData(BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT, 1);
-    else
-        UpdateData(BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF, 1);
-}
-
-// Update vehicle count WorldState to player
-void BattlefieldWG::UpdateVehicleCountWG()
-{
-    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H,     GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
-    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H));
-    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A,     GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
-    SendUpdateWorldState(BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A, GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A));
-}
-
-void BattlefieldWG::UpdateTenacity()
-{
-    TeamId team = TEAM_NEUTRAL;
-    uint32 alliancePlayers = m_PlayersInWar[TEAM_ALLIANCE].size();
-    uint32 hordePlayers = m_PlayersInWar[TEAM_HORDE].size();
-    int32 newStack = 0;
-
-    if (alliancePlayers && hordePlayers)
-    {
-        if (alliancePlayers < hordePlayers)
-            newStack = int32((float(hordePlayers / alliancePlayers) - 1) * 4);  // positive, should cast on alliance
-        else if (alliancePlayers > hordePlayers)
-            newStack = int32((1 - float(alliancePlayers / hordePlayers)) * 4);  // negative, should cast on horde
-    }
-
-    if (newStack == int32(m_tenacityStack))
-        return;
-
-    if (m_tenacityStack > 0 && newStack <= 0)               // old buff was on alliance
-        team = TEAM_ALLIANCE;
-    else if (newStack >= 0)                                 // old buff was on horde
-        team = TEAM_HORDE;
-
-    m_tenacityStack = newStack;
-    // Remove old buff
-    if (team != TEAM_NEUTRAL)
-    {
-        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-            if (Player* player = ObjectAccessor::FindPlayer(*itr))
-                if (player->getLevel() >= m_MinLevel)
-                    player->RemoveAurasDueToSpell(SPELL_TENACITY);
-
-        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-            if (Creature* creature = GetCreature(*itr))
-                creature->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
-    }
-
-    // Apply new buff
-    if (newStack)
-    {
-        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
-
-        if (newStack < 0)
-            newStack = -newStack;
-        if (newStack > 20)
-            newStack = 20;
-
-        uint32 buff_honor = SPELL_GREATEST_HONOR;
-        if (newStack < 15)
-            buff_honor = SPELL_GREATER_HONOR;
-        if (newStack < 10)
-            buff_honor = SPELL_GREAT_HONOR;
-        if (newStack < 5)
-            buff_honor = 0;
-
-        for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
-            if (Player* player = ObjectAccessor::FindPlayer(*itr))
-                player->SetAuraStack(SPELL_TENACITY, player, newStack);
-
-        for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-            if (Creature* creature = GetCreature(*itr))
-                creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, newStack);
-
-        if (buff_honor != 0)
-        {
-            for (GuidSet::const_iterator itr = m_PlayersInWar[team].begin(); itr != m_PlayersInWar[team].end(); ++itr)
-                if (Player* player = ObjectAccessor::FindPlayer(*itr))
-                    player->CastSpell(player, buff_honor, true);
-            for (GuidSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-                if (Creature* creature = GetCreature(*itr))
-                    creature->CastSpell(creature, buff_honor, true);
-        }
-    }
-}
-
-WintergraspCapturePoint::WintergraspCapturePoint(BattlefieldWG* battlefield, TeamId teamInControl) : BfCapturePoint(battlefield)
-{
-    m_Bf = battlefield;
-    m_team = teamInControl;
-    m_Workshop = nullptr;
-}
-
-void WintergraspCapturePoint::ChangeTeam(TeamId /*oldTeam*/)
-{
-    ASSERT(m_Workshop);
-    m_Workshop->GiveControlTo(m_team);
-}
-
-BfGraveyardWG::BfGraveyardWG(BattlefieldWG* battlefield) : BfGraveyard(battlefield)
-{
-    m_Bf = battlefield;
-    m_GossipTextId = 0;
-}
-
-BfWGGameObjectBuilding::BfWGGameObjectBuilding(BattlefieldWG* wg, WintergraspGameObjectBuildingType type, uint32 worldState)
-{
-    ASSERT(wg);
-
-    _wg = wg;
-    _teamControl = TEAM_NEUTRAL;
-    _type = type;
-    _worldState = worldState;
-    _state = BATTLEFIELD_WG_OBJECTSTATE_NONE;
-    _staticTowerInfo = nullptr;
-}
-
-void BfWGGameObjectBuilding::Rebuild()
-{
-    switch (_type)
-    {
-        case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
-        case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
-        case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
-        case BATTLEFIELD_WG_OBJECTTYPE_WALL:
-            _teamControl = _wg->GetDefenderTeam();      // Objects that are part of the keep should be the defender's
-            break;
-        case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
-            _teamControl = _wg->GetAttackerTeam();      // The towers in the south should be the attacker's
-            break;
-        default:
-            _teamControl = TEAM_NEUTRAL;
-            break;
-    }
-
-    if (GameObject* build = _wg->GetGameObject(_buildGUID))
-    {
-        // Rebuild gameobject
-        if (build->IsDestructibleBuilding())
-        {
-            build->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
-            if (build->GetEntry() == GO_WINTERGRASP_VAULT_GATE)
-                if (GameObject* go = build->FindNearestGameObject(GO_WINTERGRASP_KEEP_COLLISION_WALL, 50.0f))
-                    go->SetGoState(GO_STATE_READY);
-
-            // Update worldstate
-            _state = WintergraspGameObjectState(BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT - (_teamControl * 3));
-            _wg->SendUpdateWorldState(_worldState, _state);
-        }
-        UpdateCreatureAndGo();
-        build->SetFaction(WintergraspFaction[_teamControl]);
-    }
-}
-
-void BfWGGameObjectBuilding::Damaged()
-{
-    // Update worldstate
-    _state = WintergraspGameObjectState(BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE - (_teamControl * 3));
-    _wg->SendUpdateWorldState(_worldState, _state);
-
-    // Send warning message
-    if (_staticTowerInfo)
-        _wg->SendWarning(_staticTowerInfo->TextIds.Damaged);
-
-    for (ObjectGuid guid : m_CreatureTopList[_wg->GetAttackerTeam()])
-        if (Creature* creature = _wg->GetCreature(guid))
-            _wg->HideNpc(creature);
-
-    for (ObjectGuid guid : m_TurretTopList)
-        if (Creature* creature = _wg->GetCreature(guid))
-            _wg->HideNpc(creature);
-
-    if (_type == BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER)
-        _wg->UpdateDamagedTowerCount(_wg->GetDefenderTeam());
-    else if (_type == BATTLEFIELD_WG_OBJECTTYPE_TOWER)
-        _wg->UpdateDamagedTowerCount(_wg->GetAttackerTeam());
-}
-
-void BfWGGameObjectBuilding::Destroyed()
-{
-    // Update worldstate
-    _state = WintergraspGameObjectState(BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY - (_teamControl * 3));
-    _wg->SendUpdateWorldState(_worldState, _state);
-
-    // Warn players
-    if (_staticTowerInfo)
-        _wg->SendWarning(_staticTowerInfo->TextIds.Destroyed);
-
-    switch (_type)
-    {
-        // Inform the global wintergrasp script of the destruction of this object
-        case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
-        case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
-            _wg->UpdatedDestroyedTowerCount(_teamControl);
-            break;
-        case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
-            if (GameObject* build = _wg->GetGameObject(_buildGUID))
-                if (GameObject* go = build->FindNearestGameObject(GO_WINTERGRASP_KEEP_COLLISION_WALL, 50.0f))
-                    go->SetGoState(GO_STATE_ACTIVE);
-            _wg->SetRelicInteractible(true);
-            if (_wg->GetRelic())
-                _wg->GetRelic()->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
-            else
-                TC_LOG_ERROR("bg.battlefield.wg", "Titan Relic not found.");
-            break;
-        default:
-            break;
-    }
-
-    _wg->BrokenWallOrTower(_teamControl);
-}
-
-void BfWGGameObjectBuilding::Init(GameObject* go)
-{
-    if (!go)
-        return;
-
-    // GameObject associated to object
-    _buildGUID = go->GetGUID();
-
-    switch (_type)
-    {
-        case BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER:
-        case BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST:
-        case BATTLEFIELD_WG_OBJECTTYPE_DOOR:
-        case BATTLEFIELD_WG_OBJECTTYPE_WALL:
-            _teamControl = _wg->GetDefenderTeam();           // Objects that are part of the keep should be the defender's
-            break;
-        case BATTLEFIELD_WG_OBJECTTYPE_TOWER:
-            _teamControl = _wg->GetAttackerTeam();           // The towers in the south should be the attacker's
-            break;
-        default:
-            _teamControl = TEAM_NEUTRAL;
-            break;
-    }
-
-    _state = WintergraspGameObjectState(sWorld->getWorldState(_worldState));
-    switch (_state)
-    {
-        case BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_INTACT:
-        case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT:
-        case BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT:
-            go->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
-            break;
-        case BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DESTROY:
-        case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY:
-        case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY:
-            go->SetDestructibleState(GO_DESTRUCTIBLE_DESTROYED);
-            break;
-        case BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DAMAGE:
-        case BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE:
-        case BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE:
-            go->SetDestructibleState(GO_DESTRUCTIBLE_DAMAGED);
-            break;
-        default:
-            break;
-    }
-
-    int32 towerId = -1;
-    switch (go->GetEntry())
-    {
-        case GO_WINTERGRASP_FORTRESS_TOWER_1:
-            towerId = BATTLEFIELD_WG_TOWER_FORTRESS_NW;
-            break;
-        case GO_WINTERGRASP_FORTRESS_TOWER_2:
-            towerId = BATTLEFIELD_WG_TOWER_FORTRESS_SW;
-            break;
-        case GO_WINTERGRASP_FORTRESS_TOWER_3:
-            towerId = BATTLEFIELD_WG_TOWER_FORTRESS_SE;
-            break;
-        case GO_WINTERGRASP_FORTRESS_TOWER_4:
-            towerId = BATTLEFIELD_WG_TOWER_FORTRESS_NE;
-            break;
-        case GO_WINTERGRASP_SHADOWSIGHT_TOWER:
-            towerId = BATTLEFIELD_WG_TOWER_SHADOWSIGHT;
-            break;
-        case GO_WINTERGRASP_WINTER_S_EDGE_TOWER:
-            towerId = BATTLEFIELD_WG_TOWER_WINTER_S_EDGE;
-            break;
-        case GO_WINTERGRASP_FLAMEWATCH_TOWER:
-            towerId = BATTLEFIELD_WG_TOWER_FLAMEWATCH;
-            break;
-    }
-
-    if (towerId > 3) // Attacker towers
-    {
-        // Spawn associate gameobjects
-        for (uint8 i = 0; i < AttackTowers[towerId - 4].nbObject; i++)
-        {
-            WintergraspObjectPositionData const& gobData = AttackTowers[towerId - 4].GameObject[i];
-            if (GameObject* goHorde = _wg->SpawnGameObject(gobData.entryHorde, gobData.x, gobData.y, gobData.z, gobData.o))
-                m_GameObjectList[TEAM_HORDE].insert(goHorde->GetGUID());
-            if (GameObject* goAlliance = _wg->SpawnGameObject(gobData.entryAlliance, gobData.x, gobData.y, gobData.z, gobData.o))
-                m_GameObjectList[TEAM_ALLIANCE].insert(goAlliance->GetGUID());
-        }
-
-        // Spawn associate npc bottom
-        for (uint8 i = 0; i < AttackTowers[towerId - 4].nbCreatureBottom; i++)
-        {
-            WintergraspObjectPositionData const& creatureData = AttackTowers[towerId - 4].CreatureBottom[i];
-            if (Creature* creature = _wg->SpawnCreature(creatureData.entryHorde, creatureData.x, creatureData.y, creatureData.z, creatureData.o, TEAM_HORDE))
-                m_CreatureBottomList[TEAM_HORDE].insert(creature->GetGUID());
-            if (Creature* creature = _wg->SpawnCreature(creatureData.entryAlliance, creatureData.x, creatureData.y, creatureData.z, creatureData.o, TEAM_ALLIANCE))
-                m_CreatureBottomList[TEAM_ALLIANCE].insert(creature->GetGUID());
-        }
-
-        // Spawn associate npc top
-        for (uint8 i = 0; i < AttackTowers[towerId - 4].nbCreatureTop; i++)
-        {
-            WintergraspObjectPositionData const& creatureData = AttackTowers[towerId - 4].CreatureTop[i];
-            if (Creature* creature = _wg->SpawnCreature(creatureData.entryHorde, creatureData.x, creatureData.y, creatureData.z, creatureData.o, TEAM_HORDE))
-                m_CreatureTopList[TEAM_HORDE].insert(creature->GetGUID());
-            if (Creature* creature = _wg->SpawnCreature(creatureData.entryAlliance, creatureData.x, creatureData.y, creatureData.z, creatureData.o, TEAM_ALLIANCE))
-                m_CreatureTopList[TEAM_ALLIANCE].insert(creature->GetGUID());
-        }
-    }
-
-    if (towerId >= 0)
-    {
-        ASSERT(towerId < WG_MAX_TOWER);
-        _staticTowerInfo = &TowerData[towerId];
-
-        // Spawn Turret bottom
-        for (uint8 i = 0; i < TowerCannon[towerId].nbTowerCannonBottom; i++)
-        {
-            Position const& turretPos = TowerCannon[towerId].TowerCannonBottom[i];
-            if (Creature* turret = _wg->SpawnCreature(NPC_WINTERGRASP_TOWER_CANNON, turretPos, TEAM_ALLIANCE))
-            {
-                m_TowerCannonBottomList.insert(turret->GetGUID());
-                switch (go->GetEntry())
-                {
-                    case GO_WINTERGRASP_FORTRESS_TOWER_1:
-                    case GO_WINTERGRASP_FORTRESS_TOWER_2:
-                    case GO_WINTERGRASP_FORTRESS_TOWER_3:
-                    case GO_WINTERGRASP_FORTRESS_TOWER_4:
-                        turret->setFaction(WintergraspFaction[_wg->GetDefenderTeam()]);
-                        break;
-                    case GO_WINTERGRASP_SHADOWSIGHT_TOWER:
-                    case GO_WINTERGRASP_WINTER_S_EDGE_TOWER:
-                    case GO_WINTERGRASP_FLAMEWATCH_TOWER:
-                        turret->setFaction(WintergraspFaction[_wg->GetAttackerTeam()]);
-                        break;
-                }
-                _wg->HideNpc(turret);
-            }
-        }
-
-        // Spawn Turret top
-        for (uint8 i = 0; i < TowerCannon[towerId].nbTurretTop; i++)
-        {
-            Position const& towerCannonPos = TowerCannon[towerId].TurretTop[i];
-            if (Creature* turret = _wg->SpawnCreature(NPC_WINTERGRASP_TOWER_CANNON, towerCannonPos, TeamId(0)))
-            {
-                m_TurretTopList.insert(turret->GetGUID());
-                switch (go->GetEntry())
-                {
-                    case GO_WINTERGRASP_FORTRESS_TOWER_1:
-                    case GO_WINTERGRASP_FORTRESS_TOWER_2:
-                    case GO_WINTERGRASP_FORTRESS_TOWER_3:
-                    case GO_WINTERGRASP_FORTRESS_TOWER_4:
-                        turret->setFaction(WintergraspFaction[_wg->GetDefenderTeam()]);
-                        break;
-                    case GO_WINTERGRASP_SHADOWSIGHT_TOWER:
-                    case GO_WINTERGRASP_WINTER_S_EDGE_TOWER:
-                    case GO_WINTERGRASP_FLAMEWATCH_TOWER:
-                        turret->setFaction(WintergraspFaction[_wg->GetAttackerTeam()]);
-                        break;
-                }
-                _wg->HideNpc(turret);
-            }
-        }
-        UpdateCreatureAndGo();
-    }
-}
-
-void BfWGGameObjectBuilding::UpdateCreatureAndGo()
-{
-    for (ObjectGuid guid : m_CreatureTopList[_wg->GetDefenderTeam()])
-        if (Creature* creature = _wg->GetCreature(guid))
-            _wg->HideNpc(creature);
-
-    for (ObjectGuid guid : m_CreatureTopList[_wg->GetAttackerTeam()])
-        if (Creature* creature = _wg->GetCreature(guid))
-            _wg->ShowNpc(creature, true);
-
-    for (ObjectGuid guid : m_CreatureBottomList[_wg->GetDefenderTeam()])
-        if (Creature* creature = _wg->GetCreature(guid))
-            _wg->HideNpc(creature);
-
-    for (ObjectGuid guid : m_CreatureBottomList[_wg->GetAttackerTeam()])
-        if (Creature* creature = _wg->GetCreature(guid))
-            _wg->ShowNpc(creature, true);
-
-    for (ObjectGuid guid : m_GameObjectList[_wg->GetDefenderTeam()])
-        if (GameObject* go = _wg->GetGameObject(guid))
-            go->SetRespawnTime(RESPAWN_ONE_DAY);
-
-    for (ObjectGuid guid : m_GameObjectList[_wg->GetAttackerTeam()])
-        if (GameObject* go = _wg->GetGameObject(guid))
-            go->SetRespawnTime(RESPAWN_IMMEDIATELY);
-}
-
-void BfWGGameObjectBuilding::UpdateTurretAttack(bool disable)
-{
-    for (ObjectGuid guid : m_TowerCannonBottomList)
-    {
-        if (Creature* creature = _wg->GetCreature(guid))
-        {
-            if (disable)
-                _wg->HideNpc(creature);
-            else
-                _wg->ShowNpc(creature, true);
-
-            switch (_buildGUID.GetEntry())
-            {
-                case GO_WINTERGRASP_FORTRESS_TOWER_1:
-                case GO_WINTERGRASP_FORTRESS_TOWER_2:
-                case GO_WINTERGRASP_FORTRESS_TOWER_3:
-                case GO_WINTERGRASP_FORTRESS_TOWER_4:
-                {
-                    creature->setFaction(WintergraspFaction[_wg->GetDefenderTeam()]);
-                    break;
-                }
-                case GO_WINTERGRASP_SHADOWSIGHT_TOWER:
-                case GO_WINTERGRASP_WINTER_S_EDGE_TOWER:
-                case GO_WINTERGRASP_FLAMEWATCH_TOWER:
-                {
-                    creature->setFaction(WintergraspFaction[_wg->GetAttackerTeam()]);
-                    break;
-                }
-            }
-        }
-    }
-
-    for (ObjectGuid guid : m_TurretTopList)
-    {
-        if (Creature* creature = _wg->GetCreature(guid))
-        {
-            if (disable)
-                _wg->HideNpc(creature);
-            else
-                _wg->ShowNpc(creature, true);
-
-            switch (_buildGUID.GetEntry())
-            {
-                case GO_WINTERGRASP_FORTRESS_TOWER_1:
-                case GO_WINTERGRASP_FORTRESS_TOWER_2:
-                case GO_WINTERGRASP_FORTRESS_TOWER_3:
-                case GO_WINTERGRASP_FORTRESS_TOWER_4:
-                {
-                    creature->setFaction(WintergraspFaction[_wg->GetDefenderTeam()]);
-                    break;
-                }
-                case GO_WINTERGRASP_SHADOWSIGHT_TOWER:
-                case GO_WINTERGRASP_WINTER_S_EDGE_TOWER:
-                case GO_WINTERGRASP_FLAMEWATCH_TOWER:
-                {
-                    creature->setFaction(WintergraspFaction[_wg->GetAttackerTeam()]);
-                    break;
-                }
-            }
-        }
-    }
-}
-
-void BfWGGameObjectBuilding::FillInitialWorldStates(WorldPacket& data)
-{
-    data << uint32(_worldState) << uint32(_state);
-}
-
-void BfWGGameObjectBuilding::Save()
-{
-    sWorld->setWorldState(_worldState, _state);
-}
-
-WintergraspWorkshop::WintergraspWorkshop(BattlefieldWG* wg, uint8 type)
-{
-    ASSERT(wg && type < WG_MAX_WORKSHOP);
-
-    _wg = wg;
-    _state = BATTLEFIELD_WG_OBJECTSTATE_NONE;
-    _teamControl = TEAM_NEUTRAL;
-    _staticInfo = &WorkshopData[type];
-}
-
-void WintergraspWorkshop::AddCreature(WintergraspObjectPositionData const& obj)
-{
-    if (Creature* creature = _wg->SpawnCreature(obj.entryHorde, obj.x, obj.y, obj.z, obj.o, TEAM_HORDE))
-        _creatureOnPoint[TEAM_HORDE].insert(creature->GetGUID());
-
-    if (Creature* creature = _wg->SpawnCreature(obj.entryAlliance, obj.x, obj.y, obj.z, obj.o, TEAM_ALLIANCE))
-        _creatureOnPoint[TEAM_ALLIANCE].insert(creature->GetGUID());
-}
-
-void WintergraspWorkshop::AddGameObject(WintergraspObjectPositionData const& obj)
-{
-    if (GameObject* go = _wg->SpawnGameObject(obj.entryHorde, obj.x, obj.y, obj.z, obj.o))
-        _gameObjectOnPoint[TEAM_HORDE].insert(go->GetGUID());
-    if (GameObject* go = _wg->SpawnGameObject(obj.entryAlliance, obj.x, obj.y, obj.z, obj.o))
-        _gameObjectOnPoint[TEAM_ALLIANCE].insert(go->GetGUID());
-}
-
-void WintergraspWorkshop::GiveControlTo(TeamId teamId, bool init /*= false*/)
-{
-    switch (teamId)
-    {
-        case TEAM_NEUTRAL:
-        {
-            // Send warning message to all player for inform a faction attack a workshop
-            // alliance / horde attacking workshop
-            _wg->SendWarning(_teamControl == TEAM_ALLIANCE ? _staticInfo->TextIds.HordeAttack : _staticInfo->TextIds.AllianceAttack);
-            break;
-        }
-        case TEAM_ALLIANCE:
-        {
-            // Show Alliance creature
-            for (ObjectGuid guid : _creatureOnPoint[TEAM_ALLIANCE])
-                if (Creature* creature = _wg->GetCreature(guid))
-                    _wg->ShowNpc(creature, creature->GetEntry() != 30499);
-
-            // Hide Horde creature
-            for (ObjectGuid guid : _creatureOnPoint[TEAM_HORDE])
-                if (Creature* creature = _wg->GetCreature(guid))
-                    _wg->HideNpc(creature);
-
-            // Show Alliance gameobject
-            for (ObjectGuid guid : _gameObjectOnPoint[TEAM_ALLIANCE])
-                if (GameObject* go = _wg->GetGameObject(guid))
-                    go->SetRespawnTime(RESPAWN_IMMEDIATELY);
-
-            // Hide Horde gameobject
-            for (ObjectGuid guid : _gameObjectOnPoint[TEAM_HORDE])
-                if (GameObject* go = _wg->GetGameObject(guid))
-                    go->SetRespawnTime(RESPAWN_ONE_DAY);
-
-
-            // Updating worldstate
-            _state = BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT;
-            _wg->SendUpdateWorldState(_staticInfo->WorldStateId, _state);
-
-            // Warning message
-            if (!init)
-                _wg->SendWarning(_staticInfo->TextIds.AllianceCapture); // workshop taken - alliance
-
-            // Found associate graveyard and update it
-            if (_staticInfo->WorkshopId < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
-                if (BfGraveyard* gy = _wg->GetGraveyardById(_staticInfo->WorkshopId))
-                    gy->GiveControlTo(TEAM_ALLIANCE);
-
-            _teamControl = teamId;
-            break;
-        }
-        case TEAM_HORDE:
-        {
-            // Show Horde creature
-            for (ObjectGuid guid : _creatureOnPoint[TEAM_HORDE])
-                if (Creature* creature = _wg->GetCreature(guid))
-                    _wg->ShowNpc(creature, creature->GetEntry() != 30400);
-
-            // Hide Alliance creature
-            for (ObjectGuid guid : _creatureOnPoint[TEAM_ALLIANCE])
-                if (Creature* creature = _wg->GetCreature(guid))
-                    _wg->HideNpc(creature);
-
-            // Hide Alliance gameobject
-            for (ObjectGuid guid : _gameObjectOnPoint[TEAM_ALLIANCE])
-                if (GameObject* go = _wg->GetGameObject(guid))
-                    go->SetRespawnTime(RESPAWN_ONE_DAY);
-
-            // Show Horde gameobject
-            for (ObjectGuid guid : _gameObjectOnPoint[TEAM_HORDE])
-                if (GameObject* go = _wg->GetGameObject(guid))
-                    go->SetRespawnTime(RESPAWN_IMMEDIATELY);
-
-            // Update worldstate
-            _state = BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT;
-            _wg->SendUpdateWorldState(_staticInfo->WorldStateId, _state);
-
-            // Warning message
-            if (!init)
-                _wg->SendWarning(_staticInfo->TextIds.HordeCapture); // workshop taken - horde
-
-            // Update graveyard control
-            if (_staticInfo->WorkshopId < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
-                if (BfGraveyard* gy = _wg->GetGraveyardById(_staticInfo->WorkshopId))
-                    gy->GiveControlTo(TEAM_HORDE);
-
-            _teamControl = teamId;
-            break;
-        }
-    }
-    if (!init)
-        _wg->UpdateCounterVehicle(false);
-}
-
-void WintergraspWorkshop::UpdateGraveyardAndWorkshop()
-{
-    if (_staticInfo->WorkshopId < BATTLEFIELD_WG_WORKSHOP_KEEP_WEST)
-        _wg->GetGraveyardById(_staticInfo->WorkshopId)->GiveControlTo(_teamControl);
-    else
-        GiveControlTo(_wg->GetDefenderTeam(), true);
-}
-
-void WintergraspWorkshop::FillInitialWorldStates(WorldPacket& data)
-{
-    data << uint32(_staticInfo->WorldStateId) << uint32(_state);
-}
-
-void WintergraspWorkshop::Save()
-{
-    sWorld->setWorldState(_staticInfo->WorldStateId, _state);
-}
diff --git a/src/server/game/Battlefield/Zones/BattlefieldWG.h b/src/server/game/Battlefield/Zones/BattlefieldWG.h
deleted file mode 100644
index e5cc392..0000000
--- a/src/server/game/Battlefield/Zones/BattlefieldWG.h
+++ /dev/null
@@ -1,1187 +0,0 @@
-/*
- * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef BATTLEFIELD_WG_
-#define BATTLEFIELD_WG_
-
-#include "Battlefield.h"
-
-class Group;
-class BattlefieldWG;
-class WintergraspCapturePoint;
-
-struct BfWGGameObjectBuilding;
-struct WintergraspWorkshop;
-
-typedef std::set<GameObject*> GameObjectSet;
-typedef std::set<BfWGGameObjectBuilding*> GameObjectBuildingSet;
-typedef std::set<WintergraspWorkshop*> WorkshopSet;
-typedef std::set<Group*> GroupSet;
-//typedef std::set<WintergraspCapturePoint *> CapturePointSet; unused ?
-
-enum WintergrastData
-{
-    BATTLEFIELD_WG_ZONEID                        = 4197,             // Wintergrasp
-    BATTLEFIELD_WG_MAPID                         = 571               // Northrend
-};
-
-enum WintergraspSpells
-{
-    // Wartime auras
-    SPELL_RECRUIT                               = 37795,
-    SPELL_CORPORAL                              = 33280,
-    SPELL_LIEUTENANT                            = 55629,
-    SPELL_TENACITY                              = 58549,
-    SPELL_TENACITY_VEHICLE                      = 59911,
-    SPELL_TOWER_CONTROL                         = 62064,
-    SPELL_SPIRITUAL_IMMUNITY                    = 58729,
-    SPELL_GREAT_HONOR                           = 58555,
-    SPELL_GREATER_HONOR                         = 58556,
-    SPELL_GREATEST_HONOR                        = 58557,
-    SPELL_ALLIANCE_FLAG                         = 14268,
-    SPELL_HORDE_FLAG                            = 14267,
-    SPELL_GRAB_PASSENGER                        = 61178,
-
-    // Reward spells
-    SPELL_VICTORY_REWARD                        = 56902,
-    SPELL_DEFEAT_REWARD                         = 58494,
-    SPELL_DAMAGED_TOWER                         = 59135,
-    SPELL_DESTROYED_TOWER                       = 59136,
-    SPELL_DAMAGED_BUILDING                      = 59201,
-    SPELL_INTACT_BUILDING                       = 59203,
-
-    SPELL_TELEPORT_BRIDGE                       = 59096,
-    SPELL_TELEPORT_FORTRESS                     = 60035,
-
-    SPELL_TELEPORT_DALARAN                      = 53360,
-    SPELL_VICTORY_AURA                          = 60044,
-
-    // Other spells
-    SPELL_WINTERGRASP_WATER                     = 36444,
-    SPELL_ESSENCE_OF_WINTERGRASP                = 58045,
-    SPELL_WINTERGRASP_RESTRICTED_FLIGHT_AREA    = 58730,
-
-    // Phasing spells
-    SPELL_HORDE_CONTROLS_FACTORY_PHASE_SHIFT    = 56618, // ADDS PHASE 16
-    SPELL_ALLIANCE_CONTROLS_FACTORY_PHASE_SHIFT = 56617, // ADDS PHASE 32
-
-    SPELL_HORDE_CONTROL_PHASE_SHIFT             = 55773, // ADDS PHASE 64
-    SPELL_ALLIANCE_CONTROL_PHASE_SHIFT          = 55774  // ADDS PHASE 128
-};
-
-enum WintergraspData
-{
-    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_DEF,
-    BATTLEFIELD_WG_DATA_BROKEN_TOWER_DEF,
-    BATTLEFIELD_WG_DATA_DAMAGED_TOWER_ATT,
-    BATTLEFIELD_WG_DATA_BROKEN_TOWER_ATT,
-    BATTLEFIELD_WG_DATA_MAX_VEHICLE_A,
-    BATTLEFIELD_WG_DATA_MAX_VEHICLE_H,
-    BATTLEFIELD_WG_DATA_VEHICLE_A,
-    BATTLEFIELD_WG_DATA_VEHICLE_H,
-    BATTLEFIELD_WG_DATA_MAX
-};
-
-enum WintergraspAchievements
-{
-    ACHIEVEMENTS_WIN_WG                          = 1717,
-    ACHIEVEMENTS_WIN_WG_100                      = 1718, /// @todo: Has to be implemented
-    ACHIEVEMENTS_WG_GNOMESLAUGHTER               = 1723, /// @todo: Has to be implemented
-    ACHIEVEMENTS_WG_TOWER_DESTROY                = 1727,
-    ACHIEVEMENTS_DESTRUCTION_DERBY_A             = 1737, /// @todo: Has to be implemented
-    ACHIEVEMENTS_WG_TOWER_CANNON_KILL            = 1751, /// @todo: Has to be implemented
-    ACHIEVEMENTS_WG_MASTER_A                     = 1752, /// @todo: Has to be implemented
-    ACHIEVEMENTS_WIN_WG_TIMER_10                 = 1755,
-    ACHIEVEMENTS_STONE_KEEPER_50                 = 2085, /// @todo: Has to be implemented
-    ACHIEVEMENTS_STONE_KEEPER_100                = 2086, /// @todo: Has to be implemented
-    ACHIEVEMENTS_STONE_KEEPER_250                = 2087, /// @todo: Has to be implemented
-    ACHIEVEMENTS_STONE_KEEPER_500                = 2088, /// @todo: Has to be implemented
-    ACHIEVEMENTS_STONE_KEEPER_1000               = 2089, /// @todo: Has to be implemented
-    ACHIEVEMENTS_WG_RANGER                       = 2199, /// @todo: Has to be implemented
-    ACHIEVEMENTS_DESTRUCTION_DERBY_H             = 2476, /// @todo: Has to be implemented
-    ACHIEVEMENTS_WG_MASTER_H                     = 2776  /// @todo: Has to be implemented
-};
-
-enum WintergraspWorldStates
-{
-    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_H         = 3490,
-    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_H     = 3491,
-    BATTLEFIELD_WG_WORLD_STATE_VEHICLE_A         = 3680,
-    BATTLEFIELD_WG_WORLD_STATE_MAX_VEHICLE_A     = 3681,
-    BATTLEFIELD_WG_WORLD_STATE_ACTIVE            = 3801,
-    BATTLEFIELD_WG_WORLD_STATE_DEFENDER          = 3802,
-    BATTLEFIELD_WG_WORLD_STATE_ATTACKER          = 3803,
-    BATTLEFIELD_WG_WORLD_STATE_SHOW_WORLDSTATE   = 3710
-};
-
-enum WintergraspAreaIds
-{
-    AREA_WINTERGRASP_FORTRESS       = 4575,
-    AREA_THE_SUNKEN_RING            = 4538,
-    AREA_THE_BROKEN_TEMPLATE        = 4539,
-    AREA_WESTPARK_WORKSHOP          = 4611,
-    AREA_EASTPARK_WORKSHOP          = 4612,
-    AREA_WINTERGRASP                = 4197,
-    AREA_THE_CHILLED_QUAGMIRE       = 4589
-};
-
-/*#########################
- *####### Graveyards ######
- *#########################*/
-
-class BfGraveyardWG : public BfGraveyard
-{
-    public:
-        BfGraveyardWG(BattlefieldWG* Bf);
-
-        void SetTextId(uint32 textId) { m_GossipTextId = textId; }
-        uint32 GetTextId() const { return m_GossipTextId; }
-
-    protected:
-        uint32 m_GossipTextId;
-};
-
-enum WGGraveyardId
-{
-    BATTLEFIELD_WG_GY_WORKSHOP_NE,
-    BATTLEFIELD_WG_GY_WORKSHOP_NW,
-    BATTLEFIELD_WG_GY_WORKSHOP_SE,
-    BATTLEFIELD_WG_GY_WORKSHOP_SW,
-    BATTLEFIELD_WG_GY_KEEP,
-    BATTLEFIELD_WG_GY_HORDE,
-    BATTLEFIELD_WG_GY_ALLIANCE,
-    BATTLEFIELD_WG_GRAVEYARD_MAX
-};
-
-enum WGGossipText
-{
-    BATTLEFIELD_WG_GOSSIPTEXT_GY_NE              = 20071,
-    BATTLEFIELD_WG_GOSSIPTEXT_GY_NW              = 20072,
-    BATTLEFIELD_WG_GOSSIPTEXT_GY_SE              = 20074,
-    BATTLEFIELD_WG_GOSSIPTEXT_GY_SW              = 20073,
-    BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP            = 20070,
-    BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE           = 20075,
-    BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE        = 20076
-};
-
-enum WintergraspNpcs
-{
-    BATTLEFIELD_WG_NPC_GUARD_H                      = 30739,
-    BATTLEFIELD_WG_NPC_GUARD_A                      = 30740,
-    BATTLEFIELD_WG_NPC_STALKER                      = 15214,
-
-    BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER          = 31102,
-    BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR            = 32296, // <WINTERGRASP QUARTERMASTER>
-    BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN         = 31101, // <MASTER HEXXER>
-    BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI            = 39173, // <WINTERGRASP QUARTERMASTER>
-    BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH            = 31091,
-    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH     = 31151,
-    BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF        = 31106,
-    BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT            = 31053,
-    BATTLEFIELD_WG_NPC_LIEUTENANT_MURP              = 31107,
-
-    BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH              = 31052,
-    BATTLEFIELD_WG_NPC_KNIGHT_DAMERON               = 32294, // <WINTERGRASP QUARTERMASTER>
-    BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA            = 31051, // <ENCHANTRESS>
-    BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER             = 39172, // <WINTERGRASP QUARTERMASTER>
-    BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH            = 31036,
-    BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS    = 31153,
-    BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE     = 31108,
-    BATTLEFIELD_WG_NPC_ANCHORITE_TESSA              = 31054,
-    BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO  = 31109,
-
-    NPC_TAUNKA_SPIRIT_GUIDE                         = 31841, // Horde spirit guide for Wintergrasp
-    NPC_DWARVEN_SPIRIT_GUIDE                        = 31842, // Alliance spirit guide for Wintergrasp
-
-    NPC_WINTERGRASP_SIEGE_ENGINE_ALLIANCE           = 28312,
-    NPC_WINTERGRASP_SIEGE_ENGINE_HORDE              = 32627,
-    NPC_WINTERGRASP_CATAPULT                        = 27881,
-    NPC_WINTERGRASP_DEMOLISHER                      = 28094,
-    NPC_WINTERGRASP_TOWER_CANNON                    = 28366
-};
-
-struct BfWGCoordGY
-{
-    float x;
-    float y;
-    float z;
-    float o;
-    uint32 gyid;
-    uint8 type;
-    uint32 textid;          // for gossip menu
-    TeamId startcontrol;
-};
-
-uint32 const WGQuest[2][6] =
-{
-    { 13186, 13181, 13222, 13538, 13177, 13179 },
-    { 13185, 13183, 13223, 13539, 13178, 13180 },
-};
-
-// 7 in sql, 7 in header
-BfWGCoordGY const WGGraveYard[BATTLEFIELD_WG_GRAVEYARD_MAX] =
-{
-    { 5104.750f, 2300.940f, 368.579f, 0.733038f, 1329, BATTLEFIELD_WG_GY_WORKSHOP_NE, BATTLEFIELD_WG_GOSSIPTEXT_GY_NE, TEAM_NEUTRAL },
-    { 5099.120f, 3466.036f, 368.484f, 5.317802f, 1330, BATTLEFIELD_WG_GY_WORKSHOP_NW, BATTLEFIELD_WG_GOSSIPTEXT_GY_NW, TEAM_NEUTRAL },
-    { 4314.648f, 2408.522f, 392.642f, 6.268125f, 1333, BATTLEFIELD_WG_GY_WORKSHOP_SE, BATTLEFIELD_WG_GOSSIPTEXT_GY_SE, TEAM_NEUTRAL },
-    { 4331.716f, 3235.695f, 390.251f, 0.008500f, 1334, BATTLEFIELD_WG_GY_WORKSHOP_SW, BATTLEFIELD_WG_GOSSIPTEXT_GY_SW, TEAM_NEUTRAL },
-    { 5537.986f, 2897.493f, 517.057f, 4.819249f, 1285, BATTLEFIELD_WG_GY_KEEP, BATTLEFIELD_WG_GOSSIPTEXT_GY_KEEP, TEAM_NEUTRAL },
-    { 5032.454f, 3711.382f, 372.468f, 3.971623f, 1331, BATTLEFIELD_WG_GY_HORDE, BATTLEFIELD_WG_GOSSIPTEXT_GY_HORDE, TEAM_HORDE },
-    { 5140.790f, 2179.120f, 390.950f, 1.972220f, 1332, BATTLEFIELD_WG_GY_ALLIANCE, BATTLEFIELD_WG_GOSSIPTEXT_GY_ALLIANCE, TEAM_ALLIANCE },
-};
-
-/* ######################### *
- *  WintergraspCapturePoint  *
- * ######################### */
-
-class WintergraspCapturePoint : public BfCapturePoint
-{
-    public:
-        WintergraspCapturePoint(BattlefieldWG* battlefield, TeamId teamInControl);
-
-        void LinkToWorkshop(WintergraspWorkshop* workshop) { m_Workshop = workshop; }
-
-        void ChangeTeam(TeamId oldteam) override;
-        TeamId GetTeam() const { return m_team; }
-
-    protected:
-        WintergraspWorkshop* m_Workshop;
-};
-
-/* ######################### *
- * WinterGrasp Battlefield   *
- * ######################### */
-
-class BattlefieldWG : public Battlefield
-{
-    public:
-        ~BattlefieldWG();
-        /**
-         * \brief Called when the battle start
-         * - Spawn relic and turret
-         * - Rebuild tower and wall
-         * - Invite player to war
-         */
-        void OnBattleStart() override;
-
-        /**
-         * \brief Called when battle end
-         * - Remove relic and turret
-         * - Change banner/npc in keep if it needed
-         * - Saving battlestate
-         * - Reward honor/mark to player
-         * - Remove vehicle
-         * \param endByTimer : true if battle ended when timer is at 00:00, false if battle ended by clicking on relic
-         */
-        void OnBattleEnd(bool endByTimer) override;
-
-        /**
-         * \brief Called when grouping starts (15 minutes before battlestart)
-         * - Invite all player in zone to join queue
-         */
-        void OnStartGrouping() override;
-
-        /**
-         * \brief Called when player accept invite to join battle
-         * - Update aura
-         * - Teleport if it needed
-         * - Update worldstate
-         * - Update tenacity
-         * \param player: Player who accepted invite
-         */
-        void OnPlayerJoinWar(Player* player) override;
-
-        /**
-         * \brief Called when player left the battle
-         * - Update player aura
-         * \param player : Player who left the battle
-         */
-        void OnPlayerLeaveWar(Player* player) override;
-
-        /**
-         * \brief Called when player left the WG zone
-         * \param player : Player who left the zone
-         */
-        void OnPlayerLeaveZone(Player* player) override;
-
-        /**
-         * \brief Called when player enters in WG zone
-         * - Update aura
-         * - Update worldstate
-         * \param player : Player who enters the zone
-         */
-        void OnPlayerEnterZone(Player* player) override;
-
-        /**
-         * \brief Called for update battlefield data
-         * - Save battle timer in database every minutes
-         * - Update imunity aura from graveyard
-         * \param diff : time elapsed since the last call (in ms)
-         */
-        bool Update(uint32 diff) override;
-
-        /**
-         * \brief Called when a creature is created
-         * - Update vehicle count
-         */
-        void OnCreatureCreate(Creature* creature) override;
-
-        /**
-         * \brief Called when a creature is removed
-         * - Update vehicle count
-         */
-        void OnCreatureRemove(Creature* creature) override;
-
-        /**
-         * \brief Called when a gameobject is created
-         */
-        void OnGameObjectCreate(GameObject* go) override;
-
-        /**
-         * \brief Called when a wall/tower is broken
-         * - Update quest
-         */
-        void BrokenWallOrTower(TeamId team);
-
-        /**
-         * \brief Called when a tower is damaged
-         * - Update tower count (for reward calcul)
-         */
-        void UpdateDamagedTowerCount(TeamId team);
-
-        /**
-         * \brief Called when tower is broken
-         * - Update tower buff
-         * - check if three south tower is down for remove 10 minutes to wg
-         */
-        void UpdatedDestroyedTowerCount(TeamId team);
-
-        void DoCompleteOrIncrementAchievement(uint32 achievement, Player* player, uint8 incrementNumber = 1) override;
-
-        void RemoveAurasFromPlayer(Player* player);
-
-        /**
-         * \brief Called when battlefield is setup, at server start
-         */
-        bool SetupBattlefield() override;
-
-        /// Return pointer to relic object
-        GameObject* GetRelic() { return GetGameObject(m_titansRelicGUID); }
-
-        /// Define relic object
-        void SetRelic(ObjectGuid relicGUID) { m_titansRelicGUID = relicGUID; }
-
-        /// Check if players can interact with the relic (Only if the last door has been broken)
-        bool CanInteractWithRelic() { return m_isRelicInteractible; }
-
-        /// Define if player can interact with the relic
-        void SetRelicInteractible(bool allow) { m_isRelicInteractible = allow; }
-
-        void UpdateVehicleCountWG();
-        void UpdateCounterVehicle(bool init);
-
-        void SendInitWorldStatesTo(Player* player);
-        void SendInitWorldStatesToAll() override;
-        void FillInitialWorldStates(WorldPacket& data) override;
-
-        void HandleKill(Player* killer, Unit* victim) override;
-        void OnUnitDeath(Unit* unit) override;
-        void PromotePlayer(Player* killer);
-
-        void UpdateTenacity();
-        void ProcessEvent(WorldObject* obj, uint32 eventId) override;
-
-        bool FindAndRemoveVehicleFromList(Unit* vehicle);
-
-        // returns the graveyardId in the specified area.
-        uint8 GetSpiritGraveyardId(uint32 areaId) const;
-
-        uint32 GetData(uint32 data) const override;
-
-    protected:
-        bool m_isRelicInteractible;
-
-        WorkshopSet Workshops;
-
-        GuidSet DefenderPortalList;
-        GuidSet m_KeepGameObject[BG_TEAMS_COUNT];
-        GameObjectBuildingSet BuildingsInZone;
-
-        GuidSet m_vehicles[BG_TEAMS_COUNT];
-        GuidSet CanonList;
-        GuidSet KeepCreature[BG_TEAMS_COUNT];
-        GuidSet OutsideCreature[BG_TEAMS_COUNT];
-
-        uint32 m_tenacityStack;
-        uint32 m_saveTimer;
-
-        ObjectGuid m_titansRelicGUID;
-};
-
-uint32 const VehNumWorldState[]        = { 3680, 3490 };
-uint32 const MaxVehNumWorldState[]     = { 3681, 3491 };
-uint32 const ClockWorldState[]         = { 3781, 4354 };
-uint32 const WintergraspFaction[]      = { 1732, 1735, 35 };
-
-Position const WintergraspStalkerPos   = { 4948.985f, 2937.789f, 550.5172f, 1.815142f };
-
-uint8 const WG_MAX_OBJ              = 32;
-uint8 const WG_MAX_TURRET           = 15;
-uint8 const WG_MAX_KEEP_NPC         = 39;
-uint8 const WG_MAX_OUTSIDE_NPC      = 14;
-uint8 const WG_OUTSIDE_ALLIANCE_NPC = 7;
-uint8 const WG_MAX_TELEPORTER       = 12;
-uint8 const WG_MAX_WORKSHOP         = 6;
-uint8 const WG_MAX_TOWER            = 7;
-
-enum WintergraspGameObjectBuildingType
-{
-    BATTLEFIELD_WG_OBJECTTYPE_DOOR,
-    BATTLEFIELD_WG_OBJECTTYPE_TITANRELIC,
-    BATTLEFIELD_WG_OBJECTTYPE_WALL,
-    BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST,
-    BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER,
-    BATTLEFIELD_WG_OBJECTTYPE_TOWER
-};
-
-enum WintergraspGameObjectState
-{
-    BATTLEFIELD_WG_OBJECTSTATE_NONE,
-    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_INTACT,
-    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DAMAGE,
-    BATTLEFIELD_WG_OBJECTSTATE_NEUTRAL_DESTROY,
-    BATTLEFIELD_WG_OBJECTSTATE_HORDE_INTACT,
-    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DAMAGE,
-    BATTLEFIELD_WG_OBJECTSTATE_HORDE_DESTROY,
-    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_INTACT,
-    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DAMAGE,
-    BATTLEFIELD_WG_OBJECTSTATE_ALLIANCE_DESTROY
-};
-
-enum WintergraspTowerIds
-{
-    BATTLEFIELD_WG_TOWER_FORTRESS_NW,
-    BATTLEFIELD_WG_TOWER_FORTRESS_SW,
-    BATTLEFIELD_WG_TOWER_FORTRESS_SE,
-    BATTLEFIELD_WG_TOWER_FORTRESS_NE,
-    BATTLEFIELD_WG_TOWER_SHADOWSIGHT,
-    BATTLEFIELD_WG_TOWER_WINTER_S_EDGE,
-    BATTLEFIELD_WG_TOWER_FLAMEWATCH
-};
-
-enum WintergraspWorkshopIds
-{
-    BATTLEFIELD_WG_WORKSHOP_NE,
-    BATTLEFIELD_WG_WORKSHOP_NW,
-    BATTLEFIELD_WG_WORKSHOP_SE,
-    BATTLEFIELD_WG_WORKSHOP_SW,
-    BATTLEFIELD_WG_WORKSHOP_KEEP_WEST,
-    BATTLEFIELD_WG_WORKSHOP_KEEP_EAST
-};
-
-enum WintergraspWorldstates
-{
-    WORLDSTATE_WORKSHOP_NE      = 3701,
-    WORLDSTATE_WORKSHOP_NW      = 3700,
-    WORLDSTATE_WORKSHOP_SE      = 3703,
-    WORLDSTATE_WORKSHOP_SW      = 3702,
-    WORLDSTATE_WORKSHOP_K_W     = 3698,
-    WORLDSTATE_WORKSHOP_K_E     = 3699
-};
-
-enum WintergraspTeamControl
-{
-    BATTLEFIELD_WG_TEAM_ALLIANCE,
-    BATTLEFIELD_WG_TEAM_HORDE,
-    BATTLEFIELD_WG_TEAM_NEUTRAL
-};
-
-enum WintergraspText
-{
-    // Invisible Stalker
-    BATTLEFIELD_WG_TEXT_SOUTHERN_TOWER_DAMAGE           = 1,
-    BATTLEFIELD_WG_TEXT_SOUTHERN_TOWER_DESTROY          = 2,
-    BATTLEFIELD_WG_TEXT_EASTERN_TOWER_DAMAGE            = 3,
-    BATTLEFIELD_WG_TEXT_EASTERN_TOWER_DESTROY           = 4,
-    BATTLEFIELD_WG_TEXT_WESTERN_TOWER_DAMAGE            = 5,
-    BATTLEFIELD_WG_TEXT_WESTERN_TOWER_DESTROY           = 6,
-    BATTLEFIELD_WG_TEXT_NW_KEEPTOWER_DAMAGE             = 7,
-    BATTLEFIELD_WG_TEXT_NW_KEEPTOWER_DESTROY            = 8,
-    BATTLEFIELD_WG_TEXT_SE_KEEPTOWER_DAMAGE             = 9,
-    BATTLEFIELD_WG_TEXT_SE_KEEPTOWER_DESTROY            = 10,
-    BATTLEFIELD_WG_TEXT_BROKEN_TEMPLE_ATTACK_ALLIANCE   = 11,
-    BATTLEFIELD_WG_TEXT_BROKEN_TEMPLE_CAPTURE_ALLIANCE  = 12,
-    BATTLEFIELD_WG_TEXT_BROKEN_TEMPLE_ATTACK_HORDE      = 13,
-    BATTLEFIELD_WG_TEXT_BROKEN_TEMPLE_CAPTURE_HORDE     = 14,
-    BATTLEFIELD_WG_TEXT_EASTSPARK_ATTACK_ALLIANCE       = 15,
-    BATTLEFIELD_WG_TEXT_EASTSPARK_CAPTURE_ALLIANCE      = 16,
-    BATTLEFIELD_WG_TEXT_EASTSPARK_ATTACK_HORDE          = 17,
-    BATTLEFIELD_WG_TEXT_EASTSPARK_CAPTURE_HORDE         = 18,
-    BATTLEFIELD_WG_TEXT_SUNKEN_RING_ATTACK_ALLIANCE     = 19,
-    BATTLEFIELD_WG_TEXT_SUNKEN_RING_CAPTURE_ALLIANCE    = 20,
-    BATTLEFIELD_WG_TEXT_SUNKEN_RING_ATTACK_HORDE        = 21,
-    BATTLEFIELD_WG_TEXT_SUNKEN_RING_CAPTURE_HORDE       = 22,
-    BATTLEFIELD_WG_TEXT_WESTSPARK_ATTACK_ALLIANCE       = 23,
-    BATTLEFIELD_WG_TEXT_WESTSPARK_CAPTURE_ALLIANCE      = 24,
-    BATTLEFIELD_WG_TEXT_WESTSPARK_ATTACK_HORDE          = 25,
-    BATTLEFIELD_WG_TEXT_WESTSPARK_CAPTURE_HORDE         = 26,
-
-    BATTLEFIELD_WG_TEXT_START_GROUPING                  = 27,
-    BATTLEFIELD_WG_TEXT_START_BATTLE                    = 28,
-    BATTLEFIELD_WG_TEXT_FORTRESS_DEFEND_ALLIANCE        = 29,
-    BATTLEFIELD_WG_TEXT_FORTRESS_CAPTURE_ALLIANCE       = 30,
-    BATTLEFIELD_WG_TEXT_FORTRESS_DEFEND_HORDE           = 31,
-    BATTLEFIELD_WG_TEXT_FORTRESS_CAPTURE_HORDE          = 32,
-
-    BATTLEFIELD_WG_TEXT_NE_KEEPTOWER_DAMAGE             = 33,
-    BATTLEFIELD_WG_TEXT_NE_KEEPTOWER_DESTROY            = 34,
-    BATTLEFIELD_WG_TEXT_SW_KEEPTOWER_DAMAGE             = 35,
-    BATTLEFIELD_WG_TEXT_SW_KEEPTOWER_DESTROY            = 36,
-
-    BATTLEFIELD_WG_TEXT_RANK_CORPORAL                   = 37,
-    BATTLEFIELD_WG_TEXT_RANK_FIRST_LIEUTENANT           = 38
-};
-
-enum WintergraspGameObject
-{
-    GO_WINTERGRASP_FACTORY_BANNER_NE             = 190475,
-    GO_WINTERGRASP_FACTORY_BANNER_NW             = 190487,
-    GO_WINTERGRASP_FACTORY_BANNER_SE             = 194959,
-    GO_WINTERGRASP_FACTORY_BANNER_SW             = 194962,
-
-    GO_WINTERGRASP_TITAN_S_RELIC                 = 192829,
-
-    GO_WINTERGRASP_FORTRESS_TOWER_1              = 190221,
-    GO_WINTERGRASP_FORTRESS_TOWER_2              = 190373,
-    GO_WINTERGRASP_FORTRESS_TOWER_3              = 190377,
-    GO_WINTERGRASP_FORTRESS_TOWER_4              = 190378,
-
-    GO_WINTERGRASP_SHADOWSIGHT_TOWER             = 190356,
-    GO_WINTERGRASP_WINTER_S_EDGE_TOWER           = 190357,
-    GO_WINTERGRASP_FLAMEWATCH_TOWER              = 190358,
-
-    GO_WINTERGRASP_FORTRESS_GATE                 = 190375,
-    GO_WINTERGRASP_VAULT_GATE                    = 191810,
-
-    GO_WINTERGRASP_KEEP_COLLISION_WALL           = 194323
-};
-
-// *****************************************************
-// ************ Destructible (Wall, Tower..) ***********
-// *****************************************************
-
-struct WintergraspBuildingSpawnData
-{
-    uint32 entry;
-    uint32 WorldState;
-    float x;
-    float y;
-    float z;
-    float o;
-    WintergraspGameObjectBuildingType type;
-};
-
-struct WintergraspObjectPositionData
-{
-    float x;
-    float y;
-    float z;
-    float o;
-    uint32 entryHorde;
-    uint32 entryAlliance;
-};
-
-WintergraspBuildingSpawnData const WGGameObjectBuilding[WG_MAX_OBJ] =
-{
-    // Wall (Not spawned in db)
-    // Entry  WS    X         Y         Z         O           Type
-    { 190219, 3749, 5371.46f, 3047.47f, 407.571f, 3.14159f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 190220, 3750, 5331.26f, 3047.1f,  407.923f, 0.052359f,  BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191795, 3764, 5385.84f, 2909.49f, 409.713f, 0.00872f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191796, 3772, 5384.45f, 2771.84f, 410.27f,  3.14159f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191799, 3762, 5371.44f, 2630.61f, 408.816f, 3.13286f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191800, 3766, 5301.84f, 2909.09f, 409.866f, 0.008724f,  BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191801, 3770, 5301.06f, 2771.41f, 409.901f, 3.14159f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191802, 3751, 5280.2f,  2995.58f, 408.825f, 1.61443f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191803, 3752, 5279.14f, 2956.02f, 408.604f, 1.5708f,    BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191804, 3767, 5278.69f, 2882.51f, 409.539f, 1.5708f,    BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191806, 3769, 5279.5f,  2798.94f, 409.998f, 1.5708f,    BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191807, 3759, 5279.94f, 2724.77f, 409.945f, 1.56207f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191808, 3760, 5279.6f,  2683.79f, 409.849f, 1.55334f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191809, 3761, 5330.96f, 2630.78f, 409.283f, 3.13286f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 190369, 3753, 5256.08f, 2933.96f, 409.357f, 3.13286f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 190370, 3758, 5257.46f, 2747.33f, 409.743f, -3.13286f,  BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 190371, 3754, 5214.96f, 2934.09f, 409.19f,  -0.008724f, BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 190372, 3757, 5215.82f, 2747.57f, 409.188f, -3.13286f,  BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 190374, 3755, 5162.27f, 2883.04f, 410.256f, 1.57952f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 190376, 3756, 5163.72f, 2799.84f, 409.227f, 1.57952f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-
-    // Tower of keep (Not spawned in db)
-    { 190221, 3711, 5281.15f, 3044.59f, 407.843f, 3.11539f,   BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER }, // NW
-    { 190373, 3713, 5163.76f, 2932.23f, 409.19f,  3.12412f,   BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER }, // SW
-    { 190377, 3714, 5166.4f,  2748.37f, 409.188f, -1.5708f,   BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER }, // SE
-    { 190378, 3712, 5281.19f, 2632.48f, 409.099f, -1.58825f,  BATTLEFIELD_WG_OBJECTTYPE_KEEP_TOWER }, // NE
-
-    // Wall (with passage) (Not spawned in db)
-    { 191797, 3765, 5343.29f, 2908.86f, 409.576f, 0.008724f,  BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191798, 3771, 5342.72f, 2771.39f, 409.625f, 3.14159f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-    { 191805, 3768, 5279.13f, 2840.8f,  409.783f, 1.57952f,   BATTLEFIELD_WG_OBJECTTYPE_WALL },
-
-    // South tower (Not spawned in db)
-    { 190356, 3704, 4557.17f, 3623.94f, 395.883f, 1.67552f,   BATTLEFIELD_WG_OBJECTTYPE_TOWER }, // W
-    { 190357, 3705, 4398.17f, 2822.5f,  405.627f, -3.12412f,  BATTLEFIELD_WG_OBJECTTYPE_TOWER }, // S
-    { 190358, 3706, 4459.1f,  1944.33f, 434.991f, -2.00276f,  BATTLEFIELD_WG_OBJECTTYPE_TOWER }, // E
-
-    // Door of forteress (Not spawned in db)
-    { GO_WINTERGRASP_FORTRESS_GATE, 3763, 5162.99f, 2841.23f, 410.162f, -3.13286f, BATTLEFIELD_WG_OBJECTTYPE_DOOR },
-
-    // Last door (Not spawned in db)
-    { GO_WINTERGRASP_VAULT_GATE, 3773, 5397.11f, 2841.54f, 425.899f, 3.14159f, BATTLEFIELD_WG_OBJECTTYPE_DOOR_LAST },
-};
-
-struct StaticWintergraspTowerInfo
-{
-    uint8 TowerId;
-
-    struct
-    {
-        uint8 Damaged;
-        uint8 Destroyed;
-    } TextIds;
-};
-
-StaticWintergraspTowerInfo const TowerData[WG_MAX_TOWER] =
-{
-    { BATTLEFIELD_WG_TOWER_FORTRESS_NW,   { BATTLEFIELD_WG_TEXT_NW_KEEPTOWER_DAMAGE,   BATTLEFIELD_WG_TEXT_NW_KEEPTOWER_DESTROY   } },
-    { BATTLEFIELD_WG_TOWER_FORTRESS_SW,   { BATTLEFIELD_WG_TEXT_SW_KEEPTOWER_DAMAGE,   BATTLEFIELD_WG_TEXT_SW_KEEPTOWER_DESTROY   } },
-    { BATTLEFIELD_WG_TOWER_FORTRESS_SE,   { BATTLEFIELD_WG_TEXT_SE_KEEPTOWER_DAMAGE,   BATTLEFIELD_WG_TEXT_SE_KEEPTOWER_DESTROY   } },
-    { BATTLEFIELD_WG_TOWER_FORTRESS_NE,   { BATTLEFIELD_WG_TEXT_NE_KEEPTOWER_DAMAGE,   BATTLEFIELD_WG_TEXT_NE_KEEPTOWER_DESTROY   } },
-    { BATTLEFIELD_WG_TOWER_SHADOWSIGHT,   { BATTLEFIELD_WG_TEXT_WESTERN_TOWER_DAMAGE,  BATTLEFIELD_WG_TEXT_WESTERN_TOWER_DESTROY  } },
-    { BATTLEFIELD_WG_TOWER_WINTER_S_EDGE, { BATTLEFIELD_WG_TEXT_SOUTHERN_TOWER_DAMAGE, BATTLEFIELD_WG_TEXT_SOUTHERN_TOWER_DESTROY } },
-    { BATTLEFIELD_WG_TOWER_FLAMEWATCH,    { BATTLEFIELD_WG_TEXT_EASTERN_TOWER_DAMAGE,  BATTLEFIELD_WG_TEXT_EASTERN_TOWER_DESTROY  } }
-};
-
-Position const WGTurret[WG_MAX_TURRET] =
-{
-    { 5391.19f, 3060.8f,  419.616f, 1.69557f },
-    { 5266.75f, 2976.5f,  421.067f, 3.20354f },
-    { 5234.86f, 2948.8f,  420.88f,  1.61311f },
-    { 5323.05f, 2923.7f,  421.645f, 1.5817f },
-    { 5363.82f, 2923.87f, 421.709f, 1.60527f },
-    { 5264.04f, 2861.34f, 421.587f, 3.21142f },
-    { 5264.68f, 2819.78f, 421.656f, 3.15645f },
-    { 5322.16f, 2756.69f, 421.646f, 4.69978f },
-    { 5363.78f, 2756.77f, 421.629f, 4.78226f },
-    { 5236.2f,  2732.68f, 421.649f, 4.72336f },
-    { 5265.02f, 2704.63f, 421.7f,   3.12507f },
-    { 5350.87f, 2616.03f, 421.243f, 4.72729f },
-    { 5390.95f, 2615.5f,  421.126f, 4.6409f },
-    { 5148.8f,  2820.24f, 421.621f, 3.16043f },
-    { 5147.98f, 2861.93f, 421.63f,  3.18792f },
-};
-
-// Here there is all npc keeper spawn point
-WintergraspObjectPositionData const WGKeepNPC[WG_MAX_KEEP_NPC] =
-{
-    // X          Y            Z           O         horde                          alliance
-    // North East
-    { 5326.203125f, 2660.026367f, 409.100891f, 2.543383f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
-    { 5298.430176f, 2738.760010f, 409.316010f, 3.971740f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH }, // Vieron Blazefeather
-    { 5335.310059f, 2764.110107f, 409.274994f, 4.834560f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5349.810059f, 2763.629883f, 409.333008f, 4.660030f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    // North
-    { 5373.470215f, 2789.060059f, 409.322998f, 2.600540f, BATTLEFIELD_WG_NPC_STONE_GUARD_MUKAR, BATTLEFIELD_WG_NPC_KNIGHT_DAMERON }, // Stone Guard Mukar
-    { 5296.560059f, 2789.870117f, 409.274994f, 0.733038f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA }, // Voodoo Master Fu'jin
-    { 5372.670000f, 2786.740000f, 409.442000f, 2.809980f, BATTLEFIELD_WG_NPC_CHAMPION_ROS_SLAI, BATTLEFIELD_WG_NPC_MARSHAL_MAGRUDER }, // Wintergrasp Quartermaster
-    { 5368.709961f, 2856.360107f, 409.322998f, 2.949610f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5367.910156f, 2826.520020f, 409.322998f, 3.333580f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5389.270020f, 2847.370117f, 418.759003f, 3.106690f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5388.560059f, 2834.770020f, 418.759003f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5359.129883f, 2837.989990f, 409.364014f, 4.698930f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH }, // Commander Dardosh
-    { 5366.129883f, 2833.399902f, 409.322998f, 3.141590f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS }, // Tactical Officer Kilrath
-    // X          Y            Z           O         horde  alliance
-    // North West
-    { 5350.680176f, 2917.010010f, 409.274994f, 1.466080f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5335.120117f, 2916.800049f, 409.444000f, 1.500980f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5295.560059f, 2926.669922f, 409.274994f, 0.872665f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE }, // Stronghoof
-    { 5371.399902f, 3026.510010f, 409.205994f, 3.250030f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA }, // Primalist Mulfort
-    { 5392.123535f, 3031.110352f, 409.187683f, 3.677212f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Roaming Guard
-    // South
-    { 5270.060059f, 2847.550049f, 409.274994f, 3.071780f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5270.160156f, 2833.479980f, 409.274994f, 3.124140f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5179.109863f, 2837.129883f, 409.274994f, 3.211410f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5179.669922f, 2846.600098f, 409.274994f, 3.089230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5234.970215f, 2883.399902f, 409.274994f, 4.293510f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO }, // Lieutenant Murp
-    // X          Y            Z           O         horde  alliance
-    // Portal guards (from around the fortress)
-    { 5319.209473f, 3055.947754f, 409.176636f, 1.020201f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5311.612305f, 3061.207275f, 408.734161f, 0.965223f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5264.713379f, 3017.283447f, 408.479706f, 3.482424f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5269.096191f, 3008.315918f, 408.826294f, 3.843706f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5201.414551f, 2945.096924f, 409.190735f, 0.945592f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5193.386230f, 2949.617188f, 409.190735f, 1.145859f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5148.116211f, 2904.761963f, 409.193756f, 3.368532f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5153.355957f, 2895.501465f, 409.199310f, 3.549174f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5154.353027f, 2787.349365f, 409.250183f, 2.555644f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5150.066406f, 2777.876953f, 409.343903f, 2.708797f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5193.706543f, 2732.882812f, 409.189514f, 4.845073f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5202.126953f, 2737.570557f, 409.189514f, 5.375215f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5269.181152f, 2671.174072f, 409.098999f, 2.457459f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5264.960938f, 2662.332520f, 409.098999f, 2.598828f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5307.111816f, 2616.006836f, 409.095734f, 5.355575f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },       // Standing Guard
-    { 5316.770996f, 2619.430176f, 409.027740f, 5.363431f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A }        // Standing Guard
-};
-
-const WintergraspObjectPositionData WGOutsideNPC[WG_MAX_OUTSIDE_NPC] =
-{
-    { 5032.04f, 3681.79f, 362.980f, 4.210f, BATTLEFIELD_WG_NPC_VIERON_BLAZEFEATHER, 0 },
-    { 5020.71f, 3626.19f, 360.150f, 4.640f, BATTLEFIELD_WG_NPC_HOODOO_MASTER_FU_JIN, 0 },
-    { 4994.85f, 3660.51f, 359.150f, 2.260f, BATTLEFIELD_WG_NPC_COMMANDER_DARDOSH, 0 },
-    { 5015.46f, 3677.11f, 362.970f, 6.009f, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_KILRATH, 0 },
-    { 5031.12f, 3663.77f, 363.500f, 3.110f, BATTLEFIELD_WG_NPC_SIEGESMITH_STRONGHOOF, 0 },
-    { 5042.74f, 3675.82f, 363.060f, 3.358f, BATTLEFIELD_WG_NPC_PRIMALIST_MULFORT, 0 },
-    { 5014.45f, 3640.87f, 361.390f, 3.280f, BATTLEFIELD_WG_NPC_LIEUTENANT_MURP, 0 },
-    { 5100.07f, 2168.89f, 365.779f, 1.972f, 0, BATTLEFIELD_WG_NPC_BOWYER_RANDOLPH },
-    { 5081.70f, 2173.73f, 365.878f, 0.855f, 0, BATTLEFIELD_WG_NPC_SORCERESS_KAYLANA },
-    { 5078.28f, 2183.70f, 365.029f, 1.466f, 0, BATTLEFIELD_WG_NPC_COMMANDER_ZANNETH },
-    { 5088.49f, 2188.18f, 365.647f, 5.253f, 0, BATTLEFIELD_WG_NPC_TACTICAL_OFFICER_AHBRAMIS },
-    { 5095.67f, 2193.28f, 365.924f, 4.939f, 0, BATTLEFIELD_WG_NPC_SIEGE_MASTER_STOUTHANDLE },
-    { 5088.61f, 2167.66f, 365.689f, 0.680f, 0, BATTLEFIELD_WG_NPC_ANCHORITE_TESSA },
-    { 5080.40f, 2199.00f, 359.489f, 2.967f, 0, BATTLEFIELD_WG_NPC_SENIOR_DEMOLITIONIST_LEGOSO },
-};
-
-struct WintergraspTeleporterData
-{
-    uint32 entry;
-    float x;
-    float y;
-    float z;
-    float o;
-};
-
-WintergraspTeleporterData const WGPortalDefenderData[WG_MAX_TELEPORTER] =
-{
-    // Player teleporter
-    { 190763, 5153.41f, 2901.35f, 409.191f, -0.069f },
-    { 190763, 5268.70f, 2666.42f, 409.099f, -0.715f },
-    { 190763, 5197.05f, 2944.81f, 409.191f, 2.3387f },
-    { 190763, 5196.67f, 2737.34f, 409.189f, -2.932f },
-    { 190763, 5314.58f, 3055.85f, 408.862f, 0.5410f },
-    { 190763, 5391.28f, 2828.09f, 418.675f, -2.164f },
-    { 190763, 5153.93f, 2781.67f, 409.246f, 1.6580f },
-    { 190763, 5311.44f, 2618.93f, 409.092f, -2.373f },
-    { 190763, 5269.21f, 3013.84f, 408.828f, -1.762f },
-    { 190763, 5401.62f, 2853.66f, 418.674f, 2.6354f },
-    // Vehicle teleporter
-    { 192951, 5314.51f, 2703.69f, 408.550f, -0.890f },
-    { 192951, 5316.25f, 2977.04f, 408.539f, -0.820f },
-};
-
-// *********************************************************
-// **********Tower Element(GameObject, Creature)************
-// *********************************************************
-
-struct WintergraspTowerData
-{
-    uint32 towerEntry;                  // Gameobject id of tower
-    uint8 nbObject;                     // Number of gameobjects spawned on this point
-    WintergraspObjectPositionData GameObject[6];   // Gameobject position and entry (Horde/Alliance)
-
-    // Creature: Turrets and Guard /// @todo: Killed on Tower destruction ? Tower damage ? Requires confirming
-    uint8 nbCreatureBottom;
-    WintergraspObjectPositionData CreatureBottom[9];
-    uint8 nbCreatureTop;
-    WintergraspObjectPositionData CreatureTop[5];
-};
-
-uint8 const WG_MAX_ATTACKTOWERS = 3;
-// 192414 : 0 in sql, 1 in header
-// 192278 : 0 in sql, 3 in header
-const WintergraspTowerData AttackTowers[WG_MAX_ATTACKTOWERS] =
-{
-    // West tower
-    {
-        190356,
-        6,
-        {
-            { 4559.109863f, 3606.219971f, 419.998993f, -1.483530f, 192488, 192501 },    // Flag on tower
-            { 4539.419922f, 3622.489990f, 420.033997f, -3.071770f, 192488, 192501 },    // Flag on tower
-            { 4555.259766f, 3641.649902f, 419.973999f, 1.675510f, 192488, 192501 },     // Flag on tower
-            { 4574.870117f, 3625.909912f, 420.079010f, 0.080117f, 192488, 192501 },     // Flag on tower
-            { 4433.899902f, 3534.139893f, 360.274994f, -1.850050f, 192269, 192278 },    // Flag near workshop
-            { 4572.930176f, 3475.520020f, 363.009003f, 1.42240f, 192269, 192278 }       // Flag near bridge
-        },
-        1,
-        {
-            { 4418.688477f, 3506.251709f, 358.975494f, 4.293305f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-        },
-        0,
-        {
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-        }
-    },
-
-    // South Tower
-    {
-        190357,
-        5,
-        {
-            { 4416.000000f, 2822.669922f, 429.851013f, -0.017452f, 192488, 192501 },    // Flag on tower
-            { 4398.819824f, 2804.699951f, 429.791992f, -1.588250f, 192488, 192501 },    // Flag on tower
-            { 4387.620117f, 2719.570068f, 389.934998f, -1.544620f, 192366, 192414 },    // Flag near tower
-            { 4464.120117f, 2855.449951f, 406.110992f, 0.829032f, 192366, 192429 },     // Flag near tower
-            { 4526.459961f, 2810.179932f, 391.200012f, -2.993220f, 192269, 192278 },    // Flag near bridge
-            { 0, 0, 0, 0, 0, 0 },
-        },
-        6,
-        {
-            { 4452.859863f, 2808.870117f, 402.604004f, 6.056290f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-            { 4455.899902f, 2835.958008f, 401.122559f, 0.034907f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-            { 4412.649414f, 2953.792236f, 374.799957f, 0.980838f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Roaming Guard
-            { 4362.089844f, 2811.510010f, 407.337006f, 3.193950f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-            { 4412.290039f, 2753.790039f, 401.015015f, 5.829400f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-            { 4421.939941f, 2773.189941f, 400.894989f, 5.707230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-            { 0, 0, 0, 0, 0, 0},
-            { 0, 0, 0, 0, 0, 0},
-            { 0, 0, 0, 0, 0, 0},
-        },
-        0,
-        {
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-        },
-    },
-
-    // East Tower
-    {
-        190358,
-        4,
-        {
-            { 4466.790039f, 1960.420044f, 459.144012f, 1.151920f, 192488, 192501 },     // Flag on tower
-            { 4475.350098f, 1937.030029f, 459.070007f, -0.43633f, 192488, 192501 },     // Flag on tower
-            { 4451.759766f, 1928.099976f, 459.075989f, -2.00713f, 192488, 192501 },     // Flag on tower
-            { 4442.990234f, 1951.900024f, 459.092987f, 2.740160f, 192488, 192501 },     // Flag on tower
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-        },
-        5,
-        {
-            { 4501.060059f, 1990.280029f, 431.157013f, 1.029740f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-            { 4463.830078f, 2015.180054f, 430.299988f, 1.431170f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-            { 4494.580078f, 1943.760010f, 435.627014f, 6.195920f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-            { 4450.149902f, 1897.579956f, 435.045013f, 4.398230f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-            { 4428.870117f, 1906.869995f, 432.648010f, 3.996800f, BATTLEFIELD_WG_NPC_GUARD_H, BATTLEFIELD_WG_NPC_GUARD_A },     // Standing Guard
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-        },
-        0,
-        {
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-            { 0, 0, 0, 0, 0, 0 },
-        },
-    },
-};
-
-struct WintergraspTowerCannonData
-{
-    uint32 towerEntry;
-    uint8 nbTowerCannonBottom;
-    Position TowerCannonBottom[5];
-    uint8 nbTurretTop;
-    Position TurretTop[5];
-};
-
-const uint8 WG_MAX_TOWER_CANNON = 7;
-
-const WintergraspTowerCannonData TowerCannon[WG_MAX_TOWER_CANNON] =
-{
-    {
-        190221,
-        0,
-        {
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-        2,
-        {
-            { 5255.88f, 3047.63f, 438.499f, 3.13677f },
-            { 5280.9f, 3071.32f, 438.499f, 1.62879f },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-    },
-    {
-        190373,
-        0,
-        {
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-        2,
-        {
-            { 5138.59f, 2935.16f, 439.845f, 3.11723f },
-            { 5163.06f, 2959.52f, 439.846f, 1.47258f },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-    },
-    {
-        190377,
-        0,
-        {
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-        2,
-        {
-            { 5163.84f, 2723.74f, 439.844f, 1.3994f },
-            { 5139.69f, 2747.4f, 439.844f, 3.17221f },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-    },
-    {
-        190378,
-        0,
-        {
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-        2,
-        {
-            { 5278.21f, 2607.23f, 439.755f, 4.71944f },
-            { 5255.01f, 2631.98f, 439.755f, 3.15257f },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-    },
-    {
-        190356,
-        2,
-        {
-            {4537.380371f, 3599.531738f, 402.886993f, 3.998462f},
-            {4581.497559f, 3604.087158f, 402.886963f, 5.651723f},
-            {0, 0, 0, 0},
-            {0, 0, 0, 0},
-            {0, 0, 0, 0},
-        },
-        2,
-        {
-            {4469.448242f, 1966.623779f, 465.647217f, 1.153573f},
-            {4581.895996f, 3626.438477f, 426.539062f, 0.117806f},
-            {0, 0, 0, 0},
-            {0, 0, 0, 0},
-            {0, 0, 0, 0},
-        },
-    },
-    {
-        190357,
-        2,
-        {
-            { 4421.640137f, 2799.935791f, 412.630920f, 5.459298f },
-            { 4420.263184f, 2845.340332f, 412.630951f, 0.742197f },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-        3,
-        {
-            { 4423.430664f, 2822.762939f, 436.283142f, 6.223487f },
-            { 4397.825684f, 2847.629639f, 436.283325f, 1.579430f },
-            { 4398.814941f, 2797.266357f, 436.283051f, 4.703747f },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-    },
-    {
-        190358,
-        2,
-        {
-            { 4448.138184f, 1974.998779f, 441.995911f, 1.967238f },
-            { 4448.713379f, 1955.148682f, 441.995178f, 0.380733f },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-        2,
-        {
-            { 4469.448242f, 1966.623779f, 465.647217f, 1.153573f },
-            { 4481.996582f, 1933.658325f, 465.647186f, 5.873029f },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-            { 0, 0, 0, 0 },
-        },
-    },
-};
-
-// *********************************************************
-// *****************WorkShop Data & Element*****************
-// *********************************************************
-
-struct StaticWintergraspWorkshopInfo
-{
-    uint8 WorkshopId;
-    uint32 WorldStateId;
-
-    struct
-    {
-        uint8 AllianceCapture;
-        uint8 AllianceAttack;
-        uint8 HordeCapture;
-        uint8 HordeAttack;
-    } TextIds;
-};
-
-StaticWintergraspWorkshopInfo const WorkshopData[WG_MAX_WORKSHOP] =
-{
-    { BATTLEFIELD_WG_WORKSHOP_NE, WORLDSTATE_WORKSHOP_NE, { BATTLEFIELD_WG_TEXT_SUNKEN_RING_CAPTURE_ALLIANCE,   BATTLEFIELD_WG_TEXT_SUNKEN_RING_ATTACK_ALLIANCE,   BATTLEFIELD_WG_TEXT_SUNKEN_RING_CAPTURE_HORDE,   BATTLEFIELD_WG_TEXT_SUNKEN_RING_ATTACK_HORDE   } },
-    { BATTLEFIELD_WG_WORKSHOP_NW, WORLDSTATE_WORKSHOP_NW, { BATTLEFIELD_WG_TEXT_BROKEN_TEMPLE_CAPTURE_ALLIANCE, BATTLEFIELD_WG_TEXT_BROKEN_TEMPLE_ATTACK_ALLIANCE, BATTLEFIELD_WG_TEXT_BROKEN_TEMPLE_CAPTURE_HORDE, BATTLEFIELD_WG_TEXT_BROKEN_TEMPLE_ATTACK_HORDE } },
-    { BATTLEFIELD_WG_WORKSHOP_SE, WORLDSTATE_WORKSHOP_SE, { BATTLEFIELD_WG_TEXT_EASTSPARK_CAPTURE_ALLIANCE,     BATTLEFIELD_WG_TEXT_EASTSPARK_ATTACK_ALLIANCE,     BATTLEFIELD_WG_TEXT_EASTSPARK_CAPTURE_HORDE,     BATTLEFIELD_WG_TEXT_EASTSPARK_ATTACK_HORDE     } },
-    { BATTLEFIELD_WG_WORKSHOP_SW, WORLDSTATE_WORKSHOP_SW, { BATTLEFIELD_WG_TEXT_WESTSPARK_CAPTURE_ALLIANCE,     BATTLEFIELD_WG_TEXT_WESTSPARK_ATTACK_ALLIANCE,     BATTLEFIELD_WG_TEXT_WESTSPARK_CAPTURE_HORDE,     BATTLEFIELD_WG_TEXT_WESTSPARK_ATTACK_HORDE     } },
-    // KEEP WORKSHOPS - It can't be taken, so it doesn't have a textids
-    { BATTLEFIELD_WG_WORKSHOP_KEEP_WEST, WORLDSTATE_WORKSHOP_K_W, { 0, 0, 0, 0 } },
-    { BATTLEFIELD_WG_WORKSHOP_KEEP_EAST, WORLDSTATE_WORKSHOP_K_E, { 0, 0, 0, 0 } }
-};
-
-// ********************************************************************
-// *         Structs using for Building, Graveyard, Workshop          *
-// ********************************************************************
-
-// Structure for different buildings that can be destroyed during battle
-struct BfWGGameObjectBuilding
-{
-private:
-    // WG object
-    BattlefieldWG* _wg;
-
-    // Linked gameobject
-    ObjectGuid _buildGUID;
-
-    // the team that controls this point
-    TeamId _teamControl;
-
-    WintergraspGameObjectBuildingType _type;
-    uint32 _worldState;
-
-    WintergraspGameObjectState _state;
-
-    StaticWintergraspTowerInfo const* _staticTowerInfo;
-
-    // GameObject associations
-    GuidSet m_GameObjectList[BG_TEAMS_COUNT];
-
-    // Creature associations
-    GuidSet m_CreatureBottomList[BG_TEAMS_COUNT];
-    GuidSet m_CreatureTopList[BG_TEAMS_COUNT];
-    GuidSet m_TowerCannonBottomList;
-    GuidSet m_TurretTopList;
-
-public:
-    BfWGGameObjectBuilding(BattlefieldWG* wg, WintergraspGameObjectBuildingType type, uint32 worldState);
-    void Init(GameObject* go);
-
-    ObjectGuid const& GetGUID() const { return _buildGUID; }
-
-    void Rebuild();
-
-    // Called when associated gameobject is damaged
-    void Damaged();
-
-    // Called when associated gameobject is destroyed
-    void Destroyed();
-
-    void UpdateCreatureAndGo();
-
-    void UpdateTurretAttack(bool disable);
-
-    void FillInitialWorldStates(WorldPacket& data);
-
-    void Save();
-};
-
-// Structure for the 6 workshop
-struct WintergraspWorkshop
-{
-private:
-    BattlefieldWG* _wg;                             // Pointer to wintergrasp
-    ObjectGuid _buildGUID;
-    WintergraspGameObjectState _state;              // For worldstate
-    TeamId _teamControl;                            // Team witch control the workshop
-    GuidSet _creatureOnPoint[BG_TEAMS_COUNT];       // Contain all Creature associate to this point
-    GuidSet _gameObjectOnPoint[BG_TEAMS_COUNT];     // Contain all Gameobject associate to this point
-
-    StaticWintergraspWorkshopInfo const* _staticInfo;
-
-public:
-    WintergraspWorkshop(BattlefieldWG* wg, uint8 type);
-
-    uint8 GetId() const { return _staticInfo->WorkshopId; }
-    TeamId GetTeamControl() const { return _teamControl; }
-
-    // Spawning associate creature and store them
-    void AddCreature(WintergraspObjectPositionData const& obj);
-
-    // Spawning Associate gameobject and store them
-    void AddGameObject(WintergraspObjectPositionData const& obj);
-
-    // Called on change faction in CapturePoint class
-    void GiveControlTo(TeamId teamId, bool init = false);
-
-    void UpdateGraveyardAndWorkshop();
-
-    void FillInitialWorldStates(WorldPacket& data);
-
-    void Save();
-};
-
-#endif
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index aae5b48..c198d48 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -195,6 +195,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
   ${CMAKE_SOURCE_DIR}/src/server/shared/Networking
   ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
   ${MYSQL_INCLUDE_DIR}
   ${OPENSSL_INCLUDE_DIR}
   ${VALGRIND_INCLUDE_DIR}
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 31320e4..1ebfa3d 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -641,6 +641,18 @@ void Creature::Update(uint32 diff)
             if (!IsAlive())
                 break;
 
+            // Wintergrasp feature: mechanical units should take damage if isInWater (thx Tobmaps)
+            if (GetCreatureTemplate()->type == CREATURE_TYPE_MECHANICAL && GetZoneId() == 4197)
+            {
+                if (IsInWater())
+                {
+                    if (!HasAura(36444))
+                        CastSpell(this, 36444, true);
+                }
+                else
+                    RemoveAurasDueToSpell(36444);
+            }
+
             if (m_regenTimer > 0)
             {
                 if (diff >= m_regenTimer)
diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
index b030f42..bbcd0d4 100644
--- a/src/server/game/Entities/GameObject/GameObject.cpp
+++ b/src/server/game/Entities/GameObject/GameObject.cpp
@@ -575,6 +575,11 @@ void GameObject::Update(uint32 diff)
                         if (goInfo->trap.spellId)
                             CastSpell(target, goInfo->trap.spellId);
 
+                        // allow go to use wg script
+                        if (target->GetTypeId() == TYPEID_PLAYER)
+                            if (sScriptMgr->OnGossipHello(target->ToPlayer(), this))
+                                return;
+
                         // Template value or 4 seconds
                         m_cooldownTime = time(NULL) + (goInfo->trap.cooldown ? goInfo->trap.cooldown : uint32(4));
 
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 15c2c47..8f26733 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -23,7 +23,6 @@
 #include "ArenaTeamMgr.h"
 #include "Battlefield.h"
 #include "BattlefieldMgr.h"
-#include "BattlefieldWG.h"
 #include "Battleground.h"
 #include "BattlegroundMgr.h"
 #include "BattlegroundScore.h"
@@ -58,6 +57,7 @@
 #include "Opcodes.h"
 #include "OutdoorPvP.h"
 #include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 #include "Pet.h"
 #include "QuestDef.h"
 #include "ReputationMgr.h"
@@ -9373,7 +9373,7 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
 
     GetSession()->SendPacket(&data);
     SendBGWeekendWorldStates();
-    SendBattlefieldWorldStates();
+    //SendBattlefieldWorldStates();
 }
 
 void Player::SendBGWeekendWorldStates()
@@ -9390,7 +9390,7 @@ void Player::SendBGWeekendWorldStates()
         }
     }
 }
-
+/* Replaced by WinterGrasp Patch
 void Player::SendBattlefieldWorldStates()
 {
     /// Send misc stuff that needs to be sent on every login, like the battle timers.
@@ -9404,7 +9404,7 @@ void Player::SendBattlefieldWorldStates()
         }
     }
 }
-
+*/
 uint32 Player::GetXPRestBonus(uint32 xp)
 {
     uint32 rested_bonus = (uint32)GetRestBonus();           // xp for each rested bonus
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index b7d7d81..840cb0f 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -1939,7 +1939,7 @@ class Player : public Unit, public GridObject<Player>
         void SendUpdateWorldState(uint32 Field, uint32 Value);
         void SendDirectMessage(WorldPacket* data);
         void SendBGWeekendWorldStates();
-        void SendBattlefieldWorldStates();
+        //void SendBattlefieldWorldStates();
 
         void SendAurasForTarget(Unit* target);
 
diff --git a/src/server/game/Entities/Vehicle/Vehicle.cpp b/src/server/game/Entities/Vehicle/Vehicle.cpp
index 9cf4853..c47dba9 100755
--- a/src/server/game/Entities/Vehicle/Vehicle.cpp
+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp
@@ -869,3 +869,29 @@ void VehicleJoinEvent::Abort(uint64)
     if (Passenger->IsInWorld() && Passenger->HasUnitTypeMask(UNIT_MASK_ACCESSORY))
         Passenger->ToCreature()->DespawnOrUnsummon();
 }
+
+void Vehicle::Relocate(Position pos)
+{
+    TC_LOG_DEBUG("entities.vehicle","Vehicle::Relocate %u", _me->GetEntry());
+
+    std::set<Unit*> vehiclePlayers;
+    for (int8 i = 0; i < 8; i++)
+        vehiclePlayers.insert(GetPassenger(i));
+
+    // passengers should be removed or they will have movement stuck
+    RemoveAllPassengers();
+
+    for (std::set<Unit*>::const_iterator itr = vehiclePlayers.begin(); itr != vehiclePlayers.end(); ++itr)
+    {
+        if (Unit* plr = (*itr))
+        {
+            // relocate/setposition doesn't work for player
+            plr->NearTeleportTo(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
+            //plr->TeleportTo(pPlayer->GetMapId(), triggerPos.GetPositionX(), triggerPos.GetPositionY(), triggerPos.GetPositionZ(), triggerPos.GetOrientation(), TELE_TO_NOT_LEAVE_COMBAT);
+        }
+    }
+
+    _me->UpdatePosition(pos, true);
+    // problems, and impossible to do delayed enter
+    //pPlayer->EnterVehicle(veh);
+}
diff --git a/src/server/game/Entities/Vehicle/Vehicle.h b/src/server/game/Entities/Vehicle/Vehicle.h
index cd28c40..92f597c 100644
--- a/src/server/game/Entities/Vehicle/Vehicle.h
+++ b/src/server/game/Entities/Vehicle/Vehicle.h
@@ -26,6 +26,7 @@
 #include <list>
 
 struct VehicleEntry;
+struct Position;
 class Unit;
 class VehicleJoinEvent;
 
@@ -61,6 +62,7 @@ class Vehicle : public TransportBase
         void RelocatePassengers();
         void RemoveAllPassengers();
         bool IsVehicleInUse() const;
+        void Relocate(Position pos);
 
         void SetLastShootPos(Position const& pos) { _lastShootPos.Relocate(pos); }
         Position const& GetLastShootPos() const { return _lastShootPos; }
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index d206409..51f6bd4 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -314,6 +314,7 @@ void ObjectMgr::LoadCreatureLocales()
         AddLocaleString(name,       locale, data.Name);
         AddLocaleString(title,      locale, data.Title);
 
+
     } while (result->NextRow());
 
     TC_LOG_INFO("server.loading", ">> Loaded %u creature locale strings in %u ms", uint32(_creatureLocaleStore.size()), GetMSTimeDiffToNow(oldMSTime));
@@ -1743,6 +1744,7 @@ void ObjectMgr::LoadCreatures()
         if (!IsTransportMap(data.mapid) && data.spawnMask & ~spawnMasks[data.mapid])
             TC_LOG_ERROR("sql.sql", "Table `creature` has creature (GUID: %u) that have wrong spawn mask %u including unsupported difficulty modes for map (Id: %u).", guid, data.spawnMask, data.mapid);
 
+
         bool ok = true;
         for (uint32 diff = 0; diff < MAX_DIFFICULTY - 1 && ok; ++diff)
         {
@@ -1909,6 +1911,38 @@ ObjectGuid::LowType ObjectMgr::AddGOData(uint32 entry, uint32 mapId, float x, fl
     return guid;
 }
 
+bool ObjectMgr::MoveCreData(uint32 guid, uint32 mapId, Position pos)
+{
+    CreatureData& data = NewOrExistCreatureData(guid);
+    if (!data.id)
+        return false;
+
+    RemoveCreatureFromGrid(guid, &data);
+    if (data.posX == pos.GetPositionX() && data.posY == pos.GetPositionY() && data.posZ == pos.GetPositionZ())
+        return true;
+    data.posX = pos.GetPositionX();
+    data.posY = pos.GetPositionY();
+    data.posZ = pos.GetPositionZ();
+    data.orientation = pos.GetOrientation();
+    AddCreatureToGrid(guid, &data);
+
+    // Spawn if necessary (loaded grids only)
+    if (Map* map = sMapMgr->CreateBaseMap(mapId))
+    {
+        // We use spawn coords to spawn
+        if (!map->Instanceable() && map->IsGridLoaded(data.posX, data.posY))
+        {
+            Creature* creature = new Creature;
+            if (!creature->LoadCreatureFromDB(guid, map))
+            {
+                TC_LOG_ERROR("misc", "MoveCreData: Cannot add creature guid %u to map", guid);
+                delete creature;
+                return false;
+            }
+        }
+    }
+    return true;
+}
 
 ObjectGuid::LowType ObjectMgr::AddCreatureData(uint32 entry, uint32 mapId, float x, float y, float z, float o, uint32 spawntimedelay /*= 0*/)
 {
@@ -2183,6 +2217,7 @@ bool ObjectMgr::GetPlayerNameByGUID(ObjectGuid guid, std::string& name) const
 
     stmt->setUInt32(0, guid.GetCounter());
 
+
     PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
     if (result)
@@ -2224,6 +2259,9 @@ uint32 ObjectMgr::GetPlayerAccountIdByGUID(ObjectGuid guid) const
 
 
 
+
+
+
     return 0;
 }
 
@@ -2897,6 +2935,7 @@ void ObjectMgr::LoadItemSetNameLocales()
     if (!result)
         return;
 
+
     do
     {
         Field* fields = result->Fetch();
@@ -6417,16 +6456,19 @@ AreaTrigger const* ObjectMgr::GetMapEntranceTrigger(uint32 Map) const
     return NULL;
 }
 
+
 void ObjectMgr::SetHighestGuids()
 {
     QueryResult result = CharacterDatabase.Query("SELECT MAX(guid) FROM characters");
     if (result)
         GetGuidSequenceGenerator<HighGuid::Player>().Set((*result)[0].GetUInt32()+1);
 
+
     result = CharacterDatabase.Query("SELECT MAX(guid) FROM item_instance");
     if (result)
         GetGuidSequenceGenerator<HighGuid::Item>().Set((*result)[0].GetUInt32()+1);
 
+
     // Cleanup other tables from nonexistent guids ( >= _hiItemGuid)
     CharacterDatabase.PExecute("DELETE FROM character_inventory WHERE item >= '%u'", GetGuidSequenceGenerator<HighGuid::Item>().GetNextAfterMaxUsed());      // One-time query
     CharacterDatabase.PExecute("DELETE FROM mail_items WHERE item_guid >= '%u'", GetGuidSequenceGenerator<HighGuid::Item>().GetNextAfterMaxUsed());          // One-time query
@@ -6554,6 +6596,7 @@ void ObjectMgr::LoadGameObjectLocales()
         AddLocaleString(name, locale, data.Name);
         AddLocaleString(castBarCaption, locale, data.CastBarCaption);
 
+
     } while (result->NextRow());
 
     TC_LOG_INFO("server.loading", ">> Loaded %u gameobject_template_locale strings in %u ms", uint32(_gameObjectLocaleStore.size()), GetMSTimeDiffToNow(oldMSTime));
@@ -7062,6 +7105,7 @@ void ObjectMgr::LoadReputationOnKill()
 
         _repOnKillStore[creature_id] = repOnKill;
 
+
         ++count;
     } while (result->NextRow());
 
@@ -7735,6 +7779,7 @@ bool ObjectMgr::LoadTrinityStrings()
 
     _trinityStringStore.clear(); // for reload case
 
+
     QueryResult result = WorldDatabase.Query("SELECT entry, content_default, content_loc1, content_loc2, content_loc3, content_loc4, content_loc5, content_loc6, content_loc7, content_loc8 FROM trinity_string");
     if (!result)
     {
@@ -9075,6 +9120,7 @@ CreatureTemplate const* ObjectMgr::GetCreatureTemplate(uint32 entry)
     if (itr != _creatureTemplateStore.end())
         return &(itr->second);
 
+
     return NULL;
 }
 
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index ae12587..646a40b 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -1224,6 +1224,7 @@ class ObjectMgr
         void RemoveGameobjectFromGrid(ObjectGuid::LowType guid, GameObjectData const* data);
         ObjectGuid::LowType AddGOData(uint32 entry, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay = 0, float rotation0 = 0, float rotation1 = 0, float rotation2 = 0, float rotation3 = 0);
         ObjectGuid::LowType AddCreatureData(uint32 entry, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay = 0);
+        bool MoveCreData(uint32 guid, uint32 map, Position pos);
 
         // reserved names
         void LoadReservedPlayersNames();
@@ -1323,6 +1324,7 @@ class ObjectMgr
 
         bool IsTransportMap(uint32 mapId) const { return _transportMaps.count(mapId) != 0; }
 
+
     private:
         // first free id for selected id type
         uint32 _auctionId;
diff --git a/src/server/game/Handlers/BattleGroundHandler.cpp b/src/server/game/Handlers/BattleGroundHandler.cpp
index bcc698d..9f11acb 100644
--- a/src/server/game/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Handlers/BattleGroundHandler.cpp
@@ -22,6 +22,8 @@
 #include "ArenaTeamMgr.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
 
 #include "ArenaTeam.h"
 #include "BattlegroundMgr.h"
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 1c31bf4..828a1e5 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -45,7 +45,8 @@
 #include "World.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
-
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
 
 class LoginQueryHolder : public SQLQueryHolder
 {
@@ -896,6 +897,23 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     ObjectAccessor::AddObject(pCurrChar);
     //TC_LOG_DEBUG("Player %s added to Map.", pCurrChar->GetName().c_str());
 
+    //Send WG timer to player at login 
+    if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+        {
+            if (pvpWG->isWarTime()) // "Battle in progress"
+            {
+                pCurrChar->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL)));
+            } 
+            else // Time to next battle
+            {
+                pvpWG->SendInitWorldStatesTo(pCurrChar);
+                pCurrChar->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL) + pvpWG->GetTimer()));
+            }
+        }
+    }
+
     pCurrChar->SendInitialPacketsAfterAddToMap();
 
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ONLINE);
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index 758d5af..ad17f8a 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -45,6 +45,8 @@
 #include "BattlegroundMgr.h"
 #include "Battlefield.h"
 #include "BattlefieldMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 
 void WorldSession::HandleRepopRequestOpcode(WorldPacket& recvData)
 {
@@ -1714,6 +1716,15 @@ void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket& recvData)
 
     if (bg)
         sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
+    else
+    {  // Wintergrasp Hack till 3.3.5 and it's implemented as BG
+        if (GetPlayer()->GetZoneId() == 4197)
+        {
+            OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+            if (pvpWG && pvpWG->isWarTime())
+                pvpWG->SendAreaSpiritHealerQueryOpcode(_player, guid);
+        }
+    }
 
     if (Battlefield* bf = sBattlefieldMgr->GetBattlefieldToZoneId(_player->GetZoneId()))
         bf->SendAreaSpiritHealerQueryOpcode(_player, guid);
@@ -1737,6 +1748,15 @@ void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket& recvData)
 
     if (bg)
         bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
+    else
+    {  // Wintergrasp Hack till 3.3.5 and it's implemented as BG
+        if (GetPlayer()->GetZoneId() == 4197)
+        {
+            OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+            if (pvpWG && pvpWG->isWarTime())
+                pvpWG->AddPlayerToResurrectQueue(guid, _player->GetGUID());
+        }
+    }
 
     if (Battlefield* bf = sBattlefieldMgr->GetBattlefieldToZoneId(_player->GetZoneId()))
         bf->AddPlayerToResurrectQueue(guid, _player->GetGUID());
diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
index 73a9905..7de6186 100644
--- a/src/server/game/Miscellaneous/Language.h
+++ b/src/server/game/Miscellaneous/Language.h
@@ -748,6 +748,29 @@ enum TrinityStrings
 //  LANG_BG_AB_START_TWO_MINUTES        = 754, - defined above
 //  LANG_BG_EY_START_TWO_MINUTES        = 755, - defined above
 
+    // Wintergrasp
+    LANG_BG_WG_BATTLE_STARTS            = 756,
+    LANG_BG_WG_DEFENDED                 = 757,
+    LANG_BG_WG_CAPTURED                 = 758,
+    LANG_BG_WG_WORKSHOP_DAMAGED         = 759,
+    LANG_BG_WG_WORKSHOP_DESTROYED       = 760,
+    LANG_BG_WG_TOWER_DAMAGED            = 761,
+    LANG_BG_WG_TOWER_DESTROYED          = 762,
+    LANG_BG_WG_FORTRESS_UNDER_ATTACK    = 763,
+    LANG_BG_WG_SWITCH_FACTION           = 764,
+    LANG_BG_WG_CHANGE_TIMER             = 765,
+    LANG_BG_WG_BATTLE_FORCE_START       = 766,
+    LANG_BG_WG_BATTLE_FORCE_STOP        = 767,
+    LANG_BG_WG_STATUS                   = 768,
+    LANG_BG_WG_DISABLE                  = 769,
+    LANG_BG_WG_ENABLE                   = 770,
+    LANG_BG_WG_RANK1                    = 771,
+    LANG_BG_WG_RANK2                    = 772,
+    LANG_BG_WG_WORLD_ANNOUNCE_30        = 780,
+    LANG_BG_WG_WORLD_ANNOUNCE_10        = 781,
+    LANG_BG_WG_WORLD_NO_DEF             = 782,
+    LANG_BG_WG_WORLD_NO_ATK             = 783,
+
     // Room for BG/ARENA                = 773-784, 788-799 not used
     LANG_ARENA_TESTING                  = 785,
     LANG_AUTO_ANN                       = 786,
diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.h b/src/server/game/OutdoorPvP/OutdoorPvP.h
index 79f34ff..a289adf 100644
--- a/src/server/game/OutdoorPvP/OutdoorPvP.h
+++ b/src/server/game/OutdoorPvP/OutdoorPvP.h
@@ -31,10 +31,11 @@ enum OutdoorPvPTypes
     OUTDOOR_PVP_TF = 3,
     OUTDOOR_PVP_ZM = 4,
     OUTDOOR_PVP_SI = 5,
-    OUTDOOR_PVP_EP = 6
+    OUTDOOR_PVP_EP = 6,
+    OUTDOOR_PVP_WG = 7,
 };
 
-#define MAX_OUTDOORPVP_TYPES 7
+#define MAX_OUTDOORPVP_TYPES 8
 
 enum ObjectiveStates
 {
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index e983c9e..f07a6a9 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -77,6 +77,7 @@ void AddSC_tele_commandscript();
 void AddSC_ticket_commandscript();
 void AddSC_titles_commandscript();
 void AddSC_wp_commandscript();
+void AddSC_wg_commandscript();
 
 #ifdef SCRIPTS
 //world
@@ -680,6 +681,8 @@ void AddSC_outdoorpvp_na();
 void AddSC_outdoorpvp_si();
 void AddSC_outdoorpvp_tf();
 void AddSC_outdoorpvp_zm();
+void AddSC_outdoorpvp_wg();
+void AddSC_wintergrasp();
 
 // player
 void AddSC_chat_log();
@@ -766,6 +769,7 @@ void AddCommandScripts()
     AddSC_ticket_commandscript();
     AddSC_titles_commandscript();
     AddSC_wp_commandscript();
+	AddSC_wg_commandscript();
 }
 
 void AddWorldScripts()
@@ -1367,6 +1371,7 @@ void AddNorthrendScripts()
     AddSC_zuldrak();
     AddSC_crystalsong_forest();
     AddSC_isle_of_conquest();
+    AddSC_wintergrasp();
 #endif
 }
 
@@ -1398,6 +1403,7 @@ void AddOutdoorPvPScripts()
     AddSC_outdoorpvp_si();
     AddSC_outdoorpvp_tf();
     AddSC_outdoorpvp_zm();
+    AddSC_outdoorpvp_wg();
 #endif
 }
 
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index 63fe148..6eff352 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -54,6 +54,8 @@
 #include "Battlefield.h"
 #include "BattlefieldMgr.h"
 #include "TradeData.h"
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
 
 extern pEffect SpellEffects[TOTAL_SPELL_EFFECTS];
 
@@ -5478,8 +5480,17 @@ SpellCastResult Spell::CheckCast(bool strict)
                 {
                     Battlefield* Bf = sBattlefieldMgr->GetBattlefieldToZoneId(m_originalCaster->GetZoneId());
                     if (AreaTableEntry const* area = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
+                    {
                         if (area->flags & AREA_FLAG_NO_FLY_ZONE  || (Bf && !Bf->CanFlyIn()))
                             return (_triggeredCastFlags & TRIGGERED_DONT_REPORT_CAST_ERROR) ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
+                        // Wintergrasp Zone. Deny cast fly spells
+                        if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                        {
+                            OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+                            if (m_originalCaster->GetZoneId() == 4197 && pvpWG && pvpWG != 0  && pvpWG->isWarTime())
+                                return (_triggeredCastFlags & TRIGGERED_DONT_REPORT_CAST_ERROR) ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
+                        }
+                    }
                 }
                 break;
             }
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index f961654..237e15d 100644
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -54,6 +54,7 @@
 #include "InstanceScript.h"
 #include "PathGenerator.h"
 #include "ReputationMgr.h"
+#include "OutdoorPvPWG.h"
 
 pEffect SpellEffects[TOTAL_SPELL_EFFECTS]=
 {
@@ -3567,6 +3568,23 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
         {
             switch (m_spellInfo->Id)
             {
+                // Teleport to Lake Wintergrasp
+                case 58622:
+                {
+                  if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+                     if (unitTarget->getLevel() > 74)
+                     {
+                       if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
+                          unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
+                       else if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
+                          unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_HORDE_CAMP, true);
+                       else if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
+                          unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
+                       else if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
+                          unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_ALLIENCE_CAMP, true);
+                     }
+                    return;
+                }
                 // Glyph of Backstab
                 case 63975:
                 {
diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
index ff8fc45..b6fca0e 100644
--- a/src/server/game/Spells/SpellMgr.cpp
+++ b/src/server/game/Spells/SpellMgr.cpp
@@ -24,9 +24,10 @@
 #include "DBCStores.h"
 #include "Chat.h"
 #include "BattlegroundMgr.h"
-#include "BattlefieldWG.h"
 #include "BattlefieldMgr.h"
 #include "Player.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 
 bool IsPrimaryProfessionSkill(uint32 skill)
 {
@@ -1166,6 +1167,7 @@ bool SpellArea::IsFitToRequirements(Player const* player, uint32 newZone, uint32
                 return false;
             break;
         }
+/* Removed by Wintergrasp Patch
         case 58730: // No fly Zone - Wintergrasp
         {
             if (!player)
@@ -1175,7 +1177,7 @@ bool SpellArea::IsFitToRequirements(Player const* player, uint32 newZone, uint32
             if (!Bf || Bf->CanFlyIn() || (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY)))
                 return false;
             break;
-        }
+        }*/
         case 56618: // Horde Controls Factory Phase Shift
         case 56617: // Alliance Controls Factory Phase Shift
         {
@@ -1206,6 +1208,19 @@ bool SpellArea::IsFitToRequirements(Player const* player, uint32 newZone, uint32
                 return battlefieldWG->IsEnabled() && (player->GetTeamId() == battlefieldWG->GetDefenderTeam()) && !battlefieldWG->IsWarTime();
             break;
         }
+        case 58730: // No fly Zone - Wintergrasp
+        {
+            if (!player)
+                return false;
+
+            if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+            {
+                OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+                if ((pvpWG->isWarTime()==false) || player->isDead() || player->HasAura(45472) || player->HasAura(44795) || player->GetPositionZ() > 619.2f || player->IsInFlight() || (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY)))
+                   return false;
+            }
+            break;
+        }
         case 74411: // Battleground - Dampening
         {
             if (!player)
@@ -3687,6 +3702,13 @@ void SpellMgr::LoadSpellInfoCorrections()
                 break;
             // ENDOF ICECROWN CITADEL SPELLS
             //
+            // WINTERGRASP
+            //
+            case 51678: // WintergraspSiegeEngine Ram set radius of damage for units to 5 yards 
+                spellInfo->Effects[EFFECT_0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_5_YARDS); // SPELL_EFFECT_KNOCK_BACK
+                spellInfo->Effects[EFFECT_1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_5_YARDS); // SPELL_EFFECT_SCHOOL_DAMAGE
+                spellInfo->Effects[EFFECT_2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_20_YARDS); // SPELL_EFFECT_WMO_DAMAGE, Huck but it must be -> Fortress towers are much bigger than original WMO damage radius of spell
+                break;
             // RUBY SANCTUM SPELLS
             //
             case 74799: // Soul Consumption
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index e1fc737..bacafcb 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -62,6 +62,7 @@
 #include "VMapFactory.h"
 #include "WardenCheckMgr.h"
 #include "WaypointMovementGenerator.h"
+#include "OutdoorPvPWG.h"
 #include "WeatherMgr.h"
 #include "WorldSession.h"
 // Prepatch by LordPsyan
@@ -1305,14 +1306,22 @@ void World::LoadConfigSettings(bool reload)
     m_bool_configs[CONFIG_PDUMP_NO_OVERWRITE] = sConfigMgr->GetBoolDefault("PlayerDump.DisallowOverwrite", true);
     m_bool_configs[CONFIG_UI_QUESTLEVELS_IN_DIALOGS] = sConfigMgr->GetBoolDefault("UI.ShowQuestLevelsInDialogs", false);
 
-    // Wintergrasp battlefield
-    m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfigMgr->GetBoolDefault("Wintergrasp.Enable", false);
-    m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMax", 100);
-    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMin", 0);
-    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN_LVL] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMinLvl", 77);
-    m_int_configs[CONFIG_WINTERGRASP_BATTLETIME] = sConfigMgr->GetIntDefault("Wintergrasp.BattleTimer", 30);
-    m_int_configs[CONFIG_WINTERGRASP_NOBATTLETIME] = sConfigMgr->GetIntDefault("Wintergrasp.NoBattleTimer", 150);
-    m_int_configs[CONFIG_WINTERGRASP_RESTART_AFTER_CRASH] = sConfigMgr->GetIntDefault("Wintergrasp.CrashRestartTimer", 10);
+    //Wintergrasp
+    m_bool_configs[CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED]         = sConfigMgr->GetBoolDefault("OutdoorPvP.Wintergrasp.Enabled", true);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD] = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.SaveState.Period", 10000);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME]       = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.StartTime", 30);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME]      = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.BattleTime", 30);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL]         = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.Interval", 150);
+    m_bool_configs[CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR]    = sConfigMgr->GetBoolDefault("OutdoorPvP.Wintergrasp.CustomHonorRewards", false);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE]       = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorBattleWin", 3000);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE]      = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorBattleLose", 1250);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER]    = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDamageTower", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER]  = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING] = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING]  = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding", 1500);
+    m_bool_configs[CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE]  = sConfigMgr->GetBoolDefault("OutdoorPvP.Wintergrasp.Antifarm.Enable", false);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK]  = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.Antifarm.Atk", 5);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF]  = sConfigMgr->GetIntDefault("OutdoorPvP.Wintergrasp.Antifarm.Def", 5);
 
     // Stats limits
     m_bool_configs[CONFIG_STATS_LIMITS_ENABLE] = sConfigMgr->GetBoolDefault("Stats.Limits.Enable", false);
@@ -3352,3 +3361,29 @@ void World::RemoveOldCorpses()
     m_timers[WUPDATE_CORPSES].SetCurrent(m_timers[WUPDATE_CORPSES].GetInterval());
 }
 
+
+void World::SendWintergraspState()
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG)
+        return;
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (!itr->second || !itr->second->GetPlayer() || !itr->second->GetPlayer()->IsInWorld())
+            continue;
+
+        if (pvpWG->isWarTime()) // "Battle in progress"
+        {
+            itr->second->GetPlayer()->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL)));
+        } 
+        else // Time to next battle
+        {
+            pvpWG->SendInitWorldStatesTo(itr->second->GetPlayer());
+            itr->second->GetPlayer()->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL) + pvpWG->GetTimer()));
+            // Hide unneeded info which in center of screen
+            itr->second->GetPlayer()->SendInitWorldStates(itr->second->GetPlayer()->GetZoneId(), itr->second->GetPlayer()->GetAreaId());
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 7a3e56c..46ed590 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -154,8 +154,10 @@ enum WorldBoolConfigs
     CONFIG_QUEST_IGNORE_AUTO_COMPLETE,
     CONFIG_QUEST_ENABLE_QUEST_TRACKER,
     CONFIG_WARDEN_ENABLED,
+    CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED,
+    CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR,
+    CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE,
     CONFIG_ENABLE_MMAPS,
-    CONFIG_WINTERGRASP_ENABLE,
     CONFIG_UI_QUESTLEVELS_IN_DIALOGS,     // Should we add quest levels to the title in the NPC dialogs?
     CONFIG_EVENT_ANNOUNCE,
     CONFIG_STATS_LIMITS_ENABLE,
@@ -399,12 +401,18 @@ enum WorldIntConfigs
     CONFIG_WARDEN_CLIENT_BAN_DURATION,
     CONFIG_WARDEN_NUM_MEM_CHECKS,
     CONFIG_WARDEN_NUM_OTHER_CHECKS,
-    CONFIG_WINTERGRASP_PLR_MAX,
-    CONFIG_WINTERGRASP_PLR_MIN,
-    CONFIG_WINTERGRASP_PLR_MIN_LVL,
-    CONFIG_WINTERGRASP_BATTLETIME,
-    CONFIG_WINTERGRASP_NOBATTLETIME,
-    CONFIG_WINTERGRASP_RESTART_AFTER_CRASH,
+    CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME,
+    CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME,
+    CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL,
+    CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE,
+    CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING,
+    CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING,
+    CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD,
+    CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK,
+    CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF,
     CONFIG_PACKET_SPOOF_POLICY,
     CONFIG_PACKET_SPOOF_BANMODE,
     CONFIG_PACKET_SPOOF_BANDURATION,
@@ -859,6 +867,18 @@ class World
         void UpdateCharacterInfo(ObjectGuid const& guid, std::string const& name, uint8 gender = GENDER_NONE, uint8 race = RACE_NONE);
         void UpdateCharacterInfoLevel(ObjectGuid const& guid, uint8 level);
 
+        // Wintergrasp
+        uint32 GetWintergrapsTimer() { return m_WintergrapsTimer; }
+        uint32 GetWintergrapsState() { return m_WintergrapsState; }
+        uint32 m_WintergrapsTimer;
+        uint32 m_WintergrapsState;
+        void SendWintergraspState();
+        void SetWintergrapsTimer(uint32 timer, uint32 state)
+        {
+            m_WintergrapsTimer = timer;
+            m_WintergrapsState = state;
+        }
+
         uint32 GetCleaningFlags() const { return m_CleaningFlags; }
         void   SetCleaningFlags(uint32 flags) { m_CleaningFlags = flags; }
         void   ResetEventSeasonalQuests(uint16 event_id);
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index a15b6f8..821c8b3 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -68,7 +68,6 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouseBot
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
-  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
   ${CMAKE_SOURCE_DIR}/src/server/game/Chat
@@ -108,6 +107,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Spline
   ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
   ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
   ${CMAKE_SOURCE_DIR}/src/server/game/Pools
   ${CMAKE_SOURCE_DIR}/src/server/game/Quests
   ${CMAKE_SOURCE_DIR}/src/server/game/Reputation
diff --git a/src/server/scripts/Commands/cs_wintergrasp.cpp b/src/server/scripts/Commands/cs_wintergrasp.cpp
new file mode 100644
index 0000000..1b17d98
--- /dev/null
+++ b/src/server/scripts/Commands/cs_wintergrasp.cpp
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2008 - 2012 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2012 Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "ScriptMgr.h"
+#include "Chat.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
+#include "Language.h"
+
+class wg_commandscript : public CommandScript
+{
+public:
+    wg_commandscript() : CommandScript("wg_commandscript") { }
+
+    std::vector<ChatCommand> GetCommands() const override
+    {
+        static std::vector<ChatCommand> wintergraspCommandTable =
+        {
+            { "status",      rbac::RBAC_PERM_COMMAND_WG_STATUS,     false, &HandleWintergraspStatusCommand,       "" },
+            { "enable",      rbac::RBAC_PERM_COMMAND_WG_ENABLE,     false, &HandleWintergraspEnableCommand,       "" },
+            { "start",       rbac::RBAC_PERM_COMMAND_WG_START,      false, &HandleWintergraspStartCommand,        "" },
+            { "stop",        rbac::RBAC_PERM_COMMAND_WG_STOP,       false, &HandleWintergraspStopCommand,         "" },
+            { "switch",      rbac::RBAC_PERM_COMMAND_WG_SWITCH,     false, &HandleWintergraspSwitchTeamCommand,   "" },
+            { "timer",       rbac::RBAC_PERM_COMMAND_WG_TIMER,      false, &HandleWintergraspTimerCommand,        "" },
+        };
+        static std::vector<ChatCommand> commandTable =
+        {
+            { "wg",   rbac::RBAC_PERM_COMMAND_WG,   false, NULL, "", wintergraspCommandTable },
+        };
+        return commandTable;
+    }
+
+    static bool HandleWintergraspStatusCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+        if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        {
+            handler->SendSysMessage(LANG_BG_WG_DISABLE);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage(LANG_BG_WG_STATUS, sObjectMgr->GetTrinityStringForDBCLocale(
+            pvpWG->getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE),
+            secsToTimeString(pvpWG->GetTimer(), true).c_str(),
+            pvpWG->isWarTime() ? "Yes" : "No",
+            pvpWG->GetNumPlayersH(),
+            pvpWG->GetNumPlayersA());
+        return true;
+    }
+
+    static bool HandleWintergraspStartCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+        if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        {
+            handler->SendSysMessage(LANG_BG_WG_DISABLE);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        pvpWG->forceStartBattle();
+        handler->PSendSysMessage(LANG_BG_WG_BATTLE_FORCE_START);
+        return true;
+    }
+
+    static bool HandleWintergraspStopCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+        if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        {
+            handler->SendSysMessage(LANG_BG_WG_DISABLE);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        pvpWG->forceStopBattle();
+        handler->PSendSysMessage(LANG_BG_WG_BATTLE_FORCE_STOP);
+        return true;
+    }
+
+    static bool HandleWintergraspEnableCommand(ChatHandler* handler, const char* args)
+    {
+        if(!*args)
+            return false;
+
+        OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+        /*if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        {
+            handler->SendSysMessage(LANG_BG_WG_DISABLE);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }*/
+
+        if (!strncmp(args, "on", 3))
+        {
+            if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+            {
+                pvpWG->forceStopBattle();
+                sWorld->setBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED, true);
+            }
+            handler->PSendSysMessage(LANG_BG_WG_ENABLE);
+            return true;
+        }
+        else if (!strncmp(args, "off", 4))
+        {
+            if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+            {
+                pvpWG->forceStopBattle();
+                sWorld->setBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED, false);
+            }
+            handler->PSendSysMessage(LANG_BG_WG_DISABLE);
+            return true;
+        }
+        else
+        {
+            handler->SendSysMessage(LANG_USE_BOL);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+    }
+
+    static bool HandleWintergraspTimerCommand(ChatHandler* handler, const char* args)
+    {
+        if(!*args)
+            return false;
+
+        OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+        if (!pvpWG)
+        {
+            handler->SendSysMessage(LANG_BG_WG_DISABLE);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        int32 time = atoi (args);
+
+        // Min value 1 min
+        if (1 > time)
+            time = 1;
+        // Max value during wartime = 60. No wartime = 1440 (day)
+        if (pvpWG->isWarTime())
+        {
+            if (60 < time)
+                return false;
+        }
+        else if (1440 < time)
+            return false;
+
+        time *= MINUTE * IN_MILLISECONDS;
+
+        pvpWG->setTimer((uint32)time);
+        sWorld->SendWintergraspState(); //Update WG time at bg tab
+        handler->PSendSysMessage(LANG_BG_WG_CHANGE_TIMER, secsToTimeString(pvpWG->GetTimer(), true).c_str());
+        return true;
+    }
+
+    static bool HandleWintergraspSwitchTeamCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+        if (!pvpWG)
+        {
+            handler->SendSysMessage(LANG_BG_WG_DISABLE);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        uint32 timer = pvpWG->GetTimer();
+        pvpWG->forceChangeTeam();
+        pvpWG->setTimer(timer);
+        handler->PSendSysMessage(LANG_BG_WG_SWITCH_FACTION, handler->GetTrinityString(pvpWG->getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+        return true;
+    }
+};
+
+void AddSC_wg_commandscript()
+{
+    new wg_commandscript();
+}
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
index 1dc453a..7ed72ed 100644
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -10,7 +10,7 @@
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
-  Northrend/zone_wintergrasp.cpp
+  Northrend/wintergrasp.cpp
   Northrend/isle_of_conquest.cpp
   Northrend/zone_storm_peaks.cpp
   Northrend/Ulduar/HallsOfLightning/instance_halls_of_lightning.cpp
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
index 988346a..b94c169 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
@@ -18,6 +18,8 @@
 #include "ScriptMgr.h"
 #include "InstanceScript.h"
 #include "vault_of_archavon.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 
 /* Vault of Archavon encounters:
 1 - Archavon the Stone Watcher event
@@ -43,6 +45,16 @@ class instance_vault_of_archavon : public InstanceMapScript
                 KoralonDeath    = 0;
             }
 
+            void OnPlayerEnter(Player *player)
+            {
+                if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                {
+                    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+                    if (pvpWG && !player->IsGameMaster() && player->GetTeamId() != pvpWG->getDefenderTeam())
+                        player->CastSpell(player, SPELL_TELEPORT_FORTRESS, true);
+                }
+            }
+
             void OnCreatureCreate(Creature* creature) override
             {
                 switch (creature->GetEntry())
diff --git a/src/server/scripts/Northrend/wintergrasp.cpp b/src/server/scripts/Northrend/wintergrasp.cpp
new file mode 100644
index 0000000..677d772
--- /dev/null
+++ b/src/server/scripts/Northrend/wintergrasp.cpp
@@ -0,0 +1,439 @@
+/*
+ * Copyright (C) 2008 - 2012 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2012 Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
+#include "Vehicle.h"
+
+#define GOSSIP_HELLO_DEMO1  "Build catapult."
+#define GOSSIP_HELLO_DEMO2  "Build demolisher."
+#define GOSSIP_HELLO_DEMO3  "Build siege engine."
+#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
+
+class npc_demolisher_engineerer : public CreatureScript
+{
+public:
+    npc_demolisher_engineerer() : CreatureScript("npc_demolisher_engineerer") { }
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if (pCreature->IsQuestGiver())
+        pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+    if(pPlayer->IsGameMaster() || pCreature->GetZoneScript() && pCreature->GetZoneScript()->GetData(pCreature->GetSpawnId()))
+    {
+        if (pPlayer->HasAura(SPELL_CORPORAL))
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+        else if (pPlayer->HasAura(SPELL_LIEUTENANT))
+        {
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+1);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+2);
+        }
+    }
+    else
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+9);
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    if(pPlayer->IsGameMaster() || pCreature->GetZoneScript() && pCreature->GetZoneScript()->GetData(pCreature->GetSpawnId()))
+    {
+        switch(uiAction - GOSSIP_ACTION_INFO_DEF)
+        {
+            case 0: pPlayer->CastSpell(pPlayer, 56663, false, NULL, NULL, pCreature->GetGUID()); break;
+            case 1: pPlayer->CastSpell(pPlayer, 56575, false, NULL, NULL, pCreature->GetGUID()); break;
+            case 2: pPlayer->CastSpell(pPlayer, pPlayer->GetTeamId() ? 61408 : 56661, false, NULL, NULL, pCreature->GetGUID()); break;
+        }
+    }
+
+    return true;
+}
+
+    CreatureAI* GetAI(Creature* pCreature) const
+    {
+        return new npc_demolisher_engineererAI(pCreature);
+    }
+
+    struct npc_demolisher_engineererAI : public ScriptedAI
+    {
+        npc_demolisher_engineererAI(Creature* pCreature) : ScriptedAI(pCreature)
+        {
+            me->SetReactState(REACT_PASSIVE);
+        }
+    };
+
+};
+
+enum eWintergraspBattleMage
+{
+    SPELL_PORTAL_VISUAL        = 60223,
+    GO_WINTERGRASP_PORTAL    = 193772
+};
+
+class npc_wg_ally_battle_mage : public CreatureScript
+{
+public:
+    npc_wg_ally_battle_mage() : CreatureScript("npc_wg_ally_battle_mage") { }
+
+    CreatureAI *GetAI(Creature *creature) const
+    {
+        return new npc_wg_ally_battle_mageAI(creature);
+    }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+            return false;
+
+        if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+        {
+            if (pvpWG->isWarTime())
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14777, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14781, pCreature->GetGUID());
+            }
+            else
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14775, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14782, pCreature->GetGUID());
+            }
+        }
+        return true;
+    }
+
+    struct npc_wg_ally_battle_mageAI : public ScriptedAI
+    {
+        npc_wg_ally_battle_mageAI(Creature* pCreature) : ScriptedAI(pCreature)
+        {
+            uiPortalTimer = 0;
+            uiPortalPhase = 0;
+            Check = true;
+        }
+
+        uint32 uiPortalTimer;
+        uint8 uiPortalPhase;
+        GameObject* WintergraspPortal;
+        bool Player;
+        bool Check;
+        bool Check2;
+
+        void UpdateAI(const uint32 diff)
+        {
+            // If WG is disabled, don't do anything.
+            if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                return;
+
+            if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+            {
+                // Get playerlist if there is.
+                if (pvpWG->isWarTime() && Check == true)
+                {
+                    Map::PlayerList const &PlayerList = me->GetMap()->GetPlayers();
+                    for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                    {
+                        if (!PlayerList.isEmpty())
+                        {
+                            if (i->GetSource()->GetDistance2d(me) <= 75)
+                            {
+                                Player = true;
+                                Check = false;
+                            }
+                            else
+                            {
+                                Player = false;
+                                Check = false;
+                                Check2 = true;
+                            }
+                        }
+                        else
+                        {
+                            Player = false;
+                            Check = false;
+                            Check2 = true;
+                        }
+                    }
+                }
+
+                if (pvpWG->m_changeAlly != true) // If wg is switching (.wg switch)
+                {
+                    if (pvpWG->isWarTime())
+                    {
+                        if (Player == true) //(false) If there isn't any player, then, don't cast the portal spell. Just summon gameobject.
+                        {
+                            if (uiPortalTimer <= diff)
+                            {
+                                switch (uiPortalPhase)
+                                {
+                                case 0:
+                                    me->SetOrientation(4.037271f);
+                                    me->SendMovementFlagUpdate();
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 100;
+                                    break;
+                                case 1:
+                                    me->AI()->DoCast(SPELL_PORTAL_VISUAL);
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 900;
+                                    break;
+                                case 2:
+                                    WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5686.974609f, 773.303711f, 647.753235f, 5.572729f, 0, 0, 0.324484f, -0.945891f, 0);
+                                    me->SetOrientation(5.515240f);
+                                    me->SendMovementFlagUpdate();
+                                    me->Yell("Reinforcements are needed on the Wintergrasp battlefield! I have opened a portal for quick travel to the battle at The Silver Enclave.", LANG_UNIVERSAL, 0);
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 1000;
+                                    break;
+                                }
+                            }else uiPortalTimer -= diff;
+                        }
+                        else
+                        {
+                            if (Check2 == true) // If the portal isn't exist
+                            {
+                                WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5686.974609f, 773.303711f, 647.753235f, 5.572729f, 0, 0, 0.324484f, -0.945891f, 0);
+                                Check2 = false;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (pvpWG->getDefenderTeam() == TEAM_ALLIANCE)
+                        {
+                            if (pvpWG->m_timer <= 3600000) // An hour before battle begin, the portal will disappear.
+                            {
+                                uiPortalTimer = 0;
+                                uiPortalPhase = 0;
+                                Check = true;
+                                Check2 = false;
+                                if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                    WintergraspPortal->RemoveFromWorld();
+                            }
+                        }
+                        else
+                        {
+                            uiPortalTimer = 0;
+                            uiPortalPhase = 0;
+                            Check = true;
+                            Check2 = false;
+                            if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                WintergraspPortal->RemoveFromWorld();
+                        }
+                    }
+                }
+            }
+        }
+    };
+};
+
+class npc_wg_horde_battle_mage : public CreatureScript
+{
+public:
+    npc_wg_horde_battle_mage() : CreatureScript("npc_wg_horde_battle_mage") { }
+
+    CreatureAI *GetAI(Creature *creature) const
+    {
+        return new npc_wg_horde_battle_mageAI(creature);
+    }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+            return false;
+
+        if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+        {
+            if (pvpWG->isWarTime())
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14777, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14781, pCreature->GetGUID());
+            }
+            else
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14775, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14782, pCreature->GetGUID());
+            }
+        }
+        return true;
+    }
+
+    struct npc_wg_horde_battle_mageAI : public ScriptedAI
+    {
+        npc_wg_horde_battle_mageAI(Creature* pCreature) : ScriptedAI(pCreature)
+        {
+            uiPortalTimer = 0;
+            uiPortalPhase = 0;
+            Check = true;
+        }
+
+        uint32 uiPortalTimer;
+        uint8 uiPortalPhase;
+        GameObject* WintergraspPortal;
+        bool Player;
+        bool Check;
+        bool Check2;
+
+        void UpdateAI(const uint32 diff)
+        {
+            // If WG is disabled, don't do anything.
+            if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                return;
+
+            if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+            {
+                // Get playerlist if there is.
+                if (pvpWG->isWarTime() && Check == true)
+                {
+                    Map::PlayerList const &PlayerList = me->GetMap()->GetPlayers();
+                    for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                    {
+                        if (!PlayerList.isEmpty())
+                        {
+                            if (i->GetSource()->GetDistance2d(me) <= 75)
+                            {
+                                Player = true;
+                                Check = false;
+                            }
+                            else
+                            {
+                                Player = false;
+                                Check = false;
+                                Check2 = true;
+                            }
+                        }
+                        else
+                        {
+                            Player = false;
+                            Check = false;
+                            Check2 = true;
+                        }
+                    }
+                }
+
+                if (pvpWG->m_changeHorde != true) // If wg is switching (.wg switch)
+                {
+                    if (pvpWG->isWarTime())
+                    {
+                        if (Player == true) //(false) If there isn't any player, then, don't cast the portal spell. Just summon gameobject.
+                        {
+                            if (uiPortalTimer <= diff)
+                            {
+                                switch (uiPortalPhase)
+                                {
+                                case 0:
+                                    me->SetOrientation(4.356160f);
+                                    me->SendMovementFlagUpdate();
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 100;
+                                    break;
+                                case 1:
+                                    me->AI()->DoCast(SPELL_PORTAL_VISUAL);
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 900;
+                                    break;
+                                case 2:
+                                    WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5924.042969f, 570.354492f, 661.087280f, 5.930885f, 0, 0, 0.324484f, -0.945891f, 0);
+                                    me->SetOrientation(6.003930f);
+                                    me->SendMovementFlagUpdate();
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 1000;
+                                    break;
+                                }
+                            }else uiPortalTimer -= diff;
+                        }
+                        else
+                        {
+                            if (Check2 == true) // If the portal isn't exist
+                            {
+                                WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5686.974609f, 773.303711f, 647.753235f, 5.572729f, 0, 0, 0.324484f, -0.945891f, 0);
+                                Check2 = false;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                        {
+                            if (pvpWG->m_timer <= 3600000) // An hour before battle begin, the portal will disappear.
+                            {
+                                uiPortalTimer = 0;
+                                uiPortalPhase = 0;
+                                Check = true;
+                                Check2 = false;
+                                if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                    WintergraspPortal->RemoveFromWorld();
+                            }
+                        }
+                        else
+                        {
+                            uiPortalTimer = 0;
+                            uiPortalPhase = 0;
+                            Check = true;
+                            Check2 = false;
+                            if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                WintergraspPortal->RemoveFromWorld();
+                        }
+                    }
+                }
+            }
+        }
+    };
+};
+
+class go_wg_veh_teleporter : public GameObjectScript
+{
+public:
+    go_wg_veh_teleporter() : GameObjectScript("go_wg_veh_teleporter") { }
+
+    bool OnGossipHello(Player* player, GameObject* go)
+    {
+        if (GameObject* trigger = go->FindNearestGameObject(190375, 500)) // Wintergrasp Fortress Gate
+        {
+            if (Vehicle* vehicle = player->GetVehicle())
+            {
+                Position triggerPos;
+                trigger->GetPositionX();
+                triggerPos.m_positionX -= 30;
+                vehicle->Relocate(triggerPos);
+            }
+        }
+        return true;
+    }
+};
+
+void AddSC_wintergrasp()
+{
+    new npc_demolisher_engineerer();
+    new npc_wg_ally_battle_mage();
+    new npc_wg_horde_battle_mage();
+    new go_wg_veh_teleporter();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/zone_wintergrasp.cpp b/src/server/scripts/Northrend/zone_wintergrasp.cpp
deleted file mode 100644
index b0059de..0000000
--- a/src/server/scripts/Northrend/zone_wintergrasp.cpp
+++ /dev/null
@@ -1,643 +0,0 @@
-/* Copyright (C) 2008 - 2009 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "BattlefieldMgr.h"
-#include "BattlefieldWG.h"
-#include "Battlefield.h"
-#include "ScriptSystem.h"
-#include "WorldSession.h"
-#include "ObjectMgr.h"
-#include "Vehicle.h"
-#include "GameObjectAI.h"
-#include "ScriptedCreature.h"
-#include "ScriptedGossip.h"
-#include "SpellScript.h"
-#include "Player.h"
-
-#define GOSSIP_HELLO_DEMO1  "Build catapult."
-#define GOSSIP_HELLO_DEMO2  "Build demolisher."
-#define GOSSIP_HELLO_DEMO3  "Build siege engine."
-#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
-
-enum WGqueuenpctext
-{
-    WG_NPCQUEUE_TEXT_H_NOWAR            = 14775,
-    WG_NPCQUEUE_TEXT_H_QUEUE            = 14790,
-    WG_NPCQUEUE_TEXT_H_WAR              = 14777,
-    WG_NPCQUEUE_TEXT_A_NOWAR            = 14782,
-    WG_NPCQUEUE_TEXT_A_QUEUE            = 14791,
-    WG_NPCQUEUE_TEXT_A_WAR              = 14781,
-    WG_NPCQUEUE_TEXTOPTION_JOIN         = 20077,
-};
-
-enum Spells
-{
-    // Demolisher engineers spells
-    SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE     = 61409,
-    SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE  = 56662,
-    SPELL_BUILD_CATAPULT_FORCE                = 56664,
-    SPELL_BUILD_DEMOLISHER_FORCE              = 56659,
-    SPELL_ACTIVATE_CONTROL_ARMS               = 49899,
-    SPELL_RIDE_WG_VEHICLE                     = 60968,
-
-    SPELL_VEHICLE_TELEPORT                    = 49759,
-
-    // Spirit guide
-    SPELL_CHANNEL_SPIRIT_HEAL                 = 22011,
-};
-
-enum CreatureIds
-{
-    NPC_GOBLIN_MECHANIC                             = 30400,
-    NPC_GNOMISH_ENGINEER                            = 30499,
-
-    NPC_WINTERGRASP_CONTROL_ARMS                    = 27852,
-
-    NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC   = 23472,
-};
-
-enum QuestIds
-{
-    QUEST_BONES_AND_ARROWS_HORDE_ATT              = 13193,
-    QUEST_JINXING_THE_WALLS_HORDE_ATT             = 13202,
-    QUEST_SLAY_THEM_ALL_HORDE_ATT                 = 13180,
-    QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT       = 13200,
-    QUEST_HEALING_WITH_ROSES_HORDE_ATT            = 13201,
-    QUEST_DEFEND_THE_SIEGE_HORDE_ATT              = 13223,
-
-    QUEST_BONES_AND_ARROWS_HORDE_DEF              = 13199,
-    QUEST_WARDING_THE_WALLS_HORDE_DEF             = 13192,
-    QUEST_SLAY_THEM_ALL_HORDE_DEF                 = 13178,
-    QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF       = 13191,
-    QUEST_HEALING_WITH_ROSES_HORDE_DEF            = 13194,
-    QUEST_TOPPLING_THE_TOWERS_HORDE_DEF           = 13539,
-    QUEST_STOP_THE_SIEGE_HORDE_DEF                = 13185,
-
-    QUEST_BONES_AND_ARROWS_ALLIANCE_ATT           = 13196,
-    QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT       = 13198,
-    QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT = 13179,
-    QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT           = 13222,
-    QUEST_A_RARE_HERB_ALLIANCE_ATT                = 13195,
-
-    QUEST_BONES_AND_ARROWS_ALLIANCE_DEF           = 13154,
-    QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF       = 13153,
-    QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF = 13177,
-    QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF         = 13538,
-    QUEST_STOP_THE_SIEGE_ALLIANCE_DEF             = 13186,
-    QUEST_A_RARE_HERB_ALLIANCE_DEF                = 13156,
-};
-
-uint8 const MAX_WINTERGRASP_VEHICLES = 4;
-
-uint32 const vehiclesList[MAX_WINTERGRASP_VEHICLES] =
-{
-    NPC_WINTERGRASP_CATAPULT,
-    NPC_WINTERGRASP_DEMOLISHER,
-    NPC_WINTERGRASP_SIEGE_ENGINE_ALLIANCE,
-    NPC_WINTERGRASP_SIEGE_ENGINE_HORDE
-};
-
-class npc_wg_demolisher_engineer : public CreatureScript
-{
-    public:
-        npc_wg_demolisher_engineer() : CreatureScript("npc_wg_demolisher_engineer") { }
-
-        bool OnGossipHello(Player* player, Creature* creature) override
-        {
-            if (creature->IsQuestGiver())
-                player->PrepareQuestMenu(creature->GetGUID());
-
-            if (CanBuild(creature))
-            {
-                if (player->HasAura(SPELL_CORPORAL))
-                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-                else if (player->HasAura(SPELL_LIEUTENANT))
-                {
-                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
-                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);
-                }
-            }
-            else
-                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 9);
-
-            player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
-            return true;
-        }
-
-        bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action) override
-        {
-            player->CLOSE_GOSSIP_MENU();
-
-            if (CanBuild(creature))
-            {
-                switch (action - GOSSIP_ACTION_INFO_DEF)
-                {
-                    case 0:
-                        creature->CastSpell(player, SPELL_BUILD_CATAPULT_FORCE, true);
-                        break;
-                    case 1:
-                        creature->CastSpell(player, SPELL_BUILD_DEMOLISHER_FORCE, true);
-                        break;
-                    case 2:
-                        creature->CastSpell(player, player->GetTeamId() == TEAM_ALLIANCE ? SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE : SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE, true);
-                        break;
-                }
-                if (Creature* controlArms = creature->FindNearestCreature(NPC_WINTERGRASP_CONTROL_ARMS, 30.0f, true))
-                    creature->CastSpell(controlArms, SPELL_ACTIVATE_CONTROL_ARMS, true);
-            }
-            return true;
-        }
-
-    private:
-        bool CanBuild(Creature* creature)
-        {
-            Battlefield* wintergrasp = sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
-            if (!wintergrasp)
-                return false;
-
-            switch (creature->GetEntry())
-            {
-                case NPC_GOBLIN_MECHANIC:
-                    return (wintergrasp->GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H) > wintergrasp->GetData(BATTLEFIELD_WG_DATA_VEHICLE_H));
-                case NPC_GNOMISH_ENGINEER:
-                    return (wintergrasp->GetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) > wintergrasp->GetData(BATTLEFIELD_WG_DATA_VEHICLE_A));
-                default:
-                    return false;
-            }
-        }
-};
-
-class npc_wg_spirit_guide : public CreatureScript
-{
-    public:
-        npc_wg_spirit_guide() : CreatureScript("npc_wg_spirit_guide") { }
-
-        bool OnGossipHello(Player* player, Creature* creature) override
-        {
-            if (creature->IsQuestGiver())
-                player->PrepareQuestMenu(creature->GetGUID());
-
-            Battlefield* wintergrasp = sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
-            if (!wintergrasp)
-                return true;
-
-            GraveyardVect graveyard = wintergrasp->GetGraveyardVector();
-            for (uint8 i = 0; i < graveyard.size(); i++)
-                if (graveyard[i]->GetControlTeamId() == player->GetTeamId())
-                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, player->GetSession()->GetTrinityString(((BfGraveyardWG*)graveyard[i])->GetTextId()), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + i);
-
-            player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
-            return true;
-        }
-
-        bool OnGossipSelect(Player* player, Creature* /*creature*/, uint32 /*sender*/, uint32 action) override
-        {
-            player->CLOSE_GOSSIP_MENU();
-
-            Battlefield* wintergrasp = sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
-            if (wintergrasp)
-            {
-                GraveyardVect gy = wintergrasp->GetGraveyardVector();
-                for (uint8 i = 0; i < gy.size(); i++)
-                    if (action - GOSSIP_ACTION_INFO_DEF == i && gy[i]->GetControlTeamId() == player->GetTeamId())
-                        if (WorldSafeLocsEntry const* safeLoc = sWorldSafeLocsStore.LookupEntry(gy[i]->GetGraveyardId()))
-                            player->TeleportTo(safeLoc->map_id, safeLoc->x, safeLoc->y, safeLoc->z, 0);
-            }
-            return true;
-        }
-
-        struct npc_wg_spirit_guideAI : public ScriptedAI
-        {
-            npc_wg_spirit_guideAI(Creature* creature) : ScriptedAI(creature) { }
-
-            void UpdateAI(uint32 /*diff*/) override
-            {
-                if (!me->HasUnitState(UNIT_STATE_CASTING))
-                    DoCast(me, SPELL_CHANNEL_SPIRIT_HEAL);
-            }
-        };
-
-        CreatureAI* GetAI(Creature* creature) const override
-        {
-            return new npc_wg_spirit_guideAI(creature);
-        }
-};
-
-enum WGQueue
-{
-    SPELL_FROST_ARMOR                               = 12544
-};
-
-class npc_wg_queue : public CreatureScript
-{
-    public:
-        npc_wg_queue() : CreatureScript("npc_wg_queue") { }
-
-    struct npc_wg_queueAI : public ScriptedAI
-    {
-        npc_wg_queueAI(Creature* creature) : ScriptedAI(creature)
-        {
-            FrostArmor_Timer = 0;
-        }
-
-        uint32 FrostArmor_Timer;
-
-        void Reset() override
-        {
-            FrostArmor_Timer = 0;
-        }
-
-        void EnterCombat(Unit* /*who*/) override { }
-
-        void UpdateAI(uint32 diff) override
-        {
-            if (FrostArmor_Timer <= diff)
-            {
-                DoCast(me, SPELL_FROST_ARMOR);
-                FrostArmor_Timer = 180000;
-            }
-            else FrostArmor_Timer -= diff;
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
-    CreatureAI* GetAI(Creature* creature) const override
-    {
-        return new npc_wg_queueAI(creature);
-    }
-
-        bool OnGossipHello(Player* player, Creature* creature) override
-        {
-            if (creature->IsQuestGiver())
-                player->PrepareQuestMenu(creature->GetGUID());
-
-            Battlefield* wintergrasp = sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
-            if (!wintergrasp)
-                return true;
-
-            if (wintergrasp->IsWarTime())
-            {
-                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, player->GetSession()->GetTrinityString(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-                player->SEND_GOSSIP_MENU(wintergrasp->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR, creature->GetGUID());
-            }
-            else
-            {
-                uint32 timer = wintergrasp->GetTimer() / 1000;
-                player->SendUpdateWorldState(4354, time(NULL) + timer);
-                if (timer < 15 * MINUTE)
-                {
-                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, player->GetSession()->GetTrinityString(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
-                    player->SEND_GOSSIP_MENU(wintergrasp->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE, creature->GetGUID());
-                }
-                else
-                    player->SEND_GOSSIP_MENU(wintergrasp->GetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR, creature->GetGUID());
-            }
-            return true;
-        }
-
-        bool OnGossipSelect(Player* player, Creature* /*creature*/, uint32 /*sender*/, uint32 /*action*/) override
-        {
-            player->CLOSE_GOSSIP_MENU();
-
-            Battlefield* wintergrasp = sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
-            if (!wintergrasp)
-                return true;
-
-            if (wintergrasp->IsWarTime())
-                wintergrasp->InvitePlayerToWar(player);
-            else
-            {
-                uint32 timer = wintergrasp->GetTimer() / 1000;
-                if (timer < 15 * MINUTE)
-                    wintergrasp->InvitePlayerToQueue(player);
-            }
-            return true;
-        }
-};
-
-class go_wg_vehicle_teleporter : public GameObjectScript
-{
-    public:
-        go_wg_vehicle_teleporter() : GameObjectScript("go_wg_vehicle_teleporter") { }
-
-        struct go_wg_vehicle_teleporterAI : public GameObjectAI
-        {
-            go_wg_vehicle_teleporterAI(GameObject* gameObject) : GameObjectAI(gameObject), _checkTimer(1000) { }
-
-            void UpdateAI(uint32 diff) override
-            {
-                if (_checkTimer <= diff)
-                {
-                    if (Battlefield* wg = sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG))
-                        // Tabulation madness in the hole!
-                        for (uint8 i = 0; i < MAX_WINTERGRASP_VEHICLES; i++)
-                            if (Creature* vehicleCreature = go->FindNearestCreature(vehiclesList[i], 3.0f, true))
-                                if (!vehicleCreature->HasAura(SPELL_VEHICLE_TELEPORT) && vehicleCreature->getFaction() == WintergraspFaction[wg->GetDefenderTeam()])
-                                    if (Creature* teleportTrigger = vehicleCreature->FindNearestCreature(NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC, 100.0f, true))
-                                        teleportTrigger->CastSpell(vehicleCreature, SPELL_VEHICLE_TELEPORT, true);
-
-                    _checkTimer = 1000;
-                }
-                else _checkTimer -= diff;
-            }
-
-          private:
-              uint32 _checkTimer;
-        };
-
-        GameObjectAI* GetAI(GameObject* go) const override
-        {
-            return new go_wg_vehicle_teleporterAI(go);
-        }
-};
-
-class npc_wg_quest_giver : public CreatureScript
-{
-    public:
-        npc_wg_quest_giver() : CreatureScript("npc_wg_quest_giver") { }
-
-        bool OnGossipHello(Player* player, Creature* creature) override
-        {
-            Battlefield* wintergrasp = sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);
-            if (!wintergrasp)
-                return true;
-
-            if (creature->IsVendor())
-            {
-                player->ADD_GOSSIP_ITEM_DB(Player::GetDefaultGossipMenuForSource(creature), 0, GOSSIP_SENDER_MAIN, GOSSIP_OPTION_VENDOR);
-                player->PlayerTalkClass->GetGossipMenu().AddGossipMenuItemData(0, 0, 0);
-            }
-
-            /// @todo: move this to conditions or something else
-
-            // Player::PrepareQuestMenu(guid)
-            if (creature->IsQuestGiver())
-            {
-                QuestRelationBounds objectQR = sObjectMgr->GetCreatureQuestRelationBounds(creature->GetEntry());
-                QuestRelationBounds objectQIR = sObjectMgr->GetCreatureQuestInvolvedRelationBounds(creature->GetEntry());
-
-                QuestMenu& qm = player->PlayerTalkClass->GetQuestMenu();
-                qm.ClearMenu();
-
-                for (QuestRelations::const_iterator i = objectQIR.first; i != objectQIR.second; ++i)
-                {
-                    uint32 questId = i->second;
-                    QuestStatus status = player->GetQuestStatus(questId);
-                    if (status == QUEST_STATUS_COMPLETE)
-                        qm.AddMenuItem(questId, 4);
-                    else if (status == QUEST_STATUS_INCOMPLETE)
-                        qm.AddMenuItem(questId, 4);
-                    //else if (status == QUEST_STATUS_AVAILABLE)
-                    //    qm.AddMenuItem(quest_id, 2);
-                }
-
-                for (QuestRelations::const_iterator i = objectQR.first; i != objectQR.second; ++i)
-                {
-                    uint32 questId = i->second;
-                    Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
-                    if (!quest)
-                        continue;
-
-                    if (!player->CanTakeQuest(quest, false))
-                        continue;
-
-                    switch (questId)
-                    {
-                        // Horde attacker
-                        case QUEST_BONES_AND_ARROWS_HORDE_ATT:
-                        case QUEST_JINXING_THE_WALLS_HORDE_ATT:
-                        case QUEST_SLAY_THEM_ALL_HORDE_ATT:
-                        case QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT:
-                        case QUEST_HEALING_WITH_ROSES_HORDE_ATT:
-                        case QUEST_DEFEND_THE_SIEGE_HORDE_ATT:
-                            if (wintergrasp->GetAttackerTeam() != TEAM_HORDE)
-                                continue;
-                            break;
-                        // Horde defender
-                        case QUEST_BONES_AND_ARROWS_HORDE_DEF:
-                        case QUEST_WARDING_THE_WALLS_HORDE_DEF:
-                        case QUEST_SLAY_THEM_ALL_HORDE_DEF:
-                        case QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF:
-                        case QUEST_HEALING_WITH_ROSES_HORDE_DEF:
-                        case QUEST_TOPPLING_THE_TOWERS_HORDE_DEF:
-                        case QUEST_STOP_THE_SIEGE_HORDE_DEF:
-                            if (wintergrasp->GetDefenderTeam() != TEAM_HORDE)
-                                continue;
-                            break;
-                        // Alliance attacker
-                        case QUEST_BONES_AND_ARROWS_ALLIANCE_ATT:
-                        case QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT:
-                        case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT:
-                        case QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT:
-                        case QUEST_A_RARE_HERB_ALLIANCE_ATT:
-                            if (wintergrasp->GetAttackerTeam() != TEAM_ALLIANCE)
-                                continue;
-                            break;
-                        // Alliance defender
-                        case QUEST_BONES_AND_ARROWS_ALLIANCE_DEF:
-                        case QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF:
-                        case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF:
-                        case QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF:
-                        case QUEST_STOP_THE_SIEGE_ALLIANCE_DEF:
-                        case QUEST_A_RARE_HERB_ALLIANCE_DEF:
-                            if (wintergrasp->GetDefenderTeam() != TEAM_ALLIANCE)
-                                continue;
-                            break;
-                        default:
-                            break;
-                    }
-
-                    if (quest->IsAutoComplete())
-                        qm.AddMenuItem(questId, 4);
-                    else if (player->GetQuestStatus(questId) == QUEST_STATUS_NONE)
-                        qm.AddMenuItem(questId, 2);
-                }
-            }
-
-            player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
-            return true;
-        }
-};
-
-class spell_wintergrasp_force_building : public SpellScriptLoader
-{
-    public:
-        spell_wintergrasp_force_building() : SpellScriptLoader("spell_wintergrasp_force_building") { }
-
-        class spell_wintergrasp_force_building_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_wintergrasp_force_building_SpellScript);
-
-            bool Validate(SpellInfo const* /*spell*/) override
-            {
-                if (!sSpellMgr->GetSpellInfo(SPELL_BUILD_CATAPULT_FORCE)
-                    || !sSpellMgr->GetSpellInfo(SPELL_BUILD_DEMOLISHER_FORCE)
-                    || !sSpellMgr->GetSpellInfo(SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE)
-                    || !sSpellMgr->GetSpellInfo(SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE))
-                    return false;
-                return true;
-            }
-
-            void HandleScript(SpellEffIndex effIndex)
-            {
-                PreventHitDefaultEffect(effIndex);
-                GetHitUnit()->CastSpell(GetHitUnit(), GetEffectValue(), false);
-            }
-
-            void Register() override
-            {
-                OnEffectHitTarget += SpellEffectFn(spell_wintergrasp_force_building_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
-
-        SpellScript* GetSpellScript() const override
-        {
-            return new spell_wintergrasp_force_building_SpellScript();
-        }
-};
-
-class spell_wintergrasp_grab_passenger : public SpellScriptLoader
-{
-    public:
-        spell_wintergrasp_grab_passenger() : SpellScriptLoader("spell_wintergrasp_grab_passenger") { }
-
-        class spell_wintergrasp_grab_passenger_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_wintergrasp_grab_passenger_SpellScript);
-
-            void HandleScript(SpellEffIndex /*effIndex*/)
-            {
-                if (Player* target = GetHitPlayer())
-                    target->CastSpell(GetCaster(), SPELL_RIDE_WG_VEHICLE, false);
-            }
-
-            void Register() override
-            {
-                OnEffectHitTarget += SpellEffectFn(spell_wintergrasp_grab_passenger_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
-
-        SpellScript* GetSpellScript() const override
-        {
-            return new spell_wintergrasp_grab_passenger_SpellScript();
-        }
-};
-
-class achievement_wg_didnt_stand_a_chance : public AchievementCriteriaScript
-{
-public:
-    achievement_wg_didnt_stand_a_chance() : AchievementCriteriaScript("achievement_wg_didnt_stand_a_chance") { }
-
-    bool OnCheck(Player* source, Unit* target) override
-    {
-        if (!target)
-            return false;
-
-        if (Player* victim = target->ToPlayer())
-        {
-            if (!victim->IsMounted())
-                return false;
-
-            if (Vehicle* vehicle = source->GetVehicle())
-                if (vehicle->GetVehicleInfo()->m_ID == 244) // Wintergrasp Tower Cannon
-                    return true;
-        }
-
-        return false;
-    }
-};
-
-enum WgTeleport
-{
-    SPELL_WINTERGRASP_TELEPORT_TRIGGER = 54643,
-};
-
-class spell_wintergrasp_defender_teleport : public SpellScriptLoader
-{
-public:
-    spell_wintergrasp_defender_teleport() : SpellScriptLoader("spell_wintergrasp_defender_teleport") { }
-
-    class spell_wintergrasp_defender_teleport_SpellScript : public SpellScript
-    {
-        PrepareSpellScript(spell_wintergrasp_defender_teleport_SpellScript);
-
-        SpellCastResult CheckCast()
-        {
-            if (Battlefield* wg = sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG))
-                if (Player* target = GetExplTargetUnit()->ToPlayer())
-                    // check if we are in Wintergrasp at all, SotA uses same teleport spells
-                    if ((target->GetZoneId() == 4197 && target->GetTeamId() != wg->GetDefenderTeam()) || target->HasAura(SPELL_WINTERGRASP_TELEPORT_TRIGGER))
-                        return SPELL_FAILED_BAD_TARGETS;
-            return SPELL_CAST_OK;
-        }
-
-        void Register() override
-        {
-            OnCheckCast += SpellCheckCastFn(spell_wintergrasp_defender_teleport_SpellScript::CheckCast);
-        }
-    };
-
-    SpellScript* GetSpellScript() const override
-    {
-        return new spell_wintergrasp_defender_teleport_SpellScript();
-    }
-};
-
-class spell_wintergrasp_defender_teleport_trigger : public SpellScriptLoader
-{
-public:
-    spell_wintergrasp_defender_teleport_trigger() : SpellScriptLoader("spell_wintergrasp_defender_teleport_trigger") { }
-
-    class spell_wintergrasp_defender_teleport_trigger_SpellScript : public SpellScript
-    {
-        PrepareSpellScript(spell_wintergrasp_defender_teleport_trigger_SpellScript);
-
-        void HandleDummy(SpellEffIndex /*effindex*/)
-        {
-            if (Unit* target = GetHitUnit())
-            {
-                WorldLocation loc = target->GetWorldLocation();
-                SetExplTargetDest(loc);
-            }
-        }
-
-        void Register() override
-        {
-            OnEffectHitTarget += SpellEffectFn(spell_wintergrasp_defender_teleport_trigger_SpellScript::HandleDummy, EFFECT_0, SPELL_EFFECT_DUMMY);
-        }
-    };
-
-    SpellScript* GetSpellScript() const override
-    {
-        return new spell_wintergrasp_defender_teleport_trigger_SpellScript();
-    }
-};
-
-void AddSC_wintergrasp()
-{
-    new npc_wg_queue();
-    new npc_wg_spirit_guide();
-    new npc_wg_demolisher_engineer();
-    new go_wg_vehicle_teleporter();
-    new npc_wg_quest_giver();
-    new spell_wintergrasp_force_building();
-    new spell_wintergrasp_grab_passenger();
-    new achievement_wg_didnt_stand_a_chance();
-    new spell_wintergrasp_defender_teleport();
-    new spell_wintergrasp_defender_teleport_trigger();
-}
diff --git a/src/server/scripts/OutdoorPvP/CMakeLists.txt b/src/server/scripts/OutdoorPvP/CMakeLists.txt
index 91ce4ce..18325f0 100644
--- a/src/server/scripts/OutdoorPvP/CMakeLists.txt
+++ b/src/server/scripts/OutdoorPvP/CMakeLists.txt
@@ -22,6 +22,8 @@ set(scripts_STAT_SRCS
   OutdoorPvP/OutdoorPvPHP.h
   OutdoorPvP/OutdoorPvPZM.h
   OutdoorPvP/OutdoorPvPNA.h
+  OutdoorPvP/OutdoorPvPWG.cpp
+  OutdoorPvP/OutdoorPvPWG.h
 )
 
 message("  -> Prepared: Outdoor PVP Zones")
diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
new file mode 100644
index 0000000..33b560a
--- /dev/null
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
@@ -0,0 +1,2278 @@
+/*
+ * Copyright (C) 2008 - 2012 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2012 Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPWG.h"
+#include "SpellAuras.h"
+#include "Vehicle.h"
+#include "ObjectMgr.h"
+#include "World.h"
+#include "Group.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "ScriptedCreature.h"
+#include "BattlefieldMgr.h"
+#include "Battlefield.h"
+#include "Language.h"
+#include "Creature.h"
+
+Creature* FortressSpirit;
+uint32 entry;
+uint32 guide_entry;
+uint32 guide_entry_fortress_horde;
+uint32 guide_entry_fortress_alliance;
+
+char const *fmtstring(char const *format, ...)
+{
+    va_list        argptr;
+    #define    MAX_FMT_STRING    32000
+    static char        temp_buffer[MAX_FMT_STRING];
+    static char        string[MAX_FMT_STRING];
+    static int        index = 0;
+    char    *buf;
+    int len;
+
+    va_start(argptr, format);
+    vsnprintf(temp_buffer,MAX_FMT_STRING, format, argptr);
+    va_end(argptr);
+
+    len = strlen(temp_buffer);
+
+    if (len >= MAX_FMT_STRING)
+        return "ERROR";
+
+    if (len + index >= MAX_FMT_STRING-1)
+    {
+        index = 0;
+    }
+
+    buf = &string[index];
+    memcpy(buf, temp_buffer, len+1);
+
+    index += len + 1;
+
+    return buf;
+}
+
+OutdoorPvPWG::OutdoorPvPWG()
+{
+    m_TypeId = OUTDOOR_PVP_WG;
+    m_LastResurrectTime = 0; // Temporal copy of BG system till 3.2
+}
+
+void _LoadTeamPair(TeamPairMap &pairMap, const TeamPair *pair)
+{
+    while((*pair)[0])
+    {
+        pairMap[(*pair)[0]] = (*pair)[1];
+        pairMap[(*pair)[1]] = (*pair)[0];
+        ++pair;
+    }
+}
+
+void _RespawnCreatureIfNeeded(Creature *cr, uint32 entry)
+{
+    if (cr)
+    {
+        cr->UpdateEntry(entry); // SetOriginalEntry as used before may lead to crash
+        //if (cr->GetAreaId() == 4575)
+        //    cr->AI()->EnterEvadeMode();
+        if (entry != cr->GetEntry() || !cr->IsAlive())
+            cr->Respawn(true);
+        cr->SetVisible(true);
+    }
+}
+
+bool OutdoorPvPWG::SetupOutdoorPvP()
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+        return false;
+    }
+
+    //load worlstates
+    m_wartime  = sWorld->getWorldState(WORLDSTATE_WINTERGRASP_WARTIME) ? true : false;
+    m_timer    = uint32(sWorld->getWorldState(WORLDSTATE_WINTERGRASP_TIMER));
+    m_defender = TeamId(sWorld->getWorldState(WORLDSTATE_WINTERGRASP_DEFENDERS) ? true : false);
+    m_WSSaveTimer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+
+    if (m_timer == 0)
+       m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME) * MINUTE * IN_MILLISECONDS;
+
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    m_changeDefender = false;
+    m_workshopCount[TEAM_ALLIANCE] = 0;
+    m_workshopCount[TEAM_HORDE] = 0;
+    m_tenacityStack = 0;
+    m_gate = NULL;
+
+    std::list<uint32> engGuids;
+    std::list<uint32> spiritGuids;
+
+    // Store Eng, spirit guide guids and questgiver for later use
+    QueryResult result = WorldDatabase.PQuery("SELECT guid, id FROM creature WHERE creature.map=571"
+        " AND creature.id IN (%u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u);",
+        30499, 30400, 31842, 31841, 31101, 31051, 31102, 31052,
+        31107, 31109, 31151, 31153, 31106, 31108, 31053, 31054, 31091, 31036);
+    if (!result)
+        TC_LOG_ERROR("outdoorpvp", "Cannot find siege workshop master or spirit guides in creature!");
+    else
+    {
+        do
+        {
+            Position posHorde, posAlli;
+            Field *fields = result->Fetch();
+            switch(fields[1].GetUInt32())
+            {
+                case CRE_ENG_A:
+                case CRE_ENG_H:
+                    engGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case CRE_SPI_A:
+                case CRE_SPI_H:
+                    spiritGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case 31051:
+                    posHorde.Relocate(5081.7f, 2173.73f, 365.878f, 0.855211f);
+                    posAlli.Relocate(5298.39f, 2890.56f, 409.191f, 5.602510f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31101:
+                    posHorde.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    posAlli.Relocate(5016.57f, 3677.53f, 362.982f, 5.7525f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31052:
+                    posHorde.Relocate(5100.07f, 2168.89f, 365.779f, 1.97222f);
+                    posAlli.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31102:
+                    posHorde.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    posAlli.Relocate(5030.44f, 3659.82f, 363.194f, 1.83336f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31109:
+                    posHorde.Relocate(5080.4f, 2199.0f, 359.489f, 2.96706f);
+                    posAlli.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31107:
+                    posHorde.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    posAlli.Relocate(5008.64f, 3659.91f, 361.07f, 4.0796f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31153:
+                    posHorde.Relocate(5088.49f, 2188.18f, 365.647f, 5.25344f);
+                    posAlli.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31151:
+                    posHorde.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    posAlli.Relocate(5032.33f, 3680.7f, 363.018f, 3.43167f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31108:
+                    posHorde.Relocate(5095.67f, 2193.28f, 365.924f, 4.93928f);
+                    posAlli.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31106:
+                    posHorde.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    posAlli.Relocate(5032.66f, 3674.28f, 363.053f, 2.9447f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31054:
+                    posHorde.Relocate(5088.61f, 2167.66f, 365.689f, 0.680678f);
+                    posAlli.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31053:
+                    posHorde.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    posAlli.Relocate(5032.44f, 3668.66f, 363.11f, 2.87402f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31036:
+                    posHorde.Relocate(5078.28f, 2183.7f, 365.029f, 1.46608f);
+                    posAlli.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31091:
+                    posHorde.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    posAlli.Relocate(5022.43f, 3659.91f, 361.61f, 1.35426f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                default:
+                    break;
+            }
+        } while (result->NextRow());
+    }
+
+    // Select POI
+    AreaPOIList areaPOIs;
+    float minX = 9999, minY = 9999, maxX = -9999, maxY = -9999;
+    for (uint32 i = 0; i < sAreaPOIStore.GetNumRows(); ++i)
+    {
+        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
+        if (poiInfo && poiInfo->zoneId == ZONE_WINTERGRASP)
+        {
+            areaPOIs.push_back(poiInfo);
+            if (minX > poiInfo->x) minX = poiInfo->x;
+            if (minY > poiInfo->y) minY = poiInfo->y;
+            if (maxX < poiInfo->x) maxX = poiInfo->x;
+            if (maxY < poiInfo->y) maxY = poiInfo->y;
+        }
+    }
+    minX -= 20; minY -= 20; maxX += 20; maxY += 20;
+
+    // Coords: 4290.330078, 1790.359985 - 5558.379883, 4048.889893
+    result = WorldDatabase.PQuery("SELECT guid FROM gameobject,gameobject_template"
+        " WHERE gameobject.map=571"
+        " AND gameobject.position_x>%f AND gameobject.position_y>%f"
+        " AND gameobject.position_x<%f AND gameobject.position_y<%f"
+        " AND gameobject_template.type=33"
+        " AND gameobject.id=gameobject_template.entry",
+        minX, minY, maxX, maxY);
+    if (!result)
+        return false;
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        uint32 guid = fields[0].GetUInt32();
+        GameObjectData const * goData = sObjectMgr->GetGOData(guid);
+        if (!goData) // this should not happen
+            continue;
+
+        float x = goData->posX, y = goData->posY;
+        float minDist = 100;
+        AreaPOIList::iterator poi = areaPOIs.end();
+        for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end(); ++itr)
+        {
+            if (!(*itr)->icon[1]) // note: may for other use
+                continue;
+
+            float dist = (abs((*itr)->x - x) + abs((*itr)->y - y));
+            if (minDist > dist)
+            {
+                minDist = dist;
+                poi = itr;
+            }
+        }
+
+        if (poi == areaPOIs.end())
+            continue;
+
+        // add building to the list
+        TeamId teamId = x > POS_X_CENTER-300 ? getDefenderTeam() : getAttackerTeam();
+        m_buildingStates[guid] = new BuildingState((*poi)->worldState, teamId, getDefenderTeam() != TEAM_ALLIANCE);
+        if ((*poi)->id == 2246)
+            m_gate = m_buildingStates[guid];
+        areaPOIs.erase(poi);
+
+        // add capture point
+        uint32 capturePointEntry = 0;
+
+        switch(goData->id)
+        {
+            //West Goblin Workshops
+            case 192028: // NW
+            case 192030: // W
+            case 192032: // SW
+                capturePointEntry = 190475;
+                break;
+            //East Goblin Workshops
+            case 192029: // NE
+            case 192031: // E
+            case 192033: // SE
+                capturePointEntry = 190487;
+                break;
+        }
+
+        if (capturePointEntry)
+        {
+            uint32 engGuid = 0;
+            uint32 spiritGuid = 0;
+            // Find closest Eng to Workshop
+            float minDist = 100;
+            for (std::list<uint32>::iterator itr = engGuids.begin(); itr != engGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr->GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    engGuid = *itr;
+                }
+            }
+
+            if (!engGuid)
+            {
+                TC_LOG_ERROR("outdoorpvp", "Cannot find nearby siege workshop master!");
+                continue;
+            }
+            else
+                engGuids.remove(engGuid);
+            // Find closest Spirit Guide to Workshop
+            minDist = 255;
+            for (std::list<uint32>::iterator itr = spiritGuids.begin(); itr != spiritGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr->GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    spiritGuid = *itr;
+                }
+            }
+
+            // Inside fortress won't be capturable
+            OPvPCapturePointWG *workshop = new OPvPCapturePointWG(this, m_buildingStates[guid]);
+            if (goData->posX < POS_X_CENTER && !workshop->SetCapturePointData(capturePointEntry, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2), goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ))
+            {
+                delete workshop;
+                TC_LOG_ERROR("outdoorpvp", "Cannot add capture point!");
+                continue;
+            }
+            // West fortress Workshop fix
+            if(goData->id==192028 || goData->id==192029)
+                workshop->m_capturePointSpawnId = goData->id;
+
+            const CreatureData *creData = sObjectMgr->GetCreatureData(engGuid);
+            if (!creData)
+                continue;
+
+            workshop->m_engEntry = const_cast<uint32*>(&creData->id);
+            const_cast<CreatureData*>(creData)->displayid = 0;
+            workshop->m_engGuid = engGuid;
+
+            // Back spirit is linked to one of the inside workshops, 1 workshop wont have spirit
+            if (spiritGuid)
+            {
+                spiritGuids.remove(spiritGuid);
+
+                const CreatureData *spiritData = sObjectMgr->GetCreatureData(spiritGuid);
+                if (!spiritData)
+                    continue;
+
+                workshop->m_spiEntry = const_cast<uint32*>(&spiritData->id);
+                const_cast<CreatureData*>(spiritData)->displayid = 0;
+                workshop->m_spiGuid = spiritGuid;
+            }
+            else
+                workshop->m_spiGuid = 0;
+            workshop->m_workshopGuid = guid;
+            AddCapturePoint(workshop);
+            m_buildingStates[guid]->type = BUILDING_WORKSHOP;
+            workshop->SetTeamByBuildingState();
+        }
+    } while (result->NextRow());
+
+    engGuids.clear();
+    spiritGuids.clear();
+
+    if (!m_gate)
+    {
+        TC_LOG_ERROR("outdoorpvp", "Cannot find wintergrasp fortress gate!");
+        return false;
+    }
+
+    // Load Graveyard
+    GraveYardContainer::const_iterator graveLow  = sObjectMgr->GraveYardStore.lower_bound(ZONE_WINTERGRASP);
+    GraveYardContainer::const_iterator graveUp   = sObjectMgr->GraveYardStore.upper_bound(ZONE_WINTERGRASP);
+    for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end();)
+    {
+        if ((*itr)->icon[1] == 8)
+        {
+            // find or create grave yard
+            const WorldSafeLocsEntry *loc = sObjectMgr->GetClosestGraveYard((*itr)->x, (*itr)->y, (*itr)->z, (*itr)->mapId, 0);
+            if (!loc)
+            {
+                ++itr;
+                continue;
+            }
+
+            GraveYardContainer::const_iterator graveItr;
+            for (graveItr = graveLow; graveItr != graveUp; ++graveItr)
+                if (graveItr->second.safeLocId == loc->ID)
+                    break;
+            if (graveItr == graveUp)
+            {
+                GraveYardData graveData;
+                graveData.safeLocId = loc->ID;
+                graveData.team = 0;
+                graveItr = sObjectMgr->GraveYardStore.insert(std::make_pair(ZONE_WINTERGRASP, graveData));
+            }
+
+            for (BuildingStateMap::iterator stateItr = m_buildingStates.begin(); stateItr != m_buildingStates.end(); ++stateItr)
+            {
+                if (stateItr->second->worldState == (*itr)->worldState)
+                {
+                    stateItr->second->graveTeam = const_cast<uint32*>(&graveItr->second.team);
+                    break;
+                }
+            }
+            areaPOIs.erase(itr++);
+        }
+        else
+            ++itr;
+    }
+
+    //Titan Relic
+    sObjectMgr->AddGOData(192829, 571, 5440.0f, 2840.8f, 420.43f + 10.0f, 0);
+
+    _LoadTeamPair(m_goDisplayPair, OutdoorPvPWGGODisplayPair);
+    _LoadTeamPair(m_creEntryPair, OutdoorPvPWGCreEntryPair);
+
+    sWorld->SendWintergraspState();
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+
+    RegisterZone(ZONE_WINTERGRASP);
+
+    if (m_wartime)
+    {
+        uint32 m_WSTimer = m_timer;
+        StartBattle();
+        m_timer = m_WSTimer;
+    }
+    else RemoveOfflinePlayerWGAuras();
+
+    return true;
+}
+
+void OutdoorPvPWG::ProcessEvent(WorldObject *objin, uint32 eventId)
+{
+    GameObject* obj = objin->ToGameObject();
+    if (!obj)
+        return;
+
+    if (obj->GetEntry() == 192829) // Titan Relic
+    {
+        if (obj->GetGOInfo()->goober.eventId == eventId && isWarTime() && /*MaingateDestroyed==true &&*/ m_gate &&  m_gate->damageState == DAMAGE_DESTROYED)
+        {
+            m_changeDefender = true;
+            m_timer = 0;
+        }
+    }
+    else if (obj->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(obj->GetSpawnId());
+        if (itr == m_buildingStates.end())
+            return;
+        std::string msgStr;
+        switch(eventId)
+        { // TODO - Localized msgs of GO names
+            case 19672: case 19675: // Flamewatch Tower
+                msgStr = "Flamewatch";
+                break;
+            case 18553: case 19677: // Shadowsight Tower
+                msgStr = "Shadowsight";
+                break;
+            case 19673: case 19676: // Winter's Edge Tower
+                msgStr = "Winter's Edge";
+                break;
+            case 19776: case 19778: // E Workshop damaged
+                msgStr = "Sunken Ring";
+                break;
+            case 19777: case 19779: // W Workshop damaged
+                msgStr = "Broken Temple";
+                break;
+            case 19782: case 19786: // NW Workshop damaged
+                msgStr = "north-western";
+                break;
+            case 19783: case 19787: // NE Workshop damaged
+                msgStr = "north-eastern";
+                break;
+            case 19784: case 19788: // SW Workshop damaged
+                msgStr = "Westpark";
+                break;
+            case 19785: case 19789: // SE Workshop damaged
+                msgStr = "Eastpark";
+                break;
+            case 19657: case 19661: // NW Wintergrasp Keep Tower damaged
+                msgStr = "north-western";
+                break;
+            case 19658: case 19663: // NE Wintergrasp Keep Tower damaged
+                msgStr = "north-eastern";
+                break;
+            case 19659: case 19662: // SW Wintergrasp Keep Tower damaged
+                msgStr = "south-western";
+                break;
+            case 19660: case 19664: // SE Wintergrasp Keep Tower damaged
+                msgStr = "south-eastern";
+                break;
+            default:
+                msgStr = "";
+        }
+
+        BuildingState *state = itr->second;
+        if (eventId == obj->GetGOInfo()->building.damagedEvent)
+        {
+            state->damageState = DAMAGE_DAMAGED;
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                {
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DAMAGED), msgStr.c_str(), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                }
+                    break;
+                case BUILDING_WALL:
+                {
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+                    for (GuidSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+                        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                        player->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (GuidSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+                        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                        player->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                }
+                    break;
+                case BUILDING_TOWER:
+                {
+                    ++m_towerDamagedCount[state->GetTeam()];
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DAMAGED), msgStr.c_str());
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    for (GuidSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                        player->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (GuidSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                        player->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                 }
+                    break;
+            }
+        }
+        else if (eventId == obj->GetGOInfo()->building.destroyedEvent)
+        {
+            state->damageState = DAMAGE_DESTROYED;
+
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                {
+                    ModifyWorkshopCount(state->GetTeam(), false);
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DESTROYED), msgStr.c_str(), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                }
+                    break;
+                case BUILDING_WALL:
+                {
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+                    for (GuidSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                        player->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (GuidSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                        player->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                }
+                    break;
+                case BUILDING_TOWER:
+                {
+                     --m_towerDamagedCount[state->GetTeam()];
+                     ++m_towerDestroyedCount[state->GetTeam()];
+                     if (state->GetTeam() == getAttackerTeam())
+                     {
+                        TeamCastSpell(getAttackerTeam(), -SPELL_TOWER_CONTROL);
+                        TeamCastSpell(getDefenderTeam(), -SPELL_TOWER_CONTROL);
+                        uint32 attStack = 3 - m_towerDestroyedCount[getAttackerTeam()];
+                        if (m_towerDestroyedCount[getAttackerTeam()])
+                            for (GuidSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                        {
+                                if (player->getLevel() > 74)
+                                    player->SetAuraStack(SPELL_TOWER_CONTROL, player, m_towerDestroyedCount[getAttackerTeam()]);
+                        }
+                        if (attStack!=0)
+                        {
+                            for (GuidSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                        {
+                                if (player->getLevel() > 74)
+                                    player->SetAuraStack(SPELL_TOWER_CONTROL, player, attStack);
+                        }
+                        }
+                         else
+                        {
+                            if (m_timer < 600000)
+                                m_timer = 0;
+                            else
+                                m_timer = m_timer - 600000; // - 10 mins
+                        }
+                    }
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DESTROYED), msgStr.c_str());
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    for (GuidSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+                        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                        player->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+
+                     // Add Support of Quests Toppling the Towers & Southern Sabotage
+                        if (obj->GetEntry()==190356 || obj->GetEntry()==190357 || obj->GetEntry()==190358)
+                        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                        {
+                        player->RewardPlayerAndGroupAtEvent(TOWER_PVP_DESTROYED, obj);
+                        }
+                    }
+                    for (GuidSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+                        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                        player->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress destroyed Siege
+                    }
+                }
+                    break;
+            }
+            BroadcastStateChange(state);
+        }
+    }
+}
+
+void OutdoorPvPWG::RemoveOfflinePlayerWGAuras()
+{
+    // if server crashed while in battle there could be players with rank or tenacity
+    CharacterDatabase.PExecute("DELETE FROM character_aura WHERE spell IN (%u, %u, %u, %u, %u)",
+         SPELL_RECRUIT, SPELL_CORPORAL, SPELL_LIEUTENANT, SPELL_TENACITY, SPELL_TOWER_CONTROL);
+}
+
+void OutdoorPvPWG::ModifyWorkshopCount(TeamId team, bool add)
+{
+    if (team == TEAM_NEUTRAL)
+        return;
+
+    if (add)
+        ++m_workshopCount[team];
+    else if (m_workshopCount[team])
+        --m_workshopCount[team];
+    else
+        TC_LOG_ERROR("outdoorpvp", "OutdoorPvPWG::ModifyWorkshopCount: negative workshop count!");
+
+    SendUpdateWorldState(MaxVehNumWorldState[team], m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP);
+}
+
+uint32 OutdoorPvPWG::GetCreatureEntry(uint32 /*guidlow*/, const CreatureData *data)
+{
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+    {
+        TeamPairMap::const_iterator itr = m_creEntryPair.find(data->id);
+        if (itr != m_creEntryPair.end())
+        {
+            const_cast<CreatureData*>(data)->displayid = 0;
+            return itr->second;
+        }
+    }
+    return data->id;
+}
+
+OutdoorPvPWGCreType OutdoorPvPWG::GetCreatureType(uint32 entry) const
+{
+    // VEHICLES, GUARDS and TURRETS gives kill credit
+    // OTHER Not in wartime
+    // TURRET Only during wartime
+    // SPECIAL like "OTHER" but no despawn conditions
+    // Entries like Case A: Case: B have their own despawn function
+    switch(entry)
+    {
+        case 27881: // Catapult
+        case 28094: // Demolisher
+        case 28312: // Alliance Siege Engine
+        case 32627: // Horde Siege Engine
+        case 28319: // Siege turret
+        case 32629: // Siege turret
+            return CREATURE_SIEGE_VEHICLE;
+        case 28366: // Wintergrasp Tower cannon
+            return CREATURE_TURRET;
+        case CRE_ENG_A: // Alliance Engineer
+        case CRE_ENG_H: // Horde Engineer
+            return CREATURE_ENGINEER;
+        case 30739:case 30740: // Champions
+        case 32307:case 32308: // Guards
+            return CREATURE_GUARD;
+        case CRE_SPI_A: // Dwarven Spirit Guide
+        case CRE_SPI_H: // Taunka Spirit Guide
+            return CREATURE_SPIRIT_GUIDE;
+        case 6491: // Spirit Healers
+            return CREATURE_SPIRIT_HEALER;
+        case 31101:case 31051: // Hoodoo Master & Sorceress
+        case 31102:case 31052: // Vieron Blazefeather & Bowyer
+        case 31107:case 31109: // Lieutenant & Senior Demolitionist
+        case 31151:case 31153: // Tactical Officer
+        case 31106:case 31108: // Siegesmith & Siege Master
+        case 31053:case 31054: // Primalist & Anchorite
+        case 31091:case 31036: // Commander
+            return CREATURE_QUESTGIVER;
+        case 32615:case 32626: // Warbringer && Brigadier General
+        case 32296:case 32294: // Quartermaster
+        case 39173:case 39172: // Ros'slai && Marshal Magruder
+        case 30870:case 30869: // Flight Masters
+            return CREATURE_SPECIAL;
+        default:
+            return CREATURE_OTHER; // Revenants, Elementals, etc
+    }
+}
+
+void OutdoorPvPWG::OnCreatureCreate(Creature *creature)
+{
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_SIEGE_VEHICLE:
+        {
+            if (!creature->IsSummon())
+                return;
+
+            TeamId team;
+            if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
+                team = TEAM_ALLIANCE;
+            else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
+                team = TEAM_HORDE;
+            else
+                return;
+
+            if (uint32 engLowguid = ((TempSummon*)creature)->GetSummonerGUID())
+            {
+                if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(engLowguid))
+                {
+                    if (CanBuildVehicle(workshop))
+                        m_vehicles[team].insert(creature);
+                    else
+                    {
+                        creature->setDeathState(DEAD);
+                        creature->SetRespawnTime(DAY);
+                        return;
+                    }
+                }
+
+                if (m_tenacityStack > 0 && team == TEAM_ALLIANCE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, m_tenacityStack);
+                else if (m_tenacityStack < 0 && team == TEAM_HORDE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, -m_tenacityStack);
+            }
+            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
+        }
+            break;
+        case CREATURE_QUESTGIVER:
+        {
+            m_questgivers[creature->GetSpawnId()] = creature;
+            creature->SetReactState(REACT_PASSIVE);
+        }
+            break;
+        case CREATURE_ENGINEER:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_engGuid == creature->GetSpawnId())
+                    {
+                        workshop->m_engineer = creature;
+                        break;
+                    }
+            }
+            break;
+        case CREATURE_SPIRIT_GUIDE:
+        {
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_spiGuid == creature->GetSpawnId())
+                    {
+                        workshop->m_spiritguide = creature;
+                        break;
+                    }
+            }
+            creature->CastSpell(creature, SPELL_SPIRITUAL_IMMUNITY, true);
+        }
+        case CREATURE_SPIRIT_HEALER:
+        case CREATURE_TURRET:
+        case CREATURE_OTHER:
+            UpdateCreatureInfo(creature);
+        default:
+            m_creatures.insert(creature);
+            break;
+    }
+}
+
+void OutdoorPvPWG::OnCreatureRemove(Creature *creature)
+{
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_SIEGE_VEHICLE:
+        {
+            if (!creature->IsSummon())
+                return;
+
+            TeamId team;
+            // the faction may be changed in uncharm
+            // TODO: now you have to wait until the corpse of vehicle disappear to build a new one
+            if (m_vehicles[TEAM_ALLIANCE].erase(creature))
+                team = TEAM_ALLIANCE;
+            else if (m_vehicles[TEAM_HORDE].erase(creature))
+                team = TEAM_HORDE;
+            else
+                return;
+
+            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
+            break;
+        }
+        case CREATURE_QUESTGIVER:
+            m_questgivers.erase(creature->GetSpawnId());
+            break;
+        case CREATURE_ENGINEER:
+        {
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_engGuid == creature->GetSpawnId())
+                    {
+                        workshop->m_engineer = NULL;
+                        break;
+                    }
+            }
+            m_creatures.erase(creature); // prevents crash, but i think it's wrong
+        }
+            break;
+        case CREATURE_SPIRIT_GUIDE:
+        {
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_spiGuid == creature->GetSpawnId())
+                    {
+                        workshop->m_spiritguide = NULL;
+                        break;
+                    }
+            }
+            m_creatures.erase(creature); // prevents crash, but i think it's wrong
+        }
+            break;
+        default:
+            m_creatures.erase(creature);
+            break;
+    }
+}
+
+void OutdoorPvPWG::OnGameObjectCreate(GameObject *go)
+{
+    OutdoorPvP::OnGameObjectCreate(go);
+
+    if (UpdateGameObjectInfo(go))
+        m_gobjects.insert(go);
+
+    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetSpawnId());
+        if (itr != m_buildingStates.end())
+        {
+            itr->second->building = go;
+            if (go->GetGOInfo()->displayId == 7878 || go->GetGOInfo()->displayId == 7900)
+                itr->second->type = BUILDING_TOWER;
+            if (itr->second->damageState == DAMAGE_INTACT && !itr->second->health)
+            {
+                itr->second->health = go->GetGOValue()->Building.Health;
+                go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            } else {
+// Unsure why this is read only when backwards go->GetGOValue()->Building.Health = itr->second->health;
+                itr->second->health = go->GetGOValue()->Building.Health;
+                if (itr->second->damageState == DAMAGE_DAMAGED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
+                else if (itr->second->damageState == DAMAGE_DESTROYED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::OnGameObjectRemove(GameObject *go)
+{
+    OutdoorPvP::OnGameObjectRemove(go);
+
+    if (UpdateGameObjectInfo(go))
+        m_gobjects.erase(go);
+
+    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetSpawnId());
+        if (itr != m_buildingStates.end())
+            itr->second->building = NULL;
+    }
+}
+
+void OutdoorPvPWG::UpdateAllWorldObject()
+{
+    // update cre and go factions
+    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
+        UpdateGameObjectInfo(*itr);
+    for (CreatureSet::iterator itr = m_creatures.begin(); itr != m_creatures.end(); ++itr)
+        UpdateCreatureInfo(*itr);
+    for (QuestGiverMap::iterator itr = m_questgivers.begin(); itr != m_questgivers.end(); ++itr)
+        UpdateQuestGiverPosition((*itr).first, (*itr).second);
+
+    // rebuild and update building states
+    RebuildAllBuildings();
+
+    // update capture points
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            workshop->SetTeamByBuildingState();
+}
+
+void OutdoorPvPWG::RebuildAllBuildings()
+{
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+    {
+        if (itr->second->building && itr->second->building->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+        {
+            UpdateGameObjectInfo(itr->second->building);
+            itr->second->building->Refresh();
+            itr->second->building->SetDestructibleState(GO_DESTRUCTIBLE_REBUILDING, NULL, true);
+            itr->second->health = itr->second->building->GetGOValue()->Building.Health;
+            itr->second->damageState = DAMAGE_INTACT;
+        }
+        else
+            itr->second->health = 0;
+        itr->second->SetTeam(getDefenderTeam() == TEAM_ALLIANCE ? OTHER_TEAM(itr->second->defaultTeam) : itr->second->defaultTeam);
+    }
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+}
+
+void OutdoorPvPWG::SendInitWorldStatesTo(Player *player) const
+{
+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_buildingStates.size()*8)));
+    data << uint32(571);
+    data << uint32(ZONE_WINTERGRASP);
+    data << uint32(0);
+    data << uint16(4+2+4+m_buildingStates.size());
+
+    data << uint32(3803) << uint32(getDefenderTeam() == TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3802) << uint32(getDefenderTeam() != TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3801) << uint32(isWarTime() ? 0 : 1);
+    data << uint32(3710) << uint32(isWarTime() ? 1 : 0);
+
+    for (uint32 i = 0; i < 2; ++i)
+        data << ClockWorldState[i] << m_clock[i];
+
+    data << uint32(3490) << uint32(m_vehicles[TEAM_HORDE].size());
+    data << uint32(3491) << m_workshopCount[TEAM_HORDE] * MAX_VEHICLE_PER_WORKSHOP;
+    data << uint32(3680) << uint32(m_vehicles[TEAM_ALLIANCE].size());
+    data << uint32(3681) << m_workshopCount[TEAM_ALLIANCE] * MAX_VEHICLE_PER_WORKSHOP;
+
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+        itr->second->FillData(data);
+
+    if (player)
+        player->GetSession()->SendPacket(&data);
+    else
+        BroadcastPacket(data);
+}
+
+void OutdoorPvPWG::BroadcastStateChange(BuildingState *state) const
+{
+    if (m_sendUpdate)
+        for (uint32 team = 0; team < 2; ++team)
+            for (GuidSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
+                if (Player* const player = ObjectAccessor::FindPlayer(*p_itr))
+                state->SendUpdate(player);
+}
+
+// Called at Start and Battle End
+bool OutdoorPvPWG::UpdateCreatureInfo(Creature *creature)
+{
+    if (!creature)
+        return false;
+    uint32 entry = creature->GetEntry();
+
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_TURRET:
+        {
+            if (isWarTime())
+            {
+                if (!creature->IsAlive())
+                    creature->Respawn(true);
+                creature->setFaction(WintergraspFaction[getDefenderTeam()]);
+                creature->SetVisible(true);
+            } else {
+                if (creature->IsVehicle() && creature->GetVehicleKit())
+                    creature->GetVehicleKit()->RemoveAllPassengers();
+                creature->SetVisible(false);
+                creature->setFaction(35);
+            }
+            return false;
+        }
+        case CREATURE_OTHER:
+        {
+            if (isWarTime())
+            {
+                creature->SetVisible(false);
+                creature->setFaction(35);
+
+                // Prevent from hiding
+                switch (entry)
+                {
+                    case 30560: // The RP-GG
+                    case 27852: // This creature is neded for spell_target in workshops while building siege machines
+                    case 27869: // Wintergrasp Detection Unit
+                    case 23472: // World Trigger (Large AOI, Not Immune PC/NPC)
+                    {
+                        creature->SetPhaseMask(1, true);
+                        creature->RestoreFaction();
+                        creature->SetVisible(true);
+                    }
+                    break;
+                }
+            } else {
+                creature->RestoreFaction();
+                creature->SetVisible(true);
+            }
+            return false;
+        }
+        case CREATURE_SPIRIT_GUIDE:
+        {
+            if (isWarTime())
+            {
+                /* Uncomment if want to disable ressurect for both factions at the same time at fortress graveyard
+                if (creature->GetAreaId() == 4575) // Select Fortress Spirit
+                {
+                    FortressSpirit = creature;
+                    if (getDefenderTeam() == TEAM_ALLIANCE) // Fortress Spirit Alliance
+                            FortressSpirit->UpdateEntry(CRE_SPI_A);
+                    if (getDefenderTeam() == TEAM_HORDE) // Fortress Spirit Horde
+                        FortressSpirit->UpdateEntry(CRE_SPI_H);
+                }*/
+                creature->SetVisible(true);
+            }
+            else
+                creature->SetVisible(false);
+            return false;
+        }
+        case CREATURE_SPIRIT_HEALER:
+            creature->SetVisible(isWarTime() ? false : true);
+            return false;
+        case CREATURE_ENGINEER:
+           return false;
+        case CREATURE_SIEGE_VEHICLE:
+            if (!isWarTime())
+            {
+                if (creature->IsVehicle() && creature->GetVehicleKit())
+                    creature->GetVehicleKit()->RemoveAllPassengers();
+                creature->DisappearAndDie();
+            }
+            return false;
+        case CREATURE_QUESTGIVER:
+        {
+           creature->AI()->EnterEvadeMode();
+           creature->SetReactState(REACT_PASSIVE);
+        }
+           return false;
+        case CREATURE_GUARD:
+        case CREATURE_SPECIAL:
+        {
+            //TDB users comment this block if your guards doesn't spawned by pairs A+H at fortress
+            if (creature->GetAreaId()==4575)
+            {
+                switch (entry)
+                {
+                    case 30740://Alliance champion
+                    case 32308://Alliance guard
+                    {
+                        if (getDefenderTeam() == TEAM_ALLIANCE)
+                        {
+                            creature->SetPhaseMask(1, true);
+                            creature->SetVisible(true);
+                        }
+                        else 
+                        {
+                            creature->SetPhaseMask(2, true);
+                            creature->SetVisible(false);
+                        }
+                        break;
+                    }
+                    case 30739://Horde champion
+                    case 32307://Horde guard
+                    {
+                        if (getDefenderTeam() == TEAM_ALLIANCE)
+                        {
+                            creature->SetPhaseMask(2, true);
+                            creature->SetVisible(false);
+                        }
+                        else 
+                        {
+                            creature->SetPhaseMask(1, true);
+                            creature->SetVisible(true);
+                        }
+                        break;
+                    }
+                }
+                _RespawnCreatureIfNeeded(creature, entry);
+                creature->AI()->EnterEvadeMode();
+                return false;
+            }
+            else //End of block to comment  */
+            {
+                TeamPairMap::const_iterator itr = m_creEntryPair.find(creature->GetCreatureData()->id);
+                if (itr != m_creEntryPair.end())
+                {
+                    entry = getDefenderTeam() == TEAM_ALLIANCE ? itr->second : itr->first;
+                    _RespawnCreatureIfNeeded(creature, entry);
+                    creature->AI()->EnterEvadeMode();
+                }
+                return false;
+            }
+        }
+        default:
+            return false;
+    }
+}
+
+bool OutdoorPvPWG::UpdateQuestGiverPosition(uint32 guid, Creature *creature)
+{
+    assert(guid);
+    Position pos = m_qgPosMap[std::pair<uint32, bool>(guid, getDefenderTeam() == TEAM_HORDE)];
+
+    if (creature && creature->IsInWorld())
+    {
+        // if not questgiver or position is the same, do nothing
+        if (creature->GetPositionX() == pos.GetPositionX() &&
+            creature->GetPositionY() == pos.GetPositionY() &&
+            creature->GetPositionZ() == pos.GetPositionZ())
+            return false;
+
+        if (creature->IsAlive() && creature->IsInCombat())
+        {
+            creature->CombatStop(true);
+            creature->getHostileRefManager().deleteReferences();
+            creature->AI()->EnterEvadeMode();
+        }
+
+        creature->SetHomePosition(pos);
+        if (creature->GetEntry() != 30400 || creature->GetEntry() != 30499)
+            creature->SetReactState(REACT_AGGRESSIVE);
+        creature->DestroyForNearbyPlayers();
+        if (!creature->GetMap()->IsGridLoaded(pos.GetPositionX(), pos.GetPositionY()))
+            creature->GetMap()->LoadGrid(pos.GetPositionX(), pos.GetPositionY());
+        creature->GetMap()->CreatureRelocation(creature, pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
+        if (!creature->IsAlive())
+            creature->Respawn(true);
+    }
+    else
+        sObjectMgr->MoveCreData(guid, 571, pos);
+
+    return true;
+}
+
+// Return false = Need to rebuild at battle End/Start
+//        true  = no need to rebuild (ie: Banners or teleporters)
+bool OutdoorPvPWG::UpdateGameObjectInfo(GameObject *go) const
+{
+    uint32 attFaction;
+    uint32 defFaction;
+
+    if (isWarTime())
+    {
+        attFaction = WintergraspFaction[getAttackerTeam()];
+        defFaction = WintergraspFaction[getDefenderTeam()];
+    }
+    else
+    {
+        attFaction = 35;
+        defFaction = 35;
+    }
+
+    if (!go || !go->GetGOInfo())
+       return true;
+
+    switch(go->GetGOInfo()->displayId)
+    {
+        case 8244: // Defender's Portal - Vehicle Teleporter
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getDefenderTeam()]);
+            return true;
+        case 7967: // Titan relic
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getAttackerTeam()]);
+            return true;
+        case 8165: // Wintergrasp Keep Door
+        case 7877: // Wintergrasp Fortress Wall
+        case 7878: // Wintergrasp Keep Tower
+        case 7906: // Wintergrasp Fortress Gate
+        case 7909: // Wintergrasp Wall
+            go->SetUInt32Value(GAMEOBJECT_FACTION, defFaction);
+            return false;
+        case 8256://Alliance Banner
+        case 5651://Alliance Banner
+             if (getDefenderTeam() == TEAM_ALLIANCE)
+             {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(1, true);
+                 else go->SetPhaseMask(2, true);
+             } else {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(2, true);
+                 else go->SetPhaseMask(1, true);
+             }
+             return true;
+        case 8257://Horde Banner
+        case 5652://Horde Banner
+             if (getDefenderTeam() == TEAM_ALLIANCE)
+             {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(2, true);
+                 else go->SetPhaseMask(1, true);
+             } else {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(1, true);
+                 else go->SetPhaseMask(2, true);
+             }
+             return true;
+        case 7900: // Flamewatch Tower - Shadowsight Tower - Winter's Edge Tower
+            go->SetUInt32Value(GAMEOBJECT_FACTION, attFaction);
+            return false;
+        case 8208: // Goblin Workshop
+        {
+            OPvPCapturePointWG *workshop = GetWorkshopByGOGuid(go->GetGUID());
+            if (workshop)
+                go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[workshop->m_buildingState->GetTeam()]);
+        }
+            return false;
+    }
+
+    // Note: this is only for test, still need db support
+    TeamPairMap::const_iterator itr = m_goDisplayPair.find(go->GetGOInfo()->displayId);
+    if (itr != m_goDisplayPair.end())
+    {
+        go->SetUInt32Value(GAMEOBJECT_DISPLAYID, getDefenderTeam() == TEAM_ALLIANCE ?
+            itr->second : itr->first);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPWG::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+        if (plr->getLevel() < 75)
+        {
+            plr->CastSpell(plr, SPELL_TELEPORT_DALARAN, true);
+            return;
+        }
+        if (plr->getLevel() > 74)
+        {
+            if (!plr->HasAura(SPELL_RECRUIT) && !plr->HasAura(SPELL_CORPORAL)
+                && !plr->HasAura(SPELL_LIEUTENANT))
+                plr->CastSpell(plr, SPELL_RECRUIT, true);
+
+            if (plr->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            } else if (m_towerDestroyedCount[getAttackerTeam()])
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
+        }
+    }
+
+    SendInitWorldStatesTo(plr);
+    OutdoorPvP::HandlePlayerEnterZone(plr, zone);
+    UpdateTenacityStack();
+}
+
+void OutdoorPvPWG::HandlePlayerResurrects(Player* pPlayer, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+        if (pPlayer->getLevel() > 74)
+        {
+            // Tenacity
+            if (pPlayer->GetTeamId() == TEAM_ALLIANCE && m_tenacityStack > 0 ||
+                pPlayer->GetTeamId() == TEAM_HORDE && m_tenacityStack < 0)
+            {
+                if (pPlayer->HasAura(SPELL_TENACITY))
+                    pPlayer->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+                int32 newStack = m_tenacityStack < 0 ? -m_tenacityStack : m_tenacityStack;
+                if (newStack > 20)
+                    newStack = 20;
+                pPlayer->SetAuraStack(SPELL_TENACITY, pPlayer, newStack);
+            }
+
+            if (pPlayer->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    pPlayer->SetAuraStack(SPELL_TOWER_CONTROL, pPlayer, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            } else if (m_towerDestroyedCount[getAttackerTeam()])
+                    pPlayer->SetAuraStack(SPELL_TOWER_CONTROL, pPlayer, m_towerDestroyedCount[getAttackerTeam()]);
+        }
+    }
+    OutdoorPvP::HandlePlayerResurrects(pPlayer, zone);
+}
+
+void OutdoorPvPWG::HandlePlayerLeaveZone(Player* pPlayer, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (!pPlayer->GetSession()->PlayerLogout())
+    {
+        //if (pPlayer->GetVehicle())
+            //pPlayer->GetVehicle()->Dismiss();
+        pPlayer->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        pPlayer->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        pPlayer->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        pPlayer->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        pPlayer->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+    }
+    pPlayer->RemoveAurasDueToSpell(SPELL_TENACITY);
+    OutdoorPvP::HandlePlayerLeaveZone(pPlayer, zone);
+    UpdateTenacityStack();
+}
+
+void OutdoorPvPWG::PromotePlayer(Player *killer) const
+{
+    Aura * aur;
+    if (aur = killer->GetAura(SPELL_RECRUIT))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_RECRUIT);
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+            ChatHandler(killer->GetSession()).PSendSysMessage(LANG_BG_WG_RANK1);
+        } else killer->CastSpell(killer, SPELL_RECRUIT, true);
+    }
+    else if (aur = killer->GetAura(SPELL_CORPORAL))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_CORPORAL);
+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
+            ChatHandler(killer->GetSession()).PSendSysMessage(LANG_BG_WG_RANK2);
+        } else killer->CastSpell(killer, SPELL_CORPORAL, true);
+    }
+}
+
+void OutdoorPvPWG::HandleKill(Player *killer, Unit *victim)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED) || !isWarTime())
+        return;
+
+    bool ok = false;
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (victim->getLevel() >= 70)
+            ok = true;
+        killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+    } else {
+        switch (GetCreatureType(victim->GetEntry()))
+        {
+            case CREATURE_SIEGE_VEHICLE:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL_V, victim);
+                ok = true;
+                break;
+            case CREATURE_GUARD:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+                ok = true;
+                break;
+            case CREATURE_TURRET:
+                ok = true;
+                break;
+        }
+    }
+
+    if (ok)
+    {
+        if (Group *pGroup = killer->GetGroup())
+        {
+            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                if (itr->GetSource()->IsAtGroupRewardDistance(killer) && itr->GetSource()->getLevel() > 74)
+                    PromotePlayer(itr->GetSource());
+        } else if (killer->getLevel() > 74)
+            PromotePlayer(killer);
+    }
+}
+
+// Recalculates Tenacity and applies it to Players / Vehicles
+void OutdoorPvPWG::UpdateTenacityStack()
+{
+    if (!isWarTime())
+        return;
+
+    TeamId team = TEAM_NEUTRAL;
+    uint32 allianceNum = 0;
+    uint32 hordeNum = 0;
+    int32 newStack = 0;
+
+    for (GuidSet::iterator itr = m_players[TEAM_ALLIANCE].begin(); itr != m_players[TEAM_ALLIANCE].end(); ++itr)
+        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+        {
+        if (player->getLevel() > 74)
+            ++allianceNum;
+        }
+
+    for (GuidSet::iterator itr = m_players[TEAM_HORDE].begin(); itr != m_players[TEAM_HORDE].end(); ++itr)
+        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+        {
+        if (player->getLevel() > 74)
+            ++hordeNum;
+        }
+
+    if (allianceNum && hordeNum)
+    {
+        if (allianceNum < hordeNum)
+            newStack = int32((float(hordeNum) / float(allianceNum) - 1)*4); // positive, should cast on alliance
+        else if (allianceNum > hordeNum)
+            newStack = int32((1 - float(allianceNum) / float(hordeNum))*4); // negative, should cast on horde
+    }
+
+    if (newStack == m_tenacityStack)
+        return;
+
+    if (m_tenacityStack > 0 && newStack <= 0) // old buff was on alliance
+        team = TEAM_ALLIANCE;
+    else if (m_tenacityStack < 0 && newStack >= 0) // old buff was on horde
+        team = TEAM_HORDE;
+
+    m_tenacityStack = newStack;
+
+    // Remove old buff
+    if (team != TEAM_NEUTRAL)
+    {
+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+        {
+            if (player->getLevel() > 74)
+                player->RemoveAurasDueToSpell(SPELL_TENACITY);
+        }
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
+    }
+
+    // Apply new buff
+    if (newStack)
+    {
+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
+        if (newStack < 0)
+            newStack = -newStack;
+        if (newStack > 20)
+            newStack = 20;
+
+        for (GuidSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+        {
+            if (player->getLevel() > 74)
+                player->SetAuraStack(SPELL_TENACITY, player, newStack);
+        }
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->SetAuraStack(SPELL_TENACITY_VEHICLE, (*itr), newStack);
+    }
+}
+
+void OutdoorPvPWG::UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod)
+{
+    uint32 value = timer%mod;
+    if (m_clock[digit] != value)
+    {
+        m_clock[digit] = value;
+        SendUpdateWorldState(ClockWorldState[digit], uint32(timer + time(NULL)));
+        sWorld->SetWintergrapsTimer(uint32(timer + time(NULL)), digit);
+    }
+}
+
+void OutdoorPvPWG::UpdateClock()
+{
+    uint32 timer = m_timer / 1000;
+    if (!isWarTime())
+        UpdateClockDigit(timer, 1, 10);
+    else
+        UpdateClockDigit(timer, 0, 10);
+
+    //Announce in all world, comment it if you don't like/need it
+    // Announce 30 minutes left
+    if ((m_timer>1800000) && (m_timer<1802000) && (m_wartime==false))
+        sWorld->SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_30);
+
+    // Announce 10 minutes left
+    if ((m_timer>600000) && (m_timer<602000) && (m_wartime==false))
+        sWorld->SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_10);
+}
+
+bool OutdoorPvPWG::Update(uint32 diff)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return false;
+
+    if (m_timer > diff)
+    {
+        m_timer -= diff;
+
+        if (isWarTime())
+        {
+            OutdoorPvP::Update(diff); // update capture points
+
+            /*********************************************************/
+            /***        BATTLEGROUND RESSURECTION SYSTEM           ***/
+            /*********************************************************/
+
+            //this should be handled by spell system
+            m_LastResurrectTime += diff;
+            if (m_LastResurrectTime >= RESURRECTION_INTERVAL)
+            {
+                if (GetReviveQueueSize())
+                {
+                    for (std::map<ObjectGuid, GuidVector>::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+                    {
+                        Creature* sh = NULL;
+                        for (GuidVector::const_iterator itr2 = (itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+                        {
+                            Player *plr = ObjectAccessor::FindPlayer(*itr2);
+                            if (!plr)
+                                continue;
+                            if (!sh && plr->IsInWorld())
+                            {
+                                sh = plr->GetMap()->GetCreature(itr->first);
+                                // only for visual effect
+                                if (sh)
+                                    // Spirit Heal, effect 117
+                                    sh->CastSpell(sh, SPELL_SPIRIT_HEAL, true);
+                            }
+
+                            // Resurrection visual
+                            if (sh && plr->GetDistance2d(sh) <= 18.0f)
+                            {
+                                plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
+                                m_ResurrectQueue.push_back(*itr2);
+                            }
+                        }
+                        (itr->second).clear();
+                    }
+
+                    m_ReviveQueue.clear();
+                    m_LastResurrectTime = 0;
+                } else m_LastResurrectTime = 0;
+            }
+            else if (m_LastResurrectTime > 500)    // Resurrect players only half a second later, to see spirit heal effect on NPC
+            {
+                for (GuidVector::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+                {
+                    Player *plr = ObjectAccessor::FindPlayer(*itr);
+                    if (!plr)
+                        continue;
+                    plr->ResurrectPlayer(1.0f);
+                    plr->CastSpell(plr, 6962, true);
+                    plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
+                    plr->SpawnCorpseBones(false);
+                }
+                m_ResurrectQueue.clear();
+            }
+        }
+        UpdateClock();
+    } else {
+        m_sendUpdate = false;
+        int32 entry = LANG_BG_WG_DEFENDED;
+
+        if (m_changeDefender)
+        {
+            m_changeDefender = false;
+            m_defender = getAttackerTeam();
+            entry = LANG_BG_WG_CAPTURED;
+           if (m_changeAlly == true || m_changeHorde == true) // If wg is switching (.wg switch)
+           {
+           RebuildAllBuildings();
+           m_changeAlly = false;
+           m_changeHorde = false;
+           }
+        }
+        if (isWarTime())
+        {
+            if (m_timer != 1) // 1 = forceStopBattle
+                sWorld->SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(entry), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+            EndBattle();
+        } else {
+            if (m_timer != 1)
+                sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_STARTS));
+            StartBattle();
+        }
+
+        UpdateAllWorldObject();
+        UpdateClock();
+        SendInitWorldStatesTo();
+        m_sendUpdate = true;
+    }
+
+    if (m_WSSaveTimer < diff)
+    {
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_WARTIME, m_wartime);
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_TIMER, m_timer);
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_DEFENDERS, m_defender);
+        m_WSSaveTimer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+    } else m_WSSaveTimer -= diff;
+
+   return false;
+}
+
+void OutdoorPvPWG::forceStartBattle()
+{// Uptime will do all the work
+    m_wartime = false;
+
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_START));
+    }
+    sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceStopBattle()
+{// Uptime will do all the work.
+
+    if (!isWarTime())
+        m_wartime = true;
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_STOP));
+    }
+       sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceChangeTeam()
+{
+    m_changeDefender = true;
+    m_timer = 1;
+    m_changeAlly = true;
+    m_changeHorde = true;
+
+    sWorld->SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_SWITCH_FACTION), sObjectMgr->GetTrinityStringForDBCLocale(getAttackerTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+    if (isWarTime())
+        forceStartBattle();
+    else
+        forceStopBattle();
+}
+
+// Can be forced by gm's while in battle so have to reset in case it was wartime
+void OutdoorPvPWG::StartBattle()
+{
+    uint32 CountDef=0;
+    uint32 CountAtk=0;
+    m_wartime = true;
+    m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME) * MINUTE * IN_MILLISECONDS;
+
+    //Remove Essence of Wintergrasp to all players
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+    sWorld->UpdateAreaDependentAuras();
+
+    // Remove All Wintergrasp auras. Add Recruit rank and Tower Control
+    for (GuidSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+        {
+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if (player->getLevel() < 75)
+            player->CastSpell(player, SPELL_TELEPORT_DALARAN, true);
+        else
+        {
+            CountAtk++;
+            player->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+            player->RemoveAurasByType(SPELL_AURA_FLY);
+            player->CastSpell(player, 45472, true); //prevent die if fall
+            player->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+            player->SetAuraStack(SPELL_TOWER_CONTROL, player, 3);
+            player->CastSpell(player, SPELL_RECRUIT, true);
+        }
+        }
+    }
+
+    // Remove All Wintergrasp auras. Add Recruit rank
+    for (GuidSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+        {
+        player->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        player->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if (player->getLevel() < 75)
+            player->CastSpell(player, SPELL_TELEPORT_DALARAN, true);
+        else
+        {
+            CountDef++;
+            player->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+            player->RemoveAurasByType(SPELL_AURA_FLY);
+            player->CastSpell(player, 45472, true); //prevent die if fall
+            player->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+            player->CastSpell(player, SPELL_RECRUIT, true);
+        }
+        }
+    }
+
+    if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE))
+    {
+        if ((CountAtk < sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK)) || (CountDef < sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF)))
+        {
+            if (CountAtk<=CountDef)
+                sWorld->SendWorldText(LANG_BG_WG_WORLD_NO_ATK);
+            if (CountDef<CountAtk)
+            {
+                sWorld->SendWorldText(LANG_BG_WG_WORLD_NO_DEF);
+                m_changeDefender=true;
+            }
+            forceStopBattle();
+            return;
+        }
+    }
+
+    //Uncomment to tele Defenders inside Fortress
+    //TeamCastSpell(getDefenderTeam(), SPELL_TELEPORT_FORTRESS);
+
+    UpdateTenacityStack();
+    // Update timer in players battlegrounds tab
+    sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::EndBattle()
+{
+    // Cast Essence of Wintergrasp to all players (CheckCast will determine who to cast)
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    sWorld->UpdateAreaDependentAuras();
+    //Sound on End Battle
+    for (GuidSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        if (getDefenderTeam()==TEAM_ALLIANCE)
+            TeamIDsound=OutdoorPvP_WG_SOUND_ALLIANCE_WINS; //Allience Win
+        else
+            TeamIDsound=OutdoorPvP_WG_SOUND_HORDE_WINS;  //Horde Win
+        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+        player->PlayDirectSound(TeamIDsound) ; // SoundOnEndWin
+    }
+    for (GuidSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+        player->PlayDirectSound(OutdoorPvP_WG_SOUND_NEAR_VICTORY) ; // SoundOnEndLoose
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        // destroyed all vehicles
+        while(!m_vehicles[team].empty())
+        {
+            Creature *veh = *m_vehicles[team].begin();
+            m_vehicles[team].erase(m_vehicles[team].begin());
+            veh->setDeathState(JUST_DIED);
+        }
+
+        if (m_players[team].empty())
+            continue;
+
+        for (GuidSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+        if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+        {
+            // When WG ends the zone is cleaned including corpses, revive all players if dead
+            if (player->isDead())
+            {
+                player->ResurrectPlayer(1.0f);
+                player->SpawnCorpseBones(false);
+            }
+            player->RemoveAurasDueToSpell(SPELL_TENACITY);
+            player->CombatStop(true);
+            player->getHostileRefManager().deleteReferences();
+        }
+        }
+        if (m_timer == 1) // Battle End was forced so no reward.
+        {
+            for (GuidSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            {
+                if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                {
+                player->RemoveAurasDueToSpell(SPELL_RECRUIT);
+                player->RemoveAurasDueToSpell(SPELL_CORPORAL);
+                player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+                player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+                player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+                }
+            }
+            continue;
+        }
+
+        // calculate rewards
+        uint32 intactNum = 0;
+        uint32 damagedNum = 0;
+        for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                if (workshop->m_buildingState->GetTeam() == team)
+                {
+                    if (workshop->m_buildingState->damageState == DAMAGE_DAMAGED)
+                        ++damagedNum;
+                    else if (workshop->m_buildingState->damageState == DAMAGE_INTACT)
+                        ++intactNum;
+                }
+        uint32 spellRewardId = team == getDefenderTeam() ? SPELL_VICTORY_REWARD : SPELL_DEFEAT_REWARD;
+        uint32 baseHonor = 0;
+        uint32 marks = 0;
+        uint32 playersWithRankNum = 0;
+        uint32 honor = 0;
+
+        if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+        {
+            // Calculate Level 70+ with Corporal or Lieutenant rank
+            for (GuidSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+                if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                {
+                if (player->getLevel() > 74 && (player->HasAura(SPELL_LIEUTENANT) || player->HasAura(SPELL_CORPORAL)))
+                    ++playersWithRankNum;
+                }
+            baseHonor = team == getDefenderTeam() ? sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE) : sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER) * m_towerDamagedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER) * m_towerDestroyedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING) * intactNum);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING) * damagedNum);
+            if (playersWithRankNum)
+                baseHonor /= playersWithRankNum;
+        }
+
+        for (GuidSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+                if (Player* const player = ObjectAccessor::FindPlayer(*itr))
+                {
+            if (player->getLevel() < 75)
+                continue; // No rewards for level <75
+
+            // give rewards
+            if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+            {
+                if (team == getDefenderTeam())
+                {
+                    if (player->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 3;
+                        honor = baseHonor;
+                    }
+                    else if (player->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 2;
+                        honor = baseHonor;
+                    } else {
+                        marks = 1;
+                        honor = 0;
+                    }
+                } else {
+                    if (player->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    }
+                    else if (player->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    } else {
+                        marks = 0;
+                        honor = 0;
+                    }
+                }
+                player->RewardHonor(NULL, 1, honor);
+                RewardMarkOfHonor(player, marks);
+                 player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, spellRewardId);
+            } else {
+                if (player->HasAura(SPELL_LIEUTENANT) || player->HasAura(SPELL_CORPORAL))
+                {
+                    // TODO - Honor from SpellReward should be shared by team players
+                    // TODO - Marks should be given depending on Rank but 3 are given
+                    // each time so Won't give any to recruits
+                    player->CastSpell(player, spellRewardId, true);
+                    for (uint32 i = 0; i < intactNum; ++i)
+                        player->CastSpell(player, SPELL_INTACT_BUILDING, true);
+                    for (uint32 i = 0; i < damagedNum; ++i)
+                        player->CastSpell(player, SPELL_DAMAGED_BUILDING, true);
+                    for (uint32 i = 0; i < m_towerDamagedCount[OTHER_TEAM(team)]; ++i)
+                        player->CastSpell(player, SPELL_DAMAGED_TOWER, true);
+                    for (uint32 i = 0; i < m_towerDestroyedCount[OTHER_TEAM(team)]; ++i)
+                        player->CastSpell(player, SPELL_DESTROYED_TOWER, true);
+                }
+            }
+            if (team == getDefenderTeam())
+            {
+                if (player->HasAura(SPELL_LIEUTENANT) || player->HasAura(SPELL_CORPORAL))
+                {
+                    player->AreaExploredOrEventHappens(A_VICTORY_IN_WG);
+                    player->AreaExploredOrEventHappens(H_VICTORY_IN_WG);
+                }
+            }
+            player->RemoveAurasDueToSpell(SPELL_RECRUIT);
+            player->RemoveAurasDueToSpell(SPELL_CORPORAL);
+            player->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+            player->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+            player->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        }
+    }
+    }
+
+    m_wartime = false;
+    m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL) * MINUTE * IN_MILLISECONDS;
+    RemoveOfflinePlayerWGAuras();
+    // Update timer in players battlegrounds tab
+    sWorld->SendWintergraspState();
+    // update go factions
+    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
+       UpdateGameObjectInfo(*itr);
+}
+
+bool OutdoorPvPWG::CanBuildVehicle(OPvPCapturePointWG *workshop) const
+{
+    TeamId team = workshop->m_buildingState->GetTeam();
+    if (team == TEAM_NEUTRAL)
+        return false;
+
+    return isWarTime()
+        && workshop->m_buildingState->damageState != DAMAGE_DESTROYED
+        && m_vehicles[team].size() < m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP;
+}
+
+uint32 OutdoorPvPWG::GetData(uint32 id)
+{
+    // if can build more vehicles
+    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(id))
+        return CanBuildVehicle(workshop) ? 1 : 0;
+
+    return 0;
+}
+
+void OutdoorPvPWG::RewardMarkOfHonor(Player *plr, uint32 count)
+{
+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
+    if (plr->HasAura(SPELL_AURA_PLAYER_INACTIVE))
+        return;
+    if (count == 0)
+        return;
+
+    ItemPosCountVec dest;
+    uint32 no_space_count = 0;
+    uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
+
+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
+    {
+        TC_LOG_ERROR("sql.sql", "Wintergrasp reward item (Entry %u) not exist in `item_template`.", WG_MARK_OF_HONOR);
+        return;
+    }
+
+    if (msg != EQUIP_ERR_OK) // convert to possible store amount
+        count -= no_space_count;
+
+    if (count != 0 && !dest.empty()) // can add some
+        if (Item* item = plr->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
+            plr->SendNewItem(item, count, true, false);
+}
+
+void OutdoorPvPWG::LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli)
+{
+    m_qgPosMap[std::pair<uint32, bool>(guid, true)] = posHorde,
+    m_qgPosMap[std::pair<uint32, bool>(guid, false)] = posAlli,
+    m_questgivers[guid] = NULL;
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+        sObjectMgr->MoveCreData(guid, 571, posAlli);
+    if (getDefenderTeam() == TEAM_HORDE)
+        sObjectMgr->MoveCreData(guid, 571, posHorde);
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshop(uint32 lowguid) const
+{
+    if (OPvPCapturePoint *cp = GetCapturePoint(lowguid))
+        return dynamic_cast<OPvPCapturePointWG*>(cp);
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByEngGuid(uint32 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_engGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByGOGuid(uint64 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_workshopGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+/*########################################################
+ * Copy of Battleground system to make Spirit Guides Work
+ *#######################################################*/
+void OutdoorPvPWG::SendAreaSpiritHealerQueryOpcode(Player *pl, ObjectGuid guid)
+{
+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+    uint32 time_ = 30000 - m_LastResurrectTime;      // resurrect every 30 seconds
+    if (time_ == uint32(-1))
+        time_ = 0;
+    data << guid << time_;
+    pl->GetSession()->SendPacket(&data);
+}
+
+void OutdoorPvPWG::AddPlayerToResurrectQueue(ObjectGuid npc_guid, ObjectGuid player_guid)
+{
+    m_ReviveQueue[npc_guid].push_back(player_guid);
+
+    Player *plr = ObjectAccessor::FindPlayer(player_guid);
+    if (!plr)
+        return;
+
+    plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
+}
+
+void OutdoorPvPWG::RemovePlayerFromResurrectQueue(ObjectGuid player_guid)
+{
+    for (std::map<ObjectGuid, GuidVector>::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+    {
+        for (GuidVector::iterator itr2 =(itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+        {
+            if (*itr2 == player_guid)
+            {
+                (itr->second).erase(itr2);
+
+                Player *plr = ObjectAccessor::FindPlayer(player_guid);
+                if (!plr)
+                    return;
+
+                plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
+
+                return;
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateAllianceDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    GuidVector ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (GuidVector::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = ObjectAccessor::FindPlayer(*itr);
+            if (!plr)
+                continue;
+
+            if (plr->getFaction() == ALLIANCE)
+            {
+                if (ClosestGrave)
+                    plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+                else
+                    ClosestGrave = sObjectMgr->GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateHordeDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    GuidVector ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (GuidVector::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = ObjectAccessor::FindPlayer(*itr);
+            if (!plr)
+                continue;
+            if (plr->getFaction() == HORDE)
+            {
+                if (ClosestGrave)
+                    plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+                else
+                    ClosestGrave = sObjectMgr->GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+            }
+        }
+    }
+}
+
+OPvPCapturePointWG::OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state) : OPvPCapturePoint(opvp), m_spiGuid(0), m_spiritguide(NULL), m_spiritguide_horde(NULL), m_spiritguide_alliance(NULL), m_engGuid(0), m_engineer(NULL), m_buildingState(state), m_wintergrasp(opvp) {}
+
+void OPvPCapturePointWG::SetTeamByBuildingState()
+{
+    if (m_buildingState->GetTeam() == TEAM_ALLIANCE)
+    {
+        m_value = m_maxValue;
+        m_State = OBJECTIVESTATE_ALLIANCE;
+    }
+    else if (m_buildingState->GetTeam() == TEAM_HORDE)
+    {
+        m_value = -m_maxValue;
+        m_State = OBJECTIVESTATE_HORDE;
+    } else {
+        m_value = 0;
+        m_State = OBJECTIVESTATE_NEUTRAL;
+    }
+
+    if (m_team != m_buildingState->GetTeam())
+    {
+        TeamId oldTeam = m_team;
+        m_team = m_buildingState->GetTeam();
+        ChangeTeam(oldTeam);
+    }
+
+    SendChangePhase();
+}
+
+void OPvPCapturePointWG::ChangeTeam(TeamId oldTeam)
+{
+    entry = 0;
+    guide_entry = 0;
+    guide_entry_fortress_horde = 0;
+    guide_entry_fortress_alliance = 0;
+
+    if (oldTeam != TEAM_NEUTRAL)
+        m_wintergrasp->ModifyWorkshopCount(oldTeam, false);
+
+    if (m_team != TEAM_NEUTRAL)
+    {
+        entry = m_team == TEAM_ALLIANCE ? CRE_ENG_A : CRE_ENG_H;
+        guide_entry = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_H;
+        guide_entry_fortress_horde = m_team == TEAM_HORDE ? CRE_SPI_H : CRE_SPI_H;
+        guide_entry_fortress_alliance = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_A;
+        m_wintergrasp->ModifyWorkshopCount(m_team, true);
+    }
+
+    if (m_capturePoint)
+        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointSpawnId);
+
+    m_buildingState->SetTeam(m_team);
+    // TODO: this may be sent twice
+    m_wintergrasp->BroadcastStateChange(m_buildingState);
+
+    if (m_buildingState->building)
+        m_buildingState->building->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_team]);
+
+    if (entry)
+    {
+        if (m_engGuid)
+        {
+            *m_engEntry = entry;
+            _RespawnCreatureIfNeeded(m_engineer, entry);
+        }
+        if (m_spiGuid)
+        {
+            if (m_wintergrasp->getAttackerTeam() == TEAM_ALLIANCE)
+            {
+                *m_spiEntry = guide_entry;
+                _RespawnCreatureIfNeeded(m_spiritguide_horde, guide_entry_fortress_horde);
+                m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide_horde); // Horde
+                _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+                m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide); // Alliance
+            } else {
+                *m_spiEntry = guide_entry;
+                _RespawnCreatureIfNeeded(m_spiritguide_alliance, guide_entry_fortress_alliance);
+                m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide_alliance); // Alliance
+                _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+                m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide); // Horde
+            }
+        }
+    } else if (m_engineer)
+        m_engineer->SetVisible(false);
+}
+
+class OutdoorPvP_wintergrasp : public OutdoorPvPScript
+{
+    public:
+        OutdoorPvP_wintergrasp() : OutdoorPvPScript("outdoorpvp_wg") { }
+
+        OutdoorPvP* GetOutdoorPvP() const
+        {
+            return new OutdoorPvPWG();
+        }
+};
+
+void AddSC_outdoorpvp_wg()
+{
+    new OutdoorPvP_wintergrasp();
+}
\ No newline at end of file
diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
new file mode 100644
index 0000000..58ce247
--- /dev/null
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2008 - 2012 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2012 Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_WG_
+#define OUTDOOR_PVP_WG_
+
+#include "OutdoorPvP.h"
+#include "BattlegroundMgr.h"
+#include "Player.h"
+
+#define ZONE_DALARAN             4395
+#define ZONE_WINTERGRASP         4197
+#define POS_X_CENTER             5100
+#define MAX_VEHICLE_PER_WORKSHOP    4
+
+//Creature faction. Needed for proper displaying data(count) about summoned siege machines by teams
+const uint32 WintergraspFaction[3] = {1802, 1801, 35}; //YTDB
+//const uint32 WintergraspFaction[3] = {1732, 1735, 35}; //TDB
+
+const uint32 WG_MARK_OF_HONOR = 43589;
+const uint32 VehNumWorldState[2] = {3680,3490};
+const uint32 MaxVehNumWorldState[2] = {3681,3491};
+const uint32 ClockWorldState[2] = {3781,4354};
+const uint8 CapturePointArtKit[3] = {2, 1, 21};
+char const *fmtstring(char const *format, ...);
+const Team TeamId2Team[3] = {ALLIANCE, HORDE, TEAM_OTHER};
+
+enum OutdoorPvPWGSpell
+{
+    // Wartime auras
+    SPELL_RECRUIT                                = 37795,
+    SPELL_CORPORAL                               = 33280,
+    SPELL_LIEUTENANT                             = 55629,
+    SPELL_TENACITY                               = 58549,
+    SPELL_TENACITY_VEHICLE                       = 59911,
+    SPELL_TOWER_CONTROL                          = 62064,
+    SPELL_SPIRITUAL_IMMUNITY                     = 58729,
+
+    // Reward spells
+    SPELL_VICTORY_REWARD                         = 56902,
+    SPELL_DEFEAT_REWARD                          = 58494,
+    SPELL_DAMAGED_TOWER                          = 59135,
+    SPELL_DESTROYED_TOWER                        = 59136,
+    SPELL_DAMAGED_BUILDING                       = 59201,
+    SPELL_INTACT_BUILDING                        = 59203,
+
+    SPELL_TELEPORT_ALLIENCE_CAMP                 = 58633,
+    SPELL_TELEPORT_HORDE_CAMP                    = 58632,
+    SPELL_TELEPORT_FORTRESS                      = 59096,
+
+    SPELL_TELEPORT_DALARAN                       = 53360,
+    SPELL_VICTORY_AURA                           = 60044,
+};
+
+const uint16 GameEventWintergraspDefender[2] = {50, 51};
+
+enum OutdoorPvP_WG_Sounds
+{
+    OutdoorPvP_WG_SOUND_KEEP_CLAIMED            = 8192,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE  = 8173,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE     = 8213,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE = 8212,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE    = 8174,
+    OutdoorPvP_WG_SOUND_NEAR_VICTORY            = 8456,
+    OutdoorPvP_WG_SOUND_HORDE_WINS              = 8454,
+    OutdoorPvP_WG_SOUND_ALLIANCE_WINS           = 8455,
+    OutdoorPvP_WG_SOUND_WORKSHOP_Horde          = 6205,
+    OutdoorPvP_WG_SOUND_WORKSHOP_ALLIANCE       = 6298,
+    OutdoorPvP_WG_HORDE_CAPTAIN                 = 8333,
+    OutdoorPvP_WG_ALLIANCE_CAPTAIN              = 8232,
+    OutdoorPvP_WG_SOUND_START_BATTLE            = 3439, //Standart BG Start sound
+};
+
+enum DataId
+{
+     DATA_ENGINEER_DIE,
+};
+
+enum OutdoorPvP_WG_KeepStatus
+{
+    OutdoorPvP_WG_KEEP_TYPE_NEUTRAL             = 0,
+    OutdoorPvP_WG_KEEP_TYPE_CONTESTED           = 1,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_CONTESTED    = 1,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_CONTESTED   = 2,
+    OutdoorPvP_WG_KEEP_TYPE_OCCUPIED            = 3,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_OCCUPIED     = 3,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_OCCUPIED    = 4
+};
+
+enum OutdoorPVPWGStatus
+{
+    WORLDSTATE_WINTERGRASP_WARTIME            = 31001,
+    WORLDSTATE_WINTERGRASP_TIMER              = 31002,
+    WORLDSTATE_WINTERGRASP_DEFENDERS          = 31003,
+    WORLDSTATE_WINTERGRASP_CONTROLING_FACTION = 31004,
+    WORLDSTATE_VALUE_COUNT,
+};
+
+enum OutdoorPvPWGCreType
+{
+    CREATURE_OTHER,
+    CREATURE_SIEGE_VEHICLE,
+    CREATURE_TURRET,
+    CREATURE_ENGINEER,
+    CREATURE_GUARD,
+    CREATURE_SPECIAL,
+    CREATURE_SPIRIT_GUIDE,
+    CREATURE_SPIRIT_HEALER,
+    CREATURE_QUESTGIVER,
+};
+
+enum OutdoorPvPWGBuildingType
+{
+    BUILDING_WALL,
+    BUILDING_WORKSHOP,
+    BUILDING_TOWER,
+};
+
+enum OutdoorPvPWGDamageState
+{ // Do not change order
+    DAMAGE_INTACT,
+    DAMAGE_DAMAGED,
+    DAMAGE_DESTROYED,
+};
+
+typedef uint32 TeamPair[2];
+
+enum OutdoorPvPWGQuest
+{
+    A_VICTORY_IN_WG                              = 13181,
+    H_VICTORY_IN_WG                              = 13183,
+    CRE_PVP_KILL                                 = 31086, //Quest Objective - Fixme: this should be handled by DB
+    CRE_PVP_KILL_V                               = 31093, //Quest Objective - Fixme: this should be handled by DB.
+    TOWER_PVP_DESTROYED                          = 35074, //Quest Objective - Toppling the Towers & Southern Sabotage
+};
+
+enum OutdoorPvPWGCreEntry
+{
+    CRE_ENG_A                                    = 30499,
+    CRE_ENG_H                                    = 30400,
+    CRE_SPI_A                                    = 31842,
+    CRE_SPI_H                                    = 31841,
+};
+
+const TeamPair OutdoorPvPWGCreEntryPair[] =
+{
+    {32307, 32308}, // Guards
+    {30739, 30740}, // Champions
+    {32296, 32294}, // Quartermaster
+    {39173, 39172}, // Ros'slai & Marshal Magruder
+    {32615, 32626}, // Warbringer & Brigadier General
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const TeamPair OutdoorPvPWGGODisplayPair[] =
+{
+    {5651, 5652},
+    {8256, 8257},
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const uint32 AreaPOIIconId[3][3] = {{7,8,9},{4,5,6},{1,2,3}};
+typedef std::list<const AreaPOIEntry *> AreaPOIList;
+
+struct BuildingState
+{
+    explicit BuildingState(uint32 _worldState, TeamId _team, bool asDefault)
+         : worldState(_worldState), health(0)
+         , defaultTeam(asDefault ? _team : OTHER_TEAM(_team)), damageState(DAMAGE_INTACT), team(_team)
+         , building(NULL), graveTeam(NULL), type(BUILDING_WALL) {}
+    uint32 worldState;
+    uint32 health;
+    TeamId defaultTeam;
+    OutdoorPvPWGDamageState damageState;
+    TeamId team;
+    GameObject *building;
+    uint32 *graveTeam;
+    OutdoorPvPWGBuildingType type;
+
+    void SendUpdate(Player *player) const
+    {
+        player->SendUpdateWorldState(worldState, AreaPOIIconId[team][damageState]);
+    }
+
+    void FillData(WorldPacket &data) const
+    {
+        data << worldState << AreaPOIIconId[team][damageState];
+    }
+
+    TeamId GetTeam() const { return team; }
+    void SetTeam(TeamId t)
+    {
+        team = t;
+        if(graveTeam)
+            if (uint32 newTeam = TeamId2Team[t])
+                *graveTeam = newTeam;
+    }
+};
+
+typedef std::map<uint32, uint32> TeamPairMap;
+class OPvPCapturePointWG;
+
+class OutdoorPvPWG : public OutdoorPvP
+{
+    protected:
+        typedef std::map<uint32, BuildingState *> BuildingStateMap;
+        typedef std::set<Creature*> CreatureSet;
+        typedef std::set<GameObject*> GameObjectSet;
+        typedef std::map<std::pair<uint32, bool>, Position> QuestGiverPositionMap;
+        typedef std::map<uint32, Creature*> QuestGiverMap;
+
+    public:
+        OutdoorPvPWG();
+        bool SetupOutdoorPvP();
+        int TeamIDsound;
+        uint32 GetCreatureEntry(uint32 guidlow, const CreatureData *data);
+        void OnCreatureCreate(Creature *creature);
+        void OnGameObjectCreate(GameObject *go);
+        void OnCreatureRemove(Creature *creature);
+        void OnGameObjectRemove(GameObject *go);
+        void ProcessEvent(WorldObject *objin, uint32 eventId);
+        void HandlePlayerEnterZone(Player *plr, uint32 zone);
+        void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+        void HandlePlayerResurrects(Player * plr, uint32 zone);
+        void HandleKill(Player *killer, Unit *victim);
+        bool Update(uint32 diff);
+        void BroadcastStateChange(BuildingState *state) const;
+        uint32 GetData(uint32 id);
+        void ModifyWorkshopCount(TeamId team, bool add);
+        uint32 GetTimer() const { return m_timer / 1000; };
+        bool isWarTime() const { return m_wartime; };
+        void setTimer(uint32 timer) { if (timer >= 0) m_timer = timer; };
+        uint32 GetNumPlayersA() const { return m_players[TEAM_ALLIANCE].size(); };
+        uint32 GetNumPlayersH() const { return m_players[TEAM_HORDE].size(); };
+        TeamId getDefenderTeam() const { return m_defender; };
+        TeamId getAttackerTeam() const { return OTHER_TEAM(m_defender); };
+        void forceChangeTeam();
+        void forceStopBattle();
+        void forceStartBattle();
+        // Temporal BG specific till 3.2
+        void SendAreaSpiritHealerQueryOpcode(Player *pl, ObjectGuid guid);
+        void AddPlayerToResurrectQueue(ObjectGuid npc_guid, ObjectGuid player_guid);
+        void RemovePlayerFromResurrectQueue(ObjectGuid player_guid);
+        void RelocateAllianceDeadPlayers(Creature *cr);
+        void RelocateHordeDeadPlayers(Creature *cr);
+        // BG end
+        void SendInitWorldStatesTo(Player *player = NULL) const;
+        uint32 m_timer;
+        bool m_changeAlly;
+        bool m_changeHorde;
+
+    protected:
+        // Temporal BG specific till 3.2
+        GuidVector m_ResurrectQueue;               // Player GUID
+        uint32 m_LastResurrectTime;
+        // Spirit Guide guid + Player list GUIDS
+        std::map<ObjectGuid, GuidVector>  m_ReviveQueue;
+
+        uint32 GetLastResurrectTime() const { return m_LastResurrectTime; }
+        uint32 GetReviveQueueSize() const { return m_ReviveQueue.size(); }
+        // BG end
+        TeamId m_defender;
+        int32 m_tenacityStack;
+
+        BuildingStateMap m_buildingStates;
+        BuildingState *m_gate;
+
+        CreatureSet m_creatures;
+        CreatureSet m_vehicles[2];
+        GameObjectSet m_gobjects;
+        GameObjectSet m_gobjectsDestroyable;
+        QuestGiverMap m_questgivers;
+
+        TeamPairMap m_creEntryPair, m_goDisplayPair;
+        QuestGiverPositionMap m_qgPosMap;
+
+        bool m_wartime;
+        bool m_changeDefender;
+        uint32 m_clock[2];
+        uint32 m_workshopCount[2];
+        uint32 m_towerDestroyedCount[2];
+        uint32 m_towerDamagedCount[2];
+        uint32 m_WSSaveTimer;
+
+        OPvPCapturePointWG *GetWorkshop(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByEngGuid(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByGOGuid(uint64 lowguid) const;
+
+        void StartBattle();
+        void EndBattle();
+        void UpdateClock();
+        void UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod);
+        void PromotePlayer(Player *player) const;
+        void UpdateTenacityStack();
+        void UpdateAllWorldObject();
+        bool UpdateCreatureInfo(Creature *creature);
+        bool UpdateGameObjectInfo(GameObject *go) const;
+        bool CanBuildVehicle(OPvPCapturePointWG *workshop) const;
+        OutdoorPvPWGCreType GetCreatureType(uint32 entry) const;
+
+        void RebuildAllBuildings();
+        void RemoveOfflinePlayerWGAuras();
+        void RewardMarkOfHonor(Player *player, uint32 count);
+        void MoveQuestGiver(uint32 guid);
+        void LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli);
+        bool UpdateQuestGiverPosition(uint32 guid, Creature *creature);
+};
+
+class OPvPCapturePointWG : public OPvPCapturePoint
+{
+    public:
+        explicit OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state);
+        void SetTeamByBuildingState();
+        void ChangeState() { }
+        void ChangeTeam(TeamId oldteam);
+        uint32 *m_spiEntry;
+        uint32 m_spiGuid;
+        Creature *m_spiritguide;
+        Creature *m_spiritguide_horde;
+        Creature *m_spiritguide_alliance;
+        uint32 *m_engEntry;
+        uint32 m_engGuid;
+        Creature *m_engineer;
+        uint32 m_workshopGuid;
+        BuildingState *m_buildingState;
+
+    protected:
+        OutdoorPvPWG *m_wintergrasp;
+};
+#endif
\ No newline at end of file
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 03d527b..d3a04f0 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2318,57 +2318,115 @@ Battleground.RewardLoserHonorLast   = 5
 ###################################################################################################
 
 ###################################################################################################
-# BATTLEFIELD CONFIG
+# WINTERGRASP OPTIONS
 #
-#     Wintergrasp.Enable
-#         Description: Enable the Wintergrasp battlefield.
-#         Default:     0 - (Disabled)
-#                      1 - (Enabled, Experimental as in incomplete, bugged and with crashes)
-
-Wintergrasp.Enable = 0
+#   OutdoorPvP.Wintergrasp.Enabled
+#       Determines whether the Wintergrasp battle is enabled or not.
+#       Default: 1 = Enable
+#                0 = Disable
 
+OutdoorPvP.Wintergrasp.Enabled = 1
 #
-#     Wintergrasp.PlayerMax
-#         Description: Maximum number of players allowed in Wintergrasp.
-#         Default:     100
+#   OutdoorPvP.Wintergrasp.SaveState.Period
+#      Interval (in milliseconds) of Save Wintergrasp State Data to restore it after crash/shutdown/restart
+#      Default (60000 milliseconds)
+#      Warning:  Do not set it less 1 second!
 
-Wintergrasp.PlayerMax = 100
+OutdoorPvP.Wintergrasp.SaveState.Period = 60000
 
-#
-#     Wintergrasp.PlayerMin
-#         Description: Minimum number of players required for Wintergrasp.
-#         Default:     0
+#   OutdoorPvP.Wintergrasp.StartTime
+#       The start time of the first battle after server starts (in minutes)
+#       Default: 30
 
-Wintergrasp.PlayerMin = 0
+OutdoorPvP.Wintergrasp.StartTime = 30
 
-#
-#     Wintergrasp.PlayerMinLvl
-#         Description: Required character level for the Wintergrasp battle.
-#         Default:     77
+#   OutdoorPvP.Wintergrasp.BattleTime
+#       Time limit of a battle (in minutes)
+#       Default: 30
 
-Wintergrasp.PlayerMinLvl = 77
+OutdoorPvP.Wintergrasp.BattleTime = 30
 
-#
-#     Wintergrasp.BattleTimer
-#         Description: Time (in minutes) for the Wintergrasp battle to last.
-#         Default:     30
+#   OutdoorPvP.Wintergrasp.Interval
+#       Interval between battles (in minutes)
+#       Default: 150
 
-Wintergrasp.BattleTimer = 30
+OutdoorPvP.Wintergrasp.Interval = 150
 
-#
-#     Wintergrasp.NoBattleTimer
-#         Description: Time (in minutes) between Wintergrasp battles.
-#         Default:     150
+#   OutdoorPvP.Wintergrasp.CustomHonorRewards
+#       Defines whether custom honor rewards should be given to player
+#        for partaking in the Wintergrasp Battle.
+#        Default: 0 = Disable
+#                 1 = Enable
 
-Wintergrasp.NoBattleTimer = 150
+OutdoorPvP.Wintergrasp.CustomHonorRewards = 0
 
-#
-#     Wintergrasp.CrashRestartTimer
-#         Description: Time (in minutes) to delay the restart of Wintergrasp if the world server
-#                      crashed during a running battle.
-#         Default:     10
+#   OutdoorPvP.Wintergrasp.CustomHonorBattleWin
+#       Defines the amount of honor points that should be given to the
+#        team winning the Wintergrasp Battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 3000
+
+OutdoorPvP.Wintergrasp.CustomHonorBattleWin = 3000
+
+#   OutdoorPvP.Wintergrasp.CustomHonorBattleLose
+#       Defines the amount of honor points that should be given to the
+#        team losing the Wintergrasp Battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 1250
+
+OutdoorPvP.Wintergrasp.CustomHonorBattleLose = 1250
+
+#   OutdoorPvP.Wintergrasp.CustomHonorDamageTower
+#       Defines the amount of honor points that should be given to the
+#        team for damaging a tower.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+
+OutdoorPvP.Wintergrasp.CustomHonorDamageTower = 750
+
+#   OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower
+#       Defines the amount of honor points that should be given to the
+#        team for destroying a tower.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+
+OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower = 750
+
+#   OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding
+#       Defines the amount of honor points that should be given to the
+#        team for damaged buildings after the battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+
+OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding = 750
+
+#   OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding
+#      Defines the amount of honor points that should be given to the
+#        team for intact buildings after the battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 1500
+
+OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding = 1500
+
+#   OutdoorPvP.Wintergrasp.Antifarm.Enable
+#		Enable or Disable antifarm system
+#       Prevents start WG battle event if there are too low players (see options bellow)
+#       Default: 0 - Disabled
+#                1 - Enabled
+
+OutdoorPvP.Wintergrasp.Antifarm.Enable = 0
+
+#   OutdoorPvP.Wintergrasp.Antifarm.Atk
+#		Min count of attackers for antifarm
+#              (Default: 5)
+
+OutdoorPvP.Wintergrasp.Antifarm.Atk = 5
+
+#   OutdoorPvP.Wintergrasp.Antifarm.Def
+#		Min count of defenders for antifarm
+#              (Default: 5)
 
-Wintergrasp.CrashRestartTimer = 10
+OutdoorPvP.Wintergrasp.Antifarm.Def = 5
 
 #
 ###################################################################################################
-- 
2.1.4

