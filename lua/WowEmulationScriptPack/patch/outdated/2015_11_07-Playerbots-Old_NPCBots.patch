From c32021936cc77776f76a9af965c57674bbd333fa Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Sat, 7 Nov 2015 08:16:27 -0600
Subject: [PATCH] 2015_11_07-Playerbots-Old_NPCBots

---
 .../Playerbot_NPCBots/auth_rbac.sql                |    31 +
 .../Playerbot_NPCBots/character_NPC_bots.sql       |    28 +
 ...world_bot_helper_locales_gossip_menu_option.sql |    92 +
 .../Playerbot_NPCBots/world_bots.sql               |   556 +
 .../world_creature_template_outfits.sql            |    42 +
 .../Database/Implementation/CharacterDatabase.cpp  |    14 +-
 .../Database/Implementation/CharacterDatabase.h    |    10 +-
 .../Database/Implementation/WorldDatabase.cpp      |     3 +
 .../Database/Implementation/WorldDatabase.h        |     4 +
 src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp    |   121 +
 src/server/game/AI/NpcBots/bot_GridNotifiers.h     |   594 +
 src/server/game/AI/NpcBots/bot_ai.cpp              |  5027 ++++++++
 src/server/game/AI/NpcBots/bot_ai.h                |   607 +
 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp |  1698 +++
 src/server/game/AI/NpcBots/bot_druid_ai.cpp        |  1195 ++
 src/server/game/AI/NpcBots/bot_hunter_ai.cpp       |  1167 ++
 src/server/game/AI/NpcBots/bot_mage_ai.cpp         |  1007 ++
 src/server/game/AI/NpcBots/bot_paladin_ai.cpp      |  1125 ++
 src/server/game/AI/NpcBots/bot_priest_ai.cpp       |  1042 ++
 src/server/game/AI/NpcBots/bot_rogue_ai.cpp        |   884 ++
 src/server/game/AI/NpcBots/bot_shaman_ai.cpp       |  1383 +++
 src/server/game/AI/NpcBots/bot_warlock_ai.cpp      |   547 +
 src/server/game/AI/NpcBots/bot_warrior_ai.cpp      |  1144 ++
 src/server/game/AI/NpcBots/botcommands.cpp         |   660 +
 src/server/game/AI/NpcBots/botgiver.cpp            |   340 +
 src/server/game/AI/NpcBots/bothelper.cpp           |   421 +
 src/server/game/AI/NpcBots/bothelper.h             |    32 +
 src/server/game/AI/PlayerBots/PlayerbotAI.cpp      | 11882 +++++++++++++++++++
 src/server/game/AI/PlayerBots/PlayerbotAI.h        |  2130 ++++
 .../game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp  |   501 +
 .../game/AI/PlayerBots/PlayerbotDeathKnightAI.h    |   100 +
 src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp |   716 ++
 src/server/game/AI/PlayerBots/PlayerbotDruidAI.h   |   199 +
 .../game/AI/PlayerBots/PlayerbotHunterAI.cpp       |   395 +
 src/server/game/AI/PlayerBots/PlayerbotHunterAI.h  |   121 +
 src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp  |   473 +
 src/server/game/AI/PlayerBots/PlayerbotMageAI.h    |   163 +
 .../game/AI/PlayerBots/PlayerbotPaladinAI.cpp      |   619 +
 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h |   187 +
 .../game/AI/PlayerBots/PlayerbotPriestAI.cpp       |   483 +
 src/server/game/AI/PlayerBots/PlayerbotPriestAI.h  |   157 +
 src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp |   345 +
 src/server/game/AI/PlayerBots/PlayerbotRogueAI.h   |   102 +
 .../game/AI/PlayerBots/PlayerbotShamanAI.cpp       |   556 +
 src/server/game/AI/PlayerBots/PlayerbotShamanAI.h  |   119 +
 .../game/AI/PlayerBots/PlayerbotWarlockAI.cpp      |   570 +
 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h |   250 +
 .../game/AI/PlayerBots/PlayerbotWarriorAI.cpp      |   354 +
 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h |   103 +
 src/server/game/Accounts/RBAC.h                    |    12 +-
 src/server/game/CMakeLists.txt                     |     2 +
 src/server/game/Entities/Creature/Creature.cpp     |   194 +
 src/server/game/Entities/Creature/Creature.h       |    54 +
 .../game/Entities/Creature/TemporarySummon.cpp     |     8 +
 src/server/game/Entities/Object/Object.cpp         |    11 +
 src/server/game/Entities/Player/Player.cpp         |  1021 +-
 src/server/game/Entities/Player/Player.h           |    87 +-
 src/server/game/Entities/Totem/Totem.cpp           |     7 +
 src/server/game/Entities/Unit/StatSystem.cpp       |     5 +
 src/server/game/Entities/Unit/Unit.cpp             |   214 +
 src/server/game/Globals/ObjectMgr.cpp              |    76 +
 src/server/game/Globals/ObjectMgr.h                |    20 +
 src/server/game/Groups/Group.cpp                   |    16 +
 src/server/game/Groups/Group.h                     |     3 +
 src/server/game/Handlers/CharacterHandler.cpp      |   156 +-
 src/server/game/Handlers/ChatHandler.cpp           |    33 +-
 src/server/game/Handlers/GroupHandler.cpp          |    14 +
 src/server/game/Handlers/MiscHandler.cpp           |    35 +
 src/server/game/Handlers/NPCHandler.cpp            |    33 +
 src/server/game/Handlers/QuestHandler.cpp          |     7 +
 src/server/game/Handlers/SpellHandler.cpp          |    30 +
 src/server/game/Maps/Map.cpp                       |     3 +
 src/server/game/Scripting/ScriptLoader.cpp         |    35 +-
 src/server/game/Server/WorldSession.cpp            |   103 +-
 src/server/game/Server/WorldSession.h              |    41 +
 src/server/game/World/World.cpp                    |     3 +
 src/server/scripts/Spells/spell_priest.cpp         |     4 +
 src/server/worldserver/worldserver.conf.dist       |   208 +
 78 files changed, 42716 insertions(+), 18 deletions(-)
 create mode 100644 sql/TrinityCore-Patches/Playerbot_NPCBots/auth_rbac.sql
 create mode 100644 sql/TrinityCore-Patches/Playerbot_NPCBots/character_NPC_bots.sql
 create mode 100644 sql/TrinityCore-Patches/Playerbot_NPCBots/world_bot_helper_locales_gossip_menu_option.sql
 create mode 100644 sql/TrinityCore-Patches/Playerbot_NPCBots/world_bots.sql
 create mode 100644 sql/TrinityCore-Patches/Playerbot_NPCBots/world_creature_template_outfits.sql
 create mode 100644 src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_GridNotifiers.h
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_druid_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_hunter_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_mage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_paladin_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_priest_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_rogue_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_shaman_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warlock_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warrior_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommands.cpp
 create mode 100644 src/server/game/AI/NpcBots/botgiver.cpp
 create mode 100644 src/server/game/AI/NpcBots/bothelper.cpp
 create mode 100644 src/server/game/AI/NpcBots/bothelper.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotMageAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h

diff --git a/sql/TrinityCore-Patches/Playerbot_NPCBots/auth_rbac.sql b/sql/TrinityCore-Patches/Playerbot_NPCBots/auth_rbac.sql
new file mode 100644
index 0000000..230f077
--- /dev/null
+++ b/sql/TrinityCore-Patches/Playerbot_NPCBots/auth_rbac.sql
@@ -0,0 +1,31 @@
+SET @NPCB_PERM := '1100';
+
+DELETE FROM `rbac_permissions` WHERE `id` BETWEEN @NPCB_PERM AND @NPCB_PERM+11;
+INSERT INTO `rbac_permissions` (`id`,`name`) VALUES
+(@NPCB_PERM+0,'npcbot'),
+(@NPCB_PERM+1,'npcbot add'),
+(@NPCB_PERM+2,'npcbot remove'),
+(@NPCB_PERM+3,'npcbot reset'),
+(@NPCB_PERM+4,'npcbot command'),
+(@NPCB_PERM+5,'npcbot distance'),
+(@NPCB_PERM+6,'npcbot info'),
+(@NPCB_PERM+7,'npcbot helper'),
+(@NPCB_PERM+8,'npcbot revive'),
+(@NPCB_PERM+9,'bot'),
+(@NPCB_PERM+10,'bot add'),
+(@NPCB_PERM+11,'bot remove');
+
+DELETE FROM `rbac_linked_permissions` WHERE `linkedId` BETWEEN @NPCB_PERM AND @NPCB_PERM+11;
+INSERT INTO `rbac_linked_permissions` (`id`,`linkedId`) VALUES
+('199',@NPCB_PERM+0), -- player command .npcbot
+('199',@NPCB_PERM+1), -- player command .npcbot add
+('199',@NPCB_PERM+2), -- player command .npcbot remove
+('199',@NPCB_PERM+3), -- player command .npcbot reset
+('199',@NPCB_PERM+4), -- player command .npcbot command
+('199',@NPCB_PERM+5), -- player command .npcbot distance
+('199',@NPCB_PERM+6), -- player command .npcbot info
+('199',@NPCB_PERM+7), -- player command .npcbot helper
+('198',@NPCB_PERM+8), -- moderator command .npcbot revive
+('199',@NPCB_PERM+9), -- player command .bot
+('199',@NPCB_PERM+10), -- player command .bot add
+('199',@NPCB_PERM+11); -- player command .bot remove
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Playerbot_NPCBots/character_NPC_bots.sql b/sql/TrinityCore-Patches/Playerbot_NPCBots/character_NPC_bots.sql
new file mode 100644
index 0000000..486eeae
--- /dev/null
+++ b/sql/TrinityCore-Patches/Playerbot_NPCBots/character_NPC_bots.sql
@@ -0,0 +1,28 @@
+DROP TABLE IF EXISTS `character_npcbot`;
+CREATE TABLE `character_npcbot` (
+  `owner` int(10) default NULL,
+  `entry` int(10) default NULL,
+  `race` tinyint(3) default NULL,
+  `class` tinyint(3) default NULL,
+  `roles` tinyint(3) default NULL,
+  `equipMhEx` int(10) default NULL,
+  `equipOhEx` int(10) default NULL,
+  `equipRhEx` int(10) default NULL,
+  `equipHead` int(10) default NULL,
+  `equipShoulders` int(10) default NULL,
+  `equipChest` int(10) default NULL,
+  `equipWaist` int(10) default NULL,
+  `equipLegs` int(10) default NULL,
+  `equipFeet` int(10) default NULL,
+  `equipWrist` int(10) default NULL,
+  `equipHands` int(10) default NULL,
+  `equipBack` int(10) default NULL,
+  `equipBody` int(10) default NULL,
+  `equipFinger1` int(10) default NULL,
+  `equipFinger2` int(10) default NULL,
+  `equipTrinket1` int(10) default NULL,
+  `equipTrinket2` int(10) default NULL,
+  `equipNeck` int(10) default NULL,
+  `active` tinyint(3) default NULL,
+  PRIMARY KEY  (`owner`,`entry`)
+)  ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/TrinityCore-Patches/Playerbot_NPCBots/world_bot_helper_locales_gossip_menu_option.sql b/sql/TrinityCore-Patches/Playerbot_NPCBots/world_bot_helper_locales_gossip_menu_option.sql
new file mode 100644
index 0000000..a9f5c6b
--- /dev/null
+++ b/sql/TrinityCore-Patches/Playerbot_NPCBots/world_bot_helper_locales_gossip_menu_option.sql
@@ -0,0 +1,92 @@
+delete from `locales_gossip_menu_option` where `menu_id` = '60000';
+
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','1','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','2','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','3','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','4','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','5','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','6','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','7','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','8','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','9','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','10','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','11','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','12','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','13','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','14','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','15','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','16','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','17','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','18','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','19','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','20','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','21','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','22','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','23','star','star','star','star','star','star','star','star',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','24','circle','circle','circle','circle','circle','circle','circle','circle',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','25','diamond','diamond','diamond','diamond','diamond','diamond','diamond','diamond',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','26','triangle','triangle','triangle','triangle','triangle','triangle','triangle','triangle',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','27','moon','moon','moon','moon','moon','moon','moon','moon',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','28','square','square','square','square','square','square','square','square',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','29','cross','cross','cross','cross','cross','cross','cross','cross',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','30','skull','skull','skull','skull','skull','skull','skull','skull',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','31','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','32','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','33','more bot available','more bot available','more bot available','more bot available','more bot available','more bot available','more bot available','more bot available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','34','more bots available','more bots available','more bots available','more bots available','more bots available','more bots available','more bots available','more bots available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','35','bot available','bot available','bot available','bot available','bot available','bot available','bot available','bot available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','36','bots available','bots available','bots available','bots available','bots available','bots available','bots available','bots available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+
+
+-- Custom section
+-- to change text displayed in botgiver's dialog you shoul
+-- 1) translate text to your language
+-- 2) place translated text in empty quotes below, (id = original id in `locales_gossip_menu_option`)
+-- 3) replace `option_text_loc1` with your locale index
+-- LOCALE_koKR        `option_text_loc1`
+-- LOCALE_frFR          `option_text_loc2`
+-- LOCALE_deDE        `option_text_loc3`
+-- LOCALE_zhCN        `option_text_loc4`
+-- LOCALE_zhTW       `option_text_loc5`
+-- LOCALE_esES         `option_text_loc6`
+-- LOCALE_esMX       `option_text_loc7`
+-- LOCALE_ruRU        `option_text_loc8`
+-- 4) run the queue below lol
+-- 5) you most likely need to save your translation for later
+
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 1;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 2;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 3;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 4;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 5;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 6;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 7;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 8;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 9;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 10;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 11;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 12;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 13;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 14;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 15;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 16;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 17;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 18;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 19;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 20;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 21;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 22;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 23;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 24;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 25;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 26;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 27;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 28;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 29;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 30;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 31;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 32;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 33;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 34;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 35;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 36;
diff --git a/sql/TrinityCore-Patches/Playerbot_NPCBots/world_bots.sql b/sql/TrinityCore-Patches/Playerbot_NPCBots/world_bots.sql
new file mode 100644
index 0000000..a57b464
--- /dev/null
+++ b/sql/TrinityCore-Patches/Playerbot_NPCBots/world_bots.sql
@@ -0,0 +1,556 @@
+
+-- GENERAL --
+
+-- Cleanup old version
+-- delete from `creature_template` where entry between 60001 and 60248;
+-- delete from `creature_equip_template` where entry between 60001 and 60248;
+
+
+DELETE FROM `creature_template` WHERE entry BETWEEN 70000 AND 70248;
+
+INSERT INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) VALUES
+(70000,0,0,0,0,0,27541,0,27541,0,'Lagretta','Bot Officer','',0,83,83,2,35,1,1.4,1.14286,0.4,4,0,1500,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,4.8,1,1,1,1,0,0,1,0,0,'script_bot_giver',12340),
+(70001,0,0,0,0,0,5001,0,5001,0,'Khelden','Mage Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70002,0,0,0,0,0,1294,0,1294,0,'Zaldimar','Mage Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70003,0,0,0,0,0,1484,0,1484,0,'Maginor','Mage Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70004,0,0,0,0,0,3344,0,3344,0,'Anetta','Priest Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70005,0,0,0,0,0,1495,0,1495,0,'Laurena','Priest Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70006,0,0,0,0,0,1295,0,1295,0,'Josetta','Priest Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70007,0,0,0,0,0,3345,0,3345,0,'Drusilla','Warlock Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70008,0,0,0,0,0,1930,0,1930,0,'Alamar','Warlock Bot','',0,1,80,2,875,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70009,0,0,0,0,0,1469,0,1469,0,'Demisette','Warlock Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70010,0,0,0,0,0,12749,0,12749,0,'Nalesette','Hunter Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,3,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70011,0,0,0,0,0,3401,0,3401,0,'Branstock','Priest Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70012,0,0,0,0,0,3395,0,3395,0,'Thorgas','Hunter Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70013,0,0,0,0,0,3343,0,3343,0,'Llane','Warrior Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70014,0,0,0,0,0,3399,0,3399,0,'Thran','Warrior Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70015,0,0,0,0,0,1300,0,1300,0,'Lyria','Warrior Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70016,0,0,0,0,0,3351,0,3351,0,'Jorik','Rogue Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70017,0,0,0,0,0,3407,0,3407,0,'Solm','Rogue Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70018,0,0,0,0,0,1297,0,1297,0,'Keryn','Rogue Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70019,0,0,0,0,0,1507,0,1507,0,'Osborne','Rogue Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70020,0,0,0,0,0,3346,0,3346,0,'Sammuel','Paladin Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70021,0,0,0,0,0,3393,0,3393,0,'Bob','Paladin Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70022,0,0,0,0,0,1299,0,1299,0,'Wilhelm','Paladin Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70023,0,0,0,0,0,1499,0,1499,0,'Brisombre','Paladin Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70024,0,0,0,0,0,10216,0,10216,0,'Marry','Mage Bot','',0,1,80,2,875,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70025,0,0,0,0,0,4552,0,4552,0,'Haromm','Shaman Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70026,0,0,0,0,0,4567,0,4567,0,'Kartosh','Warlock Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70027,0,0,0,0,0,3429,0,3429,0,'MaxanAnvol','Priest Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70028,0,0,0,0,0,10215,0,10215,0,'Magis','Mage Bot','',0,1,80,2,875,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70029,0,0,0,0,0,3431,0,3431,0,'GranVivehache','Warrior Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70030,0,0,0,0,0,1622,0,1622,0,'Azar','Paladin Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70031,0,0,0,0,0,3436,0,3436,0,'Hogral','Rogue Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70032,0,0,0,0,0,3053,0,3053,0,'Kelstrum','Warrior Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70033,0,0,0,0,0,1578,0,1578,0,'Dannal','Warrior Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70034,0,0,0,0,0,1579,0,1579,0,'SombreDuesten','Priest Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70035,0,0,0,0,0,1592,0,1592,0,'Isabella','Mage Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70036,0,0,0,0,0,1581,0,1581,0,'Maximillion','Warlock Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70037,0,0,0,0,0,1604,0,1604,0,'Rupert','Warlock Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70038,0,0,0,0,0,1600,0,1600,0,'Cain','Mage Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70039,0,0,0,0,0,1602,0,1602,0,'SombreBeryl','Priest Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70041,0,0,0,0,0,10548,0,10548,0,'Milituus','Mage Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70042,0,0,0,0,0,2810,0,2810,0,'Lexington','Mage Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70043,0,0,0,0,0,2123,0,2123,0,'Siln','Shaman Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70044,0,0,0,0,0,19598,0,19598,0,'Umbrua','Shaman Bot','',0,1,80,2,1640,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70045,0,0,0,0,0,2102,0,2102,0,'Tigor','Shaman Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70046,0,0,0,0,0,2082,0,2082,0,'Beram','Shaman Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70047,0,0,0,0,0,2106,0,2106,0,'Turak','Druid Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70048,0,0,0,0,0,2121,0,2121,0,'Sheal','Druid Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70049,0,0,0,0,0,2115,0,2115,0,'Kym','Druid Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70050,0,0,0,0,0,2112,0,2112,0,'Kary','Hunter Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70051,0,0,0,0,0,2087,0,2087,0,'Holt','Hunter Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70052,0,0,0,0,0,2105,0,2105,0,'Urek','Hunter Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70053,0,0,0,0,0,2103,0,2103,0,'Torm','Warrior Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70054,0,0,0,0,0,2096,0,2096,0,'Sark','Warrior Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70055,0,0,0,0,0,17211,0,17211,0,'Kerra','Warrior Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70056,0,0,0,0,0,2139,0,2139,0,'Miles Welsh','Priest Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70057,0,0,0,0,0,2138,0,2138,0,'Malakai','Priest Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70058,0,0,0,0,0,2137,0,2137,0,'Cobb','Priest Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70059,0,0,0,0,0,2134,0,2134,0,'Shymm','Mage Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,5,7,1,0,0,0,0,0,0,0,0,0,0,143,145,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70060,0,0,0,0,0,6058,0,6058,0,'Ursyn','Mage Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70061,0,0,0,0,0,2135,0,2135,0,'Thurston','Mage Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70062,0,0,0,0,0,3793,0,3793,0,'Harutt','Warrior Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70063,0,0,0,0,0,3819,0,3819,0,'Gart','Druid Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,6,7,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70064,0,0,0,0,0,3810,0,3810,0,'Lanka','Hunter Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70065,0,0,0,0,0,10180,0,10180,0,'Meela','Shaman Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70066,0,0,0,0,0,3794,0,3794,0,'Krang','Warrior Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70067,0,0,0,0,0,10734,0,10734,0,'Gennia','Druid Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70068,0,0,0,0,0,3811,0,3811,0,'Yaw','Hunter Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70069,0,0,0,0,0,3816,0,3816,0,'Narm','Shaman Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70070,0,0,0,0,0,1880,0,1880,0,'Frang','Warrior Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70071,0,0,0,0,0,1882,0,1882,0,'Jenshan','Hunter Bot','',0,1,80,2,126,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70072,0,0,0,0,0,1884,0,1884,0,'Nartok','Warlock Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70073,0,0,0,0,0,1878,0,1878,0,'Shikrik','Shaman Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70074,0,0,0,0,0,3743,0,3743,0,'Tarshaw','Warrior Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70075,0,0,0,0,0,3744,0,3744,0,'Thotar','Hunter Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70076,0,0,0,0,0,3745,0,3745,0,'Dhugru','Warlock Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70077,0,0,0,0,0,3746,0,3746,0,'Swart','Shaman Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70078,0,0,0,0,0,1324,0,1324,0,'Groldar','Warlock Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70079,0,0,0,0,0,1325,0,1325,0,'Mirket','Warlock Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70080,0,0,0,0,0,1326,0,1326,0,'Zevrost','Warlock Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70081,0,0,0,0,0,1360,0,1360,0,'Kardris','Shaman Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70082,0,0,0,0,0,1373,0,1373,0,'Ormak','Hunter Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70083,0,0,0,0,0,1374,0,1374,0,'Grezz','Warrior Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70084,0,0,0,0,0,1375,0,1375,0,'Sorek','Warrior Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70085,0,0,0,0,0,4231,0,4231,0,'Siantsu','Shaman Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70086,0,0,0,0,0,4239,0,4239,0,'Xorjuul','Hunter Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70087,0,0,0,0,0,4241,0,4241,0,'Siandur','Hunter Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70088,0,0,0,0,0,4242,0,4242,0,'Zelmak','Warrior Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70089,0,0,0,0,0,7915,0,7915,0,'ClaudeErksine','Hunter Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,3,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70090,0,0,0,0,0,1721,0,1721,0,'Alyissia','Warrior Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70091,0,0,0,0,0,1725,0,1725,0,'FrahunMurmombre','Rogue Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70092,0,0,0,0,0,1733,0,1733,0,'Shanda','Priest Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70093,0,0,0,0,0,1732,0,1732,0,'Mardant','Druid Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70094,0,0,0,0,0,1707,0,1707,0,'Kyra','Warrior Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70095,0,0,0,0,0,1704,0,1704,0,'Jannok','Rogue Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70096,0,0,0,0,0,1708,0,1708,0,'Laurna','Priest Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70097,0,0,0,0,0,1706,0,1706,0,'Kal','Druid Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70098,0,0,0,0,0,4296,0,4296,0,'Harruk','Hunter Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,3,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70099,0,0,0,0,0,4299,0,4299,0,'Reban','Hunter bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,3,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70100,0,0,0,0,0,4304,0,4304,0,'Bolyun','Hunter Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,3,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70101,0,0,0,0,0,1897,0,1897,0,'Taijin','Priest Bot','',0,1,80,2,126,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70102,0,0,0,0,0,4068,0,4068,0,'Kenjai','Priest Bot','',0,1,80,2,126,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70103,0,0,0,0,0,2066,0,2066,0,'Danlaar','Hunter Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70104,0,0,0,0,0,2196,0,2196,0,'Ariasta','Warrior Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70105,0,0,0,0,0,2198,0,2198,0,'Sildanair','Warrior Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70106,0,0,0,0,0,2200,0,2200,0,'Astarii','Priest Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70107,0,0,0,0,0,2201,0,2201,0,'Jandria','Priest Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70108,0,0,0,0,0,2202,0,2202,0,'Lariia','Priest Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70109,0,0,0,0,0,2231,0,2231,0,'Syurna','Rogue Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70110,0,0,0,0,0,7669,0,7669,0,'Elissa','Mage Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70111,0,0,0,0,0,2252,0,2252,0,'Erion','Rogue Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70112,0,0,0,0,0,2243,0,2243,0,'Anishar','Rogue Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70113,0,0,0,0,0,2250,0,2250,0,'Denatharion','Druid Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70114,0,0,0,0,0,2255,0,2255,0,'Fylerian','Druid Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70115,0,0,0,0,0,2416,0,2416,0,'Caelyb','Hunter Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,3,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70116,0,0,0,0,0,2675,0,2675,0,'Kaal','Warlock Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70117,0,0,0,0,0,16800,0,16800,0,'Lana','Warlock Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70118,0,0,0,0,0,2646,0,2646,0,'Richard','Warlock Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70119,0,0,0,0,0,10214,0,10214,0,'Kaelystia','Mage Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,5,6,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70120,0,0,0,0,0,2644,0,2644,0,'Pierce','Mage Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70121,0,0,0,0,0,2657,0,2657,0,'Anastasia','Mage Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70122,0,0,0,0,0,2620,0,2620,0,'Chris','Warrior Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70123,0,0,0,0,0,2658,0,2658,0,'Angela','Warrior Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70124,0,0,0,0,0,2614,0,2614,0,'Baltus','Warrior Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70125,0,0,0,0,0,3054,0,3054,0,'Kelv','Warrior Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70126,0,0,0,0,0,3055,0,3055,0,'Bilban','Warrior Bot','',0,1,80,2,875,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70127,0,0,0,0,0,3056,0,3056,0,'Daera','Hunter Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70128,0,0,0,0,0,3072,0,3072,0,'Olmin','Hunter Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70129,0,0,0,0,0,3073,0,3073,0,'Regnus','Hunter Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70130,0,0,0,0,0,3086,0,3086,0,'Theodrus','Priest Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70131,0,0,0,0,0,3066,0,3066,0,'Braenna','Priest Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70132,0,0,0,0,0,3085,0,3085,0,'Toldren','Priest Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70134,0,0,0,0,0,3108,0,3108,0,'Bink','Mage Bot','',0,1,80,2,875,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70135,0,0,0,0,0,10214,0,10214,0,'Juli','Mage Bot','',0,1,80,2,875,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70136,0,0,0,0,0,3109,0,3109,0,'Nittegousse','Mage Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70137,0,0,0,0,0,3089,0,3089,0,'Valgar','Paladin Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70138,0,0,0,0,0,3088,0,3088,0,'Beldruk','Paladin Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70139,0,0,0,0,0,3087,0,3087,0,'Brandur','Paladin Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70140,0,0,0,0,0,3101,0,3101,0,'Hulfdan','Rogue Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70141,0,0,0,0,0,3100,0,3100,0,'Ormyr','Rogue Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70142,0,0,0,0,0,3113,0,3113,0,'Phenwick','Rogue Bot','',0,1,80,2,875,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70143,0,0,0,0,0,3115,0,3115,0,'Coeurdechardon','Warlock Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70144,0,0,0,0,0,3116,0,3116,0,'Eglantin','Warlock Bot','',0,1,80,2,875,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70145,0,0,0,0,0,3122,0,3122,0,'Alexander','Warlock Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70146,0,0,0,0,0,3280,0,3280,0,'Wu','Warrior Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70147,0,0,0,0,0,3287,0,3287,0,'Ilsa','Warrior Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70148,0,0,0,0,0,3283,0,3283,0,'Joshua','Priest Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70149,0,0,0,0,0,3284,0,3284,0,'Arthur','Paladin Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70150,0,0,0,0,0,3289,0,3289,0,'Katherine','Paladin Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70151,0,0,0,0,0,3291,0,3291,0,'Deline','Warlock Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70152,0,0,0,0,0,3286,0,3286,0,'Sandahl','Warlock Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70153,0,0,0,0,0,3292,0,3292,0,'Jennea','Mage Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70154,0,0,0,0,0,19803,0,19803,0,'Elsharin','Mage Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70155,0,0,0,0,0,3299,0,3299,0,'Kaerbrus','Hunter Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70156,0,0,0,0,0,3300,0,3300,0,'Sheldras','Druid Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70157,0,0,0,0,0,3301,0,3301,0,'Theridran','Druid Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70158,0,0,0,0,0,3312,0,3312,0,'Einris','Hunter Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70159,0,0,0,0,0,3309,0,3309,0,'Ulfir','Hunter Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70160,0,0,0,0,0,3310,0,3310,0,'Thorfin','Hunter Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70161,0,0,0,0,0,10171,0,10171,0,'UnThuwa','Mage Bot','',0,1,80,2,126,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70162,0,0,0,0,0,4524,0,4524,0,'Pephredo','Mage Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70163,0,0,0,0,0,4522,0,4522,0,'Enyo','Mage Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70164,0,0,0,0,0,4526,0,4526,0,'Mai','Mage Bot','',0,1,80,2,126,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70165,0,0,0,0,0,4523,0,4523,0,'Deino','Mage Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70166,0,0,0,0,0,4665,0,4665,0,'Birgitte','Mage Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70167,0,0,0,0,0,12849,0,12849,0,'Thuul','Mage Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70168,0,0,0,0,0,4690,0,4690,0,'Zayus','Priest Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70169,0,0,0,0,0,10473,0,10473,0,'Xyera','Priest Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70170,0,0,0,0,0,4711,0,4711,0,'Urkyo','Priest Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70171,0,0,0,0,0,6060,0,6060,0,'Uthelnay','Mage Bot','',0,1,80,2,126,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70172,0,0,0,0,0,6072,0,6072,0,'Dink','Mage Bot','',0,1,80,2,875,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70173,0,0,0,0,0,6071,0,6071,0,'Darnath','Warrior Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70174,0,0,0,0,0,7356,0,7356,0,'Karman','Paladin Bot','',0,1,80,2,894,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70175,0,0,0,0,0,11037,0,11037,0,'Evencane','Warrior Bot','',0,1,80,2,894,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70176,0,0,0,0,0,7357,0,7357,0,'Jannos','Druid Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70177,0,0,0,0,0,7538,0,7538,0,'Alenndaar','Hunter Bot','',0,1,80,2,1076,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70178,0,0,0,0,0,10738,0,10738,0,'Golhine','Druid Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70179,0,0,0,0,0,9337,0,9337,0,'Hesuwa','Hunter Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,3,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70180,0,0,0,0,0,9336,0,9336,0,'Xao\'tsu','Hunter Bot','',0,1,80,2,29,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,3,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70181,0,0,0,0,0,9338,0,9338,0,'Belia','Hunter Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,3,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70182,0,0,0,0,0,10245,0,10245,0,'Dargh','Hunter Bot','',0,1,80,2,55,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70183,0,0,0,0,0,11044,0,11044,0,'Meideros','Priest Bot','',0,1,80,2,80,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70184,0,0,0,0,0,11048,0,11048,0,'Presse','Priest Bot','',0,1,80,2,1076,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70185,0,0,0,0,0,11053,0,11053,0,'Rohan','Priest Bot','',0,1,80,2,122,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70186,0,0,0,0,0,12053,0,12053,0,'Loganaar','Druid Bot','',0,1,80,2,994,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70187,0,0,0,0,0,13171,0,13171,0,'Romano','Rogue Bot','',0,1,80,2,12,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70188,0,0,0,0,0,13341,0,13341,0,'Sagorne','Shaman Bot','',0,1,80,2,104,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70189,0,0,0,0,0,15522,0,15522,0,'Julia','Mage Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70190,0,0,0,0,0,16811,0,16811,0,'Ithelis','Paladin Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70191,0,0,0,0,0,15524,0,15524,0,'Invocateur','Warlock Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70192,0,0,0,0,0,15518,0,15518,0,'Matrone','Priest Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70193,0,0,0,0,0,2659,0,2659,0,'Eclaireur','Rogue Bot','',0,1,80,2,68,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70194,0,0,0,0,0,15520,0,15520,0,'Sallina','Hunter Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70195,0,0,0,0,0,16685,0,16685,0,'Noellene','Paladin Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70196,0,0,0,0,0,16707,0,16707,0,'Ponaris','Priest Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70197,0,0,0,0,0,16222,0,16222,0,'Keilnei','Hunter Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70198,0,0,0,0,0,16223,0,16223,0,'Valaatu','Mage Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70199,0,0,0,0,0,16224,0,16224,0,'Aurelon','Paladin Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70200,0,0,0,0,0,16225,0,16225,0,'Zalduun','Priest Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70201,0,0,0,0,0,16226,0,16226,0,'Kore','Warrior Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70202,0,0,0,0,0,16787,0,16787,0,'Alamma','Warlock Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70203,0,0,0,0,0,16800,0,16800,0,'Talionia','Warlock Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,0,0,0,0,0,9,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warlock_bot',0),
+(70204,0,0,0,0,0,16831,0,16831,0,'Zanien','Hunter Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,9,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70205,0,0,0,0,0,16781,0,16781,0,'Zaedana','Mage Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70206,0,0,0,0,0,16824,0,16824,0,'Quithas','Mage Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70207,0,0,0,0,0,16739,0,16739,0,'Harene','Druid Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70208,0,0,0,0,0,16778,0,16778,0,'Tana','Hunter Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70209,0,0,0,0,0,16816,0,16816,0,'Oninath','Hunter Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70210,0,0,0,0,0,16829,0,16829,0,'Bachi','Paladin Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70211,0,0,0,0,0,16767,0,16767,0,'Zelanis','Rogue Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70212,0,0,0,0,0,16798,0,16798,0,'Elara','Rogue Bot','',0,1,80,2,1604,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,0,0,0,0,0,4,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'rogue_bot',0),
+(70213,0,0,0,0,0,16858,0,16858,0,'Shalannius','Druid Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,0,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'druid_bot',0),
+(70214,0,0,0,0,0,17434,0,17434,0,'Deremiis','Hunter Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70215,0,0,0,0,0,17247,0,17247,0,'Caedmos','Priest Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70216,0,0,0,0,0,17225,0,17225,0,'Baatun','Paladin Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70217,0,0,0,0,0,17212,0,17212,0,'Ahonan','Warrior Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70218,0,0,0,0,0,17598,0,17598,0,'Firmanvaar','Shaman Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70219,0,0,0,0,0,16860,0,16860,0,'Actron','Hunter Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70220,0,0,0,0,0,17213,0,17213,0,'Behomat','Warrior Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70221,0,0,0,0,0,17600,0,17600,0,'Nobundo','Shaman Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70222,0,0,0,0,0,17599,0,17599,0,'Tuluun','Shaman Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70223,0,0,0,0,0,16914,0,16914,0,'Sulaa','Shaman Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70224,0,0,0,0,0,17215,0,17215,0,'Ruada','Warrior Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,0,0,0,0,0,1,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'warrior_bot',0),
+(70225,0,0,0,0,0,17233,0,17233,0,'Semid','Mage Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70226,0,0,0,0,0,17232,0,17232,0,'Guvan','Priest Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70227,0,0,0,0,0,17234,0,17234,0,'Tullas','Paladin Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70228,0,0,0,0,0,17488,0,17488,0,'Killac','Hunter bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,0,0,0,0,0,3,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'hunter_bot',0),
+(70229,0,0,0,0,0,17226,0,17226,0,'Jol','Paladin Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70230,0,0,0,0,0,17248,0,17248,0,'Fallat','Priest Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'priest_bot',0),
+(70231,0,0,0,0,0,17243,0,17243,0,'Harnan','Mage Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70232,0,0,0,0,0,17241,0,17241,0,'Bati','Mage Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,0,0,0,0,0,8,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'mage_bot',0),
+(70233,0,0,0,0,0,17792,0,17792,0,'Hobahken','Shaman Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70234,0,0,0,0,0,6820,0,6820,0,'Gurrag','Shaman Bot','',0,1,80,2,1638,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,0,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'shaman_bot',0),
+(70235,0,0,0,0,0,19596,0,19596,0,'Auberose','Paladin Bot','',0,1,80,2,1602,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,0,0,0,0,0,2,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'paladin_bot',0),
+(70236,0,0,0,0,0,10335,10335,10335,10335,'Afina','Priest Bot','',0,1,80,2,35,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,0,0,0,0,0,5,2,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'priest_bot',0),
+(70237,0,0,0,0,0,26939,26939,26939,26939,'Imhadria','Death Knight Bot','',0,1,80,2,35,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,0,0,0,0,0,6,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'death_knight_bot',0),
+(70238,0,0,0,0,0,28039,28039,28039,28039,'Mynx','Death Knight Bot','',0,1,80,2,35,1,1.2,1.3,0.8,0,0,3300,2000,1,1,1,0,0,0,0,0,0,6,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'death_knight_bot',0),
+(70239,0,0,0,0,0,26688,26688,26688,26688,'Lankral','Death Knight Bot','',0,1,80,2,35,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,0,0,0,0,0,6,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'death_knight_bot',0),
+(70240,0,0,0,0,0,26195,26195,26195,26195,'Silver','Death Knight Bot','',0,1,80,2,35,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,0,0,0,0,0,6,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'death_knight_bot',0),
+(70241,0,0,0,0,0,27402,27402,27402,27402,'Vereth','Death Knight Bot','',0,1,80,2,35,1,1.2,1.3,0.8,0,0,3300,2000,1,1,1,0,0,0,0,0,0,6,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'death_knight_bot',0),
+(70242,0,0,0,0,0,27189,27189,27189,27189,'Arly','Death Knight Bot','',0,1,80,2,35,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,0,0,0,0,0,6,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'death_knight_bot',0),
+(70243,0,0,0,0,0,26217,26217,26217,26217,'Setaal','Death Knight Bot','',0,1,80,2,35,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,0,0,0,0,0,6,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'death_knight_bot',0),
+(70244,0,0,0,0,0,28842,28842,28842,28842,'Illyrie','Death Knight Bot','',0,1,80,2,35,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,0,0,0,0,0,6,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'death_knight_bot',0),
+(70245,0,0,0,0,0,28840,28840,28840,28840,'Zor\'be','Death Knight Bot','',0,1,80,2,35,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,0,0,0,0,0,6,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'death_knight_bot',0),
+(70246,0,0,0,0,0,25512,25512,25512,25512,'Datura','Death Knight Bot','',0,1,80,2,35,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,0,0,0,0,0,6,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'death_knight_bot',0),
+(70247,0,0,0,0,0,1132,0,1132,0,'Voidwalker','Warlock\'s Pet Bot',NULL,0,1,80,2,14,0,1.2,1.3,1,0,0,2000,2000,1,1,2,0,0,0,16,0,0,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,1,1,1048688,'voidwalker_bot',0),
+(70248,0,0,0,0,0,1105,0,0,0,'Hunter\'s Pet',NULL,NULL,0,1,80,0,14,0,1.1,1.14286,1,0,0,2000,0,1,1,1,0,0,0,7,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,5708,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,149,1,0,0,'',0);
+
+-- EQUIPS --
+
+delete from `creature_equip_template` where CreatureID between 70001 and 70248;
+
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70001','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70002','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70003','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70004','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70005','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70006','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70007','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70008','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70009','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70010','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70011','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70012','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70013','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70014','1','27903','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70015','1','7723','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70016','1','13984','6448','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70017','1','13984','6448','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70018','1','6633','820','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70019','1','13984','6448','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70020','1','12584','18825','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70021','1','18876','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70022','1','12584','18825','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70023','1','18876','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70024','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70025','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70026','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70027','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70028','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70029','1','28367','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70030','1','12584','18825','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70031','1','13984','6448','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70032','1','27903','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70033','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70034','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70035','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70036','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70037','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70038','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70039','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70041','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70042','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70043','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70044','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70045','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70046','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70047','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70048','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70049','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70050','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70051','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70052','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70053','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70054','1','27903','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70055','1','28367','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70056','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70057','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70058','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70059','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70060','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70061','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70062','1','28367','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70063','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70064','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70065','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70066','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70067','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70068','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70069','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70070','1','27903','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70071','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70072','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70073','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70074','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70075','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70076','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70077','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70078','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70079','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70080','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70081','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70082','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70083','1','7723','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70084','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70085','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70086','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70087','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70088','1','27903','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70089','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70090','1','28367','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70091','1','6633','820','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70092','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70093','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70094','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70095','1','13984','6448','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70096','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70097','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70098','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70099','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70100','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70101','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70102','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70103','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70104','1','7723','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70105','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70106','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70107','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70108','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70109','1','13984','6448','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70110','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70111','1','6633','820','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70112','1','13984','6448','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70113','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70114','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70115','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70116','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70117','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70118','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70119','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70120','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70121','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70122','1','27903','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70123','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70124','1','7723','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70125','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70126','1','28367','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70127','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70128','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70129','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70130','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70131','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70132','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70134','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70135','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70136','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70137','1','18876','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70138','1','12584','18825','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70139','1','18876','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70140','1','6633','820','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70141','1','13984','6448','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70142','1','6633','820','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70143','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70144','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70145','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70146','1','27903','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70147','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70148','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70149','1','12584','18825','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70150','1','18876','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70151','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70152','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70153','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70154','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70155','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70156','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70157','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70158','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70159','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70160','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70161','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70162','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70163','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70164','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70165','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70166','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70167','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70168','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70169','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70170','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70171','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70172','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70173','1','28367','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70174','1','12584','18825','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70175','1','7723','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70176','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70177','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70178','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70179','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70180','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70181','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70182','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70183','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70184','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70185','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70186','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70187','1','13984','6448','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70188','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70189','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70190','1','12584','18826','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70191','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70192','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70193','1','13984','6448','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70194','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70195','1','12584','18826','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70196','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70197','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70198','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70199','1','18876','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70200','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70201','1','27903','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70202','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70203','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70204','1','31186','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70205','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70206','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70207','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70208','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70209','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70210','1','12584','18826','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70211','1','6633','820','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70212','1','13984','6448','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70213','1','25622','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70214','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70215','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70216','1','18876','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70217','1','28367','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70218','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70219','1','2291','0','2825');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70220','1','18002','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70221','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70222','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70223','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70224','1','27903','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70225','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70226','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70227','1','12584','18825','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70229','1','18876','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70230','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70231','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70232','1','18842','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70233','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70234','1','18203','18202','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70235','1','29175','18826','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70236','1','31289','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70237','1','13505','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70238','1','12775','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70239','1','24044','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70240','1','43601','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70241','1','23499','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70242','1','38632','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70243','1','34891','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70244','1','38632','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70245','1','50798','0','0');
+insert into `creature_equip_template` (`CreatureID`, `id`, `ItemID1`, `ItemID2`, `ItemID3`) values('70246','1','12592','0','0');
+
+-- -- -- Update 18.09.13 - Equips for shamans
+-- Orcs and Draenei. Mainhand: Cudgel of Furious Justice, Offhand: Azure-Shield of Coldarra
+UPDATE `creature_equip_template` SET `ItemID1` = '50050', `ItemID2` = '29266', `ItemID3` = '0' WHERE `CreatureID` IN (SELECT entry FROM `creature_template` WHERE (`CreatureID` BETWEEN '70000' AND '70238') AND `trainer_class` = '7' AND (`trainer_race` = '2' OR `trainer_race` = '11'));
+-- Taurens and some Draenei. De-Raged Waraxe (Two-Hand)
+UPDATE `creature_equip_template` SET `ItemID1` = '41816', `ItemID2` = '0', `ItemID3` = '0' WHERE `CreatureID` IN (SELECT entry FROM `creature_template` WHERE (`CreatureID` BETWEEN '70000' AND '70238') AND `trainer_class` = '7' AND (`trainer_race` = '6' OR `CreatureID` IN (70218,70222,70223,70233)));
+
+
+
+-- Customize section
+-- You can create your own values to be in line with your own server if these are not acceptable.
+
+-- Add flags_extra
+SET @EX_NO_BLOCK = 16;
+SET @EX_NO_CRUSH = 32;
+SET @EX_NO_XP = 64;
+SET @EX_DIMINISH = 1048576;
+SET @FLAGS_EX = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH;
+
+-- minions
+UPDATE `creature_template` SET exp:=2, faction:=35, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=3300, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Death Knight Bot';
+UPDATE `creature_template` SET exp:=2, faction:=35, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=2200, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Druid Bot';
+UPDATE `creature_template` SET exp:=2, faction:=35, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=2800, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Hunter Bot';
+UPDATE `creature_template` SET exp:=2, faction:=35, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=3800, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Mage Bot';
+UPDATE `creature_template` SET exp:=2, faction:=35, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=2300, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Paladin Bot';
+UPDATE `creature_template` SET exp:=2, faction:=35, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=3600, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Priest Bot';
+UPDATE `creature_template` SET exp:=2, faction:=35, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=1600, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Rogue Bot';
+UPDATE `creature_template` SET exp:=2, faction:=35, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=2600, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Shaman Bot';
+UPDATE `creature_template` SET exp:=2, faction:=35, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=3500, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Warlock Bot';
+UPDATE `creature_template` SET exp:=2, faction:=35, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=3400, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Warrior Bot';
+
+-- DK           -- DK            -- DK           -- DK           -- DK           -- DK            -- DK           -- DK            -- DK           -- DK            -- DK          -- DK            -- DK           -- DK           -- DK            -- DK            -- DK           -- DK           -- DK           -- DK            -- DK           -- DK            -- DK           -- DK           -- DK           -- DK            -- DK           -- DK           -- DK           -- DK            -- DK           -- DK            -- DK           -- DK           -- DK
+-- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid        -- Druid
+-- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter    -- Hunter
+-- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage        -- Mage
+-- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin    -- Paladin
+-- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest        -- Priest
+-- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue        -- Rogue
+-- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman    -- Shaman
+-- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock    -- Warlock
+-- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior    -- Warrior
+
+-- pets
+UPDATE `creature_template` SET exp:=2, faction:=35, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=2000, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry between 70001 and 70248 and name='Voidwalker';
+
+-- Command
+DELETE FROM `command` WHERE `permission` IN (1110, 1111, 1109);
+insert into `command` (`name`, `permission`, `help`) values('bot add','1110',NULL);
+insert into `command` (`name`, `permission`, `help`) values('bot remove','1111',NULL);
+insert into `command` (`name`, `permission`, `help`) values('bot','1109',NULL);
diff --git a/sql/TrinityCore-Patches/Playerbot_NPCBots/world_creature_template_outfits.sql b/sql/TrinityCore-Patches/Playerbot_NPCBots/world_creature_template_outfits.sql
new file mode 100644
index 0000000..df8a9b1
--- /dev/null
+++ b/sql/TrinityCore-Patches/Playerbot_NPCBots/world_creature_template_outfits.sql
@@ -0,0 +1,42 @@
+
+
+    -- --------------------------------------------------------
+    -- Host:                         localhost
+    -- Server version:               5.6.10 - MySQL Community Server (GPL)
+    -- Server OS:                    Win64
+    -- HeidiSQL Version:             8.0.0.4491
+    -- --------------------------------------------------------
+
+    /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
+    /*!40101 SET NAMES utf8 */;
+    /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+    /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+
+    -- Dumping structure for table e2_w.creature_template_outfits
+    CREATE TABLE IF NOT EXISTS `creature_template_outfits` (
+      `entry` INT(10) UNSIGNED NOT NULL,
+      `race` tinyint(3) UNSIGNED NOT NULL DEFAULT '1',
+      `gender` tinyint(3) UNSIGNED NOT NULL DEFAULT '0' COMMENT '0 for male, 1 for female',
+      `skin` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+      `face` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+      `hair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+      `haircolor` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+      `facialhair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+      `head` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `shoulders` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `body` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `chest` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `waist` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `legs` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `feet` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `wrists` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `hands` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `back` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `tabard` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      PRIMARY KEY  (`entry`)
+    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+    -- Data exporting was unselected.
+    /*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
+    /*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
+    /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
diff --git a/src/server/database/Database/Implementation/CharacterDatabase.cpp b/src/server/database/Database/Implementation/CharacterDatabase.cpp
index 9bd2398..5478b23 100644
--- a/src/server/database/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/database/Database/Implementation/CharacterDatabase.cpp
@@ -621,7 +621,19 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     // 04
     // 05
     // 06
-    // 07
+    // Old NPCBots
+    PrepareStatement(CHAR_SEL_NPCBOTS, "SELECT entry, race, class, roles, equipMhEx, equipOhEx, equipRhEx, "
+        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck FROM character_npcbot WHERE owner = ? AND active = 1", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_DEL_NPCBOTS, "DELETE FROM character_npcbot WHERE owner = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_NPCBOT, "REPLACE INTO character_npcbot (owner, entry, race, class, roles, equipMhEx, equipOhEx, equipRhEx, "
+        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck, active) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_EQUIP, "UPDATE character_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, "
+        "equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?, equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_ACTIVE, "UPDATE character_npcbot SET active = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_NPCBOT_EQUIP, "SELECT equipMhEx, equipOhEx, equipRhEx, "
+        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_NPCBOT_ROLES, "SELECT roles FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_ROLES, "UPDATE character_npcbot SET roles = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
     // 08
     // 09
     // 10
diff --git a/src/server/database/Database/Implementation/CharacterDatabase.h b/src/server/database/Database/Implementation/CharacterDatabase.h
index 2f6827b..d26aff3 100644
--- a/src/server/database/Database/Implementation/CharacterDatabase.h
+++ b/src/server/database/Database/Implementation/CharacterDatabase.h
@@ -539,7 +539,15 @@ enum CharacterDatabaseStatements
     // 04
     // 05
     // 06
-    // 07
+    // Old NPCBots
+    CHAR_SEL_NPCBOTS,
+    CHAR_DEL_NPCBOTS,
+    CHAR_INS_NPCBOT,
+    CHAR_UPD_NPCBOT_EQUIP,
+    CHAR_UPD_NPCBOT_ACTIVE,
+    CHAR_SEL_NPCBOT_EQUIP,
+    CHAR_SEL_NPCBOT_ROLES,
+    CHAR_UPD_NPCBOT_ROLES,
     // 08
     // 09
     // 10
diff --git a/src/server/database/Database/Implementation/WorldDatabase.cpp b/src/server/database/Database/Implementation/WorldDatabase.cpp
index d9aad94..23c92eb 100644
--- a/src/server/database/Database/Implementation/WorldDatabase.cpp
+++ b/src/server/database/Database/Implementation/WorldDatabase.cpp
@@ -91,4 +91,7 @@ void WorldDatabaseConnection::DoPrepareStatements()
     PrepareStatement(WORLD_DEL_DISABLES, "DELETE FROM disables WHERE entry = ? AND sourceType = ?", CONNECTION_ASYNC);
     PrepareStatement(WORLD_UPD_CREATURE_ZONE_AREA_DATA, "UPDATE creature SET zoneId = ?, areaId = ? WHERE guid = ?", CONNECTION_ASYNC);
     PrepareStatement(WORLD_UPD_GAMEOBJECT_ZONE_AREA_DATA, "UPDATE gameobject SET zoneId = ?, areaId = ? WHERE guid = ?", CONNECTION_ASYNC);
+    // Bot
+    PrepareStatement(WORLD_SEL_NPCBOT_TEMPLATE, "SELECT entry, trainer_race FROM creature_template WHERE scriptname = ? and trainer_class = ? and trainer_race IN (?, ?, ?, ?, ?)", CONNECTION_SYNCH);
+    PrepareStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS, "SELECT hp, mana, armor, str, agi, sta, inte, spi FROM pet_levelstats WHERE creature_entry = ? AND level = ?", CONNECTION_SYNCH);
 }
diff --git a/src/server/database/Database/Implementation/WorldDatabase.h b/src/server/database/Database/Implementation/WorldDatabase.h
index c547583..70c40fd 100644
--- a/src/server/database/Database/Implementation/WorldDatabase.h
+++ b/src/server/database/Database/Implementation/WorldDatabase.h
@@ -100,6 +100,10 @@ enum WorldDatabaseStatements
     WORLD_UPD_CREATURE_ZONE_AREA_DATA,
     WORLD_UPD_GAMEOBJECT_ZONE_AREA_DATA,
 
+    // Bot
+    WORLD_SEL_NPCBOT_TEMPLATE,
+    WORLD_SEL_NPCBOT_PET_LEVELSTATS,
+
     MAX_WORLDDATABASE_STATEMENTS
 };
 
diff --git a/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp b/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
new file mode 100644
index 0000000..28ca48c
--- /dev/null
+++ b/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
@@ -0,0 +1,121 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Bot Quest npc Airen by Graff onlysuffering@gmail.com
+Complete - 0%
+TODO:
+*/
+#define ACT                 GOSSIP_ACTION_INFO_DEF
+
+class Airen_chapter1 : public CreatureScript
+{
+public:
+    Airen_chapter1() : CreatureScript("npc_Airen_qI") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new Airen_AI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, "nothing here", 6000, ACT + 1, "nothing here either", 0 * COPPER, true);
+        player->PlayerTalkClass->SendGossipMenu(creature->GetEntry(), creature->GetGUID());
+
+        std::ostringstream msg;
+        msg << "..." << player->GetName() << ", huh?";
+        bot_ai::BotSpeak(msg.str(), CHAT_MSG_WHISPER, LANG_UNIVERSAL, creature->GetGUID(), player->GetGUID());
+
+        return true;
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        player->PlayerTalkClass->ClearMenus();
+
+        switch (sender)
+        {
+            case 6000:
+            {
+                if (action == ACT + 1)
+                {
+                    if (!player->HasEnoughMoney(1 * COPPER))
+                    {
+                        player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, 0, 0);
+                        break;
+                    }
+                    player->ModifyMoney(-(1 * COPPER));
+                }
+
+                break;
+            }
+            default:
+                break;
+        }
+
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        std::string answer = "asd";
+
+        switch (sender)
+        {
+            case 6000:
+            {
+                if (action == ACT + 1 && code == answer)
+                    bot_ai::BotSpeak("hehe", CHAT_MSG_YELL, LANG_UNIVERSAL, creature->GetGUID(), player->GetGUID());
+                break;
+            }
+        }
+
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct Airen_AI : public ScriptedAI
+    {
+        Airen_AI(Creature* creature) : ScriptedAI(creature) { }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { me->DisappearAndDie(); }
+
+        void UpdateAI(uint32 /*diff*/)
+        {
+        }
+
+        void Reset()
+        {
+            me->SetCreateHealth(213000213);
+            me->SetMaxHealth(me->GetCreateHealth());
+            me->SetFullHealth();
+
+            me->setPowerType(POWER_RAGE);
+            me->SetMaxPower(POWER_RAGE, 10000);
+            me->SetPower(POWER_RAGE, me->GetMaxPower(POWER_RAGE));
+        }
+
+        void DamageTaken(Unit* /*u*/, uint32& damage)
+        {
+            damage = me->GetHealth() > 1 ? 1 : 0;
+        }
+    };
+};
+
+void AddSC_BotQuests_chapter1()
+{
+    new Airen_chapter1();
+}
diff --git a/src/server/game/AI/NpcBots/bot_GridNotifiers.h b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
new file mode 100644
index 0000000..1fcfbac
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
@@ -0,0 +1,594 @@
+/*
+Name: bot_GridNotifiers
+%Complete: 95+
+Comment: Custom grid notifiers for Bot system by Graff (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/grids
+*/
+
+#ifndef _BOT_GRIDNOTIFIERS_H
+#define _BOT_GRIDNOTIFIERS_H
+
+#include "Group.h"
+#include "Player.h"
+#include "SpellAuras.h"
+#include "bot_ai.h"
+
+uint8 PvP = 1;
+
+class NearestHostileUnitCheck
+{
+    public:
+        explicit NearestHostileUnitCheck(Unit const* unit, float dist, bool magic, bot_ai const* m_ai, bool targetCCed = false) :
+        me(unit), m_range(dist), byspell(magic), ai(m_ai), AttackCCed(targetCCed) { }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!ai->CanBotAttack(u, byspell))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (!AttackCCed && (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE)))
+                return false;//do not allow CCed units if checked
+            //if (u->HasUnitState(UNIT_STATE_CASTING) && (u->GetTypeId() == TYPEID_PLAYER || u->IsPet()))
+            //    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+            //        if (Spell* spell = u->GetCurrentSpell(i))
+            //            if (ai->IsInBotParty(spell->m_targets.GetUnitTarget()))
+            //                return true;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
+            return true;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool byspell;
+        bot_ai const* ai;
+        bool AttackCCed;
+        NearestHostileUnitCheck(NearestHostileUnitCheck const&);
+};
+
+class HostileDispelTargetCheck
+{
+    public:
+        explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false, bot_ai const* m_ai = NULL) :
+        me(unit), m_range(dist), checksteal(stealable), ai(m_ai) { }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (u->IsWithinDistInMap(me, m_range) &&
+                u->IsAlive() &&
+                u->InSamePhase(me) &&
+                u->IsInCombat() &&
+                u->isTargetableForAttack() &&
+                u->IsVisible() &&
+                u->GetReactionTo(me) < REP_NEUTRAL &&
+                ai->IsInBotParty(u->GetVictim()))
+            {
+                if (checksteal && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449))) return false;//immune to steal
+                if (!checksteal)
+                {
+                    if (me->getLevel() >= 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(32375))) return false;//immune to mass dispel
+                    if (me->getLevel() < 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(527))) return false;//immune to direct dispel
+                }
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    SpellInfo const* Info = aura->GetSpellInfo();
+                    if (Info->Dispel != DISPEL_MAGIC) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    if (checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
+                    AuraApplication const* aurApp = aura->GetApplicationOfTarget(u->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        const std::string name = Info->SpellName[0];
+                        if (name == "Vengeance" || name == "Bloody Vengeance")
+                            continue;
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool checksteal;
+        bot_ai const* ai;
+        HostileDispelTargetCheck(HostileDispelTargetCheck const&);
+};
+
+class AffectedTargetCheck
+{
+    public:
+        explicit AffectedTargetCheck(ObjectGuid casterguid, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) :
+        caster(casterguid), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType)
+        { if (checker->GetTypeId() != TYPEID_PLAYER) return; gr = checker->GetGroup(); }
+        bool operator()(Unit* u)
+        {
+            if (caster && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+                return false;
+            if (needhostile == 0 && !u->IsHostileTo(checker)) return false;
+            if (needhostile == 1 && !(gr && gr->IsMember(u->GetGUID()) && u->GetTypeId() == TYPEID_PLAYER)) return false;
+            if (needhostile == 2 && !(gr && gr->IsMember(u->GetGUID()))) return false;
+            if (needhostile == 3 && !u->IsFriendlyTo(checker)) return false;
+
+            if (u->IsAlive() && checker->IsWithinDistInMap(u, m_range))
+            {
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    if (aura->GetId() == spell)
+                        if (caster == 0 || aura->GetCasterGUID() == caster)
+                            return true;
+                }
+            }
+            return false;
+        }
+    private:
+        ObjectGuid const caster;
+        float m_range;
+        uint32 const spell;
+        Player const* checker;
+        uint8 needhostile;
+        Group const* gr;
+        AffectedTargetCheck(AffectedTargetCheck const&);
+};
+
+class PolyUnitCheck
+{
+    public:
+        explicit PolyUnitCheck(Unit const* unit, float dist, Unit const* currTarget) : me(unit), m_range(dist), mytar(currTarget) {}
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (u == mytar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat() || !u->IsAlive() || !u->GetVictim())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_HUMANOID &&
+                u->GetCreatureType() != CREATURE_TYPE_BEAST)
+                return false;
+            if (me->GetDistance(u) < 6 || mytar->GetDistance(u) < 5 ||
+                (me->ToCreature()->GetBotClass() == CLASS_MAGE && u->GetHealthPct() < 70))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->ToCreature()->GetBotClass() == CLASS_MAGE ? !u->getAttackers().empty() : u->getAttackers().size() > 1)
+                return false;
+            if (!u->IsHostileTo(me))
+                return false;
+            if (u->IsPolymorphed() ||
+                u->isFrozen() ||
+                u->isInRoots() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(339)) || //entangling roots
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(16914)) || //hurricane
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(10)) || //blizzard
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(2121)) || //flamestrike
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(20116)) || //consecration
+                u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == CLASS_MAGE && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(118)))//Polymorph
+                return true;
+            if (me->ToCreature()->GetBotClass() == CLASS_SHAMAN && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(51514)))//Hex
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        Unit const* mytar;
+        PolyUnitCheck(PolyUnitCheck const&);
+};
+
+class FearUnitCheck
+{
+    public:
+        explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_BEAST &&
+                me->ToCreature()->GetBotClass() == CLASS_HUNTER)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (u->getAttackers().size() > 1 && u->GetVictim() != me)
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->isFeared())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == CLASS_WARLOCK &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782)))//fear rank1
+                return true;
+            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1513)))//scare beast rank1
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        FearUnitCheck(FearUnitCheck const&);
+};
+
+class StunUnitCheck
+{
+    public:
+        explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist) {}
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetVictim() == u)
+                return false;
+            if (me->GetTypeId() == TYPEID_UNIT)
+                if (Player* mymaster = me->ToCreature()->GetBotOwner())
+                    if (mymaster->GetVictim() == u)
+                        return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (me->ToCreature()->GetBotClass() == CLASS_PALADIN &&
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER && u->isFeared())
+                return false;
+            if (me->GetDistance(u) < 10)//do not allow close cast to prevent break due to AOE damage
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                u->HasAuraWithMechanic((1<<MECHANIC_SHACKLE)|(1<<MECHANIC_SLEEP)|(1<<MECHANIC_DISORIENTED)))
+                return false;
+            if (me->ToCreature()->GetBotClass() == CLASS_PALADIN &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066)))//repentance
+                return true;
+            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(60210)))//freezing arrow effect
+                return true;
+            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19386)))//wyvern sting rank 1
+                return true;
+            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1991)))//scatter shot
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        StunUnitCheck(StunUnitCheck const&);
+};
+
+class UndeadCCUnitCheck
+{
+    public:
+        explicit UndeadCCUnitCheck(Unit const* unit, float dist = 30, uint32 spell = 0) : me(unit), m_range(dist), m_spellId(spell) { if (!spell) return; }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->GetVictim() == u && u->GetVictim() == me)
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            //most horrible hacks
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                u->GetCreatureType() != CREATURE_TYPE_DEMON &&
+                (m_spellId == 2812 || m_spellId == 10318 || //holy
+                m_spellId == 27139 || m_spellId == 48816 || //wra
+                m_spellId == 48817 ||                       //th or
+                m_spellId == 10326))                        //turn evil
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) &&
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        uint32 m_spellId;
+        UndeadCCUnitCheck(UndeadCCUnitCheck const&);
+};
+
+class RootUnitCheck
+{
+    public:
+        explicit RootUnitCheck(Unit const* unit, Unit const* mytarget, float dist = 30, uint32 spell = 0) : me(unit), curtar(mytarget), m_range(dist), m_spellId(spell)
+        { if (!spell) return; }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (u == curtar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetDistance(u) < 8)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (u->isFrozen() || u->isInRoots())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackle undead*/)
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        Unit const* curtar;
+        float m_range;
+        uint32 m_spellId;
+        RootUnitCheck(RootUnitCheck const&);
+};
+
+class CastingUnitCheck
+{
+    public:
+        explicit CastingUnitCheck(Unit const* unit, float mindist = 0.f, float maxdist = 30, bool friendly = false, uint32 spell = 0) :
+        me(unit), min_range(mindist), max_range(maxdist), m_friend(friendly), m_spell(spell) {}
+        bool operator()(Unit* u)
+        {
+            if (!m_friend && !PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (min_range > 0.1f && me->GetDistance(u) < min_range)
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!m_friend && !u->isTargetableForAttack())
+                return false;
+            //if (!m_friend && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))//prevent double silence
+            //    return false;
+            if (!u->IsNonMeleeSpellCast(false))
+                return false;
+            if (m_friend == (u->GetReactionTo(me) < REP_FRIENDLY))
+                return false;
+            if (m_spell == 10326 && //turn evil
+                u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                u->GetCreatureType() != CREATURE_TYPE_DEMON)
+                return false;
+            if (m_spell == 20066 && //repentance
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (!m_spell || !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spell)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        bool m_friend;
+        uint32 m_spell;
+        CastingUnitCheck(CastingUnitCheck const&);
+};
+
+class SecondEnemyCheck
+{
+    public:
+        explicit SecondEnemyCheck(Unit const* unit, float dist, float splashdist, Unit const* currtarget, bot_ai const* m_ai) :
+        me(unit), m_range(dist), m_splashrange(splashdist), mytar(currtarget), ai(m_ai) {}
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (u == mytar)
+                return false;//We need to find SECONDARY target
+            if (!u->IsInCombat())
+                return false;
+            if (u->isMoving() != mytar->isMoving())//only when both targets idle or both moving
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range + 1.f))//distance check
+                return false;
+            if (mytar->GetDistance(u) > m_splashrange)//not close enough to each other
+                return false;
+
+            if (ai->CanBotAttack(u))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range, m_splashrange;
+        Unit const* mytar;
+        bot_ai const* ai;
+        SecondEnemyCheck(SecondEnemyCheck const&);
+};
+
+class TranquilTargetCheck
+{
+    public:
+        explicit TranquilTargetCheck(Unit const* unit, float mindist, float maxdist, bot_ai const* m_ai) :
+        me(unit), min_range(mindist), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (u != me->GetVictim() &&//check hunter_bot::hunter_botAI::CheckTranquil(uint32)
+                u->IsWithinDistInMap(me, max_range) &&
+                u->GetDistance(me) > min_range &&
+                u->IsAlive() &&
+                u->InSamePhase(me) &&
+                u->IsInCombat() &&
+                u->isTargetableForAttack() &&
+                u->IsVisible() &&
+                u->GetReactionTo(me) < REP_NEUTRAL &&
+                ai->IsInBotParty(u->GetVictim()))
+            {
+                if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19801))) return false;//immune to tranquilizing shot
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    SpellInfo const* Info = itr->second->GetSpellInfo();
+                    if (Info->Dispel != DISPEL_MAGIC && Info->Dispel != DISPEL_ENRAGE) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(u->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        bot_ai const* ai;
+        TranquilTargetCheck(TranquilTargetCheck const&);
+};
+
+class NearbyHostileUnitCheck
+{
+    public:
+        explicit NearbyHostileUnitCheck(Unit const* unit, float maxdist, float mindist, bot_ai const* m_ai, bool forCC) :
+        me(unit), max_range(maxdist), min_range(mindist), ai(m_ai), m_forCC(forCC) { }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (min_range > 0.1f && me->GetDistance(u) < min_range)
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!ai->CanBotAttack(u))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if (m_forCC && u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+
+            if (ai->IsInBotParty(u->GetVictim()))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float max_range, min_range;
+        bot_ai const* ai;
+        bool m_forCC;
+        NearbyHostileUnitCheck(NearbyHostileUnitCheck const&);
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_ai.cpp b/src/server/game/AI/NpcBots/bot_ai.cpp
new file mode 100644
index 0000000..617c8c9
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.cpp
@@ -0,0 +1,5027 @@
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+#include "CellImpl.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GameEventMgr.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "ScriptedGossip.h"
+#include "SpellAuraEffects.h"
+/*
+NpcBot System by Graff (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+TODO:
+Implement virtual inventory for bots
+Better equipment implementation
+Convert doCast events (CD etc.) into SpellHit()- and SpellHitTarget()-based
+Implement Racial Abilities
+Quests
+I NEED MORE
+*/
+const uint8 GroupIconsFlags[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+bot_minion_ai::bot_minion_ai(Creature* creature) : bot_ai(creature)
+{
+    Potion_cd = 0;
+    pvpTrinket_cd = 30000;
+    rezz_cd = 0;
+    evade_cd = 0;
+    myangle = 0.f;
+    mana_cd = uint32(-1);
+    health_cd = uint32(-1);
+    _classinfo = new PlayerClassLevelInfo();
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        for (uint8 j = 0; j != MAX_BOT_ITEM_MOD; ++j)
+            _stats[i][j] = 0;
+    for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+    {
+        _ctc[i].first = 0;
+        _ctc[i].second = 0;
+    }
+}
+bot_minion_ai::~bot_minion_ai()
+{
+    delete _classinfo;
+}
+
+bot_pet_ai::bot_pet_ai(Creature* creature) : bot_ai(creature)
+{
+    m_creatureOwner = me->GetCreatureOwner();
+    basearmor = 0;
+}
+bot_pet_ai::~bot_pet_ai() { }
+
+bot_ai::bot_ai(Creature* creature) : ScriptedAI(creature)
+{
+    master = me->GetBotOwner();
+    _roleMask = 0;
+    m_spellpower = 0;
+    m_block = 1;
+    m_expertise = 0;
+    m_spellpen = 0;
+    haste = 0;
+    hit = 0.f;
+    regen_mp5 = 0.f;
+    m_botSpellInfo = NULL;
+    clear_cd = 2;
+    temptimer = 0;
+    wait = 15;
+    GC_Timer = 0;
+    checkAurasTimer = 20;
+    roleTimer = 0;
+    cost = 0;
+    doHealth = false;
+    doMana = false;
+    //shouldUpdateStats = true;
+    pos.m_positionX = 0.f;
+    pos.m_positionY = 0.f;
+    pos.m_positionZ = 0.f;
+    aftercastTargetGuid = ObjectGuid::Empty;
+    currentSpell = 0;
+    tempMana = 0;
+    dmgmult_melee = sConfigMgr->GetFloatDefault("Bot.DamageMult.Melee", 1.0);
+    dmgmult_spell = sConfigMgr->GetFloatDefault("Bot.DamageMult.Spell", 1.0) * 0.75f;
+    dmgmult_melee = std::max(dmgmult_melee, 0.01f);
+    dmgmult_spell = std::max(dmgmult_spell, 0.01f);
+    dmgmult_melee = std::min(dmgmult_melee, 10.f);
+    dmgmult_spell = std::min(dmgmult_spell, 10.f);
+    dmgmod_melee = Creature::_GetDamageMod(me->GetCreatureTemplate()->rank);
+    dmgmod_spell = me->GetSpellDamageMod(me->GetCreatureTemplate()->rank);
+    healTargetIconFlags = sConfigMgr->GetIntDefault("Bot.HealTargetIconsMask", 8);
+    PvP = sConfigMgr->GetIntDefault("Bot.PvP", 1);
+}
+bot_ai::~bot_ai() { }
+
+SpellCastResult bot_ai::CheckBotCast(Unit* victim, uint32 spellId, uint8 botclass) const
+{
+    if (spellId == 0)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (InDuel(victim))
+        return SPELL_FAILED_DONT_REPORT;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (!CheckImmunities(spellId, victim))
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (Powers(spellInfo->PowerType) == me->getPowerType() &&
+        (int32)me->GetPower(me->getPowerType()) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+        return SPELL_FAILED_DONT_REPORT;
+
+    switch (botclass)
+    {
+        case CLASS_PALADIN:
+        case CLASS_MAGE:
+        case CLASS_PRIEST:
+        case CLASS_DRUID:
+        case CLASS_WARLOCK:
+        case CLASS_SHAMAN:
+            if (Feasting() && !master->IsInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return SPELL_FAILED_DONT_REPORT;
+            break;
+        case CLASS_WARRIOR:
+            //BladeStorm
+            if (me->HasAura(46924/*67541*/))
+                return SPELL_FAILED_DONT_REPORT;
+            break;
+        case CLASS_ROGUE:
+        case CLASS_HUNTER:
+        case CLASS_DEATH_KNIGHT:
+        default:
+            break;
+    }
+
+    return SPELL_CAST_OK;
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, bool triggered, ObjectGuid originalCaster)
+{
+    if (spellId == 0) return false;
+    if (me->IsMounted()) return false;
+    if (IsCasting()) return false;
+    if (!victim || !victim->IsInWorld() || me->GetMap() != victim->FindMap()) return false;
+
+    m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!m_botSpellInfo)
+        return false;
+
+    if (spellId == MANAPOTION)
+    {
+        value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+        me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+        return true;
+    }
+
+    //remove shapeshifts manually to restore powers/stats
+    if (me->GetShapeshiftForm() != FORM_NONE)
+    {
+        if (m_botSpellInfo->CheckShapeshift(me->GetShapeshiftForm()) != SPELL_CAST_OK)
+            removeFeralForm(true);
+    }
+
+    if (spellId != HEALINGPOTION && spellId != MANAPOTION)
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+
+    if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+    {
+        //std::ostringstream msg;
+        //msg << "casting " << spellInfo->SpellName[0] << " on " << victim->GetName();
+        //me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+        me->Relocate(victim);
+    }
+
+    TriggerCastFlags flags = triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE;
+    SpellCastTargets targets;
+    targets.SetUnitTarget(victim);
+    Spell* spell = new Spell(me, m_botSpellInfo, flags, originalCaster);
+    spell->prepare(&targets); //sets current spell if succeed
+
+    bool casted = triggered; //triggered casts are casted immediately
+    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+    {
+        if (me->GetCurrentSpell(i) == spell)
+        {
+            casted = true;
+            break;
+        }
+    }
+
+    if (!casted)
+    {
+        //failed to cast
+        //delete spell; //crash due to invalid event added to master's eventmap
+        return false;
+    }
+
+    currentSpell = spellId;
+
+    if (me->GetBotClass() == CLASS_ROGUE || GetBotStance() == DRUID_CAT_FORM || GetBotStance() == DEATH_KNIGHT_UNHOLY_PRESENCE)
+        value = int32(1000.f - 1000.f*(float(haste) / 100.f));
+    else
+        value = int32(1500.f - 1500.f*(float(haste) / 100.f));
+
+    GC_Timer = std::max<uint32>(value, 500);
+
+    return true;
+}
+//Follow point calculation
+void bot_minion_ai::_calculatePos(Position& pos)
+{
+    uint8 followdist = master->GetBotFollowDist();
+    float mydist, angle;
+
+    if (IsTank())
+    {
+        mydist = frand(3.5f, 6.5f); //stand a bit farther
+        angle = (M_PI/2.f) / 16.f * frand(-3.f, 3.f); //in front +-pi/5
+    }
+    else if (IsMelee())
+    {
+        mydist = frand(0.2f, 1.f);
+        angle = (M_PI/2.f) / 8.f * RAND(frand(5.f, 10.f), frand(-10.f, -5.f)); //to the sides +-(pi/3 to pi/1.6)
+    }
+    else
+    {
+        mydist = frand(0.15f, 0.8f);
+        angle = (M_PI/2.f) / 6.f * frand(10.5f, 13.5f); //behind pi+-pi/4.5
+    }
+    //myangle = angle used last time
+    //if difference between last angle and cur angle is too big, use new angle
+    //else use last angle (prevent constant struggling)
+    if (abs(abs(myangle) - abs(angle)) > M_PI/3.f)
+        myangle = angle;
+    else
+        angle = myangle;
+    mydist += followdist > 10 ? float(followdist - 10)/4.f : 0.f; //distance from 10+ is reduced
+    mydist = std::min<float>(mydist, 35.f); //do not spread bots too much
+    angle += master->GetOrientation();
+    float x(0),y(0),z(0);
+    float size = me->GetObjectSize()/3.f;
+    bool over = false;
+    for (uint8 i = 0; i != 5 + over; ++i)
+    {
+        if (over)
+        {
+            mydist *= 0.2f;
+            break;
+        }
+        master->GetNearPoint(me, x, y, z, size, mydist, angle);
+        if (!master->IsWithinLOS(x,y,z)) //try to get much closer to master
+        {
+            mydist *= 0.4f - float(i*0.07f);
+            size *= 0.1f;
+            if (size < 0.1)
+                size = 0.f;
+            if (size == 0.f && me->GetPositionZ() < master->GetPositionZ())
+                z += 0.25f; //prevent going underground
+        }
+        else
+            over = true;
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+
+    //            T
+    //           TTT
+    //    mmmmmmmm mmmmmmmm
+    //   mmmmmmm MMM mmmmmmm
+    //   mmmmm rrrrrrr mmmmm
+    //    ddd rrrrrrrrr ddd
+    //     ddddddddddddddd
+    //       ddddddddddd
+    //
+    //MMM - player
+    //TTT - bot tank
+    //m - melee (warrior, paladin, deathknight, ench shaman)
+    //d - default (druid, rogue, hunter)
+    //r - ranged/support (priest, warlock, mage, elem shaman)
+}
+// Movement set
+void bot_minion_ai::SetBotCommandState(CommandStates st, bool force, Position* newpos)
+{
+    if (me->isDead() || IAmDead())
+        return;
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (CCed(me, true)/* || master->HasUnitState(UNIT_STATE_FLEEING)*/) return;
+        if (me->isMoving() && Rand() > 25) return;
+        if (!newpos)
+            _calculatePos(pos);
+        else
+        {
+            pos.m_positionX = newpos->m_positionX;
+            pos.m_positionY = newpos->m_positionY;
+            pos.m_positionZ = newpos->m_positionZ;
+        }
+        if (me->getStandState() == UNIT_STAND_STATE_SIT && !Feasting())
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+        me->GetMotionMaster()->MovePoint(master->GetMapId(), pos);
+        //me->GetMotionMaster()->MoveFollow(master, mydist, angle);
+    }
+    else if (st == COMMAND_STAY)
+    {
+        me->StopMoving();
+        me->GetMotionMaster()->Clear();
+        me->GetMotionMaster()->MoveIdle();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+    if (Creature* m_botsPet = me->GetBotsPet())
+        m_botsPet->SetBotCommandState(st, force);
+}
+
+void bot_pet_ai::SetBotCommandState(CommandStates st, bool force, Position* /*newpos*/)
+{
+    if (me->isDead() || IAmDead())
+        return;
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (CCed(me, true)) return;
+        if (me->isMoving() && Rand() > 25) return;
+        Unit* followtarget = m_creatureOwner;
+        if (CCed(m_creatureOwner))
+            followtarget = master;
+        if (followtarget == m_creatureOwner)
+        {
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(master)*0.75f < me->GetDistance(m_creatureOwner))
+                me->GetMotionMaster()->MoveFollow(m_creatureOwner, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+        }
+        else
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(m_creatureOwner)*0.75f < me->GetDistance(master))
+                me->GetMotionMaster()->MoveFollow(master, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+    }
+    else if (st == COMMAND_STAY)//NUY
+    {
+        me->StopMoving();
+        me->GetMotionMaster()->Clear();
+        me->GetMotionMaster()->MoveIdle();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+}
+// Buffs And Heal (really)
+void bot_minion_ai::BuffAndHealGroup(Player* gPlayer, uint32 diff)
+{
+    if (GC_Timer > diff) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        if (!master->IsInWorld() || master->IsBeingTeleported())
+            return;
+        if (HasRole(BOT_ROLE_HEAL) && HealTarget(master, GetHealthPCT(master), diff))
+            return;
+        if (BuffTarget(master, diff))
+            return;
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+            if (HasRole(BOT_ROLE_HEAL) && HealTarget(u, GetHealthPCT(u), diff))
+                return;
+            if (Creature* cre = u->ToCreature())
+                if (cre->GetIAmABot() || cre->IsPet())
+                    if (BuffTarget(u, diff))
+                        return;
+        }
+        return;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        if (!tPlayer->m_Controlled.empty())
+            Bots = true;
+        if (!tPlayer->IsAlive()) continue;
+        if (HasRole(BOT_ROLE_HEAL) && HealTarget(tPlayer, GetHealthPCT(tPlayer), diff))
+            return;
+        if (BuffTarget(tPlayer, diff))
+            return;
+    }
+    if (Bots)
+    {
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || tPlayer->m_Controlled.empty()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+                if (HasRole(BOT_ROLE_HEAL) && HealTarget(u, GetHealthPCT(u), diff))
+                    return;
+                if (Creature* cre = u->ToCreature())
+                    if (cre->GetIAmABot() || cre->IsPet())
+                        if (BuffTarget(u, diff))
+                            return;
+            }
+        }
+    }
+    //check if we have pointed heal target
+    if (HasRole(BOT_ROLE_HEAL))
+    {
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+        {
+            if (healTargetIconFlags & GroupIconsFlags[i])
+            {
+                if (ObjectGuid guid = pGroup->GetTargetIcons()[i])//check this one
+                {
+                    if (Unit* unit = ObjectAccessor::FindConnectedPlayer(guid))
+                    {
+                        if (unit->IsAlive() && me->GetMap() == unit->FindMap() &&
+                            master->GetVictim() != unit && unit->GetVictim() != master &&
+                            unit->GetReactionTo(master) >= REP_NEUTRAL)
+                        {
+                            HealTarget(unit, GetHealthPCT(unit), diff);
+                            //CureTarget(unit, getCureSpell(), diff);
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+// Attempt to resurrect dead players using class spells
+// Target is either player or its corpse
+void bot_minion_ai::RezGroup(uint32 REZZ, Player* gPlayer)
+{
+    if (!REZZ || !gPlayer || me->IsMounted()) return;
+    if (IsCasting()) return;
+    if (rezz_cd > 0) return;
+
+    //sLog->outBasic("RezGroup by %s", me->GetName().c_str());
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        Unit* target = master;
+        if (master->IsAlive()) return;
+        if (master->isResurrectRequested()) return; //resurrected
+        if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)master->GetCorpse();
+        if (!target || !target->IsInWorld()) return;
+        if (me->GetMap() != target->FindMap()) return;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            me->Whisper("Rezzing You", LANG_UNIVERSAL, master);
+            rezz_cd = 60;
+        }
+        return;
+    }
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        Unit* target = tPlayer;
+        if (!tPlayer || tPlayer->IsAlive()) continue;
+        if (tPlayer->isResurrectRequested()) continue; //resurrected
+        if (Rand() > 5) continue;
+        if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)tPlayer->GetCorpse();
+        if (!target || !target->IsInWorld()) continue;
+        if (master->GetMap() != target->FindMap()) continue;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            me->Whisper("Rezzing You", LANG_UNIVERSAL, tPlayer);
+            if (tPlayer != master)
+            {
+                std::string rezstr = "Rezzing ";
+                rezstr += tPlayer->GetName();
+                me->Whisper(rezstr.c_str(), LANG_UNIVERSAL, master);
+            }
+            rezz_cd = 60;
+            return;
+        }
+    }
+}
+// CURES
+//cycle through the group sending members for cure
+void bot_minion_ai::CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff)
+{
+    if (!cureSpell || GC_Timer > diff) return;
+    if (me->getLevel() < 10 || pTarget->getLevel() < 10) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+    if (!master->GetMap()->IsRaid() && Rand() > 75) return;
+    //sLog->outBasic("%s: CureGroup() on %s", me->GetName().c_str(), pTarget->GetName().c_str());
+    Group* pGroup = pTarget->GetGroup();
+    if (!pGroup)
+    {
+        if (CureTarget(master, cureSpell, diff))
+            return;
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* cre = master->GetBotMap(i)->_Cre();
+            if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+            if (CureTarget(cre, cureSpell, diff))
+                return;
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (!tPlayer || (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (me->GetDistance(tPlayer) > 30) continue;
+            if (CureTarget(tPlayer, cureSpell, diff))
+                return;
+        }
+        if (!Bots) return;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+            {
+                Creature* cre = tPlayer->GetBotMap(i)->_Cre();
+                if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+                if (CureTarget(cre, cureSpell, diff))
+                    return;
+            }
+        }
+    }
+}
+
+bool bot_minion_ai::CureTarget(Unit* target, uint32 cureSpell, uint32 diff)
+{
+    return _canCureTarget(target, cureSpell, diff) ? doCast(target, cureSpell) : false;
+}
+// determines if unit has something to cure
+bool bot_minion_ai::_canCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const
+{
+    if (!cureSpell || GC_Timer > diff) return false;
+    if (!target || !target->IsAlive()) return false;
+    if (me->getLevel() < 10 || target->getLevel() < 10) return false;
+    if (me->IsMounted()) return false;
+    if (IsCasting() || Feasting()) return false;
+    if (me->GetDistance(target) > 30) return false;
+    if (!IsInBotParty(target)) return false;
+
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info)
+        return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->Effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->Effects[i].MiscValue));
+
+    if (dispelMask == 0)
+        return false;
+
+    DispelChargesList dispel_list;
+    _getBotDispellableAuraList(target, me, dispelMask, dispel_list);
+
+    return !(dispel_list.empty());
+}
+
+void bot_minion_ai::_getBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const
+{
+    if (dispelMask & (1 << DISPEL_DISEASE) && target->HasAura(50536))
+        dispelMask &= ~(1 << DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura* aura = itr->second;
+
+        if (aura->IsPassive())
+            continue;
+
+        AuraApplication* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            //do not dispel positive auras from enemies and negative ones from friends
+            if (aurApp->IsPositive() == target->IsFriendlyTo(caster))
+                continue;
+
+            //skip Vampiric Touch to prevent being CCed just heal it out
+            if (aura->GetSpellInfo()->IsRankOf(sSpellMgr->GetSpellInfo(34914)))
+                continue;
+
+            uint8 charges = (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount();
+            if (charges > 0)
+                dispelList.push_back(std::make_pair(aura, charges));
+        }
+    }
+}
+//protected
+bool bot_ai::HasAuraName(Unit* unit, uint32 spellId, ObjectGuid casterGuid, bool exclude) const
+{
+    ASSERT(spellId);
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TC_LOG_FATAL("entities.player", "bot_ai::HasAuraName(uint32): no spellInfo found for spell %u!", spellId);
+        ASSERT(false);
+    }
+
+    uint8 loc = master->GetSession()->GetSessionDbcLocale();
+    std::string const name = spellInfo->SpellName[loc];
+
+    return _hasAuraName(unit, name, casterGuid, exclude);
+}
+//private
+bool bot_ai::_hasAuraName(Unit* unit, std::string const spell, ObjectGuid casterGuid, bool exclude) const
+{
+    ASSERT(unit);
+    ASSERT(spell.length() != 0);
+
+    uint8 loc = master->GetSession()->GetSessionDbcLocale();
+
+    Unit::AuraMap const& vAuras = unit->GetOwnedAuras();
+    SpellInfo const* spellInfo;
+    std::string name;
+
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        spellInfo = itr->second->GetSpellInfo();
+        name = spellInfo->SpellName[loc];
+        if (spell == name)
+            if (casterGuid == 0 || (exclude == (casterGuid != itr->second->GetCasterGUID())))
+                return true;
+    }
+
+    return false;
+}
+//LIST AURAS
+// Debug: Returns bot's info to called player
+void bot_ai::_listAuras(Player* player, Unit* unit) const
+{
+    if (!IsInBotParty(player)) return;
+    if (!IsInBotParty(unit)) return;
+    ChatHandler ch(player->GetSession());
+    std::ostringstream botstring;
+    if (unit->GetTypeId() == TYPEID_PLAYER)
+        botstring << "player";
+    else if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        if (unit->ToCreature()->GetIAmABot())
+        {
+            botstring << "minion bot, master: ";
+            std::string const& ownername = unit->ToCreature()->GetBotOwner()->GetName();
+            botstring << ownername;
+        }
+        else if (unit->ToCreature()->GetIAmABotsPet())
+        {
+            Player* owner = unit->ToCreature()->GetBotOwner();
+            Creature* creowner = unit->ToCreature()->GetBotPetAI()->GetCreatureOwner();
+            std::string const& ownername = owner ? owner->GetName() : "none";
+            std::string const& creownername = creowner ? creowner->GetName() : "none";
+            botstring << "pet bot, master: ";
+            botstring << ownername;
+            botstring << ", creature owner: ";
+            botstring << creownername;
+            if (creowner)
+                botstring << " (" << creowner->GetGUID().GetCounter() << ')';
+        }
+    }
+    ch.PSendSysMessage("ListAuras for %s, %s", unit->GetName().c_str(), botstring.str().c_str());
+    uint8 locale = player->GetSession()->GetSessionDbcLocale();
+    Unit::AuraMap const &vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+        if (!spellInfo)
+            continue;
+        uint32 id = spellInfo->Id;
+        SpellInfo const* learnSpellInfo = sSpellMgr->GetSpellInfo(spellInfo->Effects[0].TriggerSpell);
+        const std::string name = spellInfo->SpellName[locale];
+        std::ostringstream spellmsg;
+        spellmsg << id << " - |cffffffff|Hspell:" << id << "|h[" << name;
+        spellmsg << ' ' << localeNames[locale] << "]|h|r";
+        uint32 talentcost = GetTalentSpellCost(id);
+        uint32 rank = 0;
+        if (talentcost > 0 && spellInfo->GetNextRankSpell())
+            rank = talentcost;
+        else if (learnSpellInfo && learnSpellInfo->GetNextRankSpell())
+            rank = spellInfo->GetRank();
+        if (rank > 0)
+            spellmsg << " Rank " << rank;
+        if (talentcost > 0)
+            spellmsg << " [talent]";
+        if (spellInfo->IsPassive())
+            spellmsg << " [passive]";
+        if (unit->GetTypeId() == TYPEID_PLAYER && unit->ToPlayer()->HasSpell(id))
+            spellmsg << " [known]";
+
+        ch.PSendSysMessage(spellmsg.str().c_str());
+    }
+    for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+    {
+        std::string mystat;
+        switch (i)
+        {
+            case STAT_STRENGTH: mystat = "str"; break;
+            case STAT_AGILITY: mystat = "agi"; break;
+            case STAT_STAMINA: mystat = "sta"; break;
+            case STAT_INTELLECT: mystat = "int"; break;
+            case STAT_SPIRIT: mystat = "spi"; break;
+            default: mystat = "unk stat"; break;
+        }
+        ch.PSendSysMessage("%s: %.1f", mystat.c_str(), unit->GetTotalStatValue(Stats(i)));
+    }
+    ch.PSendSysMessage("Melee AP: %.1f", unit->GetTotalAttackPowerValue(BASE_ATTACK));
+    ch.PSendSysMessage("Ranged AP: %.1f", unit->GetTotalAttackPowerValue(RANGED_ATTACK));
+    ch.PSendSysMessage("armor: %u", unit->GetArmor());
+    ch.PSendSysMessage("crit: %.1f pct", unit->GetUnitCriticalChance(BASE_ATTACK, me));
+    ch.PSendSysMessage("dodge: %.1f pct", unit->GetUnitDodgeChance());
+    ch.PSendSysMessage("parry: %.1f pct", unit->GetUnitParryChance());
+    ch.PSendSysMessage("block: %.1f pct", unit->GetUnitBlockChance());
+    ch.PSendSysMessage("block value: %u", unit->GetShieldBlockValue());
+    ch.PSendSysMessage("Damage taken melee: %.3f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL));
+    ch.PSendSysMessage("Damage taken spell: %.3f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC));
+    ch.PSendSysMessage("Damage range mainhand: min: %.1f, max: %.1f", unit->GetFloatValue(UNIT_FIELD_MINDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    ch.PSendSysMessage("Damage range offhand: min: %.1f, max: %.1f", unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+    ch.PSendSysMessage("Damage range ranged: min: %.1f, max: %.1f", unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+    ch.PSendSysMessage("Damage mult mainhand: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    ch.PSendSysMessage("Damage mult offhand: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+    ch.PSendSysMessage("Damage mult ranged: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+    ch.PSendSysMessage("Attack time mainhand: %.2f", float(unit->GetAttackTime(BASE_ATTACK))/1000.f);
+    ch.PSendSysMessage("Attack time offhand: %.2f", float(unit->GetAttackTime(OFF_ATTACK))/1000.f);
+    ch.PSendSysMessage("Attack time ranged: %.2f", float(unit->GetAttackTime(RANGED_ATTACK))/1000.f);
+    if (unit == me)
+        ch.PSendSysMessage("melee damage mult: %.3f", dmgmult_melee);
+    ch.PSendSysMessage("base hp: %u", unit->GetCreateHealth());
+    ch.PSendSysMessage("total hp: %u", unit->GetMaxHealth());
+    ch.PSendSysMessage("base mana: %u", unit->GetCreateMana());
+    ch.PSendSysMessage("total mana: %u", unit->GetMaxPower(POWER_MANA));
+    //DEBUG1
+    //ch.PSendSysMessage("STATS: ");
+    //ch.PSendSysMessage("Health");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_PCT));
+    //ch.PSendSysMessage("Mana");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_PCT));
+    //ch.PSendSysMessage("Stamina");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT));
+    //ch.PSendSysMessage("Intellect");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT));
+    //ch.PSendSysMessage("Spirit");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_PCT));
+    //END DEBUG1
+    if (unit == me)
+    {
+        ch.PSendSysMessage("spellpower: %u", m_spellpower/* - m_spellpower % 50*/);
+        ch.PSendSysMessage("spell damage mult: %.3f", dmgmult_spell);
+        ch.PSendSysMessage("mana regen: %.2f", regen_mp5/* - (int32(regen_mp5) % 45)*/);
+        ch.PSendSysMessage("haste: %u *10 pct", haste);
+        ch.PSendSysMessage("hit: +%.2f pct", hit);
+        ch.PSendSysMessage("expertise: %i (-%.2f pct)", m_expertise, float(m_expertise) * 0.25f);
+        ch.PSendSysMessage("spell penetration: %i", m_spellpen);
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            const char* resist = NULL;
+            switch (i)
+            {
+                case 1: resist = "holy";   break;
+                case 2: resist = "fire";   break;
+                case 3: resist = "nature"; break;
+                case 4: resist = "frost";  break;
+                case 5: resist = "shadow"; break;
+                case 6: resist = "arcane"; break;
+            }
+            ch.PSendSysMessage("Resistance %s: %u", resist, me->GetResistance(SpellSchools(i)));
+        }
+        ch.PSendSysMessage("BotCommandState: %s", m_botCommandState == COMMAND_FOLLOW ? "Follow" : m_botCommandState == COMMAND_ATTACK ? "Attack" : m_botCommandState == COMMAND_STAY ? "Stay" : m_botCommandState == COMMAND_ABANDON ? "Reset" : "none");
+        ch.PSendSysMessage("Follow distance: %u", master->GetBotFollowDist());
+
+        //ch.PSendSysMessage("healTargetIconFlags: %u", healTargetIconFlags);
+
+        //ch.PSendSysMessage("Roles:");
+        //for (uint8 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+        //{
+        //    if (_roleMask & i)
+        //    {
+        //        switch (i)
+        //        {
+        //            case BOT_ROLE_TANK:
+        //                ch.PSendSysMessage("BOT_ROLE_TANK");
+        //                break;
+        //            case BOT_ROLE_DPS:
+        //                ch.PSendSysMessage("BOT_ROLE_DPS");
+        //                break;
+        //            case BOT_ROLE_HEAL:
+        //                ch.PSendSysMessage("BOT_ROLE_HEAL");
+        //                break;
+        //            //case BOT_ROLE_MELEE:
+        //            //    ch.PSendSysMessage("BOT_ROLE_MELEE");
+        //            //    break;
+        //            case BOT_ROLE_RANGED:
+        //                ch.PSendSysMessage("BOT_ROLE_RANGED");
+        //                break;
+        //        }
+        //    }
+        //}
+
+        //ch.PSendSysMessage("Stat bonuses:");
+        //for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        //{
+        //    int32 val = 0;
+        //    uint32 const a = i;
+        //    for (uint8 j = 0; j != BOT_INVENTORY_SIZE; ++j)
+        //        val += static_cast<BotStat>(_stats[j])[a];
+
+        //    if (val != 0)
+        //        ch.PSendSysMessage("Item mod %u: bonus = %i", i, val);
+        //}
+
+        //ch.PSendSysMessage("CTCs:");
+        //for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+        //{
+        //    if (!_ctc[i].first)
+        //        continue;
+
+        //    if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(_ctc[i].first))
+        //    {
+        //        std::ostringstream msg;
+        //        msg << uint32(CalcCTC(_ctc[i].first)) << " pct to cast ";
+        //        _AddSpellLink(player, spellInfo, msg);
+        //        msg << " on damage deal";
+        //        ch.PSendSysMessage(msg.str().c_str());
+        //    }
+        //}
+
+        //debug
+        //if (IsPetAI()) GetPetAI()->ListSpells(&ch);
+    }
+}
+//SetStats
+// Health, Armor, Powers, Combat Ratings, and global update setup
+void bot_minion_ai::SetStats(bool force, bool shapeshift)
+{
+    uint8 myclass = me->GetBotClass();
+    uint8 mylevel = master->getLevel();
+    if (myclass == CLASS_DRUID)
+        myclass = GetBotStance();
+    if (myclass != DRUID_BEAR_FORM && myclass != DRUID_CAT_FORM && (master->isDead() || (!shouldUpdateStats && !force))) return;
+    /*sLog->outBasic("SetStats(): Updating bot %s, class: %u, race: %u, level %u, master: %s",
+        me->GetName().c_str(), myclass, myrace, mylevel, master->GetName().c_str());*/
+
+    mylevel = std::min<uint8>(mylevel, 80);
+
+    //Do not remove this code under any circumstances! You've been warned.
+    if (myclass == CLASS_DEATH_KNIGHT)
+        mylevel = std::max<uint8>(mylevel, 55);
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells();
+        //ApplyPassives(me->GetBotClass());
+
+        //need to find a way to remove all passives before reapply (except levelups)
+        //!!!this is only for gm's (players are not supposed to lower their level)
+        ApplyClassPassives();
+    }
+
+    //PHASE
+    if (master->GetPhaseMask() != me->GetPhaseMask())
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+    //INIT STATS
+    //partially receive master's stats and get base class stats, we'll need all this later
+    uint8 tempclass = myclass == DRUID_BEAR_FORM || myclass == DRUID_CAT_FORM ? CLASS_DRUID : myclass;
+    sObjectMgr->GetPlayerClassLevelInfo(tempclass, mylevel, _classinfo);
+    const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->getClass());//use creature class
+    float value;
+    if (force)
+        for (uint8 i = STAT_STAMINA; i < MAX_STATS; i++)
+            me->SetCreateStat(Stats(i), master->GetCreateStat(Stats(i)));
+
+    //MAXSTAT
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+    {
+        value = master->GetTotalStatValue(Stats(i));
+        if (i == 0 || value > stat)
+            stat = value; //Get Hightest stat (on first cycle just set base value)
+    }
+    stat = std::max(stat - 18.f, 0.f); //base value for all stats is 18 (isn't counted in any way)
+
+    //INIT CLASS MODIFIERS
+    switch (myclass)
+    {
+        case CLASS_WARRIOR:      ap_mod = 1.3f; spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 0.75f; parry_mod = 1.75f; break;
+        case CLASS_DEATH_KNIGHT: ap_mod = 1.2f; spp_mod = 0.0f; armor_mod = 1.05f; crit_mod = 1.1f; haste_mod = 1.05f; dodge_mod = 0.6f;  parry_mod = 1.95f;  break;
+        case CLASS_PALADIN:      ap_mod = 1.0f; spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f;  parry_mod = 1.5f;  break;
+        case CLASS_ROGUE:        ap_mod = 1.5f; spp_mod = 0.0f; armor_mod = 0.7f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f;  parry_mod = 0.8f;  break;
+        case CLASS_HUNTER:       ap_mod = 1.7f; spp_mod = 0.2f; armor_mod = 1.0f;  crit_mod = 1.2f; haste_mod = 1.85f; dodge_mod = 1.3f;  parry_mod = 1.2f;  break;
+        case CLASS_SHAMAN:       ap_mod = 1.1f; spp_mod = 0.5f; armor_mod = 1.1f;  crit_mod = 1.1f; haste_mod = 1.45f; dodge_mod = 1.1f;  parry_mod = 1.4f;  break;
+        case CLASS_DRUID:        ap_mod = 0.0f; spp_mod = 1.3f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.95f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case CLASS_MAGE:         ap_mod = 0.0f; spp_mod = 0.8f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case CLASS_PRIEST:       ap_mod = 0.0f; spp_mod = 1.2f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case CLASS_WARLOCK:      ap_mod = 0.0f; spp_mod = 1.0f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case DRUID_BEAR_FORM:    ap_mod = 2.0f; spp_mod = 1.3f; armor_mod = 2.25f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 2.5f;  parry_mod = 0.0f;  break;
+        case DRUID_CAT_FORM:     ap_mod = 1.5f; spp_mod = 1.3f; armor_mod = 1.1f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.35f; parry_mod = 0.0f;  break;
+        default:                 ap_mod = 0.0f; spp_mod = 0.0f; armor_mod = 0.0f;  crit_mod = 0.0f; haste_mod = 0.00f; dodge_mod = 0.0f;  parry_mod = 0.0f;  break;
+    }
+    if (spp_mod != 0.f && mylevel > 39)
+        spp_mod *= (float(mylevel - 39))/41.f;// gain spell power slowly
+
+    //DAMAGE
+    _OnMeleeDamageUpdate(myclass);
+
+    //ARMOR
+    //sLog->outBasic("Unpdating %s's ARMOR: ", me->GetName().c_str());
+    //sLog->outBasic("armor mod: %f", armor_mod);
+    armor_mod *= (master->GetModifierValue(UNIT_MOD_ARMOR, BASE_PCT) + master->GetModifierValue(UNIT_MOD_ARMOR, TOTAL_PCT))/2.f;
+    //sLog->outBasic("armor mod * master's modifier: %f", armor_mod);
+    value = float(classstats->BaseArmor / 2);
+    //sLog->outBasic("base armor: %f", value);
+    value += float(master->GetArmor())/5.f;
+    //sLog->outBasic("base armor + 1/5 of master's armor: %f", value);
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        value += _stats[i][BOT_ITEM_MOD_ARMOR];
+
+    if (IsTank())
+        armor_mod += 0.5f;
+    if (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE)
+        armor_mod += 0.6f;
+
+    value *= armor_mod;
+    //sLog->outBasic("multiplied by armor mod (total base armor): %f", value);
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor();//buffs will be took in consideration here
+
+    //RESISTANCES
+    //sLog->outBasic("Unpdating %s's RESISTANCES: ", me->GetName().c_str());
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = float(master->GetResistance(SpellSchools(i)));
+
+        for (uint8 j = 0; j != BOT_INVENTORY_SIZE; ++j)
+            value += 2.5f * (_stats[j][BOT_ITEM_MOD_RESIST_HOLY + (i - 1)]);
+
+        //sLog->outBasic("master's resistance %u: %f, setting %f (triple) to bot", uint32(UNIT_MOD_RESISTANCE_START + i), value, value*3);
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, value * 2.f + float(mylevel * 2));
+        //me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_PCT, 1.f);
+        me->UpdateResistances(i);
+    }
+    //DAMAGE TAKEN
+    float directReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL);
+    float magicReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC);
+    value = (directReduction + magicReduction)/2.f; // average
+    if (value > 1.f)
+        value -= 1.f;
+    else
+        value = 1.f - value; //get reduction even if master's is 1.0+
+    value = std::min(0.42f, value);
+    value/= 0.01f; //here we get percent like 0.42/0.01 = 42% (value * 100.f)
+    if (mylevel > 77)
+        value += float(mylevel - 78)*6.f;// + 2 stacks for high level
+    RefreshAura(DMG_TAKEN, int8(value/6.f));//so max aura count = 10
+
+    //HEALTH
+    _OnHealthUpdate();
+
+    //HASTE
+    value = 0.f;
+    for (uint8 i = CR_HASTE_MELEE; i != CR_HASTE_SPELL + 1; ++i)
+        if (float rating = std::min<float>(master->GetRatingBonusValue(CombatRating(i)), 30.f))
+            if (rating > value) //master got some haste
+                value = rating; //get hightest pct
+    for (uint8 i = EQUIPMENT_SLOT_BACK; i < EQUIPMENT_SLOT_END; ++i)
+        if (Item* item = master->GetItemByPos(0, i)) //inventory weapons
+            if (item->GetTemplate()->ItemLevel >= 277) //bears ICC 25H LK items or Wrathful items
+                value += 9.f; //only weapons so we can add 1 to 3 stacks (rogue, warr, sham...)
+
+    if (mylevel >= 70)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //25.5 HR = 1% haste at 80 (12.75 for bot)
+            float tempval = _stats[i][ITEM_MOD_HASTE_MELEE_RATING] + _stats[i][ITEM_MOD_HASTE_RANGED_RATING] + _stats[i][ITEM_MOD_HASTE_SPELL_RATING] + _stats[i][ITEM_MOD_HASTE_RATING];
+            value += 3.f * (tempval / (25.5f * (float(mylevel - 40) / 40.f)));
+        }
+    }
+
+    value *= haste_mod;
+    if (IsMeleeClass(myclass))
+        value *= 0.67f; //nerf melee haste by 1/3
+    value = value/10.f + float(mylevel/39);//get bonus at 39 and 78
+    if (myclass == DRUID_CAT_FORM) //give cat lots of haste
+        value += float(mylevel/16); //or 20 (+ 4-5 stacks);
+    RefreshAura(HASTE,  uint8(value) + uint8(myclass == CLASS_SHAMAN) * 2); //spell haste
+    RefreshAura(HASTE2, uint8(value) + uint8(myclass == CLASS_ROGUE)); //melee haste
+    if (myclass == CLASS_ROGUE || myclass == CLASS_HUNTER)
+        RefreshAura(HASTE3, uint8(value) + uint8(myclass == CLASS_HUNTER) * 2); //ranged haste
+    haste = uint8(value); //for show only
+
+    //HIT
+    int32 melee_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_HIT_CHANCE) + master->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE) + master->GetRatingBonusValue(CR_HIT_MELEE);
+    int32 spell_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_SPELL_HIT_CHANCE) + master->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT, SPELL_SCHOOL_MASK_SPELL) + master->GetRatingBonusValue(CR_HIT_SPELL);
+    value = std::min<float>(25.0f, float(melee_hit > spell_hit ? melee_hit : spell_hit) * 1.5f); //hightest, buff hit chance for bots
+
+    if (mylevel >= 20)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //32.5 HR = 1% hit at 80
+            float tempval = _stats[i][ITEM_MOD_HIT_MELEE_RATING] + _stats[i][ITEM_MOD_HIT_RANGED_RATING] + _stats[i][ITEM_MOD_HIT_SPELL_RATING] + _stats[i][ITEM_MOD_HIT_RATING];
+            value += 5.f * (tempval / (32.5f * (float(mylevel - 10) / 70.f)));
+        }
+    }
+
+    hit = value;
+    RefreshAura(PRECISION,  int8(hit) + mylevel / 39); //melee
+    RefreshAura(PRECISION2, int8(hit) + mylevel / 39); //spell
+
+    //EXPERTISE
+    if (ap_mod > 0.f) //don't bother casters
+    {
+        m_expertise = std::min<int32>(80, (master->GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) + master->GetRatingBonusValue(CR_EXPERTISE)) * 2); //lots of expertise for bots
+
+        if (mylevel >= 20)
+        {
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                //~8.0 ER = 1 expertise at 80
+                float tempval = _stats[i][ITEM_MOD_EXPERTISE_RATING];
+                m_expertise += int32(2.f * (tempval / (8.0f * (float(mylevel - 10) / 70.f))));
+            }
+        }
+
+        if (m_expertise < 20)
+            RefreshAura(EXPERTISE,  int8(m_expertise / 5)  + mylevel / 39); //5  expertise + 10
+        else
+            RefreshAura(EXPERTISE2, int8(m_expertise / 10) + mylevel / 39); //10 expertise + 20
+    }
+    else
+        m_expertise = 0;
+
+    //CRIT
+    //chose melee or ranged cuz crit rating increases melee/spell, and hunter benefits from agility
+    value = std::min<float>(50.0f, master->GetUnitCriticalChance((master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK), me));
+    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if can
+
+    if (mylevel >= 10)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //45 CR = 1% crit at 80
+            float tempval = _stats[i][ITEM_MOD_CRIT_MELEE_RATING] + _stats[i][ITEM_MOD_CRIT_RANGED_RATING] + _stats[i][ITEM_MOD_CRIT_SPELL_RATING] + _stats[i][ITEM_MOD_CRIT_RATING];
+            value += 1.5f * (tempval / (45.f * (float(mylevel - 5) / 75.f)));
+        }
+    }
+
+    value *= crit_mod;
+    RefreshAura(CRITS, int8(value / 5.f) + 1);
+    if (myclass == CLASS_PRIEST)
+        RefreshAura(HOLYCRIT, int8(value / 7.f)); //add holy crit to healers
+
+    //PARRY
+    value = 0.5f * master->GetFloatValue(PLAYER_PARRY_PERCENTAGE);
+    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if possible
+
+    if (mylevel >= 30)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //67 PR = 1% parry at 80
+            float tempval = _stats[i][ITEM_MOD_PARRY_RATING];
+            value += 1.5f * (tempval / (67.f * (float(mylevel - 20) / 60.f)));
+            //125 DR = 1% block/parry/dodge at 80
+            tempval = _stats[i][ITEM_MOD_DEFENSE_SKILL_RATING];
+            value += 1.5f * (tempval / (125.f * (float(mylevel - 20) / 60.f)));
+        }
+    }
+
+    value *= parry_mod;
+    if (IsTank() && myclass != DRUID_CAT_FORM && myclass != DRUID_BEAR_FORM) //feral cannot parry so let it be base 5%
+        value += 10.f;
+    //Forceful Deflection: 12.5% (half of base 25%) of strength (use max stat) goes to parry rating (~1% parry per 67 rating at 80)
+    if (myclass == CLASS_DEATH_KNIGHT/* && mylevel >= 55*/)
+        value += (stat / 8.f) / (float(mylevel) - (13.f / (float(mylevel - 40) / 40.f))); //~20 at 55, ~34 at 60 and 67 at 80
+    if (value > 35.f)
+        value = 35.f;
+    float parryAndDodge = value; //set temp value, this is needed to keep total avoidance within 40%
+    RefreshAura(PARRY, int8(value/5.f)); //5% per stack aplied
+
+    //DODGE
+    value = 0.5f * master->GetUnitDodgeChance();
+    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if possible
+
+    if (mylevel >= 20)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //53 DR = 1% dodge at 80
+            float tempval = _stats[i][ITEM_MOD_DODGE_RATING];
+            value += 1.5f * (tempval / (53.f * (float(mylevel - 10) / 70.f)));
+            //125 DR = 1% block/parry/dodge at 80
+            tempval = _stats[i][ITEM_MOD_DEFENSE_SKILL_RATING];
+            value += 1.5f * (tempval / (125.f * (float(mylevel - 10) / 70.f)));
+        }
+    }
+
+    value *= dodge_mod;
+    if (IsTank())
+        value += 10.f;
+    if (value > 35.f)
+        value = 35.f;
+    if (parryAndDodge + value > 35.f)
+        value = 35.f - parryAndDodge; //do not allow avoidance to be more than 40% (base 5+5)
+    RefreshAura(DODGE, int8(value / 5.f));
+
+    //BLOCK
+    if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+    {
+        value = master->GetFloatValue(PLAYER_BLOCK_PERCENTAGE);
+        if (mylevel >= 10)
+        {
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                //16.5 BR = 1% block at 80
+                float tempval = _stats[i][ITEM_MOD_BLOCK_RATING];
+                value += 1.5f * (tempval / (16.5f * (float(mylevel - 5) / 75.f)));
+                //125 DR = 1% block/parry/dodge at 80
+                tempval = _stats[i][ITEM_MOD_DEFENSE_SKILL_RATING];
+                value += 2.5f * (tempval / (125.f * (float(mylevel - 5) / 75.f)));
+            }
+        }
+
+        if (IsTank())
+            value += 15.f;
+        value = std::min<float>(value, 75.0f);
+        RefreshAura(BLOCK, int8(value / 5.f));
+
+        //BLOCK VALUE
+        float tempval = float(mylevel + mylevel / 4);
+        //tempval += master->GetShieldBlockValue();
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            tempval += 0.75f * (_stats[i][ITEM_MOD_STRENGTH]);
+            tempval += 1.25f * (_stats[i][ITEM_MOD_BLOCK_VALUE]);
+        }
+
+        //Shield Mastery
+        if (mylevel >= 20 && myclass == CLASS_WARRIOR)
+            tempval *= 1.3f;
+
+        tempval = std::max<float>(tempval - 10.f, 1.f);
+
+        m_block = uint32(tempval);
+    }
+    else
+        m_block = 1;
+
+    //MANA
+    _OnManaUpdate(shapeshift);
+
+    //MANA REGEN
+    if (mylevel >= 40 && (me->getPowerType() == POWER_MANA || me->getPowerType() == POWER_RUNIC_POWER))
+    {
+        regen_mp5 = 0.5f * master->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER);
+        //TOO COMPLICATED
+        //regen_mp5 = (master->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + sqrt(master->GetStat(STAT_INTELLECT)) * master->OCTRegenMPPerSpirit()) / 5.f;
+        //Unit::AuraEffectList const& regenAura = master->GetAuraEffectsByType(SPELL_AURA_MOD_MANA_REGEN_FROM_STAT);
+        //for (Unit::AuraEffectList::const_iterator i = regenAura.begin(); i != regenAura.end(); ++i)
+        //    regen_mp5 += master->GetStat(Stats((*i)->GetMiscValue())) * (*i)->GetAmount() / 500.f;
+        //regen_mp5 *= 0.8f;//custom modifier
+        float regen_mp5_a = stat * 0.2f;
+        //regen_mp5 += master->GetTotalStatValue(STAT_SPIRIT) * 0.1f;
+        regen_mp5 = regen_mp5 > regen_mp5_a ? regen_mp5 : regen_mp5_a;
+
+        //unknown values
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            regen_mp5 += 2.f * (_stats[i][ITEM_MOD_MANA_REGENERATION]);
+            regen_mp5 += 1.f * (_stats[i][ITEM_MOD_SPIRIT]);
+        }
+
+        if (myclass == CLASS_HUNTER && mylevel > 20)
+            regen_mp5 += 45.f * ((mylevel - 20) / 15 + 1);
+        if (regen_mp5 >= 45.f)
+        {
+            me->RemoveAurasDueToSpell(MANAREGEN100);
+            me->RemoveAurasDueToSpell(MANAREGEN45);
+            if      (regen_mp5 > 200.f)   RefreshAura(MANAREGEN100,int8(regen_mp5/100.f) + mylevel / 20);
+            else/*if (regen_mp5 > 150.f)*/RefreshAura(MANAREGEN45, int8(regen_mp5/45.f)  + mylevel / 20);
+        }
+    }
+
+    //SPELL PENETRATION
+    if (mylevel >= 30 && spp_mod > 0.f)
+    {
+        m_spellpen = std::min<int32>(200, master->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, SPELL_SCHOOL_MASK_SPELL) / 2);
+
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //~1 SPPR = 1 spell penetration
+            m_spellpen += 5 * _stats[i][ITEM_MOD_SPELL_PENETRATION];
+        }
+
+        if (m_spellpen < 25)
+            RefreshAura(SPELL_PEN_5,  int8(m_spellpen / 5)  + mylevel / 20); //5  sppen + 20
+        else
+            RefreshAura(SPELL_PEN_20, int8(m_spellpen / 20) + mylevel / 40); //20 sppen + 40
+    }
+    else
+        m_spellpen = 0;
+
+    //SPELL POWER
+    if (mylevel >= 40 && spp_mod > 0.f)
+    {
+        //sLog->outBasic("Updating spellpower for %s:", me->GetName().c_str());
+        //sLog->outBasic("spp_mod: %f", spp_mod);
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
+            if (power > sppower || i == SPELL_SCHOOL_HOLY)
+                sppower = power;
+        }
+        //sLog->outBasic("Master's spell power: %i", sppower);
+        atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
+        atpower *= 0.67f;
+        //sLog->outBasic("Master's 2/3 of attack power: %f", atpower);
+        m_spellpower = sppower > atpower ? sppower : atpower;
+        //sLog->outBasic("Chosen stat value: %i", m_spellpower);
+
+        m_spellpower /= 3; //reduce spellpower since we have items
+
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            m_spellpower += 2 * (_stats[i][ITEM_MOD_SPELL_POWER]);
+
+        m_spellpower = int32(float(m_spellpower) * spp_mod);
+        //sLog->outBasic("spellpower * mod: %i", m_spellpower);
+
+        if (myclass == CLASS_MAGE)
+            RefreshAura(FIREDAM_86, (m_spellpower / 4) / 86 + (mylevel >= 78) * 2); //(86,172,258,344,430,516,602,688...) // fire spp, do not touch this
+        me->RemoveAurasDueToSpell(SPELL_BONUS_250);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_150);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_50);
+        if      (mylevel < 60) RefreshAura(SPELL_BONUS_50,  m_spellpower / 50);
+        else if (mylevel < 80) RefreshAura(SPELL_BONUS_150, m_spellpower / 150 + 1);
+        else                   RefreshAura(SPELL_BONUS_250, m_spellpower / 250 + 2);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    //SetStats for pet
+    if (Creature* pet = me->GetBotsPet())
+        if (bot_pet_ai* petai = pet->GetBotPetAI())
+            petai->SetStats(force);
+
+    shouldUpdateStats = false;
+}
+void bot_pet_ai::SetStats(bool force)
+{
+    uint8 mylevel = master->getLevel();
+    uint8 petType = GetPetType(me);
+    if (petType == PET_TYPE_NONE || petType >= MAX_PET_TYPES) return;
+    if (!shouldUpdateStats && !force) return;
+    //TC_LOG_ERROR("entities.player", "SetStats(): Updating pet bot %s, type: %u, level %u, owner: %s, master: %s", me->GetName().c_str(), petType, mylevel, m_creatureOwner->GetName().c_str(), master->GetName().c_str());
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells();
+        //ApplyPassives(me->GetBotClass());
+
+        //need to find a way to remove all passives before reapply (except levelups)
+        //!!!this is only for gm's (players are not supposed to lower their level)
+        ApplyClassPassives();
+    }
+
+    //PHASE
+    if (master->GetPhaseMask() != me->GetPhaseMask())
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+
+    ////INIT STATS
+    //uint8 botclass = m_creatureOwner->GetBotClass();
+    //sObjectMgr->GetPlayerClassLevelInfo(botclass, m_creatureOwner->getLevel(), _classinfo);
+    //const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->GetBotClass());//use creature class
+    //if (force)
+    //    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; i++)
+    //        me->SetCreateStat(Stats(i), master->GetCreateStat(Stats(i))*0.5f);
+
+    //MAXSTAT
+    float value;
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+    {
+        value = master->GetTotalStatValue(Stats(i));
+        if (i == 0 || value > stat)
+            stat = value;//Get Hightest stat (on first cycle just set base value)
+    }
+    stat = std::max(stat - 18.f, 0.f);//remove base
+
+    //INIT CLASS MODIFIERS
+    //STAT -- 'mod' -- used stat values to apply
+    //WARLOCK
+    //Stamina x0.3  -- health
+    //Armor   x0.35 -- armor
+    //Int     x0.3  -- crit/mana
+    //Spd     x0.15 -- spd (if has mana)
+    //AP      x0.57 -- attack power (if melee pet)
+    //Resist  x0.4  -- resistances
+    //MAGE
+    //
+    //SHAMAN
+    //
+    //HUNTER
+    //Other   x1.0  -- use as default
+    switch (petType)
+    {
+        case PET_TYPE_VOIDWALKER:       ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;
+        //case PET_TYPE_FELHUNTER:        ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_FELGUARD:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_SUCCUBUS:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_IMP:              ap_mod = 0.f;   spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+
+        //case PET_TYPE_WATER_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_FIRE_ELEMENTAL:   ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+        //case PET_TYPE_EARTH_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_VULTURE:          ap_mod = 0.9f;  spp_mod = 1.0f; crit_mod = 1.2f; break;//NYI
+        default:                        ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;
+    }
+    //case CLASS_WARRIOR:      ap_mod = 1.3f;  spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 0.75f; parry_mod = 1.75f; break;
+    //case CLASS_DEATH_KNIGHT: ap_mod = 1.2f;  spp_mod = 1.0f; armor_mod = 1.15f; crit_mod = 0.9f; haste_mod = 0.65f; dodge_mod = 0.8f;  parry_mod = 2.0f;  break;//NYI
+    //case CLASS_PALADIN:      ap_mod = 1.0f;  spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f;  parry_mod = 1.5f;  break;
+    //case CLASS_ROGUE:        ap_mod = 1.5f;  spp_mod = 0.0f; armor_mod = 0.7f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f;  parry_mod = 0.8f;  break;//NYI
+    //case CLASS_HUNTER:       ap_mod = 1.15f; spp_mod = 0.0f; armor_mod = 0.85f; crit_mod = 1.2f; haste_mod = 1.25f; dodge_mod = 1.2f;  parry_mod = 1.2f;  break;//NYI
+    //case CLASS_SHAMAN:       ap_mod = 0.9f;  spp_mod = 1.0f; armor_mod = 0.9f;  crit_mod = 1.2f; haste_mod = 1.65f; dodge_mod = 0.8f;  parry_mod = 0.5f;  break;//NYI
+    //case CLASS_DRUID:        ap_mod = 0.0f;  spp_mod = 1.3f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.95f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case CLASS_MAGE:         ap_mod = 0.0f;  spp_mod = 0.8f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case CLASS_PRIEST:       ap_mod = 0.0f;  spp_mod = 1.2f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case CLASS_WARLOCK:      ap_mod = 0.0f;  spp_mod = 1.0f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case BEAR:               ap_mod = 2.0f;  spp_mod = 1.3f; armor_mod = 2.25f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 2.5f;  parry_mod = 0.0f;  break;
+    //case CAT:                ap_mod = 1.5f;  spp_mod = 1.3f; armor_mod = 1.1f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.35f; parry_mod = 0.0f;  break;
+
+    if (spp_mod != 0.f && mylevel > 39)
+        spp_mod *= (float(mylevel - 39)) / 41.f;// gain spell power slowly
+
+    //DAMAGE
+    if (ap_mod > 0.f)//do not bother casters
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case CLASS_WARLOCK:
+                value = float(m_creatureOwner->GetBotAI()->GetSpellPower());
+                break;
+            case CLASS_DEATH_KNIGHT:
+                value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+                break;
+            case CLASS_HUNTER:
+                value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+                break;
+            default: //some weird class or NYI
+                value = 0.f;
+                break;
+        }
+        //Calculate ap
+        //set base strength
+        me->SetModifierValue(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, me->GetCreateStat(STAT_STRENGTH) - 9.f);
+        //calc attack power (strength and minion's spd)
+        atpower = me->GetTotalAuraModValue(UNIT_MOD_STAT_STRENGTH) * 2.f + value * ap_mod;
+        //set value
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage();
+    }
+
+    //ARMOR
+    value = float(basearmor);
+    //get minion's armor and give 35% to pet (just as for real pets)
+    value += m_creatureOwner->GetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE) * 0.35f;
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor();//buffs will be took in consideration here
+
+    //RESISTANCES
+    //based on minion's resistances gain x0.4
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = float(master->GetResistance(SpellSchools(i)));
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, 0.4f * (value * 2.5f + float(mylevel * 2)));
+        me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    //just get minion's reduction and apply to pet
+    value = m_creatureOwner->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL);
+    if (value > 1.f)
+        value -= 1.f;
+    else
+        value = 1.f - value; //get reduction even if owner's is 1.0+
+    value = std::min(0.42f, value);
+    value/= 0.01f; //here we get percent like 0.42/0.01 = 42% (value * 100.f)
+    RefreshAura(DMG_TAKEN, int8(value/6.f));//so max aura count = 10
+
+    //HEALTH
+    _OnHealthUpdate();
+
+//////RATINGS//////
+    //ok now, pet receives 100% of its master's ratings
+
+    //HASTE
+    haste = m_creatureOwner->GetBotAI()->GetHaste();
+    RefreshAura(HASTE,  haste);//spell haste
+    RefreshAura(HASTE2, haste);//melee haste
+
+    //HIT
+    hit = m_creatureOwner->GetBotAI()->GetHitRating();
+    RefreshAura(PRECISION,  int8(hit) + mylevel / 39);//melee
+    RefreshAura(PRECISION2, int8(hit) + mylevel / 39);//spell
+
+    //CRIT
+    //chose melee or ranged cuz crit rating increases melee/spell, and hunter benefits from agility
+    value = master->GetUnitCriticalChance((master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK), me);
+    if (crit_mod != 1.0f)
+        value *= crit_mod;
+    RefreshAura(CRITS, int8(value / 5.f) + mylevel / 39);
+
+    //PARRY
+    value = master->GetFloatValue(PLAYER_PARRY_PERCENTAGE);
+    if (IsTank())
+        value += 10.f;
+    if (value > 65.f)
+        value = 65.f;
+    float parryAndDodge = value; //set temp value, this is needed to keep total avoidance within 75%
+    RefreshAura(PARRY, int8(value / 5.f));
+
+    //DODGE
+    value = master->GetUnitDodgeChance();
+    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if possible
+    if (IsTank())
+        value += 10.f;
+    if (value > 65.f)
+        value = 65.f;
+    if (parryAndDodge + value > 65.f)
+        value = 65.f - parryAndDodge; //do not allow avoidance to be more than 75% (base 5+5)
+    RefreshAura(DODGE, int8(value / 5.f));
+
+    //MANA
+    _OnManaUpdate(false);
+
+    //MANA REGEN
+    if (mylevel >= 40 && me->getPowerType() == POWER_MANA)
+    {
+        //let regen rate be same as stats rate x0.3
+        regen_mp5 = m_creatureOwner->GetBotAI()->GetManaRegen() * 0.3f;
+        if (regen_mp5 >= 45.f)
+        {
+            me->RemoveAurasDueToSpell(MANAREGEN100);
+            me->RemoveAurasDueToSpell(MANAREGEN45);
+            if      (regen_mp5 > 200.f)   RefreshAura(MANAREGEN100,int8(regen_mp5 / 100.f) + mylevel / 20);
+            else/*if (regen_mp5 > 150.f)*/RefreshAura(MANAREGEN45, int8(regen_mp5 / 45.f)  + mylevel / 20);
+        }
+    }
+
+    //SPELL POWER
+    if (mylevel >= 40 && spp_mod != 0.f)
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case CLASS_WARLOCK:
+                value = float(m_creatureOwner->GetBotAI()->GetSpellPower());
+                break;
+            case CLASS_DEATH_KNIGHT:
+                value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+                break;
+            case CLASS_HUNTER:
+                value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+                break;
+            default: //some weird class or NYI
+                value = 0.f;
+                break;
+        }
+        m_spellpower = int32(value * spp_mod);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_250);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_150);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_50);
+        if      (mylevel < 60) RefreshAura(SPELL_BONUS_50,  m_spellpower / 50);
+        else if (mylevel < 80) RefreshAura(SPELL_BONUS_150, m_spellpower / 150 + 1);
+        else                   RefreshAura(SPELL_BONUS_250, m_spellpower / 250 + 2);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    shouldUpdateStats = false;
+}
+//Emotion-based action
+void bot_ai::ReceiveEmote(Player* player, uint32 emote)
+{
+    switch (emote)
+    {
+        case TEXT_EMOTE_BONK:
+            _listAuras(player, me);
+            break;
+        case TEXT_EMOTE_SALUTE:
+            _listAuras(player, player);
+            break;
+        case TEXT_EMOTE_STAND:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_STAY);
+            me->Whisper("Standing Still.", LANG_UNIVERSAL, player);
+            break;
+        case TEXT_EMOTE_WAVE:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_FOLLOW, true);
+            me->Whisper("Following!", LANG_UNIVERSAL, player);
+            break;
+        default:
+            break;
+    }
+}
+
+//ISINBOTPARTY
+//Returns group members (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_ai::IsInBotParty(Unit* unit) const
+{
+    if (!unit) return false;
+    if (unit == me || unit == master) return true;
+
+    //cheap check
+    if (Group* gr = master->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if (healTargetIconFlags & GroupIconsFlags[i])
+                if (ObjectGuid guid = gr->GetTargetIcons()[i])//check this one
+                    if (guid == unit->GetGUID())
+                        if (unit->GetReactionTo(master) >= REP_NEUTRAL &&
+                            master->GetVictim() != unit &&
+                            unit->GetVictim() != master)
+                            return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature* cre = unit->ToCreature())
+    {
+        //npcbot/npcbot's pet case
+        if (Player* owner = cre->GetBotOwner())
+        {
+            if (owner == master)
+                return true;
+        }
+        //pets, minions, guardians etc.
+        else
+        {
+            ObjectGuid ownerGuid = unit->GetOwnerGUID();
+            //controlled by group member
+            if (Group* gr = master->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+        }
+    }
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/reapplies aura stacks
+bool bot_ai::RefreshAura(uint32 spell, int8 count) const
+{
+    if (!spell)
+        return false;
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell);
+    if (!spellInfo)
+        return false;
+    //if (!spellInfo->IsPassive())
+    //{
+    //    TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): %s received spell %u (%s) which is not a passive spell!", target->GetName().c_str(), spell, spellInfo->SpellName[0]);
+    //    //return false;
+    //}
+    if (me->HasAura(spell))
+        me->RemoveAurasDueToSpell(spell);
+
+    //if (count > 15)
+    //    TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): %s's aura count for spell %u (%s) is greater than 15... (%i)", target->GetName().c_str(), spell, spellInfo->SpellName, count);
+
+    for (uint8 i = 0; i < count; ++i)
+        me->AddAura(spellInfo, MAX_EFFECT_MASK, me);
+    return true;
+}
+//CHECKAURAS
+//Updates bot's condition once a while
+void bot_minion_ai::CheckAuras(bool force)
+{
+    opponent = me->GetVictim(); //safe
+
+    if (!force)
+        _updateRations(); //safe
+
+    if (checkAurasTimer == 0)
+    {
+        checkAurasTimer = 10 + master->GetNpcBotsCount()/2;
+
+        if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY && opponent && !CCed(me, true))
+        {
+            if (IsMelee())
+            {
+                if (me->GetDistance(opponent) > 1.5f)
+                    GetInPosition(true);
+            }
+            else
+            {
+                CalculateAttackPos(opponent, attackpos);
+                if (me->GetDistance(attackpos) > 8)
+                    GetInPosition(true, opponent, &attackpos);
+            }
+        }
+        if (shouldUpdateStats)
+            SetStats(false);
+        else
+        {
+            UpdateHealth();
+            UpdateMana();
+        }
+        if (rezz_cd > 0)
+            --rezz_cd;
+        if (clear_cd > 0)
+            --clear_cd;
+        else
+            clear_cd = 15;
+        return;
+    }
+    else if (force)
+    {
+        if (!opponent)
+        {
+            if (master->isDead())
+            {
+                //If ghost move to corpse, else move to dead player
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                {
+                    Corpse* corpse = master->GetCorpse();
+                    if (corpse && me->GetMap() == corpse->FindMap() && !me->IsInCombat() && !me->HasUnitState(UNIT_STATE_MOVING) && !IsCasting() && !CCed(me) && me->GetDistance(corpse) > 5)
+                        me->GetMotionMaster()->MovePoint(corpse->GetMapId(), *corpse);
+                }
+                else
+                {
+                    if (m_botCommandState != COMMAND_FOLLOW || me->GetDistance(master) > 30 - 20 * (!me->IsWithinLOSInMap(master)))
+                        Follow(true);
+                }
+            }
+            else if (m_botCommandState != COMMAND_STAY && !IsCasting())
+            {
+                _calculatePos(pos);
+                uint8 followdist = master->GetBotFollowDist();
+                if (me->GetExactDist(&pos) > (followdist > 8 ? 4 + followdist/2*(!master->isMoving()) : 8))
+                    Follow(true, &pos); //check if doing nothing
+            }
+        }
+        if (!IsCasting())
+        {
+            if (me->IsInCombat())
+            {
+                if (me->GetBotClass() == CLASS_HUNTER)
+                {
+                    if (me->GetSheath() != SHEATH_STATE_RANGED)
+                        me->SetSheath(SHEATH_STATE_RANGED);
+                }
+                else if (me->GetSheath() != SHEATH_STATE_MELEE)
+                    me->SetSheath(SHEATH_STATE_MELEE);
+            }
+            else if (me->IsStandState() && me->GetSheath() != SHEATH_STATE_UNARMED && Rand() < 50)
+                me->SetSheath(SHEATH_STATE_UNARMED);
+        }
+        _updateMountedState();
+        _updateStandState();
+    }
+}
+void bot_pet_ai::CheckAuras(bool /*force*/)
+{
+    if (checkAurasTimer > 0) return;
+    checkAurasTimer = 10 + master->GetNpcBotsCount()/2;
+    if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY)
+    {
+        opponent = me->GetVictim();
+        if (opponent)
+        {
+            switch (GetPetType(me))
+            {
+                case PET_TYPE_IMP:
+                    CalculateAttackPos(opponent, attackpos);
+                    if (me->GetDistance(attackpos) > 8)
+                        GetInPosition(true, opponent, &attackpos);
+                    break;
+                default:
+                    if (me->GetDistance(opponent) > 1.5f)
+                        GetInPosition(true);
+                    break;
+            }
+        }
+    }
+    if (clear_cd > 0)
+        --clear_cd;
+    else
+        clear_cd = 15;
+
+    return;
+}
+
+bool bot_ai::CanBotAttack(Unit* target, int8 byspell) const
+{
+    if (!target)
+        return false;
+    if (!PvP && (target->ToPlayer() || (target->ToCreature() && target->ToCreature()->GetBotAI())))
+        return false;
+    uint8 followdist = master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    return
+       (target->IsAlive() &&
+       target->IsVisible() &&
+       (master->isDead() || target->GetTypeId() == TYPEID_PLAYER || target->IsPet() ||
+       (target->GetDistance(master) < foldist && me->GetDistance(master) < followdist)) &&//if master is killed pursue to the end
+        target->isTargetableForAttack() &&
+        !IsInBotParty(target) &&
+        (target->IsHostileTo(master) ||
+        (target->GetReactionTo(master) < REP_FRIENDLY && master->GetVictim() == target && (master->IsInCombat() || target->IsInCombat())) ||//master has pointed this target
+        target->IsHostileTo(me)) &&//if master is controlled
+        //target->IsWithinLOSInMap(me) &&
+        (byspell == -1 || !target->IsImmunedToDamage(byspell ? SPELL_SCHOOL_MASK_MAGIC : SPELL_SCHOOL_MASK_NORMAL)));
+}
+//GETTARGET
+//Returns attack target or 'no target'
+//uses follow distance if range isn't set
+Unit* bot_ai::_getTarget(bool byspell, bool ranged, bool &reset) const
+{
+    //check if no need to change target
+    Unit* u = master->GetVictim();
+    Unit* mytar = me->GetVictim();
+    if (!mytar && IsMinionAI())
+        if (Creature* pet = me->GetBotsPet())
+            mytar = pet->GetVictim();
+
+    //TC_LOG_ERROR("entities.player", "bot_ai::getTarget(): bot: %s, PvP = %u", me->GetName().c_str(), PvP);
+
+    if (u && u == mytar)
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack common target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;//forced
+    }
+    //Follow if...
+    uint8 followdist = master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    if (!u && master->IsAlive() && (me->GetDistance(master) > foldist || (mytar && master->GetDistance(mytar) > foldist && me->GetDistance(master) > foldist)))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s cannot attack target %s, too far away", me->GetName().c_str(), mytar ? mytar->GetName().c_str() : "");
+        return NULL;
+    }
+
+    if (u && (master->IsInCombat() || u->IsInCombat()) && !InDuel(u) && !IsInBotParty(u) && !(!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI()))))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s starts attack master's target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;
+    }
+
+    if (CanBotAttack(mytar, byspell) && !InDuel(mytar))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack its target %s", me->GetName().c_str(), mytar->GetName().c_str());
+        if (me->GetDistance(mytar) > (ranged ? 20.f : 5.f) && m_botCommandState != COMMAND_STAY && m_botCommandState != COMMAND_FOLLOW)
+            reset = true;
+        return mytar;
+    }
+
+    if (followdist == 0 && master->IsAlive())
+        return NULL; //do not bother
+
+    //check group
+    Group* gr = master->GetGroup();
+    if (!gr)
+    {
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = master->GetBotMap(i)->_Cre();
+            if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+            u = bot->GetVictim();
+            if (u && CanBotAttack(u, byspell) &&
+                (bot->IsInCombat() || u->IsInCombat()) &&
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+            Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+            if (!pet || !pet->InSamePhase(me)) continue;
+            u = pet->GetVictim();
+            if (u && CanBotAttack(u, byspell) &&
+                (pet->IsInCombat() || u->IsInCombat()) &&
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+        }
+    }
+    else
+    {
+        for (GroupReference* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+        {
+            Player* pl = ref->GetSource();
+            if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+            if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+            u = pl->GetVictim();
+            if (u && pl != master && CanBotAttack(u, byspell) &&
+                (pl->IsInCombat() || u->IsInCombat()) &&
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pl->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+            if (!pl->HaveBot()) continue;
+            for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+            {
+                Creature* bot = pl->GetBotMap(i)->_Cre();
+                if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                if (!bot->IsInWorld()) continue;
+                if (me->GetMap() != bot->FindMap()) continue;
+                u = bot->GetVictim();
+                if (u && CanBotAttack(u, byspell) &&
+                    (bot->IsInCombat() || u->IsInCombat()) &&
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+                Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+                if (!pet || !pet->InSamePhase(me)) continue;
+                if (!pet->IsInWorld()) continue;
+                if (me->GetMap() != pet->FindMap()) continue;
+                u = pet->GetVictim();
+                if (u && CanBotAttack(u, byspell) &&
+                    (pet->IsInCombat() || u->IsInCombat()) &&
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+            }
+        }
+    }
+
+    //check targets around
+    Unit* t = NULL;
+    float maxdist = InitAttackRange(float(followdist), ranged);
+    //first cycle we search non-cced target, then, if not found, check all
+    for (uint8 i = 0; i != 2; ++i)
+    {
+        if (!t)
+        {
+            bool attackCC = i;
+
+            CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+            Cell cell(p);
+            cell.SetNoCreate();
+
+            NearestHostileUnitCheck check(me, maxdist, byspell, this, attackCC);
+            Trinity::UnitLastSearcher <NearestHostileUnitCheck> searcher(master, t, check);
+            me->VisitNearbyObject(maxdist, searcher);
+        }
+    }
+
+    if (t && opponent && t != opponent)
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s has Found new target %s", me->GetName().c_str(), t->GetName().c_str());
+        reset = true;
+    }
+    return t;
+}
+//'CanAttack' function
+bool bot_ai::CheckAttackTarget(uint8 botOrPetType)
+{
+    bool byspell = false, ranged = !IsMelee(), reset = false;
+
+    if (IsMinionAI())
+    {
+        switch (botOrPetType)
+        {
+            case CLASS_DRUID:
+                byspell = me->GetShapeshiftForm() == FORM_NONE ||
+                    me->GetShapeshiftForm() == FORM_TREE ||
+                    me->GetShapeshiftForm() == FORM_MOONKIN;
+                ranged = byspell;
+                break;
+            case CLASS_PRIEST:
+            case CLASS_MAGE:
+            case CLASS_WARLOCK:
+            case CLASS_SHAMAN:
+                byspell = true;
+            default:
+                break;
+        }
+    }
+    else
+    {
+        switch (botOrPetType)
+        {
+            case PET_TYPE_IMP:
+                byspell = true;
+                ranged = true;
+                break;
+            default:
+                break;
+        }
+    }
+
+    opponent = _getTarget(byspell, ranged, reset);
+    if (!opponent)
+    {
+        me->AttackStop();
+        return false;
+    }
+
+    if (reset)
+        m_botCommandState = COMMAND_ABANDON;//reset AttackStart()
+
+    if (opponent != me->GetVictim())
+        me->Attack(opponent, !ranged);
+
+    return true;
+}
+//POSITION
+void bot_ai::CalculateAttackPos(Unit* target, Position& pos) const
+{
+    uint8 followdist = master->GetBotFollowDist();
+    float x(0),y(0),z(0),
+        dist = float(6 + urand(followdist/4, followdist/3)),
+        angle = target->GetAngle(me);
+    dist = std::min(dist, 20.f);
+    if (me->GetIAmABotsPet())
+        dist *= 0.5f;
+    float clockwise = RAND(1.f,-1.f);
+    for (uint8 i = 0; i != 5; ++i)
+    {
+        target->GetNearPoint(me, x, y, z, me->GetObjectSize()/2.f, dist, angle);
+        bool toofaraway = master->GetDistance(x,y,z) > (followdist > 28 ? 28.f : followdist < 20 ? 20.f : float(followdist));
+        bool outoflos = !target->IsWithinLOS(x,y,z);
+        if (toofaraway || outoflos)
+        {
+            if (toofaraway)
+                angle = target->GetAngle(master) + frand(0.f, M_PI*0.5f) * clockwise;
+            if (outoflos)
+                dist *= 0.5f;
+        }
+        else
+        {
+            dist *= 0.75f;
+            break;
+        }
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_ai::GetInPosition(bool force, Unit* newtarget, Position* mypos)
+{
+    if (me->HasUnitState(UNIT_STATE_ROOT)) return;
+    if (!newtarget)
+        newtarget = me->GetVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->IsInCombat() || m_botCommandState == COMMAND_STAY) && !force)
+        return;
+    if (IsCasting())
+        return;
+    uint8 followdist = master->GetBotFollowDist();
+    bool ranged = !IsMelee();
+    if (ranged)
+    {
+        if (newtarget->GetTypeId() == TYPEID_PLAYER &&
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3)) return;//do not allow constant runaway from player
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        if (me->GetDistance(attackpos) > (me->GetBotClass() == CLASS_HUNTER ? 4 : 8))
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+    }
+    else if (!me->HasUnitState(UNIT_STATE_CHASE) || !me->HasUnitState(UNIT_STATE_CHASE_MOVE))
+        me->GetMotionMaster()->MoveChase(newtarget);
+
+    if (newtarget != me->GetVictim())
+        me->Attack(newtarget, !ranged);
+}
+
+void bot_ai::CheckAttackState()
+{
+    if (me->GetVictim())
+    {
+        if (HasRole(BOT_ROLE_DPS))
+            DoMeleeAttackIfReady();
+    }
+    else
+        Evade();
+}
+
+bool bot_ai::MoveBehind(Unit &target) const
+{
+    if (me->HasUnitState(UNIT_STATE_ROOT)) return false;
+    if (target.IsWithinCombatRange(me, ATTACK_DISTANCE) &&
+        target.HasInArc(M_PI, me)                       &&
+        !IsTank()                                       &&
+        (me->GetBotClass() == CLASS_ROGUE ? target.GetVictim() != me || CCed(&target) : target.GetVictim() != me && !CCed(&target)))
+    {
+        float x(0),y(0),z(0);
+        target.GetNearPoint(me, x, y, z, me->GetObjectSize()/3, 0.1f, me->GetAngle(&target));
+        me->GetMotionMaster()->MovePoint(target.GetMapId(), x, y, z);
+        return true;
+    }
+    return false;
+}
+//MOUNT SUPPORT
+void bot_minion_ai::_updateMountedState()
+{
+    if (GetBotCommandState() != COMMAND_FOLLOW)
+        return;
+
+    bool aura = me->HasAuraType(SPELL_AURA_MOUNTED);
+    bool mounted = me->IsMounted();
+    if ((!master->IsMounted() || aura != mounted || (me->IsInCombat() && opponent)) && (aura || mounted))
+    {
+        const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType &= ~INHABIT_AIR;
+        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+        //me->RemoveUnitMovementFlag(MOVEMENTFLAG_HOVER);
+        me->SetCanFly(false);
+        me->SetDisableGravity(false);
+        me->RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING);
+        me->Dismount();
+        return;
+    }
+    if (me->IsInCombat() || IsCasting() || me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING)) //IsInWater() is too much calculations
+        return;
+    //fly
+    //if ((master->IsMounted() && master->HasAuraType(SPELL_AURA_FLY))/* || master->HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_FLYING)*/)
+    //{
+    //    if (!me->IsMounted() || !me->HasAuraType(SPELL_AURA_FLY))
+    //    {
+    //        //if (me->GetBotClass() == CLASS_DRUID && InitSpell(FLY_FORM))//TODO
+    //        //{
+    //        //}
+    //        //else
+    //        {
+    //            uint32 mount = 0;
+    //            Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+    //            if (!mounts.empty())
+    //                mount = mounts.front()->GetId();
+    //            if (mount)
+    //            {
+    //                if (me->HasAuraType(SPELL_AURA_MOUNTED))
+    //                        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+    //                if (doCast(me, mount))
+    //                {
+    //                    if (Feasting())
+    //                    {
+    //                        me->RemoveAurasDueToSpell(DRINK);
+    //                        me->RemoveAurasDueToSpell(EAT);
+    //                    }
+    //                }
+    //            }
+    //        }
+    //    }
+    //}
+    ////ground
+    /*else */
+    if (master->IsMounted() && !me->IsMounted() && !master->IsInCombat() && !me->IsInCombat() && !me->GetVictim())
+    {
+        uint32 mount = 0;
+        Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        if (!mounts.empty())
+        {
+            //Winter Veil addition
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                mount = master->CanFly() ? REINDEER_FLY : REINDEER;
+            else
+                mount = mounts.front()->GetId();
+        }
+        if (mount)
+        {
+            if (me->HasAuraType(SPELL_AURA_MOUNTED))
+                me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+            if (Feasting())
+            {
+                me->RemoveAurasDueToSpell(DRINK);
+                me->RemoveAurasDueToSpell(EAT);
+            }
+            if (doCast(me, mount))
+            {
+                return;
+            }
+        }
+    }
+}
+//STANDSTATE
+void bot_minion_ai::_updateStandState() const
+{
+    if (master->getStandState() == UNIT_STAND_STATE_STAND &&
+        me->getStandState() == UNIT_STAND_STATE_SIT &&
+        !(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    if ((master->getStandState() == UNIT_STAND_STATE_SIT || Feasting()) && !me->IsInCombat() && !me->isMoving() &&
+        me->getStandState() == UNIT_STAND_STATE_STAND)
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+
+}
+//RATIONS
+void bot_minion_ai::_updateRations()
+{
+    if (mana_cd > RATIONS_CD)
+        mana_cd = uint32(-1);
+    if (health_cd > RATIONS_CD)
+        health_cd = uint32(-1);
+
+    if (me->IsInCombat() || CCed(me))
+    {
+        if (health_cd <= RATIONS_CD && me->HasAura(EAT))
+        {
+            health_cd = uint32(-1);
+            me->RemoveAurasDueToSpell(EAT);
+        }
+        if (mana_cd <= RATIONS_CD && me->HasAura(DRINK))
+        {
+            mana_cd = uint32(-1);
+            me->RemoveAurasDueToSpell(DRINK);
+        }
+
+        return;
+    }
+
+    //drink
+    if (me->getPowerType() == POWER_MANA && !me->IsMounted() && !me->isMoving() &&
+        !me->IsInCombat() && !IsCasting() && urand(0, 100) < 20 && GetManaPCT(me) < 80 &&
+        !me->HasAura(DRINK))
+    {
+        mana_cd = RATIONS_CD;
+        me->CastSpell(me, DRINK);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (mana_cd == 0 && me->getPowerType() == POWER_MANA && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA))
+    {
+        mana_cd = RATIONS_CD;
+        me->ModifyPower(POWER_MANA, me->GetMaxPower(POWER_MANA) / (RATIONS_CD / 40)/*1000/40=25*/); //4% per second
+    }
+
+    //eat
+    if (!me->IsMounted() && !me->isMoving() && !me->IsInCombat() && !IsCasting() &&
+        urand(0, 100) < 20 && GetHealthPCT(me) < 80 &&
+        !me->HasAura(EAT))
+    {
+        health_cd = RATIONS_CD;
+        me->CastSpell(me, EAT);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (health_cd == 0 && me->GetHealth() < me->GetMaxHealth() && me->HasAura(EAT))
+    {
+        health_cd = RATIONS_CD;
+        me->SetHealth(me->GetHealth() + me->GetMaxHealth() / (RATIONS_CD / 50)/*1000/50=20*/); //5% per second
+    }
+
+    //check
+    if (health_cd <= RATIONS_CD && me->GetHealth() >= me->GetMaxHealth() && me->HasAura(EAT))
+    {
+        health_cd = uint32(-1);
+        me->RemoveAurasDueToSpell(EAT);
+    }
+
+    if (mana_cd <= RATIONS_CD && me->getPowerType() == POWER_MANA &&
+        me->GetPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA) &&
+        me->HasAura(DRINK))
+    {
+        mana_cd = uint32(-1);
+        me->RemoveAurasDueToSpell(DRINK);
+    }
+}
+//PASSIVES
+// Used to apply common passives (run once)
+void bot_ai::ApplyPassives(uint8 botOrPetType) const
+{
+    //me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+    //me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+    //movement speed
+    if (master->HasAuraType(SPELL_AURA_MOD_SPEED_ALWAYS) ||
+        master->HasAuraType(SPELL_AURA_MOD_SPEED_NOT_STACK) ||
+        master->HasAuraType(SPELL_AURA_MOD_INCREASE_SPEED))
+        RefreshAura(BOAR);
+
+    //apply +healing taken
+    if (master->getLevel() >= 40)
+        RefreshAura(BOR);//+40%
+
+    if (IsMinionAI())
+    {
+        //apply -threat mod
+        switch (botOrPetType)
+        {
+            case CLASS_WARRIOR:
+            case CLASS_DEATH_KNIGHT:
+                RefreshAura(RCP, 1 * !IsTank()); //-27%
+                break;
+            case CLASS_PRIEST:
+            case CLASS_MAGE:
+            case CLASS_ROGUE:
+            case CLASS_HUNTER:
+            case CLASS_SHAMAN:
+                RefreshAura(RCP, 3 * !IsTank()); //-87%
+                break;
+            default:
+                RefreshAura(RCP, 2 * !IsTank()); //-54%
+                break;
+        }
+        //apply +threat mod
+        RefreshAura(DEFENSIVE_STANCE_PASSIVE, 1 * IsTank()); //+43%
+    }
+    else
+    {
+        switch (botOrPetType)
+        {
+            case PET_TYPE_VOIDWALKER:
+                RefreshAura(DEFENSIVE_STANCE_PASSIVE, 2 * IsTank());
+                break;
+            default:
+                break;
+        }
+    }
+}
+//check if our party players are in duel. if so - ignore them, their opponents and any bots they have
+bool bot_ai::InDuel(Unit* target) const
+{
+    if (!target) return false;
+    bool isbot = target->GetTypeId() == TYPEID_UNIT && (target->ToCreature()->GetIAmABot() || target->ToCreature()->GetIAmABotsPet());
+    Player* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : isbot ? target->ToCreature()->GetBotOwner() : NULL;
+    if (!player)
+    {
+        if (!target->IsControlledByPlayer())
+            return false;
+        player = target->GetCharmerOrOwnerPlayerOrPlayerItself();
+    }
+
+    return (player && player->duel && (IsInBotParty(player) || IsInBotParty(player->duel->opponent)));
+}
+//Used to find target for priest's dispels and mage's spellsteal (also shaman's purge in future)
+//Returns dispellable/stealable 'Any Hostile Unit Attacking BotParty'
+Unit* bot_minion_ai::FindHostileDispelTarget(float dist, bool stealable) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    HostileDispelTargetCheck check(me, dist, stealable, this);
+    Trinity::UnitLastSearcher <HostileDispelTargetCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds single target affected by given spell (and given caster if is)
+//Can check:
+//    hostile targets  (hostile = 0) <default>
+//    our party players (hostile = 1)
+//    our party members  (hostile = 2)
+//    any friendly target (hostile = 3)
+//    any target in range  (hostile = any other value)
+Unit* bot_minion_ai::FindAffectedTarget(uint32 spellId, ObjectGuid caster, float dist, uint8 hostile) const
+{
+    if (!spellId)
+        return NULL;
+    if (master->GetMap()->Instanceable())
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+
+    CellCoord p(Trinity::ComputeCellCoord(master->GetPositionX(), master->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    AffectedTargetCheck check(caster, dist, spellId, master, hostile);
+    Trinity::UnitLastSearcher <AffectedTargetCheck> searcher(master, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, dist);
+    cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, dist);
+
+    return unit;
+}
+//Finds target for mage's polymorph or shaman's hex
+Unit* bot_minion_ai::FindPolyTarget(float dist, Unit* currTarget) const
+{
+    if (!currTarget)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    PolyUnitCheck check(me, dist, currTarget);
+    Trinity::UnitLastSearcher <PolyUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for direct fear (warlock)
+Unit* bot_minion_ai::FindFearTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    FearUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <FearUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for paladin's repentance
+Unit* bot_minion_ai::FindStunTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    StunUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <StunUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for priest's shackles
+Unit* bot_minion_ai::FindUndeadCCTarget(float dist, uint32 spellId/* = 0*/) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    UndeadCCUnitCheck check(me, dist, spellId);
+    Trinity::UnitLastSearcher <UndeadCCUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for druid's Entangling Roots
+Unit* bot_minion_ai::FindRootTarget(float dist, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    RootUnitCheck check(me, me->GetVictim(), dist, spellId);
+    Trinity::UnitLastSearcher <RootUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds casting target (friend or enemy)
+Unit* bot_minion_ai::FindCastingTarget(float maxdist, float mindist, bool isFriend, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    CastingUnitCheck check(me, mindist, maxdist, isFriend, spellId);
+    Trinity::UnitLastSearcher <CastingUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+
+    return unit;
+}
+// Returns target for AOE spell (blizzard, hurricane etc.) based on attackers count
+// Cycles through BotParty, first checks player and, if checked, npcbots
+// If checked, can return friendly target as target for AOE spell
+Unit* bot_minion_ai::FindAOETarget(float dist, bool checkbots, bool targetfriend) const
+{
+    if (IsCasting())
+        return NULL;
+
+    Unit* unit = NULL;
+    Group* pGroup = master->GetGroup();
+    if (!pGroup)
+    {
+        AttackerSet m_attackers = master->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || !(*iter)->IsAlive()) continue;
+                if ((*iter)->isMoving()) continue;
+                if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                    continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = master->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = master;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (!checkbots)
+            return unit;
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = master->GetBotMap(i)->_Cre();
+            if (!bot || !bot->IsAlive() || !bot->IsInWorld() || me->GetDistance(bot) > dist) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || !(*iter)->IsAlive()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                        continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+            if (unit) return unit;
+        }//end for
+        return unit;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (!tPlayer) continue;
+        if (checkbots && tPlayer->HaveBot())
+            Bots = true;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
+        if (me->GetDistance(tPlayer) > 40) continue;
+
+        AttackerSet m_attackers = tPlayer->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || !(*iter)->IsAlive()) continue;
+                if ((*iter)->isMoving()) continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = tPlayer->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = tPlayer;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (unit) return unit;
+    }//end for
+    if (!Bots) return NULL;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+            if (!bot || !bot->IsAlive() || me->GetMap() != bot->FindMap()) continue;
+            if (!bot->IsInWorld()) continue;
+            if (me->GetDistance(bot) > 40) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || !(*iter)->IsAlive()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+        }//end for
+        if (unit) return unit;
+    }//end for
+    return unit;
+}
+// Finds secondary target for spells like Cleave, Swipe, Mind Sear etc.
+Unit* bot_minion_ai::FindSplashTarget(float dist, Unit* To, float splashdist) const
+{
+    if (!To)
+        To = me->GetVictim();
+    if (!To)
+        return NULL;
+
+    if (me->GetDistance(To) > dist)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    SecondEnemyCheck check(me, dist, splashdist, To, this);
+    Trinity::UnitLastSearcher <SecondEnemyCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+
+Unit* bot_minion_ai::FindTranquilTarget(float mindist, float maxdist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    TranquilTargetCheck check(me, mindist, maxdist, this);
+    Trinity::UnitLastSearcher <TranquilTargetCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <TranquilTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <TranquilTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+
+    return unit;
+}
+
+void bot_minion_ai::GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, float mindist, bool forCC) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    NearbyHostileUnitCheck check(me, maxdist, mindist, this, forCC);
+    Trinity::UnitListSearcher <NearbyHostileUnitCheck> searcher(me, targets, check);
+
+    TypeContainerVisitor<Trinity::UnitListSearcher <NearbyHostileUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitListSearcher <NearbyHostileUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+}
+
+//////////
+//Internal
+//////////
+//Using rist-rank spell as source, returns spell of max rank allowed for given caster
+uint32 bot_ai::InitSpell(Unit const* caster, uint32 spell)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+    {
+        TC_LOG_FATAL("entities.player", "InitSpell(): No SpellInfo found for spell %u", spell);
+        return 0; //weird spell with no info, disable it
+    }
+
+    uint8 lvl = caster->getLevel();
+    if (lvl < info->BaseLevel) //only 1st rank spells check
+        return 0; //cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell; //cannot use next rank, use this one
+        else
+            return InitSpell(caster, spInfo->Id); //can use next rank, forward check
+    }
+
+    return spell; //max rank, use this
+}
+//Using rist-rank spell as source, returns spell of max rank allowed for given caster in given spellmap
+void bot_ai::InitSpellMap(uint32 basespell, bool forceadd)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(basespell);
+    if (!info)
+    {
+        TC_LOG_FATAL("entities.player", "InitSpellMap(): No SpellInfo found for base spell %u", basespell);
+        return; //invalid spell id
+    }
+
+    uint8 lvl = me->getLevel();
+    uint32 spellId = 0;
+
+    while (info != NULL && (forceadd || lvl >= info->BaseLevel))
+    {
+        spellId = info->Id; //can use this spell
+        info = info->GetNextRankSpell(); //check next rank
+    }
+
+    //if (spellId != 0)
+    //{
+        BotSpell newSpell;
+        newSpell.first = spellId;
+        newSpell.second = GetSpellCooldown(basespell);
+        spells[basespell] = newSpell;
+    //}
+}
+//Using rist-rank spell as source, return current spell id
+uint32 bot_ai::GetSpell(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+    return itr != spells.end() ? itr->second.first : 0;
+}
+//Using rist-rank spell as source, returns cooldown on current spell
+uint32 bot_ai::GetSpellCooldown(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+    return itr != spells.end() ? itr->second.second : 0;
+}
+bool bot_ai::IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD, uint32 forcedTime) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+
+    if (itr != spells.end())
+    {
+        return
+        ((*itr).second.first != 0 &&
+        (!checkGCD || GC_Timer <= diff) &&
+        (*itr).second.second <= (forcedTime ? forcedTime : diff));
+    }
+
+    return false;
+}
+//Using rist-rank spell as source, sets cooldown for current spell
+void bot_ai::SetSpellCooldown(uint32 basespell, uint32 msCooldown)
+{
+    BotSpellMap::iterator itr = spells.find(basespell);
+
+    if (itr != spells.end())
+        (*itr).second.second = msCooldown;
+}
+//Using rist-rank spell as source, disables certain spell for this bot
+void bot_ai::RemoveSpell(uint32 basespell)
+{
+    BotSpellMap::iterator itr = spells.find(basespell);
+
+    if (itr != spells.end())
+    {
+        //spells.erase(itr); //usafe possible
+        (*itr).second.first = 0;
+        //(*itr).second.second = 0; //unneeded
+    }
+}
+void bot_ai::SpellTimers(uint32 diff)
+{
+    // spell must be initialized!!!
+    for (BotSpellMap::iterator itr = spells.begin(); itr != spells.end(); ++itr)
+        if ((*itr).second.second > diff)
+            (*itr).second.second -= diff;
+}
+//Health magement for minions
+//Including health calcs, set and regeneration
+void bot_minion_ai::_OnHealthUpdate() const
+{
+    uint8 myclass = me->GetBotClass();
+    uint8 mylevel = master->getLevel();
+    if (myclass == CLASS_DRUID)
+        myclass = GetBotStance();
+    //TC_LOG_ERROR("entities.player", "_OnHealthUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = me->GetHealthPct();// needs for regeneration
+    uint32 m_basehp = _classinfo->basehealth;
+    //TC_LOG_ERROR("entities.player", "class base health: %u", m_basehp);
+    me->SetCreateHealth(m_basehp);
+    float stammod;
+    switch (myclass)
+    {
+        case CLASS_WARRIOR: case CLASS_DEATH_KNIGHT: case DRUID_BEAR_FORM:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 16.f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 13.f;
+                    break;
+                default: stammod = 9.8f; break;
+            }
+            break;
+        case CLASS_PALADIN:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 15.5f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 12.5f;
+                    break;
+                case CLASS_PALADIN:
+                    stammod = 9.8f;
+                    break;
+                default: stammod = 9.f; break;
+            }
+            break;
+        case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 9.8f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 8.f;
+                    break;
+                default: stammod = 5.f; break;
+            }
+            break;
+        case CLASS_DRUID: case DRUID_CAT_FORM: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 12.f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 9.8f;
+                    break;
+                default: stammod = 8.f; break;
+            }
+            break;
+        default:
+            TC_LOG_FATAL("entities.player", "bmai::_OnHealthUpdate(): unknown 'myclass' value (%u)", myclass);
+            stammod = 10.f;
+            break;
+    }
+    stammod -= 0.3f;
+    stammod *= 0.75f;
+    //TC_LOG_ERROR("entities.player", "stammod: %f", stammod);
+
+    //manually pick up stamina from bot's buffs
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA);
+    stamValue = std::max(stamValue - 18.f, 1.f); //remove base stamina (not calculated into health)
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        stamValue += 1.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_STAMINA]);
+
+    //TC_LOG_ERROR("entities.player", "bot's stats to health add: Stamina (%f), value: %f", stamValue, stamValue * 10.f);
+    int32 hp_add = int32(stamValue * 10.f);
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        hp_add += 3.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_HEALTH]);
+
+    //pick up master's stamina from items
+    float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT) - 0.1f), 1.f);
+    float base_stam = master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE);
+    base_stam = std::max(base_stam - 18.f, 0.f); //remove base stamina (not calculated into health)
+    stamValue = base_stam * master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT) * total_pct;
+    //TC_LOG_ERROR("entities.player", "stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
+    hp_add += int32(stamValue * stammod);
+    //float stamstat = stat * 0.5f;
+    //if (stamValue > stamstat)
+    //{
+    //    //sLog->outBasic("selected stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
+    //    hp_add += int32(stamValue * stammod);
+    //}
+    //else
+    //{
+    //    //sLog->outBasic("selected stat to health add: stamStat (%f), value: %f", stamstat, stamstat*stammod);
+    //    hp_add += int32(stamstat * stammod);
+    //}
+    //sLog->outBasic("health to add after master's stat mod: %i", hp_add);
+    int32 miscVal = me->getGender() * mylevel;
+    //TC_LOG_ERROR("entities.player", "health to remove from gender mod: %i", -miscVal);
+    hp_add -= miscVal;//less hp for females lol
+    //TC_LOG_ERROR("entities.player", "health to add after gender mod: %i", hp_add);
+    //miscVal = myrace*(mylevel/5);
+    //TC_LOG_ERROR("entities.player", "health to add from race mod: %i", miscVal);
+    //hp_add += miscVal;//draenei tanks lol
+    //TC_LOG_ERROR("entities.player", "health to add after race mod: %i", hp_add);
+    miscVal = master->GetNpcBotSlot(me->GetGUID()) * (mylevel / 5);
+    //TC_LOG_ERROR("entities.player", "health to remove from slot mod: %i", -miscVal);
+    hp_add -= miscVal;
+    //TC_LOG_ERROR("entities.player", "health to add after slot mod: %i", hp_add);
+    uint32 m_totalhp = m_basehp + hp_add; //m_totalhp = uint32(float(m_basehp + hp_add) * stammod);
+    //TC_LOG_ERROR("entities.player", "total base health: %u", m_totalhp);
+    uint32 bonuspct = 0;
+    bonuspct += 35 * IsTank();
+    bonuspct += 8 * (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE);
+    if (bonuspct)
+        m_totalhp = (m_totalhp * (100 + bonuspct)) / 100;
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp)); //replaces base hp at max lvl
+    me->UpdateMaxHealth();//will use our values we just set (update base health and buffs)
+    //TC_LOG_ERROR("entities.player", "overall hp: %u", me->GetMaxHealth());
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+    if (!me->IsInCombat())
+        me->SetHealth(me->GetHealth() + m_basehp / 100 + me->getLevel() / 2); //regenerate
+}
+//Mana management for minions
+//Including calcs and set
+void bot_minion_ai::_OnManaUpdate(bool shapeshift)
+{
+    if (me->getPowerType() != POWER_MANA)
+        return;
+    uint8 myclass = me->GetBotClass();
+    uint8 mylevel = master->getLevel();
+    //TC_LOG_ERROR("entities.player", "_OnManaUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = _classinfo->basemana > 0 ? _classinfo->basemana : me->GetCreateMana();
+    //TC_LOG_ERROR("entities.player", "classinfo base mana = %f", m_basemana);
+    me->SetCreateMana(m_basemana); //set base mana, critical
+    float manamod = 15.f; //here we set mana multiplier from intellect as we gain mana from MASTER's stats mostly
+    switch (myclass)
+    {
+        case CLASS_HUNTER:                     manamod =  8.5f; break;
+        case CLASS_PALADIN:                    manamod =  4.5f; break;
+        case CLASS_SHAMAN:                     manamod = 13.5f; break;
+        case CLASS_DRUID:                      manamod = 12.5f; break;
+        case CLASS_PRIEST:                     manamod = 16.5f; break;
+        case CLASS_MAGE: case CLASS_WARLOCK:   manamod = 10.5f; break;
+        default:                                                break;
+    }
+
+    manamod *= 0.75f; //custom
+
+    //TC_LOG_ERROR("entities.player", "Manamod: %f", manamod);
+    float intValue = me->GetTotalStatValue(STAT_INTELLECT);
+    intValue = std::max(intValue - 18.f, 1.f); //remove base int (not calculated into mana)
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        intValue += 1.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_INTELLECT]);
+        m_basemana += 3.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_MANA]);
+    }
+
+    //TC_LOG_ERROR("entities.player", "bot's stats to mana add: Int (%f), value: %f", intValue, intValue * manamod);
+    m_basemana += intValue * 15.f;
+    //pick up master's intellect from items if master has mana
+    if (master->getPowerType() == POWER_MANA)
+    {
+        float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT) - 0.1f), 1.f);
+        intValue = std::max(master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE) - 18.f, 1.f); //remove base int (not calculated into mana)
+        intValue = intValue * master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT) * total_pct;
+    }
+    else // pick up maxstat
+        intValue = stat * 0.5f;
+    //TC_LOG_ERROR("entities.player", "mana add from master's stat: %f", intValue * manamod);
+    m_basemana += intValue * manamod;
+    //TC_LOG_ERROR("entities.player", "base mana + mana from master's intellect or stat: %f", m_basemana);
+    //intValue = me->GetTotalAuraModValue(UNIT_MOD_STAT_INTELLECT);
+    //sLog->outBasic("Intellect from buffs: %f", intValue);
+    //m_basemana += uint32(intValue) * manamod;
+    //sLog->outBasic("base mana + mana from intellect + mana from buffs: %u", m_basemana);
+    uint8 otherVal = me->getGender() * 3 * mylevel;
+    //TC_LOG_ERROR("entities.player", "mana to add from gender mod: %u", otherVal);
+    m_basemana += float(otherVal); //more mana for females lol
+    //TC_LOG_ERROR("entities.player", "base mana after gender mod: %f", m_basemana);
+    otherVal = master->GetNpcBotSlot(me->GetGUID()) * (mylevel / 5); //only to make mana unique
+    //TC_LOG_ERROR("entities.player", "mana to remove from slot mod: %i", -int8(otherVal));
+    m_basemana -= otherVal;
+    //TC_LOG_ERROR("entities.player", "base mana after slot mod: %f", m_basemana);
+    float m_totalmana = m_basemana;
+    //TC_LOG_ERROR("entities.player", "total mana to set: %f", m_totalmana);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_totalmana);
+    me->UpdateMaxPower(POWER_MANA);
+    //TC_LOG_ERROR("entities.player", "Overall mana to set: %u", me->GetMaxPower(POWER_MANA));
+    if (tempMana)
+    {
+        me->SetPower(POWER_MANA, tempMana);
+        if (shapeshift == false)
+            tempMana = 0;
+    }
+    else
+        me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f)); //restore pct
+    //No Regen
+}
+//Melee damage for minions (melee classes only)
+//Calculation is based on master's attack power if melee/hunter or spellpower
+void bot_minion_ai::_OnMeleeDamageUpdate(uint8 myclass) const
+{
+    if (ap_mod < 0.1f) return; //do not bother casters
+    //sLog->outBasic("_OnMeleeDamageUpdate: Updating bot %s", me->GetName().c_str());
+    float my_ap_mod = ap_mod;
+    float mod = master->getClass() == CLASS_HUNTER ? (master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT))/2.f :
+        (master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT))/2.f;
+    mod = std::max(mod, 1.f); // x1 is Minimum
+    mod = std::min(mod, 2.5f); // x2.5 is Maximum
+    //sLog->outBasic("got base damage modifier: %f", mod);
+    mod -= (mod - 1.f)*0.33f;//reduce bonus by 33%
+    //sLog->outBasic("damage modifier truencated to %f, applying", mod);
+
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+        me->SetModifierValue(UnitMods(UNIT_MOD_DAMAGE_MAINHAND + i), BASE_VALUE, static_cast<BotStat>(_stats[i])[BOT_ITEM_MOD_DAMAGE]);
+
+    me->SetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT, mod);
+    me->SetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT, mod);
+    me->SetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT, mod);
+    //me->SetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT, mod);//NUY
+    mod = (mod - 1.f)*0.5f;
+    //sLog->outBasic("reduced damage modifier to gain bonus: %f", mod);
+    //sLog->outBasic("base ap modifier is %f", my_ap_mod);
+    my_ap_mod *= 0.5f;
+    //sLog->outBasic("ap modifier multiplied to %f", my_ap_mod);
+    my_ap_mod += my_ap_mod > 0.f ? mod : 0.f; //add reduced master's multiplier if can have damage
+    //sLog->outBasic("ap modifier + mod = %f", my_ap_mod);
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_PCT, my_ap_mod);
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_PCT, my_ap_mod);
+
+    int32 sppower = 0;
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
+        if (power > sppower)
+            sppower = power;
+    }
+    //sLog->outBasic("master's spellpower is %i, multiplying...", sppower);
+    sppower *= 1.5f;
+    //sLog->outBasic("got spellpower of %i", sppower);
+    //atpower = float(master->GetInt32Value(master->getClass() == CLASS_HUNTER ? UNIT_FIELD_RANGED_ATTACK_POWER : UNIT_FIELD_ATTACK_POWER));
+    float atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
+    //sLog->outBasic("master's base attack power is %f", atpower);
+    atpower = sppower > atpower ? sppower : atpower; //highest stat is used (either 1.5x spellpower or attack power)
+    //sLog->outBasic("chosen attack power stat value: %f", atpower);
+    //sLog->outBasic("expected attack power: %f", atpower*ap_mod);
+    atpower *= 0.333f; //reduce damage since we can have weapons
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        atpower += static_cast<BotStat>(_stats[i])[ITEM_MOD_ATTACK_POWER] + static_cast<BotStat>(_stats[i])[ITEM_MOD_RANGED_ATTACK_POWER] +
+            static_cast<BotStat>(_stats[i])[ITEM_MOD_STRENGTH] * 2 + static_cast<BotStat>(_stats[i])[ITEM_MOD_AGILITY] * 2;
+    }
+
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+    if (myclass == CLASS_HUNTER || myclass == CLASS_ROGUE)
+    {
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage(true);
+    }
+    me->UpdateAttackPowerAndDamage();
+    //sLog->outBasic("listing stats: ");
+    //sLog->outBasic("attack power main hand: %f", me->GetTotalAttackPowerValue(BASE_ATTACK));
+    //sLog->outBasic("attack power off hand: %f", me->GetTotalAttackPowerValue(OFF_ATTACK));
+    //sLog->outBasic("attack power ranged: %f", me->GetTotalAttackPowerValue(RANGED_ATTACK));
+    //sLog->outBasic("damage multiplier main hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    //sLog->outBasic("damage multiplier off hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+    //sLog->outBasic("damage multiplier ranged: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+    //sLog->outBasic("Damage range main hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    //sLog->outBasic("Damage range off hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+    //sLog->outBasic("Damage range ranged: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+}
+//Health for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnHealthUpdate() const
+{
+    uint8 mylevel = master->getLevel();
+    float hp_mult = 10.f;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:
+            hp_mult = 11.f;
+            break;
+        default:
+            break;
+    }
+    float pct = me->GetHealthPct();// needs for regeneration
+    //Use simple checks and calcs
+    //0.3 hp for bots (inaccurate but cheap)
+    uint32 m_basehp = me->GetCreateHealth() / 2;
+    //pick up stamina from buffs
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA);
+    stamValue = std::max(stamValue - 18.f, 1.f); //remove base stamina (not calculated into health)
+    uint32 hp_add = uint32(stamValue * hp_mult);
+    hp_add += (m_creatureOwner->GetMaxHealth() - m_creatureOwner->GetCreateHealth()) * 0.3f;
+    uint8 miscVal = GetPetType(me)*mylevel;
+    hp_add -= miscVal;
+    uint32 m_totalhp = m_basehp + hp_add;
+    if (IsTank())
+        m_totalhp = (m_totalhp * 135) / 100; //35% hp bonus for tanks
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp));
+    me->UpdateMaxHealth(); //will use values set (update base health and buffs)
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+    if (!me->IsInCombat())
+        me->SetHealth(me->GetHealth() + m_basehp / 100 + me->getLevel() / 2); //regenerate
+}
+//Mana for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnManaUpdate(bool /*shapeshift*/)
+{
+    if (me->getPowerType() != POWER_MANA)
+        return;
+
+    uint8 mylevel = master->getLevel();
+
+    float mana_mult = 15.f;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:
+            mana_mult = 11.5f;
+            break;
+        default:
+            break;
+    }
+    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    //Use simple checks and calcs
+    //0.3 mana for bots (inaccurate but cheap)
+    float m_basemana = float(me->GetCreateMana());
+    m_basemana += (std::max<float>(me->GetTotalStatValue(STAT_INTELLECT) - 18.f, 1.f))*mana_mult; //remove base stamina (not calculated into mana)
+    m_basemana += float(m_creatureOwner->GetMaxPower(POWER_MANA) - m_creatureOwner->GetCreateMana())*0.3f;
+    m_basemana -= float(GetPetType(me)*mylevel);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA))*pct / 100.f));//restore pct
+}
+//Sends all master's bots a message to not try to evade for a certain period of time
+void bot_ai::SendPartyEvadeAbort() const
+{
+    for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        if (Creature* bot = master->GetBotMap(i)->_Cre())
+            if (bot_minion_ai* ai = bot->GetBotMinionAI())
+                ai->SetEvadeTimer(50);
+}
+//Removes buggy bots' threat from party, so no 'stuck in combat' bugs form bot mod
+//optionally interrupts casted spell if target is dead for bot and it's pet
+void bot_minion_ai::_evade()
+{
+    if (me->HasUnitState(UNIT_STATE_CASTING))
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = me->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (!u->IsAlive() && !IsInBotParty(u))
+                            me->InterruptSpell(CurrentSpellTypes(i), false, false);
+
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet && m_botsPet->HasUnitState(UNIT_STATE_CASTING))
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = m_botsPet->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (!u->IsAlive() && !IsInBotParty(u))
+                            m_botsPet->InterruptSpell(CurrentSpellTypes(i), false, false);
+
+    if (Rand() > 10) return;
+    if (!master->IsInCombat() && !me->IsInCombat() && (!m_botsPet || !m_botsPet->IsInCombat())) return;
+    if (CheckAttackTarget(me->GetBotClass()))
+        return;
+    //ChatHandler ch(master);
+    //ch.PSendSysMessage("_evade() by bot %s", me->GetName().c_str());
+    if (master->IsInCombat())
+    {
+        HostileRefManager& mgr = master->getHostileRefManager();
+        if (!mgr.isEmpty())
+        {
+            std::set<Unit*> Set;
+            HostileReference* ref = mgr.getFirst();
+            while (ref)
+            {
+                if (ref->GetSource() && ref->GetSource()->GetOwner())
+                    Set.insert(ref->GetSource()->GetOwner());
+                ref = ref->next();
+            }
+            for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+            {
+                Unit* unit = (*i);
+                if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                {
+                    //ch.PSendSysMessage("_evade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), master->GetName().c_str());
+                    mgr.deleteReference(unit);
+                }
+            }
+        }
+    }
+    else
+    {
+        SendPartyEvadeAbort();
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* cre = master->GetBotMap(i)->_Cre();
+            if (!cre) continue;
+            if (cre->IsInCombat())
+            {
+                cre->DeleteThreatList();
+                HostileRefManager& mgr = cre->getHostileRefManager();
+                if (!mgr.isEmpty())
+                {
+                    std::set<Unit*> Set;
+                    HostileReference* ref = mgr.getFirst();
+                    while (ref)
+                    {
+                        if (ref->GetSource() && ref->GetSource()->GetOwner())
+                            Set.insert(ref->GetSource()->GetOwner());
+                        ref = ref->next();
+                    }
+                    for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                    {
+                        Unit* unit = (*i);
+                        if (!unit->InSamePhase(me)) continue;
+                        if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                        {
+                            //ch.PSendSysMessage("_evade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), cre->GetName().c_str());
+                            mgr.deleteReference(unit);
+                        }
+                    }
+                }
+                //if (mgr.isEmpty())// has empty threat list and no hostile refs - we have all rights to stop combat
+                //{
+                //    if (cre->IsInCombat())
+                //    {
+                //        //ch.PSendSysMessage("_evade(): %s's HostileRef is empty! Combatstop!", cre->GetName().c_str());
+                //        cre->ClearInCombat();
+                //    }
+                //}
+            }
+
+            Creature* m_botsPet = cre->GetBotsPet();
+            if (!m_botsPet || !m_botsPet->IsInCombat()) continue;
+            m_botsPet->DeleteThreatList();
+            HostileRefManager& mgr = m_botsPet->getHostileRefManager();
+            if (!mgr.isEmpty())
+            {
+                std::set<Unit*> Set;
+                HostileReference* ref = mgr.getFirst();
+                while (ref)
+                {
+                    if (ref->GetSource() && ref->GetSource()->GetOwner())
+                        Set.insert(ref->GetSource()->GetOwner());
+                    ref = ref->next();
+                }
+                for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                {
+                    Unit* unit = (*i);
+                    if (!unit->InSamePhase(me)) continue;
+                    if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                    {
+                        //ch.PSendSysMessage("_evade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), m_botsPet->GetName().c_str());
+                        mgr.deleteReference(unit);
+                    }
+                }
+            }
+            //if (mgr.isEmpty())// has empty threat list and no hostile refs - we have all rights to stop combat
+            //{
+            //    if (m_botsPet->IsInCombat())
+            //    {
+            //        //ch.PSendSysMessage("_evade(): %s's HostileRef is empty! Combatstop!", pet->GetName().c_str());
+            //        m_botsPet->ClearInCombat();
+            //    }
+            //}
+        }
+    }
+}
+//SpellHit()... OnSpellHit()
+void bot_ai::OnSpellHit(Unit* /*caster*/, SpellInfo const* spell)
+{
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        uint32 auraname = spell->Effects[i].ApplyAuraName;
+        //remove pet on mount
+        if (auraname == SPELL_AURA_MOUNTED)
+        {
+            me->SetBotsPetDied();
+            if (master->HasAuraType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED) ||
+                master->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+            {
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType |= INHABIT_AIR;
+                //me->AddUnitMovementFlag(MOVEMENTFLAG_HOVER);
+                me->SetCanFly(true);
+                me->SetDisableGravity(true);
+                me->SetSpeed(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+                me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+            }
+            else
+                me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_RUN) * 1.25f);
+        }
+
+        //update stats
+        if (auraname == SPELL_AURA_MOD_STAT)
+        {
+            shouldUpdateStats = true;
+        }
+        else
+        {
+            if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH ||
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 ||
+                auraname == SPELL_AURA_230 ||//SPELL_AURA_MOD_INCREASE_HEALTH_2
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
+                doHealth = true;
+            else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY ||
+                auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
+                doMana = true;
+        }
+    }
+}
+//Messed up
+//Hp + Mana update
+//target update
+//returns fake wait time between overall AI updates (if it is even understandable)
+uint8 bot_ai::GetWait()
+{
+    if (doHealth)
+    {
+        doHealth = false;
+        _OnHealthUpdate();
+    }
+    if (doMana)
+    {
+        doMana = false;
+        _OnManaUpdate();
+    }
+    CheckAuras(true);
+    //0 to 2 plus 1 for every 3 bots except first one
+    return (1 + (master->GetNpcBotsCount() - 1)/3 + (irand(0,100) <= 50)*int8(RAND(-1,1)));
+}
+//Damage Mods
+//1) Apply class-specified damage/crit chance/crit damage bonuses
+//2) Apply bot damage multiplier
+//3) Remove Creature damage multiplier (make independent from original config)
+//Bug with config reload (creatures do not update their damage on reload) is not bot-related but still annoying
+void bot_ai::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& /*damageinfo*/) const
+{
+    //ApplyClassDamageMultiplierMelee(damage, damageinfo);
+    damage = int32(float(damage)*dmgmult_melee/dmgmod_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    ApplyClassDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(float(damage)*dmgmult_melee/dmgmod_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(float(damage)*dmgmult_spell/dmgmod_spell);
+}
+void bot_ai::ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const
+{
+    //Only for damage effects which can scale (TC check)
+    bool canEffectScale = false;
+    switch (spellInfo->Effects[effect_index].Effect)
+    {
+        case SPELL_EFFECT_SCHOOL_DAMAGE:
+        //case SPELL_EFFECT_DUMMY:
+        //case SPELL_EFFECT_POWER_DRAIN:
+        //case SPELL_EFFECT_HEALTH_LEECH:
+        case SPELL_EFFECT_HEAL:
+        case SPELL_EFFECT_WEAPON_DAMAGE:
+        //case SPELL_EFFECT_POWER_BURN:
+        //case SPELL_EFFECT_SCRIPT_EFFECT:
+        case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+        //case SPELL_EFFECT_FORCE_CAST_WITH_VALUE:
+        //case SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE:
+        //case SPELL_EFFECT_TRIGGER_MISSILE_SPELL_WITH_VALUE:
+            canEffectScale = true;
+            break;
+        default:
+            break;
+    }
+    switch (spellInfo->Effects[effect_index].ApplyAuraName)
+    {
+        case SPELL_AURA_PERIODIC_DAMAGE:
+        //case SPELL_AURA_DUMMY:
+        //case SPELL_AURA_PERIODIC_HEAL:
+        //case SPELL_AURA_DAMAGE_SHIELD:
+        case SPELL_AURA_PROC_TRIGGER_DAMAGE:
+        //case SPELL_AURA_PERIODIC_LEECH:
+        //case SPELL_AURA_PERIODIC_MANA_LEECH:
+        //case SPELL_AURA_SCHOOL_ABSORB:
+        //case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
+            canEffectScale = true;
+            break;
+        default:
+            break;
+    }
+
+    if (!canEffectScale)
+        return;
+
+    ApplyClassDamageMultiplierEffect(spellInfo, effect_index, value);
+
+    if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED)
+        value = value*dmgmult_melee/dmgmod_melee;
+    else if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC)
+        value = value*dmgmult_spell/dmgmod_spell;
+}
+//////////
+//GOSSIP//
+//////////
+//GossipHello
+bool bot_minion_ai::OnGossipHello(Player* player, Creature* creature)
+{
+    if (creature->IsInCombat() || creature->GetBotMinionAI()->IAmDead())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    if (player == creature->GetBotOwner())
+    {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage equipment...", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage roles...", GOSSIP_SENDER_ROLES, GOSSIP_ACTION_INFO_DEF + 1);
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Use ability...", GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 1);
+    }
+
+    switch (creature->GetBotClass())
+    {
+        case CLASS_MAGE:
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need food", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need drink", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        default:
+            break;
+    }
+
+    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Nevermind", 0, GOSSIP_ACTION_INFO_DEF + 1);
+    player->PlayerTalkClass->SendGossipMenu(GOSSIP_SERVE_MASTER, creature->GetGUID());
+    return true;
+}
+
+//GossipSelect
+bool bot_minion_ai::OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+{
+    if (!IsInBotParty(player))
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    player->PlayerTalkClass->ClearMenus();
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case 0: //any kind of fail
+        {
+            me->Say("...", LANG_UNIVERSAL, player);
+            break;
+        }
+        case 1: //return to main menu
+        {
+            return bot_minion_ai::OnGossipHello(player, creature);
+        }
+        case GOSSIP_SENDER_CLASS: //food/drink (classes: MAGE)
+        {
+            //Prevent high-leveled consumables for low-level characters
+            Unit* checker;
+            if (player->getLevel() < me->getLevel())
+                checker = player;
+            else
+                checker = me;
+
+            // Conjure Refreshment rank 1
+            uint32 food = InitSpell(checker, 42955);
+            bool iswater = (action == GOSSIP_ACTION_INFO_DEF + 2);
+            if (!food)
+            {
+                if (!iswater)// Conjure Food rank 1
+                    food = InitSpell(checker, 587);
+                else// Conjure Water rank 1
+                    food = InitSpell(checker, 5504);
+            }
+            if (!food)
+            {
+                std::string errorstr = "I can't conjure ";
+                errorstr += iswater ? "water" : "food";
+                errorstr += " yet";
+                me->Whisper(errorstr.c_str(), LANG_UNIVERSAL, player);
+                //player->PlayerTalkClass->ClearMenus();
+                //return OnGossipHello(player, me);
+                break;
+            }
+            SpellInfo const* Info = sSpellMgr->GetSpellInfo(food);
+            Spell* foodspell = new Spell(me, Info, TRIGGERED_NONE, player->GetGUID());
+            SpellCastTargets targets;
+            targets.SetUnitTarget(player);
+            //TODO implement checkcast for bots
+            SpellCastResult result = me->IsMounted() || CCed(me) ? SPELL_FAILED_CUSTOM_ERROR : foodspell->CheckPetCast(player);
+            if (result != SPELL_CAST_OK)
+            {
+                foodspell->finish(false);
+                delete foodspell;
+                me->Whisper("I can't do it right now", LANG_UNIVERSAL, player);
+            }
+            else
+            {
+                aftercastTargetGuid = player->GetGUID();
+                foodspell->prepare(&targets);
+                me->Whisper("Here you go...", LANG_UNIVERSAL, player);
+            }
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT: //equips change s1: send what slots we can use
+        {
+            subMenu = true;
+
+            //general
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Show me your inventory", GOSSIP_SENDER_EQUIPMENT_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+            //player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Create itemset", GOSSIP_SENDER_EQUIPMENT_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //weapons
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Main hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_MAINHAND);
+            if (CanUseOffHand())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Off-hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_OFFHAND);
+            if (CanUseRanged())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Ranged...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_RANGED);
+
+            //armor
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Head...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HEAD);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Shoulders...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_SHOULDERS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Chest...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_CHEST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Waist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WAIST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Legs...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_LEGS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Feet...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FEET);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Wrist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WRIST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Hands...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HANDS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BACK);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Shirt...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BODY);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Finger1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Finger2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Trinket1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Trinket2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Neck...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_NECK);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_LIST: //list inventory
+        {
+            //if (action - GOSSIP_ACTION_INFO_DEF != BOT_SLOT_NONE)
+            //    break;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (uint32 itemId = master->GetBotEquip(me, i))
+                {
+                    std::ostringstream msg;
+                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+                        _AddItemTemplateLink(master, proto, msg);
+                    else
+                        msg << "Unknown item";
+                    msg << " in slot " << uint32(i) << " (" << _getNameForSlot(i + 1) << ')';
+                    if (i < BOT_SLOT_RANGED && einfo && einfo->ItemEntry[i] == itemId)
+                        msg << " |cffe6cc80|h[!standard item!]|h|r";
+                    me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master);
+                }
+            }
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_INFO: //request equip item info
+        {
+            //GOSSIP ITEMS RESTRICTED
+            //subMenu = true; //needed for return
+
+            uint8 slot = action - (GOSSIP_ACTION_INFO_DEF + 1);
+            if (uint32 itemId = master->GetBotEquip(me, slot))
+            {
+                std::ostringstream msg;
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+                    _AddItemTemplateLink(master, proto, msg);
+                else
+                    msg << "Unknown";
+
+                int8 id = 1;
+                EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+                if (slot < BOT_SLOT_RANGED && einfo && einfo->ItemEntry[slot] == itemId)
+                    msg << " |cffe6cc80|h[!standard item!]|h|r";
+
+                me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master);
+            }
+
+            //break; //no break here - return to menu
+        }
+        case GOSSIP_SENDER_EQUIPMENT_SHOW: //equips change s2: send list of equippable items
+        {
+            subMenu = true;
+
+            std::set<uint32> itemList;
+
+            //s2.1: build list
+            //s2.1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                    if (CanEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF) && itemList.find(pItem->GetEntry()) == itemList.end())
+                        itemList.insert(pItem->GetEntry());
+
+            //s2.1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                if (Bag* pBag = player->GetBagByPos(i))
+                    for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                        if (Item* pItem = player->GetItemByPos(i, j))
+                            if (CanEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF) && itemList.find(pItem->GetEntry()) == itemList.end())
+                                itemList.insert(pItem->GetEntry());
+
+            //s2.2: add gossips
+
+            //s2.2.0 add current item (with return)
+            uint8 slot = action - (GOSSIP_ACTION_INFO_DEF + 1);
+            std::ostringstream str;
+            str << "Equipped: ";
+            if (uint32 itemId = master->GetBotEquip(me, slot))
+            {
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+                    _AddItemTemplateLink(master, proto, str);
+                else
+                    str << "unknown item";
+
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_INFO, action);
+            }
+            else
+            {
+                str << "nothing";
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_SHOW, action);
+            }
+
+            //s2.2.1 add unequip option if have weapon
+            if (action - GOSSIP_ACTION_INFO_DEF <= BOT_SLOT_RANGED)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Use your old equipment", GOSSIP_SENDER_EQUIP_RESET, action);
+
+            //s2.2.2 add unequip option if have weapon
+            if (master->GetBotEquip(me, action - (GOSSIP_ACTION_INFO_DEF + 1)))
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Unequip it", GOSSIP_SENDER_UNEQUIP, action);
+
+            //s2.2.3a: add an empty submenu with info if no items are found
+            if (itemList.empty())
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Hm... I have nothing to give you", 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                ItemTemplate const* weap;
+                uint32 counter = 0;
+                uint32 maxcounter = GOSSIP_MAX_MENU_ITEMS - 4; //unequip, reset, current, back
+                uint32 slot = action - GOSSIP_ACTION_INFO_DEF;
+                //s2.2.3b: add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    weap = sObjectMgr->GetItemTemplate(*itr);
+                    if (weap)
+                    {
+                        std::ostringstream name;
+                        _AddItemTemplateLink(master, weap, name);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + (slot - 1), GOSSIP_ACTION_INFO_DEF + weap->ItemId);
+                        ++counter;
+                    }
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+
+            //TC_LOG_ERROR("entities.player", "OnGossipSelect(bot): added %u item(s) to list of %s (requester: %s)",
+            //    counter, me->GetName().c_str(), player->GetName().c_str());
+
+            break;
+        }
+        case GOSSIP_SENDER_UNEQUIP: //equips change s3: Unequip
+        {
+            if (action - GOSSIP_ACTION_INFO_DEF == BOT_SLOT_MAINHAND)
+            {
+                if (me->GetBotClass() == CLASS_WARRIOR || me->GetBotClass() == CLASS_DEATH_KNIGHT ||
+                    me->GetBotClass() == CLASS_ROGUE || (me->GetBotClass() == CLASS_SHAMAN && IsMelee()) ||
+                    me->GetBotClass() == CLASS_PALADIN || me->GetBotClass() == CLASS_HUNTER)
+                {
+                    me->Say("What, with my bare hands? No way", LANG_UNIVERSAL, player);
+                    break;
+                }
+            }
+            else if (action - GOSSIP_ACTION_INFO_DEF == BOT_SLOT_OFFHAND)
+            {
+                if (me->GetBotClass() == CLASS_ROGUE)
+                {
+                    me->Say("No. Never", LANG_UNIVERSAL, player);
+                    break;
+                }
+            }
+            else if (action - GOSSIP_ACTION_INFO_DEF == BOT_SLOT_RANGED)
+            {
+                if (me->GetBotClass() == CLASS_HUNTER)
+                {
+                    me->Say("Yeah, very funny...", LANG_UNIVERSAL, player);
+                    break;
+                }
+            }
+
+            if (Unequip(action - (GOSSIP_ACTION_INFO_DEF + 1)))
+                me->Say("Hm...", LANG_UNIVERSAL, player);
+            break;
+        }
+        case GOSSIP_SENDER_EQUIP_RESET: //equips change s4a: reset equipment
+        {
+            if (ResetEquipment(action - (GOSSIP_ACTION_INFO_DEF + 1)))
+                me->Say("Very well", LANG_UNIVERSAL, player);
+            break;
+        }
+        //equips change s4b: Equip item
+        case GOSSIP_SENDER_EQUIP_BEGIN:     //1 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_OHAND:     //2 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_RANGED:    //3 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_HEAD:      //4 - 1 head
+        case GOSSIP_SENDER_EQUIP_SHOULDERS: //5 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_CHEST:     //6 - 1 chest
+        case GOSSIP_SENDER_EQUIP_WAIST:     //7 - 1 waist
+        case GOSSIP_SENDER_EQUIP_LEGS:      //8 - 1 legs
+        case GOSSIP_SENDER_EQUIP_FEET:      //9 - 1 feet
+        case GOSSIP_SENDER_EQUIP_WRIST:     //10 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_HANDS:     //11 - 1 hands
+        case GOSSIP_SENDER_EQUIP_BACK:      //12 - 1 back
+        case GOSSIP_SENDER_EQUIP_BODY:      //13 - 1 body
+        case GOSSIP_SENDER_EQUIP_FINGER1:   //14 - 1 finger
+        case GOSSIP_SENDER_EQUIP_FINGER2:   //15 - 1 finger
+        case GOSSIP_SENDER_EQUIP_TRINKET1:  //16 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_TRINKET2:  //17 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_NECK:      //18 - 1 neck
+        {
+            if (Equip(action - GOSSIP_ACTION_INFO_DEF, sender - GOSSIP_SENDER_EQUIP))
+                me->Say("Very well", LANG_UNIVERSAL, player);
+            break;
+        }
+        case GOSSIP_SENDER_ROLES_TOGGLE: //ROLES 2: set/unset
+        {
+            ToggleRole(action - GOSSIP_ACTION_INFO_DEF);
+
+            //break;
+        }
+        case GOSSIP_SENDER_ROLES: //ROLES 1: list
+        {
+            subMenu = true;
+
+            uint8 role = BOT_ROLE_TANK;
+
+            for (; role != BOT_MAX_ROLE; role <<= 1)
+                player->ADD_GOSSIP_ITEM(_onOffIcon(role), GetRoleString(role), GOSSIP_SENDER_ROLES_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + role + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_USE:
+        {
+            if (uint32 basespell = action - GOSSIP_ACTION_INFO_DEF)
+            {
+                uint32 spellId = GetSpell(basespell);
+                if (doCast(player, spellId))
+                {
+                    uint32 rec = sSpellMgr->GetSpellInfo(spellId)->GetRecoveryTime();
+                    rec = !rec ? 15000 : std::min<uint32>(rec, 90000);
+                    SetSpellCooldown(basespell, rec);
+                }
+            }
+
+            //break;
+        }
+        case GOSSIP_SENDER_ABILITIES:
+        {
+            subMenu = true;
+
+            uint32 basespell;
+            SpellInfo const* spellInfo;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                basespell = (*itr).first; //always valid
+                if (!CanUseManually(basespell)) continue;
+                if (!IsSpellReady(basespell, 0, false, 5000)) continue;
+                spellInfo = sSpellMgr->GetSpellInfo(basespell); //always valid
+
+                std::ostringstream name;
+                _AddSpellLink(player, spellInfo, name);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, name.str().c_str(), GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF + basespell);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update", GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 2);
+
+            break;
+        }
+        default:
+            break;
+    }
+
+    //if we add submenus send them else we should return
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(GOSSIP_SERVE_MASTER, me->GetGUID());
+    else
+        player->CLOSE_GOSSIP_MENU();
+
+    return true;
+}
+//Summons pet for bot
+void bot_minion_ai::SummonBotsPet(uint32 entry)
+{
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet)
+        me->SetBotsPetDied();
+
+    uint8 mylevel = std::min<uint8>(master->getLevel(), 80);
+    uint32 originalentry = bot_pet_ai::GetPetOriginalEntry(entry);
+    if (!originalentry)
+    {
+        //annoy master
+        me->Whisper("Why am I trying to summon unknown pet!?", LANG_UNIVERSAL, master);
+        return;
+    }
+    uint32 armor = 0;
+    float x(0),y(0),z(0);
+    me->GetClosePoint(x, y, z, me->GetObjectSize());
+    m_botsPet = me->SummonCreature(entry, x, y, z, 0, TEMPSUMMON_DEAD_DESPAWN);
+
+    if (!m_botsPet)
+    {
+        me->Whisper("Failed to summon pet!", LANG_UNIVERSAL, master);
+        return;
+    }
+
+    //std::string name = sObjectMgr->GeneratePetName(originalentry);//voidwalker
+    //if (!name.empty())
+    //    m_botsPet->SetName(name);
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS);
+    stmt->setUInt32(0, originalentry);
+    stmt->setUInt8(1, mylevel);
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+    //QueryResult result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi, sta, inte, spi FROM `pet_levelstats` WHERE `creature_entry` = '%u' AND `level` = '%u'", originalentry, mylevel);
+
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        uint32 hp = fields[0].GetUInt16();
+        uint32 mana = fields[1].GetUInt16();
+        armor = fields[2].GetUInt32();
+        uint32 str = fields[3].GetUInt16();
+        uint32 agi = fields[4].GetUInt16();
+        uint32 sta = fields[5].GetUInt16();
+        uint32 inte = fields[6].GetUInt16();
+        uint32 spi = fields[7].GetUInt16();
+
+        m_botsPet->SetCreateHealth(hp);
+        m_botsPet->SetMaxHealth(hp);
+        m_botsPet->SetCreateMana(mana);
+        m_botsPet->SetMaxPower(POWER_MANA, mana);
+
+        m_botsPet->SetCreateStat(STAT_STRENGTH, str);
+        m_botsPet->SetCreateStat(STAT_AGILITY, agi);
+        m_botsPet->SetCreateStat(STAT_STAMINA, sta);
+        m_botsPet->SetCreateStat(STAT_INTELLECT, inte);
+        m_botsPet->SetCreateStat(STAT_SPIRIT, spi);
+    }
+
+    m_botsPet->SetBotOwner(master);
+    m_botsPet->SetCreatureOwner(me);
+    m_botsPet->SetBotClass(bot_pet_ai::GetPetClass(m_botsPet));
+    master->SetMinion((Minion*)m_botsPet, true);
+    m_botsPet->SetGuidValue(UNIT_FIELD_CREATEDBY, me->GetGUID());
+    m_botsPet->DeleteThreatList();
+    m_botsPet->AddUnitTypeMask(UNIT_MASK_MINION);
+    //m_botsPet->SetLevel(master->getLevel());
+    m_botsPet->AIM_Initialize();
+    m_botsPet->InitBotAI(true);
+    m_botsPet->setFaction(master->getFaction());
+    //bot_pet_ai* petai = m_botsPet->GetBotPetAI();
+    //petai->SetCreatureOwner(me);
+    //petai->SetBaseArmor(armor);
+    //petai->SetStats(mylevel, bot_pet_ai::GetPetType(m_botsPet), true);
+    m_botsPet->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    me->SetBotsPet(m_botsPet);
+
+    m_botsPet->SendUpdateToPlayer(master);
+}
+
+uint16 bot_ai::Rand() const
+{
+    return urand(0, 100 + (master->GetNpcBotsCount() - 1) * 10);
+}
+//Returns pet type (maybe unneeded)
+uint8 bot_pet_ai::GetPetType(Creature* pet)
+{
+    switch (pet->GetEntry())
+    {
+        case PET_VOIDWALKER:
+            return PET_TYPE_VOIDWALKER;
+    }
+    return PET_TYPE_NONE;
+}
+//Returns pet's class
+uint8 bot_pet_ai::GetPetClass(Creature* pet)
+{
+    switch (GetPetType(pet))
+    {
+        case PET_TYPE_IMP:
+            return CLASS_MAGE;
+        default:
+            return CLASS_PALADIN;
+    }
+}
+//Return entry used to summon real pets
+uint32 bot_pet_ai::GetPetOriginalEntry(uint32 entry)
+{
+    switch (entry)
+    {
+        case PET_VOIDWALKER:
+            return ORIGINAL_ENTRY_VOIDWALKER;
+        default:
+            return 0;
+    }
+}
+//PvP trinket for minions
+void bot_minion_ai::BreakCC(uint32 diff)
+{
+    if (pvpTrinket_cd <= diff && CCed(me, true) && (me->GetVictim() || !me->getAttackers().empty()))
+    {
+        temptimer = GC_Timer;
+        if (doCast(me, PVPTRINKET))
+        {
+            pvpTrinket_cd = 120000; //2 minutes default pvp trinket CD
+            GC_Timer = temptimer;
+            return;
+        }
+    }
+}
+//Returns attack range based on given range
+//If mounted: 20%
+//If ranged: 125%
+//If master is dead: max range
+float bot_ai::InitAttackRange(float origRange, bool ranged) const
+{
+    if (me->IsMounted())
+        origRange *= 0.2f;
+    else
+    {
+        if (ranged)
+            origRange *= 1.25f;
+        if (master->isDead())
+            origRange += sWorld->GetMaxVisibleDistanceOnContinents();
+    }
+    return origRange;
+}
+//Force bots to start attack anyone who tries to DAMAGE me or master
+//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
+void bot_minion_ai::OnOwnerDamagedBy(Unit* attacker)
+{
+    if (IAmDead())
+        return;
+    if (me->GetVictim())
+        return;
+    if (InDuel(attacker))
+        return;
+    bool byspell = false;
+    bool ranged = !IsMelee();
+    switch (me->GetBotClass())
+    {
+        case CLASS_DRUID:
+            byspell = GetBotStance() == CLASS_DRUID || GetBotStance() == DRUID_MOONKIN_FORM;
+            break;
+        case CLASS_PRIEST:
+        case CLASS_MAGE:
+        case CLASS_WARLOCK:
+        case CLASS_SHAMAN:
+            byspell = true;
+            break;
+        default:
+            break;
+    }
+    float maxdist = InitAttackRange(float(master->GetBotFollowDist()), ranged); //use increased range
+    if (!attacker->IsWithinDist(me, maxdist))
+        return;
+    if (!CanBotAttack(attacker, byspell))
+        return;
+
+    m_botCommandState = COMMAND_ABANDON; //reset AttackStart()
+    me->Attack(attacker, !ranged);
+}
+
+bool bot_minion_ai::CanUseOffHand() const
+{
+    //warriot can wield any offhand with titan's grip
+    if (me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60)
+        return true;
+
+    //no offhand: check we are using one-handed weapon in main hand
+    if (!me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1))
+    {
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0)))
+            if (proto->Class == ITEM_CLASS_WEAPON &&
+                (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
+                return true;
+    }
+    else if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1)))
+    {
+        //Now we have something in off-hand
+        //1 check if it is one-handed weapon
+        if (proto->Class == ITEM_CLASS_WEAPON &&
+            (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
+            return true;
+        //2 check of it is a shield
+        if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            return true;
+        //3 check of it is a 'held in off-hand' item
+        if (proto->InventoryType == INVTYPE_HOLDABLE)
+            return true;
+    }
+
+    //NO
+    return false;
+}
+
+bool bot_minion_ai::CanUseRanged() const
+{
+    return (me->GetBotClass() == CLASS_HUNTER/* || me->GetBotClass() == CLASS_ROGUE*/);
+    //return (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2) != 0);
+}
+
+bool bot_minion_ai::CanEquip(ItemTemplate const* item, uint8 slot) const
+{
+    //prevent reequipping same items
+    if (item->ItemId == master->GetBotEquip(me, slot - 1))
+        return false;
+
+    //prevent equipping items with random properties (temp)
+    if (item->RandomProperty > 0 || item->RandomSuffix > 0)
+        //if (item->Quality >= ITEM_QUALITY_RARE)
+            return false;
+
+    //level requirements
+    if (me->getLevel() < item->RequiredLevel)
+        return false;
+
+    //class requirements
+    if (!(item->AllowableClass & (1<<(me->GetBotClass()-1))))
+        return false;
+
+    //skip race requirements
+
+    if (item->Class == ITEM_CLASS_WEAPON)
+    {
+        if (slot > BOT_SLOT_RANGED)
+            return false;
+
+        if (slot == BOT_SLOT_OFFHAND && item->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+            return false;
+
+        if (slot == BOT_SLOT_OFFHAND && me->GetBotClass() != CLASS_WARRIOR &&
+            me->GetBotClass() != CLASS_ROGUE && me->GetBotClass() != CLASS_HUNTER &&
+            me->GetBotClass() != CLASS_SHAMAN && me->GetBotClass() != CLASS_DEATH_KNIGHT)
+            return false;
+
+        if (slot == BOT_SLOT_MAINHAND && item->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+            me->GetBotClass() == CLASS_ROGUE)
+            return false;
+
+        if (/*proto->InventoryType == INVTYPE_THROWN ||*/
+            item->InventoryType == INVTYPE_RANGED ||
+            item->InventoryType == INVTYPE_RANGEDRIGHT)
+        {
+            return (slot == BOT_SLOT_RANGED && CanUseRanged());
+        }
+        else if (item->InventoryType == INVTYPE_2HWEAPON)
+        {
+            if (me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60)
+                return true;
+
+            if ((me->GetBotClass() == CLASS_MAGE || me->GetBotClass() == CLASS_PRIEST ||
+                me->GetBotClass() == CLASS_WARLOCK || me->GetBotClass() == CLASS_DRUID) &&
+                item->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+                return false;
+
+            return (slot == BOT_SLOT_MAINHAND);
+        }
+        else if (item->InventoryType == INVTYPE_WEAPON ||
+            item->InventoryType == INVTYPE_WEAPONMAINHAND ||
+            item->InventoryType == INVTYPE_WEAPONOFFHAND)
+        {
+            return (slot == BOT_SLOT_MAINHAND ||
+                (slot == BOT_SLOT_OFFHAND && me->GetBotClass() != CLASS_PALADIN && CanUseOffHand()));
+        }
+    }
+    else if (item->Class == ITEM_CLASS_ARMOR)
+    {
+        switch (item->InventoryType)
+        {
+            case INVTYPE_HEAD:
+                if (slot != BOT_SLOT_HEAD)
+                    return false;
+                break;
+            case INVTYPE_SHOULDERS:
+                if (slot != BOT_SLOT_SHOULDERS)
+                    return false;
+                break;
+            case INVTYPE_BODY:
+                if (slot != BOT_SLOT_BODY)
+                    return false;
+                break;
+            case INVTYPE_CHEST:
+            case INVTYPE_ROBE:
+                if (slot != BOT_SLOT_CHEST)
+                    return false;
+                break;
+            case INVTYPE_WAIST:
+                if (slot != BOT_SLOT_WAIST)
+                    return false;
+                break;
+            case INVTYPE_LEGS:
+                if (slot != BOT_SLOT_LEGS)
+                    return false;
+                break;
+            case INVTYPE_FEET:
+                if (slot != BOT_SLOT_FEET)
+                    return false;
+                break;
+            case INVTYPE_WRISTS:
+                if (slot != BOT_SLOT_WRIST)
+                    return false;
+                break;
+            case INVTYPE_HANDS:
+                if (slot != BOT_SLOT_HANDS)
+                    return false;
+                break;
+            case INVTYPE_FINGER:
+                if (slot != BOT_SLOT_FINGER1 && slot != BOT_SLOT_FINGER2)
+                    return false;
+                break;
+            case INVTYPE_TRINKET:
+                if (slot != BOT_SLOT_TRINKET1 && slot != BOT_SLOT_TRINKET2)
+                    return false;
+                break;
+            case INVTYPE_NECK:
+                if (slot != BOT_SLOT_NECK)
+                    return false;
+                break;
+            case INVTYPE_CLOAK:
+                if (slot != BOT_SLOT_BACK)
+                    return false;
+                break;
+            case INVTYPE_HOLDABLE:
+            case INVTYPE_SHIELD:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                break;
+            case INVTYPE_RELIC:
+                if (slot != BOT_SLOT_RANGED)
+                    return false;
+                break;
+            default:
+                break;
+        }
+
+        if (item->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        {
+            if (slot == BOT_SLOT_OFFHAND)
+            {
+                return CanUseOffHand() &&
+                    (me->GetBotClass() == CLASS_WARRIOR ||
+                    me->GetBotClass() == CLASS_PALADIN ||
+                    me->GetBotClass() == CLASS_SHAMAN);
+            }
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_PLATE)
+        {
+            return (me->getLevel() >= 40 &&
+                (me->GetBotClass() == CLASS_WARRIOR ||
+                me->GetBotClass() == CLASS_DEATH_KNIGHT ||
+                me->GetBotClass() == CLASS_PALADIN));
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_MAIL)
+        {
+            if (me->GetBotClass() == CLASS_WARRIOR ||
+                me->GetBotClass() == CLASS_DEATH_KNIGHT ||
+                me->GetBotClass() == CLASS_PALADIN)
+                return true;
+
+            return (me->getLevel() >= 40 &&
+                (me->GetBotClass() == CLASS_SHAMAN ||
+                me->GetBotClass() == CLASS_HUNTER));
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_LEATHER)
+        {
+            return (me->GetBotClass() != CLASS_WARLOCK &&
+                me->GetBotClass() != CLASS_MAGE &&
+                me->GetBotClass() != CLASS_PRIEST);
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_CLOTH)
+        {
+            return true;
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_MISC)
+        {
+            if (item->InventoryType == INVTYPE_FEET && slot == BOT_SLOT_FEET)
+                return true;
+            if (item->InventoryType == INVTYPE_BODY && slot == BOT_SLOT_BODY)
+                return true;
+            if (item->InventoryType == INVTYPE_FINGER &&
+                (slot == BOT_SLOT_FINGER1 || slot == BOT_SLOT_FINGER2))
+                return true;
+            if (item->InventoryType == INVTYPE_TRINKET &&
+                (slot == BOT_SLOT_TRINKET1 || slot == BOT_SLOT_TRINKET2))
+                return true;
+            if (item->InventoryType == INVTYPE_NECK && slot == BOT_SLOT_NECK)
+                return true;
+            if (item->InventoryType == INVTYPE_HOLDABLE && slot == BOT_SLOT_OFFHAND)
+                return true;
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_LIBRAM)
+            return me->GetBotClass() == CLASS_PALADIN && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_IDOL)
+            return me->GetBotClass() == CLASS_DRUID && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_TOTEM)
+            return me->GetBotClass() == CLASS_SHAMAN && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_SIGIL)
+            return me->GetBotClass() == CLASS_DEATH_KNIGHT && slot == BOT_SLOT_RANGED;
+    }
+
+    return false;
+}
+
+bool bot_minion_ai::Unequip(uint8 slot)
+{
+    if (slot < BOT_SLOT_RANGED)
+    {
+        int8 id = 1;
+        EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+        uint32 itemId = me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot);
+        if (!einfo || einfo->ItemEntry[slot] != me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot))
+        {
+            ItemPosCountVec dest;
+            uint32 no_space = 0;
+            InventoryResult msg = master->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1, &no_space);
+            if (msg != EQUIP_ERR_OK)
+            {
+                master->SendEquipError(msg, NULL, NULL, itemId);
+                return false;
+            }
+            Item* pItem = master->StoreNewItem(dest, itemId, true, 0);
+            if (!pItem)
+            {
+                master->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+                return false;
+            }
+            master->SendNewItem(pItem, 1, true, false, false);
+        }
+
+        //only for non-standard items
+        if (!(einfo && einfo->ItemEntry[slot] == itemId))
+            RemoveItemBonuses(slot);
+
+        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, 0);
+        me->SetAttackTime(WeaponAttackType(slot), 2000); //without weapon
+        master->UpdateBotEquips(me, slot, 0);
+
+        if (slot + 1 == BOT_SLOT_OFFHAND)
+        {
+            if (me->CanDualWield())
+                me->SetCanDualWield(false);
+            if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra |= CREATURE_FLAG_EXTRA_NO_BLOCK;
+        }
+    }
+    else
+    {
+        uint32 itemId = master->GetBotEquip(me, slot);
+        if (itemId == 0)
+            return true; //nothing to unequip
+
+        ItemPosCountVec dest;
+        uint32 no_space = 0;
+        InventoryResult msg = master->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1, &no_space);
+        if (msg != EQUIP_ERR_OK)
+        {
+            master->SendEquipError(msg, NULL, NULL, itemId);
+            return false;
+        }
+        Item* pItem = master->StoreNewItem(dest, itemId, true, 0);
+        if (!pItem)
+        {
+            master->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+            return false;
+        }
+        master->SendNewItem(pItem, 1, true, false, false);
+
+        RemoveItemBonuses(slot);
+
+        master->UpdateBotEquips(me, slot, 0);
+    }
+
+    return true;
+}
+
+bool bot_minion_ai::Equip(uint32 itemId, uint8 slot)
+{
+    if (master->GetBotEquip(me, slot) == itemId)
+        return false;
+
+    if (!itemId)
+        return false;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return false;
+
+    if (slot < BOT_SLOT_RANGED)
+    {
+        int8 id = 1;
+        EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+        if (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot))
+        {
+            if (!Unequip(slot))
+            {
+                me->Say("You have no space for my current item", LANG_UNIVERSAL, master);
+                return false;
+            }
+        }
+
+        if (!einfo || einfo->ItemEntry[slot] != itemId)
+        {
+            if (!master->HasItemCount(itemId, 1))
+            {
+                std::ostringstream msg;
+                msg << "Cannot find ";
+                _AddItemTemplateLink(master, proto, msg);
+                msg << " (id: " << uint32(itemId) << ")!";
+                me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master);
+                return false;
+            }
+
+            master->DestroyItemCount(itemId, 1, true);
+        }
+
+        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, itemId);
+        me->SetAttackTime(WeaponAttackType(slot), einfo && einfo->ItemEntry[slot] == itemId ? me->GetCreatureTemplate()->BaseAttackTime : proto->Delay); //set attack speed
+        master->UpdateBotEquips(me, slot, itemId);
+
+        //only for non-standard items
+        if (!(einfo && einfo->ItemEntry[slot] == itemId))
+            ApplyItemBonuses(slot);
+
+        if (slot + 1 == BOT_SLOT_OFFHAND)
+        {
+            if (proto->Class == ITEM_CLASS_WEAPON)
+            {
+                if (!me->CanDualWield())
+                    me->SetCanDualWield(true);
+            }
+            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            {
+                if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+            }
+        }
+        else if (slot + 1 == BOT_SLOT_MAINHAND && proto->InventoryType == INVTYPE_2HWEAPON &&
+            !(me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60))
+        {
+            //if have offhand unequip it
+            if (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1))
+                Unequip(BOT_SLOT_OFFHAND - 1);
+        }
+    }
+    else
+    {
+        if (!Unequip(slot))
+        {
+            me->Say("You have no space for my current item", LANG_UNIVERSAL, master);
+            return false;
+        }
+
+        if (!master->HasItemCount(itemId, 1))
+        {
+            std::ostringstream msg;
+            msg << "Cannot find ";
+            _AddItemTemplateLink(master, proto, msg);
+            msg << " (id: " << uint32(itemId) << ")!";
+            me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master);
+            return false;
+        }
+
+        master->DestroyItemCount(itemId, 1, true);
+
+        master->UpdateBotEquips(me, slot, itemId);
+        ApplyItemBonuses(slot);
+    }
+
+    return true;
+}
+
+bool bot_minion_ai::ResetEquipment(uint8 slot)
+{
+    if (slot < BOT_SLOT_RANGED)
+    {
+        int8 id = 1;
+        EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+        if (!einfo || !einfo->ItemEntry[slot])
+            return Unequip(slot);
+
+        if (slot + 1 == BOT_SLOT_MAINHAND && !(me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60))
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[slot]))
+            {
+                if (proto->Class == ITEM_CLASS_WEAPON &&
+                    (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2 ||
+                    proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM ||
+                    proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF || proto->SubClass == ITEM_SUBCLASS_WEAPON_SPEAR))
+                {
+                    if (!Unequip(BOT_SLOT_OFFHAND - 1))
+                        return false;
+                }
+            }
+        }
+
+        return Equip(einfo->ItemEntry[slot], slot);
+    }
+
+    return Unequip(slot);
+}
+
+void bot_minion_ai::ApplyItemBonuses(uint8 slot)
+{
+    //ensurance to set zeros
+    RemoveItemBonuses(slot);
+
+    uint32 itemId = master->GetBotEquip(me, slot);
+    if (!itemId)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : NULL;
+
+    uint32 ssd_level = me->getLevel();
+    if (ssd && ssd_level > ssd->MaxLevel)
+        ssd_level = ssd->MaxLevel;
+
+    ScalingStatValuesEntry const* ssv = proto->ScalingStatValue ? sScalingStatValuesStore.LookupEntry(ssd_level) : NULL;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_STATS; ++i)
+    {
+        uint32 statType = 0;
+        int32  val = 0;
+        if (ssd && ssv)
+        {
+            if (ssd->StatMod[i] < 0)
+                continue;
+            statType = ssd->StatMod[i];
+            val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Modifier[i]) / 10000;
+        }
+        else
+        {
+            if (i >= proto->StatsCount)
+                continue;
+
+            statType = proto->ItemStat[i].ItemStatType;
+            val = proto->ItemStat[i].ItemStatValue;
+        }
+
+        if (val == 0)
+            continue;
+
+        _stats[slot][statType] += val;
+    }
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        _Spell const& spellData = proto->Spells[i];
+        if (!spellData.SpellId)
+            continue;
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+        if (!spellInfo)
+            continue;
+
+        if (spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
+            continue;
+
+        for (uint8 j = 0; j != MAX_SPELL_EFFECTS; ++j)
+        {
+            if (spellInfo->Effects[j].ApplyAuraName == SPELL_AURA_MOD_SHIELD_BLOCKVALUE)
+                _stats[slot][ITEM_MOD_BLOCK_VALUE] += spellInfo->Effects[j].CalcValue();
+        }
+
+        if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
+            continue;
+
+        bool exists = false;
+        for (uint8 j = 0; j != MAX_BOT_CTC_SPELLS; ++j)
+        {
+            if (_ctc[j].first == spellInfo->Id)
+            {
+                exists = true;
+                break;
+            }
+        }
+        if (exists)
+            continue;
+
+        for (uint8 j = 0; j != MAX_BOT_CTC_SPELLS; ++j)
+        {
+            if (_ctc[j].first == 0)
+            {
+                _ctc[j].first = spellInfo->Id;
+                _ctc[j].second = 0; //reset cd
+                break;
+            }
+        }
+    }
+
+    _stats[slot][BOT_ITEM_MOD_RESIST_HOLY] = proto->HolyRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FIRE] = proto->FireRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_NATURE] = proto->NatureRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FROST] = proto->FrostRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_SHADOW] = proto->ShadowRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_ARCANE] = proto->ArcaneRes;
+
+    if (proto->Class == ITEM_CLASS_WEAPON)
+        _stats[slot][BOT_ITEM_MOD_DAMAGE] = proto->Damage[0].DamageMin;
+    else if (proto->Class == ITEM_CLASS_ARMOR)
+        _stats[slot][BOT_ITEM_MOD_ARMOR] = proto->Armor;
+
+    if (proto->Block)
+        _stats[slot][ITEM_MOD_BLOCK_VALUE] += proto->Block;
+
+    shouldUpdateStats = true;
+}
+
+void bot_minion_ai::RemoveItemBonuses(uint8 slot)
+{
+    uint32 itemId = master->GetBotEquip(me, slot);
+    if (!itemId)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        _stats[slot][i] = 0;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        if (uint32 spellId = proto->Spells[i].SpellId)
+        {
+            for (uint8 j = 0; j != MAX_BOT_CTC_SPELLS; ++j)
+            {
+                if (_ctc[j].first == spellId)
+                {
+                    _ctc[j].first = 0;
+                    break;
+                }
+            }
+        }
+    }
+
+    _stats[slot][BOT_ITEM_MOD_RESIST_HOLY] = 0;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FIRE] = 0;
+    _stats[slot][BOT_ITEM_MOD_RESIST_NATURE] = 0;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FROST] = 0;
+    _stats[slot][BOT_ITEM_MOD_RESIST_SHADOW] = 0;
+    _stats[slot][BOT_ITEM_MOD_RESIST_ARCANE] = 0;
+
+    if (proto->Class == ITEM_CLASS_WEAPON)
+        _stats[slot][BOT_ITEM_MOD_DAMAGE] = 0;
+    else if (proto->Class == ITEM_CLASS_ARMOR)
+        _stats[slot][BOT_ITEM_MOD_ARMOR] = 0;
+
+    if (proto->Block)
+        _stats[slot][ITEM_MOD_BLOCK_VALUE] = 0;
+
+    shouldUpdateStats = true;
+}
+
+char const* bot_minion_ai::_getNameForSlot(uint8 slot) const
+{
+    switch (slot)
+    {
+        case BOT_SLOT_MAINHAND:
+            return "Main Hand Weapon";
+        case BOT_SLOT_OFFHAND:
+            return "Offhand Weapon";
+        case BOT_SLOT_RANGED:
+            return "Ranged Weapon";
+        case BOT_SLOT_HEAD:
+            return "Head";
+        case BOT_SLOT_SHOULDERS:
+            return "Shoulders";
+        case BOT_SLOT_CHEST:
+            return "Chest";
+        case BOT_SLOT_WAIST:
+            return "Waist";
+        case BOT_SLOT_LEGS:
+            return "Legs";
+        case BOT_SLOT_FEET:
+            return "Feet";
+        case BOT_SLOT_WRIST:
+            return "Wrist";
+        case BOT_SLOT_HANDS:
+            return "Hands";
+        case BOT_SLOT_BACK:
+            return "Back";
+        case BOT_SLOT_BODY:
+            return "Body";
+        case BOT_SLOT_FINGER1:
+            return "Finger1";
+        case BOT_SLOT_FINGER2:
+            return "Finger2";
+        case BOT_SLOT_TRINKET1:
+            return "Trinket1";
+        case BOT_SLOT_TRINKET2:
+            return "Trinket2";
+        case BOT_SLOT_NECK:
+            return "Neck";
+        default:
+            return "Unknown";
+    }
+}
+
+uint8 const bot_minion_ai::_onOffIcon(uint8 role) const
+{
+    return HasRole(role) ? BOT_ICON_ON : BOT_ICON_OFF;
+}
+
+bool bot_minion_ai::CanHeal() const
+{
+    if (me->getPowerType() != POWER_MANA)
+        return false;
+
+    return
+        (me->GetBotClass() == CLASS_PRIEST || me->GetBotClass() == CLASS_DRUID ||
+        me->GetBotClass() == CLASS_SHAMAN || me->GetBotClass() == CLASS_PALADIN);
+}
+
+char const* bot_ai::GetRoleString(uint8 role) const
+{
+    switch (role)
+    {
+        case BOT_ROLE_NONE:
+            return "???";
+        case BOT_ROLE_TANK:
+            return "Tanking";
+        case BOT_ROLE_DPS:
+            return "DPS";
+        case BOT_ROLE_HEAL:
+            return "Heal";
+        //case BOT_ROLE_MELEE:
+        //    return "Melee";
+        case BOT_ROLE_RANGED:
+            return "Ranged";
+        default:
+        {
+            std::ostringstream str;
+            str << "role " << uint32(role);
+            return str.str().c_str();
+        }
+    }
+}
+
+void bot_ai::InitRoles()
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_ROLES);
+    //"SELECT roles FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_SYNC
+    stmt->setUInt32(0, master->GetGUID().GetCounter());
+    stmt->setUInt32(1, me->GetEntry());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    if (!result)
+    {
+        //default roles
+        _roleMask = BOT_ROLE_DPS;
+        if (!IsMeleeClass(me->GetBotClass()))
+            _roleMask |= BOT_ROLE_RANGED;
+        if (CanHeal())
+            _roleMask |= BOT_ROLE_HEAL;
+        return;
+    }
+
+    Field* field = result->Fetch();
+    _roleMask = field[0].GetInt8();
+}
+
+void bot_ai::ToggleRole(uint8 role)
+{
+    if (roleTimer > 0)
+        return;
+
+    roleTimer = 350; //delay next attempt (prevent abuse)
+
+    HasRole(role) ? _roleMask &= ~role : _roleMask |= role;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_ROLES);
+    //"UPDATE character_npcbot SET roles = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC
+    stmt->setUInt8(0, _roleMask);
+    stmt->setUInt32(1, master->GetGUID().GetCounter());
+    stmt->setUInt32(2, me->GetEntry());
+    CharacterDatabase.Execute(stmt);
+
+    //Update passives
+    ApplyPassives(me->GetBotClass());
+}
+
+bool bot_ai::IsTank(Unit* unit) const
+{
+    if (!unit)
+        unit = me;
+
+    if (unit == me)
+        return (_roleMask & BOT_ROLE_TANK);
+
+    if (Creature* bot = unit->ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            return bot->GetBotAI()->HasRole(BOT_ROLE_TANK);
+
+    if (Player* player = unit->ToPlayer())
+    {
+        if (Group* gr = player->GetGroup())
+        {
+            Group::MemberSlotList const& slots = gr->GetMemberSlots();
+            for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
+                if (itr->guid == player->GetGUID())
+                    return (*itr).flags & MEMBER_FLAG_MAINTANK;
+        }
+    }
+
+    return false;
+}
+
+//UTILITIES
+void bot_ai::_AddItemTemplateLink(Player* forPlayer, ItemTemplate const* item, std::ostringstream &str) const
+{
+    //color
+    str << "|c";
+    switch (item->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << uint32(item->ItemId) << ":";
+
+    //permanent enchantment, 3 gems, 4 unknowns, reporter_level (9)
+    str << "0:0:0:0:0:0:0:0:0";
+
+    //name
+    std::string name = item->Name1;
+    _LocalizeItem(forPlayer, name, item->ItemId);
+    str << "|h[" << name << "]|h|r";
+
+    //max in stack
+    if (item->BuyCount > 1)
+        str<< "|cff009900x" << item->BuyCount << ".|r";
+    else
+        str << "|cff009900.|r";
+}
+
+void bot_ai::_AddItemLink(Player* forPlayer, Item const* item, std::ostringstream &str) const
+{
+    ItemTemplate const* proto = item->GetTemplate();
+
+    //color
+    str << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << proto->ItemId << ":";
+
+    //permanent enchantment
+    str << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":";
+
+    //gems (3)
+    uint32 g1 = 0, g2 = 0, g3 = 0;
+    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot != SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++slot)
+    {
+        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
+        if (!eId)
+            continue;
+
+        SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(eId);
+        if (!enchant) continue;
+
+        switch (slot - SOCK_ENCHANTMENT_SLOT)
+        {
+            case 1: g1 = enchant->GemID;    break;
+            case 2: g2 = enchant->GemID;    break;
+            case 3: g3 = enchant->GemID;    break;
+        }
+    }
+    str << g1 << ":" << g2 << ":" << g3 << ":";
+
+    //temp enchantment, bonus enchantment and prismatic enchantment (3 + 1 unk)
+    str << "0:0:0:0:";
+
+    //reporter level
+    str << "0";
+
+    //name
+    std::string name = proto->Name1;
+    _LocalizeItem(forPlayer, name, proto->ItemId);
+    str << "|h[" << name << "]|h|r";
+
+    //quantity
+    if (item->GetCount() > 1)
+        str << "x" << item->GetCount() << ' ';
+}
+
+void bot_ai::_AddQuestLink(Player* forPlayer, Quest const* quest, std::ostringstream &str) const
+{
+    std::string questTitle = quest->GetTitle();
+    _LocalizeQuest(forPlayer, questTitle, quest->GetQuestId());
+    str << "|cFFEFFD00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+}
+
+void bot_ai::_AddWeaponSkillLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|cff00ffff|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << " : " << master->GetSkillValue(skillid) << " /" << master->GetMaxSkillValue(skillid) << "]|h|r";
+}
+
+void bot_ai::_AddSpellLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|cffffffff|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << "]|h|r";
+}
+
+void bot_ai::_AddProfessionLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const
+{
+    ASSERT(master->HasSkill(skillId));
+    // |cffffd000|Htrade:4037:1:150:1:6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA|h[Engineering]|h|r
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    SkillLineEntry const* skillInfo = sSkillLineStore.LookupEntry(skillId);
+    if (skillInfo)
+    {
+        uint32 curValue = master->GetPureSkillValue(skillId);
+        uint32 maxValue  = master->GetPureMaxSkillValue(skillId);
+        str << "|cffffd000|Htrade:" << spellInfo->Id << ':' << curValue << ':' << maxValue << ':' << master->GetGUID().GetCounter() << ":6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA" << "|h[" << skillInfo->name[loc] << "]|h|r";
+    }
+}
+//Localization
+void bot_ai::_LocalizeItem(Player* forPlayer, std::string &itemName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(entry);
+    if (!itemInfo)
+        return;
+
+    if (itemInfo->Name.size() > loc && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+}
+
+void bot_ai::_LocalizeQuest(Player* forPlayer, std::string &questTitle, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const* questInfo = sObjectMgr->GetQuestLocale(entry);
+    if (!questInfo)
+        return;
+
+    if (questInfo->Title.size() > loc && !questInfo->Title[loc].empty())
+    {
+        const std::string title = questInfo->Title[loc];
+        if (Utf8FitTo(title, wnamepart))
+            questTitle = title;
+    }
+}
+
+void bot_ai::_LocalizeCreature(Player* forPlayer, std::string &creatureName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    CreatureLocale const* creatureInfo = sObjectMgr->GetCreatureLocale(entry);
+    if (!creatureInfo)
+        return;
+
+    if (creatureInfo->Name.size() > loc && !creatureInfo->Name[loc].empty())
+    {
+        const std::string title = creatureInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            creatureName = title;
+    }
+}
+
+void bot_ai::_LocalizeGameObject(Player* forPlayer, std::string &gameobjectName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    GameObjectLocale const* gameObjectInfo = sObjectMgr->GetGameObjectLocale(entry);
+    if (!gameObjectInfo)
+        return;
+
+    if (gameObjectInfo->Name.size() > loc && !gameObjectInfo->Name[loc].empty())
+    {
+        const std::string title = gameObjectInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            gameobjectName = title;
+    }
+}
+
+//Advanced
+void bot_ai::BotSpeak(std::string const& text, uint8 msgtype, uint32 language, ObjectGuid speaker, ObjectGuid receiver)
+{
+    if (msgtype == CHAT_MSG_WHISPER)
+        language = LANG_UNIVERSAL;
+
+    std::string _text(text);
+    //sScriptMgr->OnPlayerChat(this, CHAT_MSG_SAY, language, _text);
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    //BuildPlayerChat(&data, msgType, _text, language);
+    data << uint8(msgtype);
+    data << uint32(language);
+    data << ObjectGuid(speaker);
+    data << uint32(0);                 // constant unknown time
+    data << ObjectGuid(speaker);
+    data << uint32(text.length() + 1);
+    data << text;
+    data << uint8(0);
+
+    if (msgtype == CHAT_MSG_WHISPER)
+    {
+        ASSERT(receiver || "BotSpeak(): no receiver for whisper!");
+        ASSERT(receiver.IsPlayer() || "BotSpeak(): whisper receiver is not a player!");
+
+        if (Player* res = ObjectAccessor::FindPlayer(receiver))
+            res->GetSession()->SendPacket(&data);
+    }
+    else
+    {
+        if (Unit* snd = ObjectAccessor::FindConnectedPlayer(speaker))
+        {
+            float dist = std::max<float>(sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL) * 0.5f);
+            Trinity::MessageDistDeliverer notifier(snd, &data, dist, false);
+            snd->VisitNearbyWorldObject(dist, notifier);
+        }
+    }
+    //SendMessageToSetInRange(&data, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), true);
+}
+
+void bot_ai::JustDied(Unit*)
+{
+    if (master)
+        master->SetNpcBotDied(me->GetGUID());
+}
diff --git a/src/server/game/AI/NpcBots/bot_ai.h b/src/server/game/AI/NpcBots/bot_ai.h
new file mode 100644
index 0000000..9e671ae
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.h
@@ -0,0 +1,607 @@
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+#include "ScriptedCreature.h"
+
+struct PlayerClassLevelInfo;
+struct BotClassLevelInfo
+{
+    BotClassLevelInfo() : basehealth(0), basemana(0) { }
+    uint32 basehealth;
+    uint32 basemana;
+};
+
+enum CommonValues
+{
+//MISC
+    BOT_ENTRY_BEGIN                     = 70001,
+    BOT_ENTRY_END                       = 70248,
+    BOT_ICON_ON                         = 9,//GOSSIP_ICON_BATTLE,
+    BOT_ICON_OFF                        = 7,//GOSSIP_ICON_TALK,
+//COMMON SPELLS
+    MANAPOTION                          = 32453,//"Uses a Holy elixir to heal the caster for 32000"
+    HEALINGPOTION                       = 15504,//"Drinks Holy Elixir to heal the caster"
+    DRINK                               = 66041,//"Restores 4% mana per sec for 30 sec"
+    EAT                                 = 66478,//"Restores Health"
+    PVPTRINKET                          = 42292,//PvP Trinket no CD
+//COMMON CDs
+    POTION_CD                           = 60000,//default 60sec potion cd
+    RATIONS_CD                          = 1000,//update rations every X milliseconds
+//COMMON PASSIVES
+  //1) "Increase(d) @whatever"
+    //SPELL_BONUS_10                      = 33021,//10spp
+    SPELL_BONUS_50                      = 45011,//50spp
+    SPELL_BONUS_150                     = 28141,//150spp
+    SPELL_BONUS_250                     = 69709,//250spp
+    FIREDAM_86                          = 33816,//86 fire spp
+    MANAREGEN45                         = 35867,//45 mp5
+    MANAREGEN100                        = 45216,//100 mp5
+    SPELL_PEN_5                         = 31921,//5 sppen
+    SPELL_PEN_20                        = 26283,//20 sppen
+  //2) Talents
+    HASTE    /*Gift of the EarthMother*/= 51183,//rank 5 10% spell haste
+    HASTE2   /*Blood Frenzy - warrior*/ = 29859,//rank 2 10% melee haste, bonus for rend (warriors only)
+    HASTE3   /*       "Haste"       */  = 29418,//rank 0 10% increased ranged attack speed
+    CRITS    /*Thundering Strikes-sham*/= 16305,//rank 5 5% crit
+    HOLYCRIT /*Holy Spec - priest*/     = 15011,//rank 5 5% holy crit
+    DODGE    /*Anticipation - paladin*/ = 20100,//rank 5 5% dodge
+    PARRY    /*Deflection - warrior*/   = 16466,//rank 5 5% parry
+    BLOCK/*zzOLD Shield Specialization*/= 16253,//rank 1 5% block 10% amount, 3.3.5 & 4.3.4 deprecated
+    PRECISION /*Precision - warrior*/   = 29592,//rank 3 3% melee hit
+    PRECISION2/*Precision - mage*/      = 29440,//rank 3 3% spell hit
+    DMG_TAKEN/*Deadened Nerves - rogue*/= 31383,//rank 3 6% reduced all damage taken
+    EXPERTISE /*Weapon Expertise-rogue*/= 30919,//rank 1 5 expertise
+    EXPERTISE2/*Weapon Expertise-rogue*/= 30920,//rank 2 10 expertise
+  //3) Pet/Special
+    THREAT   /*Tank Class Passive*/     = 57339,//+43% threat
+    BOR      /*Blood of Rhino - pet*/   = 53482,//rank 2 +40% healing taken
+    BOAR     /*Boar's Speed - pet*/     = 19596,//rank 1 +30% movement speed
+    RCP      /*Rogue Class Passive*/    = 21184,//-27% threat caused
+    DEFENSIVE_STANCE_PASSIVE            = 7376, //+ 400% threat 10% damage reduction
+//COMMON GOSSIPS
+    GOSSIP_SERVE_MASTER                 = 2279, //"I live only to serve the master."
+    GOSSIP_SENDER_BEGIN                 = 6000,
+    GOSSIP_SENDER_CLASS,
+    GOSSIP_SENDER_EQUIPMENT,
+    GOSSIP_SENDER_EQUIPMENT_LIST,
+    GOSSIP_SENDER_EQUIPMENT_SHOW,
+    GOSSIP_SENDER_EQUIPMENT_INFO,
+    GOSSIP_SENDER_UNEQUIP,
+    GOSSIP_SENDER_EQUIP_RESET,
+    GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_BEGIN           = GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_MHAND           = GOSSIP_SENDER_EQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_NECK,
+    GOSSIP_SENDER_ROLES,
+    GOSSIP_SENDER_ROLES_TOGGLE,
+    GOSSIP_SENDER_ABILITIES,
+    GOSSIP_SENDER_ABILITIES_USE,
+//COMMON GAMEEVENTS
+    GAME_EVENT_WINTER_VEIL              = 2,
+//COMMON MOUNTS SPELLS
+    REINDEER                            = 25859,
+    REINDEER_FLY                        = 44827
+};
+
+enum BotRoles
+{
+    BOT_ROLE_NONE                       = 0x00,
+    BOT_ROLE_TANK                       = 0x01,
+    BOT_ROLE_DPS                        = 0x02,
+    BOT_ROLE_HEAL                       = 0x04,
+    BOT_ROLE_RANGED                     = 0x08,
+    BOT_MAX_ROLE                        = 0x10
+};
+
+enum BotStances
+{
+    BOT_STANCE_NONE                     = 0,
+    WARRIOR_BATTLE_STANCE               = 21,
+    WARRIOR_DEFENSIVE_STANCE            = 22,
+    WARRIOR_BERSERKER_STANCE            = 23,
+    DEATH_KNIGHT_BLOOD_PRESENCE         = 24,
+    DEATH_KNIGHT_FROST_PRESENCE         = 25,
+    DEATH_KNIGHT_UNHOLY_PRESENCE        = 26,
+    DRUID_BEAR_FORM                     = 27,
+    DRUID_CAT_FORM                      = 28,
+    //DRUID_TRAVEL_FORM                 = 29,   //NYI
+    //DRUID_FLY_FORM                    = 30,   //NYI
+    DRUID_MOONKIN_FORM                = 31      //NYI
+};
+
+enum BotPetTypes
+{
+    PET_TYPE_NONE,
+//Warlock
+    PET_TYPE_IMP,
+    PET_TYPE_VOIDWALKER,
+    PET_TYPE_SUCCUBUS,
+    PET_TYPE_FELHUNTER,
+    PET_TYPE_FELGUARD,
+//Mage
+    PET_TYPE_WATER_ELEMENTAL,
+//Shaman
+    //PET_TYPE_GHOSTLY_WOLF,
+    PET_TYPE_FIRE_ELEMENTAL,
+    PET_TYPE_EARTH_ELEMENTAL,
+//Hunter
+    PET_TYPE_VULTURE,
+
+    MAX_PET_TYPES
+};
+
+enum WarlockBotPets
+{
+    //PET_IMP                     = ,
+    PET_VOIDWALKER              = 70247
+    //PET_SUCCUBUS                =
+};
+
+enum HunterBotPets
+{
+    PET_VULTURE                 = 70248
+};
+
+enum BotPetsOriginalEntries
+{
+    ORIGINAL_ENTRY_VOIDWALKER   = 1860
+};
+
+enum BotEquipSlot
+{
+    BOT_SLOT_NONE               = 0,
+    BOT_SLOT_MAINHAND           = 1,
+    BOT_SLOT_OFFHAND            = 2,
+    BOT_SLOT_RANGED             = 3,
+    BOT_SLOT_HEAD               = 4,
+    BOT_SLOT_SHOULDERS          = 5,
+    BOT_SLOT_CHEST              = 6,
+    BOT_SLOT_WAIST              = 7,
+    BOT_SLOT_LEGS               = 8,
+    BOT_SLOT_FEET               = 9,
+    BOT_SLOT_WRIST              = 10,
+    BOT_SLOT_HANDS              = 11,
+    BOT_SLOT_BACK               = 12,
+    BOT_SLOT_BODY               = 13,
+    BOT_SLOT_FINGER1            = 14,
+    BOT_SLOT_FINGER2            = 15,
+    BOT_SLOT_TRINKET1           = 16,
+    BOT_SLOT_TRINKET2           = 17,
+    BOT_SLOT_NECK               = 18,
+    BOT_MAX_SLOTS,
+    BOT_INVENTORY_SIZE = BOT_MAX_SLOTS - 1
+};
+
+enum BotStatTypes
+{
+    //ItemProtoType.h
+    //ITEM_MOD_MANA                     = 0,
+    //ITEM_MOD_HEALTH                   = 1,
+    //ITEM_MOD_AGILITY                  = 3,
+    //ITEM_MOD_STRENGTH                 = 4,
+    //ITEM_MOD_INTELLECT                = 5,
+    //ITEM_MOD_SPIRIT                   = 6,
+    //ITEM_MOD_STAMINA                  = 7,
+    //ITEM_MOD_DEFENSE_SKILL_RATING     = 12,
+    //ITEM_MOD_DODGE_RATING             = 13,
+    //ITEM_MOD_PARRY_RATING             = 14,
+    //ITEM_MOD_BLOCK_RATING             = 15,
+    //ITEM_MOD_HIT_MELEE_RATING         = 16,
+    //ITEM_MOD_HIT_RANGED_RATING        = 17,
+    //ITEM_MOD_HIT_SPELL_RATING         = 18,
+    //ITEM_MOD_CRIT_MELEE_RATING        = 19,
+    //ITEM_MOD_CRIT_RANGED_RATING       = 20,
+    //ITEM_MOD_CRIT_SPELL_RATING        = 21,
+    //ITEM_MOD_HIT_TAKEN_MELEE_RATING   = 22,
+    //ITEM_MOD_HIT_TAKEN_RANGED_RATING  = 23,
+    //ITEM_MOD_HIT_TAKEN_SPELL_RATING   = 24,
+    //ITEM_MOD_CRIT_TAKEN_MELEE_RATING  = 25,
+    //ITEM_MOD_CRIT_TAKEN_RANGED_RATING = 26,
+    //ITEM_MOD_CRIT_TAKEN_SPELL_RATING  = 27,
+    //ITEM_MOD_HASTE_MELEE_RATING       = 28,
+    //ITEM_MOD_HASTE_RANGED_RATING      = 29,
+    //ITEM_MOD_HASTE_SPELL_RATING       = 30,
+    //ITEM_MOD_HIT_RATING               = 31,
+    //ITEM_MOD_CRIT_RATING              = 32,
+    //ITEM_MOD_HIT_TAKEN_RATING         = 33,
+    //ITEM_MOD_CRIT_TAKEN_RATING        = 34,
+    //ITEM_MOD_RESILIENCE_RATING        = 35,
+    //ITEM_MOD_HASTE_RATING             = 36,
+    //ITEM_MOD_EXPERTISE_RATING         = 37,
+    //ITEM_MOD_ATTACK_POWER             = 38,
+    //ITEM_MOD_RANGED_ATTACK_POWER      = 39,
+    ////ITEM_MOD_FERAL_ATTACK_POWER       = 40, not in 3.3
+    //ITEM_MOD_SPELL_HEALING_DONE       = 41,                 // deprecated
+    //ITEM_MOD_SPELL_DAMAGE_DONE        = 42,                 // deprecated
+    //ITEM_MOD_MANA_REGENERATION        = 43,
+    //ITEM_MOD_ARMOR_PENETRATION_RATING = 44,
+    //ITEM_MOD_SPELL_POWER              = 45,
+    //ITEM_MOD_HEALTH_REGEN             = 46,
+    //ITEM_MOD_SPELL_PENETRATION        = 47,
+    //ITEM_MOD_BLOCK_VALUE              = 48,
+    //END ItemProtoType.h
+
+    BOT_ITEM_MOD_DAMAGE                 = MAX_ITEM_MOD,
+    BOT_ITEM_MOD_ARMOR,
+    BOT_ITEM_MOD_RESIST_HOLY,
+    BOT_ITEM_MOD_RESIST_FIRE,
+    BOT_ITEM_MOD_RESIST_NATURE,
+    BOT_ITEM_MOD_RESIST_FROST,
+    BOT_ITEM_MOD_RESIST_SHADOW,
+    BOT_ITEM_MOD_RESIST_ARCANE,
+    BOT_ITEM_MOD_EX,
+    MAX_BOT_ITEM_MOD
+};
+
+#define MAX_BOT_CTC_SPELLS              1//(MAX_EQUIPMENT_ITEMS * MAX_ITEM_SPELLS)
+
+class bot_ai : public ScriptedAI
+{
+    public:
+        virtual ~bot_ai();
+        bot_ai(Creature* creature);
+        //Player* GetMaster() const { return master; }
+        virtual bool IsMinionAI() const = 0;
+        virtual bool IsPetAI() const = 0;
+        virtual void SetBotCommandState(CommandStates /*st*/, bool /*force*/ = false, Position* /*newpos*/ = NULL) = 0;
+        virtual const bot_minion_ai* GetMinionAI() const { return NULL; }
+        virtual const bot_pet_ai* GetPetAI() const { return NULL; }
+        bool IsInBotParty(Unit* unit) const;
+        bool CanBotAttack(Unit* target, int8 byspell = 0) const;
+        bool InDuel(Unit* target) const;
+        CommandStates GetBotCommandState() const { return m_botCommandState; }
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const;
+        inline void SendPartyEvadeAbort() const;
+        inline void SetShouldUpdateStats() { shouldUpdateStats = true; }
+        inline void UpdateHealth() { doHealth = true; }
+        inline void UpdateMana() { doMana = true; }
+        inline float GetManaRegen() const { return regen_mp5; }
+        inline float GetHitRating() const { return hit; }
+        inline int32 GetSpellPower() const { return m_spellpower; }
+        inline uint8 GetHaste() const { return haste; }
+        inline uint32 GetShieldBlockValue() const { return m_block; }
+        virtual uint8 GetBotStance() const { return 0; }
+        inline uint8 GetBotRoles() const { return _roleMask; }
+        inline bool HasRole(uint8 role) const { return _roleMask & role; }
+        void ToggleRole(uint8 role);
+        char const* GetRoleString(uint8 role) const;
+
+        virtual void OnBotSummon(Creature* /*summon*/) {}
+        virtual void OnBotDespawn(Creature* /*summon*/) {}
+        virtual void UnsummonAll() {}
+
+        void ReceiveEmote(Player* player, uint32 emote);
+        void ApplyPassives(uint8 botOrPetType) const;
+
+        virtual void RemoveItemBonuses(uint8 /*slot*/) {}
+        virtual void ApplyItemBonuses(uint8 /*slot*/) {}
+
+        static inline bool CCed(Unit* target, bool root = false)
+        {
+            return target ? target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE) || (root && target->HasUnitState(UNIT_STATE_ROOT)) : true;
+        }
+
+        virtual bool CanUseOffHand() const { return false; }
+        virtual bool CanUseRanged() const { return false; }
+        virtual bool CanEquip(ItemTemplate const* /*item*/, uint8 /*slot*/) const { return false; }
+        virtual bool Unequip(uint8 /*slot*/) { return false; }
+        virtual bool Equip(uint32 /*itemId*/, uint8 /*slot*/) { return false; }
+        virtual bool ResetEquipment(uint8 /*slot*/) { return false; }
+
+        static void BotSpeak(std::string const& text, uint8 msgtype, uint32 language, ObjectGuid sender, ObjectGuid receiver);
+
+        virtual void JustDied(Unit*);
+
+    protected:
+        static uint32 InitSpell(Unit const* caster, uint32 spell);
+        void InitSpellMap(uint32 basespell, bool forceadd = false);
+        uint32 GetSpell(uint32 basespell) const;
+        uint32 GetSpellCooldown(uint32 basespell) const;
+        bool IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD = true, uint32 forcedTime = 0) const;
+        void SetSpellCooldown(uint32 basespell, uint32 msCooldown);
+        void ResetSpellCooldown(uint32 basespell) { SetSpellCooldown(basespell, 0); }
+        void RemoveSpell(uint32 basespell);
+        void SpellTimers(uint32 diff);
+
+        void InitRoles();
+        bool IsTank(Unit* unit = NULL) const;
+
+        bool HasAuraName(Unit* unit, uint32 spellId, ObjectGuid casterGuid = ObjectGuid::Empty, bool exclude = false) const;
+        bool RefreshAura(uint32 spell, int8 count = 1) const;
+        bool CheckAttackTarget(uint8 botOrPetType);
+        bool MoveBehind(Unit &target) const;
+        bool CheckImmunities(uint32 spell, Unit* target = NULL) const { return (spell && target && !target->ToCorpse() && target->IsHostileTo(me) ? !target->IsImmunedToDamage(sSpellMgr->GetSpellInfo(spell)) : true); }
+
+        //everything cast-related
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false, ObjectGuid originalCaster = ObjectGuid::Empty);
+        SpellCastResult CheckBotCast(Unit* victim, uint32 spellId, uint8 botclass) const;
+        virtual void removeFeralForm(bool /*force*/ = false, bool /*init*/ = true, uint32 /*diff*/ = 0) {}
+
+        inline bool Feasting() const { return (me->HasAura(EAT) || me->HasAura(DRINK)); }
+        inline bool IsMeleeClass(uint8 m_class) const { return (m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT); }
+        inline bool IsTankingClass(uint8 m_class) const { return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT); }
+        inline bool IsChanneling(Unit* u = NULL) const { if (!u) u = me; return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
+        inline bool IsCasting(Unit* u = NULL) const { if (!u) u = me; return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCast(false, false, true)); }
+
+        void GetInPosition(bool force = false, Unit* newtarget = NULL, Position* pos = NULL);
+        void OnSpellHit(Unit* caster, SpellInfo const* spell);
+        void CalculateAttackPos(Unit* target, Position &pos) const;
+        void CheckAttackState();
+        inline virtual void Evade() {}
+
+        //virtual void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+        virtual void ApplyClassDamageMultiplierMelee(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierEffect(SpellInfo const* /*spellInfo*/, uint8 /*effect_index*/, float& /*value*/) const {}
+        virtual void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
+        virtual void CheckAuras(bool /*force*/ = false) {}
+        virtual void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
+        virtual void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        virtual void InitSpells() {}
+        virtual void InitPowers() {}
+        virtual void ApplyClassPassives() {}
+        virtual void _OnHealthUpdate() const = 0;
+        virtual void _OnManaUpdate(bool /*shapeshift*/ = false) = 0;
+        //virtual void _OnMeleeDamageUpdate(uint8 /*myclass*/) const = 0;
+
+        //virtual void ReceiveEmote(Player* /*player*/, uint32 /*emote*/) {}
+        //virtual void CommonTimers(uint32 diff) = 0;
+
+        virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        virtual bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
+        virtual bool IsMelee() const { return HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_RANGED); }
+        virtual bool CanHeal() const { return false; }
+
+        uint8 GetWait();
+        inline float InitAttackRange(float origRange, bool ranged) const;
+        uint16 Rand() const;
+        static inline uint32 GetLostHP(Unit* unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
+        static inline uint8 GetHealthPCT(Unit* hTarget) { if (!hTarget || hTarget->isDead()) return 100; return (hTarget->GetHealth()*100/hTarget->GetMaxHealth()); }
+        static inline uint8 GetManaPCT(Unit* hTarget) { if (!hTarget || hTarget->isDead() || hTarget->getPowerType() != POWER_MANA) return 100; return (hTarget->GetPower(POWER_MANA)*100/(hTarget->GetMaxPower(POWER_MANA) + 1)); }
+
+        typedef std::set<Unit*> AttackerSet;
+        typedef std::unordered_map<uint32 /*stat*/, int32 /*statvalue*/> BotStat;
+        typedef std::pair<uint32 /*spellId*/, uint32 /*cooldown*/> BotCTCSpell;
+
+        BotStat _stats[BOT_MAX_SLOTS - 1];
+        BotCTCSpell _ctc[MAX_BOT_CTC_SPELLS];
+        uint32 CalcCTC(uint32 /*spellId*/) const { return 8; } //placeholder
+
+        //utilities
+        void _AddItemTemplateLink(Player* forPlayer, ItemTemplate const* item, std::ostringstream &str) const;
+        void _AddItemLink(Player* forPlayer, Item const* item, std::ostringstream &str) const;
+        void _AddQuestLink(Player* forPlayer, Quest const* quest, std::ostringstream &str) const;
+        void _AddWeaponSkillLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const;
+        void _AddSpellLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str) const;
+        void _AddProfessionLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const;
+        void _LocalizeItem(Player* forPlayer, std::string &itemName, uint32 entry) const;
+        void _LocalizeQuest(Player* forPlayer, std::string &questTitle, uint32 entry) const;
+        void _LocalizeCreature(Player* forPlayer, std::string &creatureName, uint32 entry) const;
+        void _LocalizeGameObject(Player* forPlayer, std::string &gameobjectName, uint32 entry) const;
+
+        typedef std::pair<uint32 /*spellId*/, uint32 /*cooldown*/> BotSpell;
+        typedef std::unordered_map<uint32 /*spellId_1*/, BotSpell /*spell*/> BotSpellMap;
+
+        BotSpellMap const& GetSpellMap() const { return spells; }
+
+        Player* master;
+        Unit* opponent;
+        CommandStates m_botCommandState;
+        SpellInfo const* m_botSpellInfo;
+        Position pos, attackpos;
+        float stat, atpower, maxdist, regen_mp5, hit,
+            ap_mod, spp_mod, crit_mod;
+        ObjectGuid aftercastTargetGuid;
+        int32 cost, value, sppower, m_spellpower, m_expertise, m_spellpen;
+        uint32 GC_Timer, temptimer, checkAurasTimer, roleTimer, wait, currentSpell, tempMana, m_block;
+        uint8 clear_cd, haste, healTargetIconFlags;
+        bool doHealth, doMana, shouldUpdateStats;
+
+    private:
+        Unit* _getTarget(bool byspell, bool ranged, bool &reset) const;
+        bool _hasAuraName(Unit* unit, const std::string spell, ObjectGuid casterGuid = ObjectGuid::Empty, bool exclude = false) const;
+        void _listAuras(Player* player, Unit* unit) const;
+        static inline float _getAttackDistance(float distance) { return distance > 0.f ? distance*0.72 : 0.f; }
+
+        BotSpellMap spells;
+        uint8 _roleMask;
+        float dmgmult_melee, dmgmult_spell;
+        float dmgmod_melee, dmgmod_spell;
+        ObjectGuid m_TankGuid;
+};
+
+class bot_minion_ai : public bot_ai
+{
+    public:
+        virtual ~bot_minion_ai();
+        bot_minion_ai(Creature* creature);
+        const bot_minion_ai* GetMinionAI() const { return this; }
+        bool IsMinionAI() const { return true; }
+        bool IsPetAI() const { return false; }
+        void SummonBotsPet(uint32 entry);
+        inline bool IAmDead() const { return (!master || me->isDead()); }
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        void CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff);
+        bool CureTarget(Unit* target, uint32 cureSpell, uint32 diff);
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void SetStats(bool force, bool shapeshift = false);
+        virtual uint8 GetBotStance() const { return me->GetBotClass(); }
+
+        static bool OnGossipHello(Player* player, Creature* creature);
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
+
+        void InitSpells() {}
+        void InitPowers() {}
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate(bool shapeshift = false);
+        void _OnMeleeDamageUpdate(uint8 myclass) const;
+
+        void RemoveItemBonuses(uint8 slot);
+        void ApplyItemBonuses(uint8 slot);
+
+        void OnOwnerDamagedBy(Unit* attacker);
+
+        inline void SetEvadeTimer(uint8 time) { evade_cd = time; }
+
+        bool CanUseOffHand() const;
+        bool CanUseRanged() const;
+        bool CanEquip(ItemTemplate const* item, uint8 slot) const;
+        bool Unequip(uint8 slot);
+        bool Equip(uint32 itemId, uint8 slot);
+        bool ResetEquipment(uint8 slot);
+
+        bool CanHeal() const;
+
+    protected:
+        virtual bool CanUseManually(uint32 /*basespell*/) const { return false; }
+        void BuffAndHealGroup(Player* gPlayer, uint32 diff);
+        void RezGroup(uint32 REZZ, Player* gPlayer);
+
+        void Follow(bool force = false, Position* newpos = NULL)
+        {
+            if (force ||
+                (me->IsAlive() && (!me->IsInCombat() || !opponent) && m_botCommandState != COMMAND_STAY))
+                SetBotCommandState(COMMAND_FOLLOW, force, newpos);
+        }
+
+        inline void Evade() { _evade(); }
+
+        virtual void BreakCC(uint32 diff);
+
+        void CommonTimers(uint32 diff)
+        {
+            if (pvpTrinket_cd > diff)       pvpTrinket_cd -= diff;
+            if (Potion_cd > diff)           Potion_cd -= diff;
+            if (GC_Timer > diff)            GC_Timer -= diff;
+            if (temptimer > diff)           temptimer -= diff;
+            if (checkAurasTimer != 0)       --checkAurasTimer;
+            if (wait != 0)                  --wait;
+            if (evade_cd != 0)              --evade_cd;
+
+            if (mana_cd > diff)             mana_cd -= diff;
+            else if (mana_cd > 0)           mana_cd = 0;
+            if (health_cd > diff)           health_cd -= diff;
+            else if (health_cd > 0)         health_cd = 0;
+
+            if (roleTimer > diff)           roleTimer -= diff;
+            else if (roleTimer > 0)         roleTimer = 0;
+
+            for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+            {
+                if (_ctc[i].second > diff)  _ctc[i].second -= diff;
+                else                        _ctc[i].second = 0;
+            }
+        }
+
+        Unit* FindHostileDispelTarget(float dist = 30, bool stealable = false) const;
+        Unit* FindAffectedTarget(uint32 spellId, ObjectGuid caster = ObjectGuid::Empty, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0) const;
+        Unit* FindPolyTarget(float dist = 30, Unit* currTarget = NULL) const;
+        Unit* FindFearTarget(float dist = 30) const;
+        Unit* FindStunTarget(float dist = 20) const;
+        Unit* FindUndeadCCTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindRootTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindCastingTarget(float maxdist = 10, float mindist = 0, bool isFriend = false, uint32 spellId = 0) const;
+        Unit* FindAOETarget(float dist = 30, bool checkbots = false, bool targetfriend = true) const;
+        Unit* FindSplashTarget(float dist = 5, Unit* To = NULL, float splashdist = 4) const;
+        Unit* FindTranquilTarget(float mindist = 5, float maxdist = 35) const;
+        void GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist = 10, float mindist = 0, bool forCC = false) const;
+
+        uint32 Potion_cd;
+
+    private:
+        bool _canCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const;
+        void _getBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const;
+        void _calculatePos(Position& pos);
+        void _updateMountedState();
+        void _updateStandState() const;
+        void _updateRations();
+        void _evade();
+        char const* _getNameForSlot(uint8 slot) const;
+        uint8 const _onOffIcon(uint8 role) const;
+        //BotClassLevelInfo classinfo;
+        PlayerClassLevelInfo* _classinfo;
+        float myangle, armor_mod, haste_mod, dodge_mod, parry_mod;
+        uint32 mana_cd, health_cd, pvpTrinket_cd;
+        uint8 rezz_cd, evade_cd;
+};
+
+class bot_pet_ai : public bot_ai
+{
+    public:
+        virtual ~bot_pet_ai();
+        bot_pet_ai(Creature* creature);
+        const bot_pet_ai* GetPetAI() const { return this; }
+        Creature* GetCreatureOwner() const { return m_creatureOwner; }
+        bool IsMinionAI() const { return false; }
+        bool IsPetAI() const { return true; }
+        inline bool IAmDead() const { return (!master || !m_creatureOwner || me->isDead()); }
+        //void SetCreatureOwner(Creature* newowner) { m_creatureOwner = newowner; }
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        //void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
+        //void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        //void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
+        //bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void SetStats(bool force);
+
+        static uint8 GetPetType(Creature* pet);
+        static uint8 GetPetClass(Creature* pet);
+        static uint32 GetPetOriginalEntry(uint32 entry);
+
+        //debug
+        //virtual void ListSpells(ChatHandler* /*handler*/) const {}
+
+        void InitSpells() {}
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate(bool shapeshift = false);
+        //void _OnMeleeDamageUpdate(uint8 /*myclass*/) const {}
+        void SetBaseArmor(uint32 armor) { basearmor = armor; }
+
+    protected:
+        void CommonTimers(uint32 diff)
+        {
+            if (GC_Timer > diff)            GC_Timer -= diff;
+            if (temptimer > diff)           temptimer -= diff;
+            if (roleTimer > diff)           roleTimer -= diff;
+            if (checkAurasTimer != 0)       --checkAurasTimer;
+            if (wait != 0)                  --wait;
+        }
+
+        Creature* m_creatureOwner;
+    private:
+        uint32 basearmor;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
new file mode 100644
index 0000000..e39f225
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
@@ -0,0 +1,1698 @@
+#include "bot_ai.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+/*
+Death Knight NpcBot by Graff onlysuffering@gmail.com
+Complete - around 55%
+Note: Rune system adapted from TC
+TODO: REMEMBER ALREADY DK HAS MINIMUM LEVEL 55!
+*/
+const RuneType runeSlotTypes[MAX_RUNES] =
+{
+    RUNE_BLOOD,
+    RUNE_BLOOD,
+    RUNE_UNHOLY,
+    RUNE_UNHOLY,
+    RUNE_FROST,
+    RUNE_FROST
+};
+struct BotRuneInfo
+{
+    uint8 BaseRune;
+    uint8 CurrentRune;
+    uint32 Cooldown;
+    //AuraEffect const* ConvertAura;
+};
+
+struct BotRunes
+{
+    BotRuneInfo runes[MAX_RUNES];
+    //uint8 runeState;          //UNUSED
+    //uint8 lastUsedRune;       //UNUSED
+
+    //void SetRuneState(uint8 index, bool set = true)
+    //{
+    //    if (set)
+    //        runeState |= (1 << index);    // usable
+    //    else
+    //        runeState &= ~(1 << index);   // on cooldown
+    //}
+};
+class death_knight_bot : public CreatureScript
+{
+public:
+    death_knight_bot() : CreatureScript("death_knight_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new death_knight_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct death_knight_botAI : public bot_minion_ai
+    {
+        death_knight_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_DEATH_KNIGHT) != SPELL_CAST_OK)
+                return false;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+            int32 runecost[NUM_RUNE_TYPES];
+            for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+                runecost[i] = 0;
+
+            if (!triggered)
+            {
+                if (!HaveRunes(spellInfo, runecost))
+                    return false;
+            }
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result)
+            {
+                //std::ostringstream str;
+                //str << "Casting " << spellInfo->SpellName[0] << " on " << victim->GetName();
+                //me->Whisper(str.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+                //Set cooldown for runes
+                if (!triggered)
+                {
+                    SpendRunes(runecost);
+                    ////debug
+                    //for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+                    //    if (runecost[i])
+                    //        TC_LOG_FATAL("entities.player", "doCast():: DK bot %s has casted spell %u (%s) without %u rune(s) (type %u)!",
+                    //            me->GetName().c_str(), spellId, spellInfo->SpellName[0], runecost[i], i);
+                }
+                //runic power gain: all dk spells are instant but some have no unit target so
+                //we gain runic power here instead of SpellHitTarget()
+                if (SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID))
+                    if (int32 rp = int32(src->runePowerGain * runicpowerIncomeMult))
+                        me->ModifyPower(POWER_RUNIC_POWER, int32(rp));
+            }
+
+            return result;
+        }
+
+        bool HaveRunes(SpellInfo const* spellInfo, int32 *runecost) const
+        {
+            if (spellInfo->PowerType != POWER_RUNE || !spellInfo->RuneCostID)
+                return true;
+
+            CalcRuneCost(spellInfo, runecost);
+
+            if (runecost[RUNE_DEATH] != 0 && runecost[RUNE_DEATH] > GetDeathRunesCount())
+                return false;
+
+            return true;
+        }
+
+        void CalcRuneCost(SpellInfo const* spellInfo, int32 *runecost) const
+        {
+            SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID);
+            if (!src)
+                return;
+
+            if (src->NoRuneCost())
+                return;
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                runecost[i] = src->RuneCost[i];
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                uint8 rune = _runes.runes[i].BaseRune;
+                if (_runes.runes[i].CurrentRune == rune && _runes.runes[i].Cooldown == 0 && runecost[rune] > 0)
+                    runecost[rune]--;
+            }
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                if (runecost[i] > 0)
+                    runecost[RUNE_DEATH] += runecost[i];
+
+            ////restore cost to allow cooldown set
+            //for (uint8 i = 0; i != RUNE_DEATH; ++i)
+            //    runecost[i] = src->RuneCost[i];
+        }
+
+        int32 GetDeathRunesCount() const
+        {
+            int32 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes.runes[i].CurrentRune == RUNE_DEATH && _runes.runes[i].Cooldown == 0)
+                    ++count;
+
+            return count;
+        }
+
+        uint8 GetCooledRunesCount(uint8 runetype) const
+        {
+            uint8 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes.runes[i].BaseRune == runetype && _runes.runes[i].Cooldown > 0)
+                    ++count;
+
+            return count;
+        }
+
+        void SpendRunes(int32* runecost)
+        {
+            for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+            {
+                if (runecost[i] <= 0)
+                    continue;
+
+                for (uint8 j = 0; j != MAX_RUNES && runecost[i] > 0; ++j)
+                {
+                    if (SpendRune(i))
+                        runecost[i]--;
+                }
+            }
+
+            if (GetCooledRunesCount(RUNE_BLOOD) > 1)
+            {
+                me->CastSpell(me, BLADE_BARRIER_AURA, true);
+            }
+        }
+
+        bool SpendRune(uint8 runetype)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes.runes[i].CurrentRune == runetype && _runes.runes[i].Cooldown == 0)
+                {
+                    _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
+                    //_runes.lastUsedRune = _runes.runes[i].CurrentRune;        //UNUSED
+                    //_runes.SetRuneState(i, false);                            //UNUSED
+                    //DK receives rune regen bonus from mana regen
+                    uint32 cooldown = RUNE_BASE_COOLDOWN - std::min<uint32>(uint32(GetManaRegen() * 10), RUNE_BASE_COOLDOWN);
+                    _runes.runes[i].Cooldown = cooldown;
+                    //std::ostringstream str;
+                    //str << "Spent rune " << uint32(i) << " (type: " << uint32(runetype) << ')';
+                    //me->Whisper(str.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        bool HaveRune(uint8 runetype) const
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if ((_runes.runes[i].CurrentRune == runetype || _runes.runes[i].CurrentRune == RUNE_DEATH) &&
+                    _runes.runes[i].Cooldown == 0)
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        void ConvertRune(uint8 runetype, uint8 count)
+        {
+            if (runetype == RUNE_DEATH)
+                return;
+
+            uint8 failcount = 0;
+            for (uint8 i = 0; i != MAX_RUNES && count > 0; ++i)
+            {
+                if (_runes.runes[i].BaseRune == runetype)
+                {
+                    if (_runes.runes[i].CurrentRune == RUNE_DEATH)
+                    {
+                        ++failcount;
+                        continue;
+                    }
+
+                    if (_runes.runes[i].Cooldown > 3000)
+                        _runes.runes[i].Cooldown -= 3000;
+
+                    _runes.runes[i].CurrentRune = RUNE_DEATH;
+                    --count;
+                }
+            }
+
+            if (!count && !failcount)
+                return;
+
+            //std::ostringstream str;
+            //str << "Failed to convert rune of type: " << uint32(runetype) << ")!";
+            //me->Whisper(str.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+        }
+
+        void ActivateAllRunes()
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes.runes[i].Cooldown = 0;
+                //_runes.SetRuneState(i, true);       //UNUSED
+            }
+        }
+
+        void InitRunes()
+        {
+            //_runes.runeState = 0;                   //UNUSED
+            //_runes.lastUsedRune = RUNE_BLOOD;       //UNUSED
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes.runes[i].BaseRune = runeSlotTypes[i];
+                _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
+                _runes.runes[i].Cooldown = 0;
+                //_runes.runes[i].ConvertAura = NULL; //UNUSED
+                //_runes.SetRuneState(i, true);       //UNUSED
+            }
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void RuneTimers(uint32 diff)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes.runes[i].Cooldown <= diff)
+                {
+                    _runes.runes[i].Cooldown = 0;
+                    //_runes.SetRuneState(i, true);     //UNUSED
+                }
+                else
+                    _runes.runes[i].Cooldown -= diff;
+            }
+        }
+
+        void modpower(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && runicpower < uint32(abs(mod)))
+            {
+                //debug set runic power to 0
+                mod = 0;
+                set = true;
+                return;
+            }
+
+            if (set)
+                runicpower = mod ? mod * 10 : 0;
+            else
+                runicpower += mod * 10;
+
+            me->SetPower(POWER_RUNIC_POWER, runicpower);
+        }
+
+        uint32 getpower()
+        {
+            runicpower = me->GetPower(POWER_RUNIC_POWER);
+            return runicpower;
+        }
+
+        uint8 GetBotStance() const { return Presence; }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit* u) { bot_ai::JustDied(u); }
+        void KilledUnit(Unit*) { }
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || IsCasting() || Feasting() || Rand() > 20)
+                return;
+
+            //PATH OF FROST
+            if (GetSpell(PATH_OF_FROST_1) && HaveRune(RUNE_FROST)/* && !me->IsMounted()*/) //works while mounted
+            {
+                if ((me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !me->HasAuraType(SPELL_AURA_WATER_WALK)) ||
+                    (master->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !master->HasAuraType(SPELL_AURA_WATER_WALK) && me->GetDistance(master) < 50))
+                {
+                    if (doCast(me, GetSpell(PATH_OF_FROST_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckHysteria(uint32 diff)
+        {
+            if (!IsSpellReady(HYSTERIA_1, diff) || IsCasting() || Rand() > 15)
+                return;
+
+            Unit* target = NULL;
+
+            if (master->IsAlive() && IsMeleeClass(master->getClass()) && master->IsInCombat() &&
+                GetHealthPCT(master) > 80 && me->GetDistance(master) < 30 &&
+                master->getAttackers().empty() && !CCed(master, true))
+            {
+                if (Unit* u = master->GetVictim())
+                    if (u->GetHealth() > me->GetMaxHealth() / 2)
+                        target = master;
+            }
+
+            if (!target && IsMeleeClass(me->GetBotClass()) && GetHealthPCT(me) > 80 &&
+                me->getAttackers().empty() && !CCed(me, true))
+            {
+                if (Unit* u = me->GetVictim())
+                    if (u->GetHealth() > me->GetMaxHealth() / 2)
+                        target = me;
+            }
+
+            if (!target)
+            {
+                Group* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == master) continue;
+                        if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
+                        if (!IsMeleeClass(tPlayer->getClass()) || !tPlayer->IsInCombat()) continue;
+                        if (GetHealthPCT(tPlayer) < 80 || me->GetDistance(tPlayer) > 30) continue;
+                        if (!tPlayer->getAttackers().empty() || CCed(tPlayer, true)) continue;
+                        if (Unit* u = tPlayer->GetVictim())
+                        {
+                            if (u->GetHealth() > (me->GetMaxHealth() * 2) / 3)
+                            {
+                                target = tPlayer;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (target && doCast(target, GetSpell(HYSTERIA_1)))
+            {
+                if (target->GetTypeId() == TYPEID_PLAYER)
+                {
+                    me->Whisper("Hysteria on You!", LANG_UNIVERSAL, target->ToPlayer());
+                    SetSpellCooldown(HYSTERIA_1, 90000); //1.5 min for player
+                }
+                else
+                    SetSpellCooldown(HYSTERIA_1, 30000); //30 sec for bot
+
+                GC_Timer = 800;
+                return;
+            }
+
+            SetSpellCooldown(HYSTERIA_1, 2000); //fail
+        }
+
+        void CheckAntiMagicShell(uint32 diff)
+        {
+            if (!IsSpellReady(ANTI_MAGIC_SHELL_1, diff, false) || GetHealthPCT(me) > 55 ||
+                getpower() < 200 || IsCasting() || Rand() > 50)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+                return;
+
+            bool cast = false;
+            uint8 count = 0;
+
+            for (AttackerSet::const_iterator itr = b_attackers.begin(); itr != b_attackers.end(); ++itr)
+            {
+                if (!(*itr) || !(*itr)->IsAlive()) continue;
+                if (Spell* spell = (*itr)->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (spell->m_targets.GetUnitTargetGUID() == me->GetGUID())
+                    {
+                        if ((*itr)->ToCreature() && (*itr)->ToCreature()->isWorldBoss())
+                        {
+                            cast = true;
+                            break;
+                        }
+
+                        if (++count >= 3)
+                        {
+                            cast = true;
+                            break;
+                        }
+                    }
+                }
+            }
+
+            if (cast)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(ANTI_MAGIC_SHELL_1)))
+                {
+                    SetSpellCooldown(ANTI_MAGIC_SHELL_1, 30000); //30 sec for bot
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(ANTI_MAGIC_SHELL_1, 1500); //fail
+        }
+
+        void CheckPresence(uint32 diff)
+        {
+            if (presencetimer > diff || IsCasting() || Rand() > 30) //no GCD
+                return;
+
+            uint8 newpresence = IsTank() ? DEATH_KNIGHT_FROST_PRESENCE : DEATH_KNIGHT_BLOOD_PRESENCE;
+            if (Presence == newpresence)
+            {
+                presencetimer = 500;
+                return;
+            }
+
+            Presence = newpresence;
+
+            if (Presence == DEATH_KNIGHT_FROST_PRESENCE && HaveRune(RUNE_FROST))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, FROST_PRESENCE_1))
+                {
+                    GC_Timer = temptimer;
+                    presencetimer = 1000;
+                    return;
+                }
+            }
+            else if (Presence == DEATH_KNIGHT_BLOOD_PRESENCE && HaveRune(RUNE_BLOOD))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, BLOOD_PRESENCE_1))
+                {
+                    GC_Timer = temptimer;
+                    presencetimer = 1000;
+                    return;
+                }
+            }
+
+            presencetimer = 500; //fail
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (IsSpellReady(LICHBORNE_1, diff, false) &&/* Rand() < 75 &&*/
+                me->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(LICHBORNE_1)))
+                {
+                    SetSpellCooldown(LICHBORNE_1, 60000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+
+            if (me->getPowerType() != POWER_RUNIC_POWER)
+                InitPowers();
+
+            if (runicpowertimer <= diff)
+            {
+                if (!me->IsInCombat())
+                {
+                    if (getpower() > uint32(30 * runicpowerLossMult))
+                        me->SetPower(POWER_RUNIC_POWER, runicpower - uint32(30 * runicpowerLossMult)); //-3 runic power every 2 sec
+                    else
+                        me->SetPower(POWER_RUNIC_POWER, 0);
+                }
+                runicpowertimer = 2000;
+            }
+            if (runicpowertimer2 <= diff)
+            {
+                if (me->IsInCombat())
+                {
+                    if (getpower() < me->GetMaxPower(POWER_RUNIC_POWER))
+                        me->SetPower(POWER_RUNIC_POWER, runicpower + uint32(20 * runicpowerIncomeMult)); //+2 runic power every 5 sec
+                    else
+                        me->SetPower(POWER_RUNIC_POWER, me->GetMaxPower(POWER_RUNIC_POWER));
+                }
+                runicpowertimer2 = 5000;
+            }
+
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            CheckPresence(diff);
+
+            //HORN OF WINTER
+            if (IsSpellReady(HORN_OF_WINTER_1, diff, false, (me->IsInCombat() ? 45000 : 0)) && Rand() < 30 &&
+                (me->IsInCombat() || (me->GetDistance(master) < 28 && master->IsWithinLOSInMap(me))))
+            {
+                Aura* horn = master->GetAura(GetSpell(HORN_OF_WINTER_1));
+                if (!horn || horn->GetDuration() < 5000)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(HORN_OF_WINTER_1)))
+                    {
+                        SetSpellCooldown(HORN_OF_WINTER_1, 60000);
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+            //BONE SHIELD
+            if (IsSpellReady(BONE_SHIELD_1, diff) && HaveRune(RUNE_UNHOLY) && Rand() < 25)
+            {
+                Aura* bone = me->GetAura(GetSpell(BONE_SHIELD_1));
+                if (!bone || bone->GetCharges() < 2 || (!me->IsInCombat() && bone->GetDuration() < 60000))
+                {
+                    if (doCast(me, GetSpell(BONE_SHIELD_1)))
+                    {
+                        SetSpellCooldown(BONE_SHIELD_1, 30000);
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(BONE_SHIELD_1, 1000); //fail
+            }
+
+            if (me->IsInCombat())
+            {
+                //ICEBOUND FORTITUDE
+                if (IsSpellReady(ICEBOUND_FORTITUDE_1, diff, false) && getpower() >= 200 &&
+                    GetHealthPCT(me) < std::min<uint32>(85, 45 + uint8(me->getAttackers().size()) * 7) &&
+                    Rand() < 40 + IsTank() * 50)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(ICEBOUND_FORTITUDE_1)))
+                    {
+                        GC_Timer = temptimer;
+                        SetSpellCooldown(ICEBOUND_FORTITUDE_1, 90000);
+                    }
+                }
+
+                CheckAntiMagicShell(diff);
+                CheckHysteria(diff);
+            }
+
+            if (!CheckAttackTarget(CLASS_DEATH_KNIGHT))
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            //SELFHEAL
+
+            //RUNE TAP
+            if (IsSpellReady(RUNE_TAP_1, diff) && GetHealthPCT(me) < 40 && Rand() < 50)
+            {
+                if (!HaveRune(RUNE_BLOOD) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                    {
+                        ActivateAllRunes();
+                        SetSpellCooldown(EMPOWER_RUNE_WEAPON_1, 60000);
+                        GC_Timer = temptimer;
+                    }
+                }
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(RUNE_TAP_1)))
+                {
+                    SetSpellCooldown(RUNE_TAP_1, 20000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //VAMPIRIC BLOOD
+            if (IsSpellReady(VAMPIRIC_BLOOD_1, diff, false) && GetHealthPCT(me) < 26/* && Rand() < 75*/)
+            {
+                if (!HaveRune(RUNE_BLOOD) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false, 40000))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                    {
+                        ActivateAllRunes();
+                        SetSpellCooldown(EMPOWER_RUNE_WEAPON_1, 60000);
+                        GC_Timer = temptimer;
+                    }
+                }
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(VAMPIRIC_BLOOD_1)))
+                {
+                    SetSpellCooldown(VAMPIRIC_BLOOD_1, 40000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //END SELFHEAL
+
+            //MARK OF BLOOD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(MARK_OF_BLOOD_1, diff) && HaveRune(RUNE_BLOOD) &&
+                u && GetHealthPCT(u) < 85 && opponent->GetHealth() > u->GetMaxHealth() / 3 &&
+                (IsTank(u) || u->GetTypeId() == TYPEID_PLAYER) &&
+                Rand() < 35 && !opponent->HasAura(MARK_OF_BLOOD_1) && IsInBotParty(u))
+            {
+                if (doCast(opponent, GetSpell(MARK_OF_BLOOD_1)))
+                {
+                    SetSpellCooldown(MARK_OF_BLOOD_1, 90000); //1.5 min for bots
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //NON-DISEASE SECTION
+
+            //PLACEHOLDER: ARMY OF THE DEAD
+
+            //RANGED SECTION
+
+            //STRANGULATE
+            if (IsSpellReady(STRANGULATE_1, diff) && meleedist <= 30 && HaveRune(RUNE_BLOOD) &&
+                opponent->IsNonMeleeSpellCast(false) && Rand() < 40)
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                if (doCast(opponent, GetSpell(STRANGULATE_1)))
+                {
+                    SetSpellCooldown(STRANGULATE_1, 40000); //-67% for bots
+                    GC_Timer = 800;
+                    return;
+                }
+
+                SetSpellCooldown(STRANGULATE_1, 500); //fail
+            }
+
+            //DARK COMMAND
+            if (IsSpellReady(DARK_COMMAND_1, diff, false) && dist < 30 && IsTank() &&
+                opponent->GetVictim() != me && Rand() < 70)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(DARK_COMMAND_1)))
+                {
+                    SetSpellCooldown(DARK_COMMAND_1, 6000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            ////DEATH GRIP - DISABLED
+            //if (DEATH_GRIP && DeathGrip_cd <= diff && dist < 30 &&
+            //    (tank == me && opponent->GetVictim() != me) ||
+            //    (opponent->GetVictim() == me && opponent->ToPlayer() && opponent->IsNonMeleeSpellCasted(false)) &&
+            //    Rand() < 75)
+            //{
+            //    temptimer = GC_Timer;
+            //    if (doCast(opponent, DEATH_GRIP))
+            //    {
+            //        DeathGrip_cd = 25000;
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+
+            //    DeathGrip_cd = 1000; //fail
+            //}
+            //CHAINS OF ICE
+            if (uint32 CHAINS_OF_ICE = GetSpell(CHAINS_OF_ICE_1))
+            {
+                if (GC_Timer <= diff && dist < 20 && HaveRune(RUNE_FROST) && opponent->isMoving() &&
+                    !CCed(opponent) && !IsTank(opponent->GetVictim()) && IsInBotParty(opponent->GetVictim()) && Rand() < 25)
+                {
+                    Aura* chains = opponent->GetAura(CHAINS_OF_ICE);
+                    if (!chains || chains->GetDuration() < chains->GetMaxDuration() / 4)
+                    {
+                        if (doCast(opponent, CHAINS_OF_ICE))
+                        {
+                            //Improved Chains of Ice: convert frost rune into death rune
+                            ConvertRune(RUNE_FROST, 1);
+                            return;
+                        }
+                    }
+                }
+            }
+
+            //AOE SECTION
+
+            //HOWLING BLAST
+            if (IsSpellReady(HOWLING_BLAST_1, diff) && IsTank() && meleedist < 8 && HasRole(BOT_ROLE_DPS) &&
+                me->getAttackers().size() > 2 && HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) && Rand() < 50)
+            {
+                if (doCast(me, GetSpell(HOWLING_BLAST_1)))
+                {
+                    SetSpellCooldown(HOWLING_BLAST_1, 7000);
+                    GC_Timer = 800;
+                    return;
+                }
+
+                SetSpellCooldown(HOWLING_BLAST_1, 500); //fail
+            }
+            //BLOOD BOIL
+            if (IsSpellReady(BLOOD_BOIL_1, diff) && HasRole(BOT_ROLE_DPS) && HaveRune(RUNE_BLOOD) && Rand() < (10 + 40 * IsTank()))
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.5f);
+                if (targets.size() >= 5)
+                    if (doCast(me, GetSpell(BLOOD_BOIL_1)))
+                        return;
+            }
+            //DEATH AND DECAY
+            if (IsSpellReady(DEATH_AND_DECAY_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < (30 + 30 * IsTank()) &&
+                HaveRune(RUNE_BLOOD) && HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST))
+            {
+                if (Unit* target = FindAOETarget(30, true))
+                {
+                    if (doCast(target, GetSpell(DEATH_AND_DECAY_1)))
+                    {
+                        SetSpellCooldown(DEATH_AND_DECAY_1, 15000); //improved by Morbidity
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(DEATH_AND_DECAY_1, 500); //fail
+            }
+
+            //END AOE SECTION
+
+            //ICY TOUCH
+            if (IsSpellReady(ICY_TOUCH_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && HaveRune(RUNE_FROST) && Rand() < 25 &&
+                !opponent->HasAura(FROST_FEVER_AURA, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(ICY_TOUCH_1)))
+                    return;
+            }
+            //DEATH COIL //custom cd condition
+            if (GetSpell(DEATH_COIL_1) && GC_Timer <= 600 && dist < 20 && HasRole(BOT_ROLE_DPS) &&
+                int32(getpower()) >= (400 + 200 * (GetSpell(RUNE_STRIKE_1) != 0 || GetSpell(MIND_FREEZE_1) != 0 || GetSpell(ANTI_MAGIC_SHELL_1) != 0) + 400 * (GetSpell(HUNGERING_COLD_1) != 0)) &&
+                Rand() < 60)
+            {
+                if (doCast(opponent, GetSpell(DEATH_COIL_1)))
+                    return;
+            }
+
+            //MELEE SECTION
+
+            //MIND FREEZE
+            if (IsSpellReady(MIND_FREEZE_1, diff, false) && meleedist <= 5 && getpower() >= 200 &&
+                opponent->IsNonMeleeSpellCast(false) && Rand() < 60)
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(MIND_FREEZE_1)))
+                {
+                    SetSpellCooldown(MIND_FREEZE_1, 8000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HUNGERING COLD
+            if (IsSpellReady(HUNGERING_COLD_1, diff) && HasRole(BOT_ROLE_DPS) && getpower() >= 400 && Rand() < 20)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.f, 0, true);
+                if (targets.size() >= 3)
+                {
+                    if (doCast(me, GetSpell(HUNGERING_COLD_1)))
+                    {
+                        SetSpellCooldown(HUNGERING_COLD_1, 45000);
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(HUNGERING_COLD_1, 500); //fail
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //RUNE STRIKE
+            if (IsSpellReady(RUNE_STRIKE_1, diff, false) && runestriketimer > me->getAttackTimer(BASE_ATTACK) &&
+                HasRole(BOT_ROLE_DPS) && meleedist <= 5 && getpower() >= 200/* && Rand() < 75*/)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(RUNE_STRIKE_1)))
+                {
+                    SetSpellCooldown(RUNE_STRIKE_1, me->getAttackTimer(BASE_ATTACK)); //only one per swing
+                    runestriketimer = 0; //do not remove aura, just disable ability
+                    GC_Timer = temptimer;
+                }
+            }
+            //PLAGUE STRIKE
+            if (IsSpellReady(PLAGUE_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && HaveRune(RUNE_UNHOLY) && Rand() < 35 &&
+                !opponent->HasAura(BLOOD_PLAGUE_AURA, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(PLAGUE_STRIKE_1)))
+                    return;
+            }
+
+            //DISEASE SECTION
+            uint32 diseases = opponent->GetDiseasesByCaster(me->GetGUID());
+
+            //PESTILENCE //custom cd condition
+            if (GetSpell(PESTILENCE_1) && pestilencetimer == 0 && HasRole(BOT_ROLE_DPS) && GC_Timer <= 600 &&
+                diseases > 1 && meleedist <= 5 &&
+                HaveRune(RUNE_BLOOD) && Rand() < 15)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.f);
+                if (targets.size() > 2)
+                {
+                    if (doCast(opponent, GetSpell(PESTILENCE_1)))
+                    {
+                        pestilencetimer = 10000;
+                        return;
+                    }
+                }
+
+                pestilencetimer = 1000; //fail
+            }
+            //DEATH STRIKE
+            if (IsSpellReady(DEATH_STRIKE_1, diff) && diseases > 0 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) &&
+                GetHealthPCT(me) < (91 - 10 * diseases) && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(DEATH_STRIKE_1)))
+                    return;
+            }
+            //OBLITERATE
+            if (IsSpellReady(OBLITERATE_1, diff) && diseases > 2 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) && Rand() < 20)
+            {
+                if (doCast(opponent, GetSpell(OBLITERATE_1)))
+                    return;
+            }
+            //BLOOD STRIKE //custom
+            if (BLOOD_STRIKE && GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && diseases > 1 && meleedist <= 5 &&
+                HaveRune(RUNE_BLOOD) && Rand() < 25)
+            {
+                if (doCast(opponent, BLOOD_STRIKE))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+
+                //Increased Plague Strike Crit (id 60130): 10% additional critical chance for Plague Strike
+                if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                    aftercrit += 0.1f;
+                //Glyph of Rune Strike: 10% additional critical chance for Rune Strike
+                if (spellId == GetSpell(RUNE_STRIKE_1))
+                    aftercrit += 0.1f;
+                //Subversion: 9% additional critical chance for Blood Strike, Scourge Strike, Heart Strike and Obliterate
+                if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
+                    /*spellId == GetSpell(SCOURGE_STRIKE_1) || */spellId == GetSpell(OBLITERATE_1))
+                    aftercrit += 0.09f;
+                //Improved Death Strike (part 2): 6% additional critical chance for Death Strike
+                if (spellId == GetSpell(DEATH_STRIKE_1))
+                    aftercrit += 0.06f;
+                //Rime (part 1 melee): 15% additional critical chance for Obliterate
+                if (lvl >= 68 && spellId == GetSpell(OBLITERATE_1))
+                    aftercrit += 15.f;
+                //Vicious Strikes (part 1): 6% additional critical chance for Plague Strike and Scourge Strike
+                if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
+                    aftercrit += 6.f;
+
+                //Annihilation: 3% additional critical chance for melee special abilities
+                if (lvl >= 57)
+                    aftercrit += 0.03f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+
+                //Might of Mograine: 45% crit damage bonus for Blood Boil, Blood Strike, Death Strike and Heart Strike
+                if (lvl >= 68 &&
+                    (spellId == GetSpell(BLOOD_BOIL_1) || spellId == BLOOD_STRIKE ||
+                    spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(HEART_STRIKE_1)))
+                    pctbonus += 0.45f / 2.f;
+                //Guile of Gorefiend (part 1 melee): 45% crit damage bonus for Blood Strike, Frost Strike and Obliterate
+                if (lvl >= 69 &&
+                    (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
+                    spellId == GetSpell(OBLITERATE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
+                    pctbonus += 0.45f / 2.f;
+                //Vicious Strikes (part 2): 30% crit damage bonus for Plague Strike and Scourge Strike
+                if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
+                    pctbonus += 0.3f / 2.f;
+            }
+
+            //Glypg of Plague Strike: 20% bonus damage for Plague Strike
+            if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                pctbonus += 0.2f;
+            //Glyph of Blood Strike: 20% bonus damage for Blood Strike on snared targets (Heart Strike too for bots)
+            //warning unsafe
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+                if (damageinfo.target->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_SLOW_ATTACK)))
+                    pctbonus += 0.2f;
+            //Increased Blood Strike Damage: 90 bonus damage for Blood Strike and Heart Strike
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+                fdamage += 90.f;
+            //Glyph of Death Strike: 1% bonus damage for every runic power point (max 25) for Death Strike
+            if (spellId == GetSpell(DEATH_STRIKE_1) && me->GetPower(POWER_RUNIC_POWER) >= 10)
+            {
+                //10 to 250 * 0.001 = 10 to 250 / 1000 = 0.01 to 0.25
+                pctbonus += float(std::min<uint32>(me->GetPower(POWER_RUNIC_POWER), 250)) * 0.001f;
+            }
+            //Glyph of Obliterate: 25% bonus damage for Obliterate
+            if (spellId == GetSpell(OBLITERATE_1))
+                pctbonus += 0.25f;
+            //Bloody Strikes: 15% bonus damage for Blood Strike, 45% for Heart Strike and 30% for Blood Boil
+            if (lvl >= 60)
+            {
+                if (spellId == BLOOD_STRIKE)
+                    pctbonus += 0.15f;
+                else if (spellId == GetSpell(HEART_STRIKE_1))
+                    pctbonus += 0.45f;
+                else if (spellId == GetSpell(BLOOD_BOIL_1))
+                    pctbonus += 0.3f;
+            }
+            //Improved Death Strike (part 1): 30% bonus damage for Death Strike
+            if (spellId == GetSpell(DEATH_STRIKE_1))
+                pctbonus += 0.3f;
+            //Merciless Combat (melee): 12% bonus damage for Obliterate on targets with less than 35% hp
+            //warning unsafe
+            if (lvl >= 67 && spellId == GetSpell(OBLITERATE_1) && damageinfo.target->GetHealthPct() < 35)
+                pctbonus += 0.12f;
+            //Blood of the North (part 1): 10% bonus damage for Blood Strike and Frost Strike (make Heart strike too)
+            if (lvl >= 69 && (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
+                pctbonus += 0.1f;
+            //Tundra Stalker (melee): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
+            //warning unsafe
+            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
+                pctbonus += 0.2f;
+            //Outbreak: 30% bonus damage for Plague Strike and 20% for Scourge Strike
+            if (lvl >= 59)
+            {
+                if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                    pctbonus += 0.3f;
+                //else if (spellId == GetSpell(SCOURGE_STRIKE_1))
+                //    pctbonus += 0.2f;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Rime (part 1 spell): 15% additional critical chance for Icy Touch
+                if (lvl >= 68 && spellId == GetSpell(ICY_TOUCH_1))
+                    aftercrit += 15.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+
+                //Guile of Gorefiend (part 1 spell): 45% crit damage bonus for Howling Blast
+                if (lvl >= 69 && spellId == GetSpell(HOWLING_BLAST_1))
+                    pctbonus += 0.45f / 1.5f;
+
+                //Runic Focus: 50% crit damage bonus for all spells
+                pctbonus += 0.5f / 1.5f;
+            }
+
+            //Improved Icy Touch: 15% bonus damage for Icy Touch
+            if (spellId == GetSpell(ICY_TOUCH_1))
+                pctbonus += 0.15f;
+            //Increased Icy Touch Damage (id 54800): 111 bonus damage for Icy Touch
+            if (spellId == GetSpell(ICY_TOUCH_1))
+                fdamage += 111.f;
+            //Increased Death Coil Damage (id 54807): 80 bonus damage for Death Coil
+            if (spellId == GetSpell(DEATH_COIL_1))
+                fdamage += 80.f;
+            //Black Ice: 10% bonus damage for all Shadow and Frost spells
+            if (lvl >= 58 &&
+                ((SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()) ||
+                (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask())))
+                pctbonus += 0.1f;
+            //Glacier Rot: 20% bonus damage for Icy Touch, Howling Blast and Frost Strike
+            //warning unsafe
+            if (lvl >= 63 && (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
+                damageinfo.target->GetDiseasesByCaster(me->GetGUID()) > 0)
+                pctbonus += 0.2f;
+            //Merciless Combat (spell): 12% bonus damage for Icy Touch, Howling Blast and Frost Strike on targets with less than 35% hp
+            //warning unsafe
+            if (lvl >= 67 &&
+                (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
+                damageinfo.target->GetHealthPct() < 35)
+                pctbonus += 0.12f;
+            //Tundra Stalker (spell): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
+            //warning unsafe
+            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
+                pctbonus += 0.2f;
+            //Morbidity: 15% damage bonus for Death Coil
+            if (lvl >= 58 && spellId == GetSpell(DEATH_COIL_1))
+                pctbonus += 0.15f;
+
+            //temp
+            if (spellId == GetSpell(RUNE_TAP_1))
+                pctbonus += 1.f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float& value) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pct_mod = 1.f;
+
+            //Periodic damage bonuses
+            if (spellInfo->Effects[effect_index].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE)
+            {
+                //float ticksnum = float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+
+                //Increased Plague Strike DoT Damage (id 54802): increased DoT damage by 100
+                if (spellId == BLOOD_PLAGUE_AURA)
+                    value += 100.f;
+                //Glyph of Icy Touch: 20% bonus damage for Frost Fever
+                if (spellId == FROST_FEVER_AURA)
+                    pct_mod += 0.2f;
+                //Black Ice: 10% bonus damage for all Shadow and Frost spells
+                if (lvl >= 58 &&
+                    ((SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()) ||
+                    (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask())))
+                    pct_mod += 0.1f;
+                //Glyph of Unholy Blight: 40% damage bonus for Unholy Blight (100% for bot)
+                if (spellId == UNHOLY_BLIGHT_AURA)
+                    pct_mod += 1.f;
+            }
+            //Heal bonuses
+            if (spellInfo->Effects[effect_index].Effect == SPELL_EFFECT_HEAL)
+            {
+                //Improved Rune Tap: 100% bonus healing from Rune Tap
+                if (spellId == GetSpell(RUNE_TAP_1))
+                    pct_mod += 1.f;
+            }
+
+            value *= pct_mod;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Glyph of Horn of Winter: 1 minute bonus duration (3 for bot)
+            if (spellId == GetSpell(HORN_OF_WINTER_1))
+            {
+                if (Aura* horn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = horn->GetDuration() + 180000;
+                    horn->SetDuration(dur);
+                    horn->SetMaxDuration(dur);
+                }
+
+                //Winter Veil addition
+                if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                    me->AddAura(44755, target); //snowflakes
+            }
+
+            if (target == me)
+                return;
+
+            //Epidemic: 10 sec bonus duration for all diseases
+            if (spellId == FROST_FEVER_AURA || spellId == BLOOD_PLAGUE_AURA ||
+                spellId == CRYPT_FEVER_AURA || spellId == EBON_PLAGUE_AURA)
+            {
+                if (Aura* fever = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = fever->GetDuration() + 10000;
+                    fever->SetDuration(dur);
+                    fever->SetMaxDuration(dur);
+                }
+            }
+            //Sudden Doom: 15% ctc Death Coil on Blood Strike or Heart Strike (up to 30% for bot)
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+            {
+                if (GetSpell(DEATH_COIL_1) && me->getLevel() >= 65 && irand(1,100) <= (me->getLevel() - 50))
+                {
+                    //debug: dk bot cannot cast without runic power even triggered spells
+                    modpower(40);
+                    me->CastSpell(target, GetSpell(DEATH_COIL_1), true);
+                }
+            }
+            //Rime (part 2): Obliterate has 15% chance to reset Howling Blast cooldown (25% for bot, screw runes part)
+            if (spellId == GetSpell(OBLITERATE_1))
+            {
+                if (me->getLevel() >= 67 && urand(1,100) <= 25)
+                    ResetSpellCooldown(HOWLING_BLAST_1);
+            }
+            //Chillblains Improved: increase duration by 10 sec (disable on players)
+            if (spellId == ICY_CLUTCH)
+            {
+                if (target->GetTypeId() != TYPEID_PLAYER)
+                {
+                    if (Aura* chill = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = chill->GetDuration() + 10000;
+                        chill->SetDuration(dur);
+                        chill->SetMaxDuration(dur);
+                    }
+                }
+            }
+            //Blood of the North (part 2): Blood Strike and Pestilence convert Blood Rune to Dark Rune (make Heart Strike too)
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) || GetSpell(spellId == PESTILENCE_1))
+            {
+                if (me->getLevel() >= 69)
+                    ConvertRune(RUNE_BLOOD, 1);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == RUNE_STRIKE_ACIVATION_AURA)
+            {
+                //Rune Strike activation and timer set
+                runestriketimer = 10000;
+            }
+            if (spellId == GetSpell(ANTI_MAGIC_SHELL_1))
+            {
+                //Glyph of Anti-Magic Shell: 2 sec increased duration (5 for bot)
+                if (Aura* shell = me->GetAura(spellId))
+                {
+                    uint32 dur = shell->GetDuration() + 5000;
+                    shell->SetDuration(dur);
+                    shell->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(VAMPIRIC_BLOOD_1))
+            {
+                //Glyph of Vampiric Blood: 5 sec increased duration
+                if (Aura* blood = me->GetAura(spellId))
+                {
+                    uint32 dur = blood->GetDuration() + 5000;
+                    blood->SetDuration(dur);
+                    blood->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(BONE_SHIELD_1))
+            {
+                //Glyph of Bone Shield: 1 bonus charge (2 for bot, 7 for tank)
+                if (Aura* bone = me->GetAura(spellId))
+                {
+                    bone->SetCharges(bone->GetCharges() + (IsTank() ? 3 : 1));
+                }
+            }
+            if (spellId == ICY_TALONS_AURA1 || spellId == ICY_TALONS_AURA2 ||
+                spellId == ICY_TALONS_AURA3 || spellId == ICY_TALONS_AURA4 || spellId == ICY_TALONS_AURA5)
+            {
+                //Icy Talons: Synchronize with Epidemic, add 10 sec duration
+                if (Aura* talons = me->GetAura(spellId))
+                {
+                    uint32 dur = talons->GetDuration() + 10000;
+                    talons->SetDuration(dur);
+                    talons->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(OBLITERATE_1))
+            {
+                //Death Rune Mastery: convert Unholy and Frost Runes into Death Runes
+                ConvertRune(RUNE_UNHOLY, 1);
+                ConvertRune(RUNE_FROST, 1);
+            }
+            if (spellId == GetSpell(ICEBOUND_FORTITUDE_1))
+            {
+                //Guile of Gorefiend (part 2): Icebound Fortitude 6 sec increased duration (18 for bot)
+                if (Aura* fort = me->GetAura(spellId))
+                {
+                    uint32 dur = fort->GetDuration() + 18000;
+                    fort->SetDuration(dur);
+                    fort->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                //Blood Presence Heal
+                if (me->HasAura(IMPROVED_BLOOD_PRESENCE_AURA))
+                {
+                    int32 bp0 = int32(damage / 25); //4%
+                    me->CastCustomSpell(me, BLOOD_PRESENCE_HEAL_EFFECT, &bp0, NULL, NULL, true);
+                }
+
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            presencetimer = 0;
+            runicpowertimer = 2000;
+            runicpowertimer2 = 5000;
+            runestriketimer = 0;
+            pestilencetimer = 0;
+
+            Presence = BOT_STANCE_NONE;
+
+            runicpowerIncomeMult = sWorld->getRate(RATE_POWER_RUNICPOWER_INCOME);
+            runicpowerLossMult = sWorld->getRate(RATE_POWER_RUNICPOWER_LOSS);
+            me->setPowerType(POWER_RUNIC_POWER);
+            me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                InitPowers();
+                InitRunes();
+                ApplyPassives(CLASS_DEATH_KNIGHT);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+            RuneTimers(diff);
+
+            if (presencetimer > diff)               presencetimer -= diff;
+            if (runicpowertimer > diff)             runicpowertimer -= diff;
+            if (runicpowertimer2 > diff)            runicpowertimer2 -= diff;
+
+            if (runestriketimer > diff)             runestriketimer -= diff;
+            else                                    runestriketimer = 0;
+            if (pestilencetimer > diff)             pestilencetimer -= diff;
+            else                                    pestilencetimer = 0;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitPowers()
+        {
+            if (master->getLevel() >= 70)
+                RefreshAura(RUNIC_POWER_MASTERY,5);
+            else if (master->getLevel() >= 58)
+                RefreshAura(RUNIC_POWER_MASTERY,4);
+            else
+                me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
+
+            if (runicpower)
+                me->SetPower(POWER_RUNIC_POWER, runicpower);
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            //InitSpellMap(BLOOD_STRIKE_1);
+            InitSpellMap(ICY_TOUCH_1);
+            InitSpellMap(PLAGUE_STRIKE_1);
+            InitSpellMap(DEATH_STRIKE_1);
+            InitSpellMap(OBLITERATE_1);
+            InitSpellMap(RUNE_STRIKE_1);
+  /*Talent*/InitSpellMap(HEART_STRIKE_1);
+
+            InitSpellMap(BLOOD_BOIL_1);
+            InitSpellMap(DEATH_AND_DECAY_1);
+  /*Talent*/lvl >= 63 ? InitSpellMap(HOWLING_BLAST_1) : RemoveSpell(HOWLING_BLAST_1);
+
+            InitSpellMap(DEATH_COIL_1);
+            InitSpellMap(DEATH_GRIP_1, true);
+            InitSpellMap(PESTILENCE_1);
+            InitSpellMap(MIND_FREEZE_1);
+            InitSpellMap(STRANGULATE_1);
+            InitSpellMap(CHAINS_OF_ICE_1);
+            InitSpellMap(ICEBOUND_FORTITUDE_1);
+            InitSpellMap(DARK_COMMAND_1);
+            InitSpellMap(ANTI_MAGIC_SHELL_1);
+            InitSpellMap(ARMY_OF_THE_DEAD_1);
+  /*Talent*/InitSpellMap(LICHBORNE_1, true);
+  /*Talent*/lvl >= 60 ? InitSpellMap(HUNGERING_COLD_1) : RemoveSpell(HUNGERING_COLD_1);
+
+            InitSpellMap(PATH_OF_FROST_1);
+            InitSpellMap(HORN_OF_WINTER_1);
+  /*Talent*/InitSpellMap(RUNE_TAP_1, true);
+  /*Talent*/lvl >= 58 ? InitSpellMap(BONE_SHIELD_1) : RemoveSpell(BONE_SHIELD_1);
+            InitSpellMap(EMPOWER_RUNE_WEAPON_1);
+  /*Talent*/InitSpellMap(MARK_OF_BLOOD_1, true);
+  /*Talent*/InitSpellMap(VAMPIRIC_BLOOD_1, true);
+  /*Talent*/lvl >= 59 ? InitSpellMap(HYSTERIA_1) : RemoveSpell(HYSTERIA_1);
+
+            InitSpellMap(BLOOD_PRESENCE_1, true);
+            InitSpellMap(FROST_PRESENCE_1, true);
+            //InitSpellMap(UNHOLY_PRESENCE_1, true);
+
+  /*Custom*/BLOOD_STRIKE = lvl >= 65 ? GetSpell(HEART_STRIKE_1) : InitSpell(me, BLOOD_STRIKE_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            if (level >= 58)
+                RefreshAura(GLYPH_OF_CHAINS_OF_ICE);
+            if (level >= 80)
+                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH,4);
+            else if (level >= 77)
+                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH,3);
+            else if (level >= 68)
+                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH,2);
+            else if (level >= 58)
+                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH);
+            if (level >= 65)
+                RefreshAura(GLYPH_OF_HEART_STRIKE);
+            if (level >= 68)
+                RefreshAura(GLYPH_OF_RUNE_TAP,2);
+            else if (level >= 60)
+                RefreshAura(GLYPH_OF_RUNE_TAP);
+            if (level >= 63)
+                RefreshAura(GLYPH_OF_HOWLING_BLAST);
+            if (level >= 57)
+                RefreshAura(BUTCHERY);
+            if (level >= 58)
+                RefreshAura(SCENT_OF_BLOOD);
+            if (level >= 59)
+                RefreshAura(VENDETTA);
+            if (level >= 65)
+                RefreshAura(BLOODY_VENGEANCE3);
+            else if (level >= 60)
+                RefreshAura(BLOODY_VENGEANCE2);
+            else if (level >= 57)
+                RefreshAura(BLOODY_VENGEANCE1);
+            if (level >= 60)
+                RefreshAura(ABOMINATIONS_MIGHT);
+            if (level >= 67)
+                RefreshAura(IMPROVED_BLOOD_PRESENCE);
+            if (level >= 65)
+                RefreshAura(BLOODWORMS,2);
+            //if (level >= 66)
+            //    RefreshAura(IMPROVED_DEATH_STRIKE);
+            if (level >= 57)
+                RefreshAura(TOUGHNESS);
+            if (level >= 57)
+                RefreshAura(ANNIHILATION);
+            if (level >= 60)
+                RefreshAura(ICY_TALONS);
+            if (level >= 68)
+                RefreshAura(CHILL_OF_THE_GRAVE,2);
+            else if (level >= 58)
+                RefreshAura(CHILL_OF_THE_GRAVE);
+            if (level >= 64)
+                RefreshAura(IMPROVED_ICY_TALONS);
+            if (level >= 68)
+                RefreshAura(CHILBLAINS);
+            if (level >= 69)
+                RefreshAura(ACCLIMATION);
+            if (level >= 63)
+                RefreshAura(NECROSIS5);
+            else if (level >= 62)
+                RefreshAura(NECROSIS4);
+            else if (level >= 61)
+                RefreshAura(NECROSIS3);
+            else if (level >= 60)
+                RefreshAura(NECROSIS2);
+            else if (level >= 59)
+                RefreshAura(NECROSIS1);
+            if (level >= 65)
+                RefreshAura(BLOOD_CAKED_BLADE3);
+            else if (level >= 62)
+                RefreshAura(BLOOD_CAKED_BLADE2);
+            else if (level >= 60)
+                RefreshAura(BLOOD_CAKED_BLADE1);
+            if (level >= 67)
+                RefreshAura(DIRGE,2);
+            else if (level >= 61)
+                RefreshAura(DIRGE);
+            if (level >= 61)
+                RefreshAura(UNHOLY_BLIGHT);
+            if (level >= 62)
+                RefreshAura(DESECRATION);
+            if (level >= 64)
+                RefreshAura(CRYPT_FEVER);
+            if (level >= 68)
+                RefreshAura(EBON_PLAGUEBRINGER);
+            if (level >= 67)
+                RefreshAura(WANDERING_PLAGUE);
+
+            RefreshAura(FROST_FEVER);
+            RefreshAura(BLOOD_PLAGUE);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case LICHBORNE_1:
+                case PATH_OF_FROST_1:
+                case HORN_OF_WINTER_1:
+                case BONE_SHIELD_1:
+                case RUNE_TAP_1:
+                case EMPOWER_RUNE_WEAPON_1:
+                case VAMPIRIC_BLOOD_1:
+                case HYSTERIA_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 BLOOD_STRIKE;
+/*tmrs*/uint32 presencetimer, runicpowertimer, runicpowertimer2, runestriketimer, pestilencetimer;
+/*misc*/uint32 runicpower;
+/*misc*/float runicpowerIncomeMult, runicpowerLossMult;
+/*Chck*/uint8 Presence;
+
+        BotRunes _runes;
+
+        enum DeathKnightBaseSpells
+        {
+            BLOOD_STRIKE_1                      = 45902,
+            ICY_TOUCH_1                         = 45477,
+            PLAGUE_STRIKE_1                     = 45462,
+            DEATH_STRIKE_1                      = 49998,
+            OBLITERATE_1                        = 49020,
+            RUNE_STRIKE_1                       = 56815,
+            HEART_STRIKE_1                      = 55050,
+
+            BLOOD_BOIL_1                        = 48721,
+            DEATH_AND_DECAY_1                   = 43265,
+            HOWLING_BLAST_1                     = 49184,
+
+            DEATH_COIL_1                        = 47541,
+            DEATH_GRIP_1                        = 49576,
+            PESTILENCE_1                        = 50842,
+            MIND_FREEZE_1                       = 47528,
+            STRANGULATE_1                       = 47476,
+            CHAINS_OF_ICE_1                     = 45524,
+            ICEBOUND_FORTITUDE_1                = 48792,
+            DARK_COMMAND_1                      = 56222,
+            ANTI_MAGIC_SHELL_1                  = 48707,
+            ARMY_OF_THE_DEAD_1                  = 42650,
+            LICHBORNE_1                         = 49039,
+            HUNGERING_COLD_1                    = 49203,
+
+            PATH_OF_FROST_1                     = 3714,
+            HORN_OF_WINTER_1                    = 57330,
+            BONE_SHIELD_1                       = 49222,
+            RUNE_TAP_1                          = 48982,
+            EMPOWER_RUNE_WEAPON_1               = 47568,
+            MARK_OF_BLOOD_1                     = 49005,
+            VAMPIRIC_BLOOD_1                    = 55233,
+            HYSTERIA_1                          = 49016,
+
+            BLOOD_PRESENCE_1                    = 48266,
+            FROST_PRESENCE_1                    = 48263
+            //UNHOLY_PRESENCE_1                   = 48265
+        };
+        enum DeathKnightPassives
+        {
+        //Talents
+            BUTCHERY                            = 49483,//rank 2
+            SCENT_OF_BLOOD                      = 49509,//rank 3
+            VENDETTA                            = 55136,//rank 3
+            BLOODY_VENGEANCE1                   = 48988,
+            BLOODY_VENGEANCE2                   = 49503,
+            BLOODY_VENGEANCE3                   = 49504,
+            ABOMINATIONS_MIGHT                  = 53138,//rank 2
+            IMPROVED_BLOOD_PRESENCE             = 50371,//rank 2
+            BLOODWORMS                          = 49543,//rank 3
+            IMPROVED_DEATH_STRIKE               = 62908,//rank 2
+            TOUGHNESS                           = 49789,//rank 5
+            ANNIHILATION                        = 51473,//rank 3
+            ICY_TALONS                          = 50887,//rank 5
+            CHILL_OF_THE_GRAVE                  = 50115,//rank 2
+            IMPROVED_ICY_TALONS                 = 55610,
+            CHILBLAINS                          = 50043,//rank 3
+            ACCLIMATION                         = 50152,//rank 3
+            NECROSIS1                           = 51459,
+            NECROSIS2                           = 51462,
+            NECROSIS3                           = 51463,
+            NECROSIS4                           = 51464,
+            NECROSIS5                           = 51465,
+            BLOOD_CAKED_BLADE1                  = 49219,
+            BLOOD_CAKED_BLADE2                  = 49227,
+            BLOOD_CAKED_BLADE3                  = 49228,
+            DIRGE                               = 51206,//rank 2
+            UNHOLY_BLIGHT                       = 49194,
+            DESECRATION                         = 55667,//rank 2
+            CRYPT_FEVER                         = 49632,//rank 3
+            EBON_PLAGUEBRINGER                  = 51161,//rank 3
+            WANDERING_PLAGUE                    = 49655,//rank 3
+        //Special
+  /*Talent*/RUNIC_POWER_MASTERY                 = 50147,//rank 2
+            FROST_FEVER                         = 59921,
+            BLOOD_PLAGUE                        = 59879,
+        //Other
+            GLYPH_OF_CHAINS_OF_ICE              = 58620,//damage proc
+            CHAINS_OF_ICE_FROST_RUNE_REFRESH    = 62459,//5 runic power gain
+            GLYPH_OF_HEART_STRIKE               = 58616,//snare 50% for 10 sec
+            GLYPH_OF_RUNE_TAP                   = 59327,//10% heal for party
+            GLYPH_OF_HOWLING_BLAST              = 63335 //frost fever on targets
+        };
+        enum DeathKnightSpecial
+        {
+            FROST_FEVER_AURA                    = 55095,
+            BLOOD_PLAGUE_AURA                   = 55078,
+            CRYPT_FEVER_AURA                    = 50510,//rank 3
+            EBON_PLAGUE_AURA                    = 51735,//rank 3
+
+            RUNE_STRIKE_ACIVATION_AURA          = 56817,
+
+            IMPROVED_BLOOD_PRESENCE_AURA        = 63611,
+            BLOOD_PRESENCE_HEAL_EFFECT          = 50475,
+            BLADE_BARRIER_AURA                  = 64859,//rank 5
+            UNHOLY_BLIGHT_AURA                  = 50536,
+
+            ICY_TALONS_AURA1                    = 50882,//rank 1
+            ICY_TALONS_AURA2                    = 58575,//rank 2
+            ICY_TALONS_AURA3                    = 58576,//rank 3
+            ICY_TALONS_AURA4                    = 58577,//rank 4
+            ICY_TALONS_AURA5                    = 58578,//rank 5
+
+            DEATH_COIL_ENEMY                    = 47632,
+            ICY_CLUTCH                          = 50436 //rank 3 Chilblains proc
+        };
+        //enum RunePlacing
+        //{
+        //    RUNE_BLOOD_FIRST,
+        //    RUNE_BLOOD_SECOND,
+        //    RUNE_UNHOLY_FIRST,
+        //    RUNE_UNHOLY_SECOND,
+        //    RUNE_FROST_FIRST,
+        //    RUNE_FROST_SECOND,
+        //    NO_RUNE
+        //};
+    };
+};
+
+void AddSC_death_knight_bot()
+{
+    new death_knight_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_druid_ai.cpp b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
new file mode 100644
index 0000000..a7766fe
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
@@ -0,0 +1,1195 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Druid NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Maybe 30%
+TODO: Feral Spells (from scratch), More Forms, Balance Spells + treants...
+*/
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new bot_druid_ai(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct bot_druid_ai : public bot_minion_ai
+    {
+        bot_druid_ai(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_DRUID) != SPELL_CAST_OK)
+                return false;
+
+            m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (me->GetShapeshiftForm() == FORM_NONE && swiftness && m_botSpellInfo->CalcCastTime() > 0)
+            {
+                DoCast(victim, spellId, true);
+                me->RemoveAurasDueToSpell(NATURES_SWIFTNESS_1, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                me->RemoveAurasDueToSpell(CRIT_50, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                swiftness = false;
+                return true;
+            }
+            if (spellId == GetSpell(BEAR_FORM_1) || GetSpell(spellId == CAT_FORM_1))
+            {
+                me->ModifyPower(POWER_MANA, - int32(m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask())));
+                mana = me->GetPower(POWER_MANA);
+                if (Unit* u = me->GetVictim())
+                    GetInPosition(true, u);
+            }
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result &&
+                //spellId != GetSpell(BEAR_FORM_1) && spellId != GetSpell(spellId == CAT_FORM_1) &&
+                spellId != MANAPOTION && spellId != WARSTOMP_1 &&
+                me->HasAura(OMEN_OF_CLARITY_BUFF))
+            {
+                cost = m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask());
+                clearcast = true;
+                power = me->getPowerType();
+            }
+            return result;
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit* u) { removeFeralForm(true, false); bot_ai::JustDied(u); }
+
+        uint8 GetBotStance() const
+        {
+            switch (me->GetShapeshiftForm())
+            {
+                case FORM_BEAR:
+                case FORM_DIREBEAR:
+                    return DRUID_BEAR_FORM;
+                case FORM_CAT:
+                    return DRUID_CAT_FORM;
+            }
+
+            return CLASS_DRUID;
+        }
+
+        void warstomp(uint32 diff)
+        {
+            if (me->getRace() != RACE_TAUREN) return;
+            if (IsSpellReady(WARSTOMP_1, diff, false)) return;
+            if (me->GetShapeshiftForm() != FORM_NONE)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+            {
+                Unit* u = me->SelectNearestTarget(5);
+                if (u && u->IsInCombat() && u->isTargetableForAttack())
+                {
+                    if (doCast(me, WARSTOMP_1))
+                    {
+                        SetSpellCooldown(WARSTOMP_1, 30000); //30sec
+                        return;
+                    }
+                }
+            }
+            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if (!(*iter)->isTargetableForAttack()) continue;
+                if (me->GetDistance((*iter)) <= 5)
+                {
+                    if (doCast(me, WARSTOMP_1))
+                        SetSpellCooldown(WARSTOMP_1, 30000); //30sec
+                }
+            }
+        }
+
+        bool DamagePossible()
+        {
+            return true;
+            //return (GetManaPCT(me) < 30 || GetHealthPCT(master) < 50);
+            /*if (GetHealthPCT(master) < 75 || GetHealthPCT(me) < 75) return false;
+
+            if (Group* pGroup = master->GetGroup())
+            {
+                uint8 LHPcount = 0;
+                uint8 DIScount = 0;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75)
+                        ++LHPcount;
+                    Unit::AuraApplicationMap const& auras = tPlayer->GetAppliedAuras();
+                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                        if (itr->second->GetBase()->GetSpellInfo()->Dispel == DISPEL_POISON)
+                            ++DIScount;
+                }
+                uint8 members = master->GetGroup()->GetMembersCount();
+
+                if (members > 10)
+                {
+                    if (LHPcount > 1 || DIScount > 2) return false;
+                }
+                if (members > 4)
+                {
+                    if (LHPcount > 0 || DIScount > 1) return false;
+                }
+                if (members < 5)
+                {
+                    if (LHPcount > 0 || DIScount > 0) return false;
+                }
+            }//endif unitlist
+
+            Unit* u = master->GetVictim();
+            if (master->getAttackers().size() > 4 ||
+              (!master->getAttackers().empty() &&
+                u != NULL && u->GetHealth() > me->GetMaxHealth()*17))
+                return false;
+
+            return true;*/
+        }
+
+        void removeFeralForm(bool force = false, bool init = true, uint32 diff = 0)
+        {
+            if (!force && formtimer > diff) return;
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                    case FORM_DIREBEAR:
+                    case FORM_BEAR:
+                        me->RemoveAurasDueToSpell(GetSpell(BEAR_FORM_1));
+                        break;
+                    case FORM_CAT:
+                        me->RemoveAurasDueToSpell(GetSpell(CAT_FORM_1));
+                        me->RemoveAurasDueToSpell(ENERGIZE);
+                        break;
+                    default:
+                        break;
+                }
+                setStats(CLASS_DRUID, init);
+            }
+        }
+
+        bool IsMelee() const
+        {
+            if (GetBotStance() == DRUID_BEAR_FORM || GetBotStance() == DRUID_CAT_FORM)
+                return true;
+
+            return bot_ai::IsMelee();
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void doBearActions(uint32 diff)
+        {
+            if (me->getPowerType() != POWER_RAGE) return;
+
+            if (GetHealthPCT(me) < 75)
+                if (HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (IsSpellReady(MANGLE_BEAR_1, diff) && HasRole(BOT_ROLE_DPS) && rage >= 150 && Rand() < 35 &&
+                doCast(opponent, GetSpell(MANGLE_BEAR_1)))
+            {
+                SetSpellCooldown(MANGLE_BEAR_1, 6000);
+                return;
+            }
+
+            if (IsSpellReady(SWIPE_1, diff) && HasRole(BOT_ROLE_DPS) && rage >= 150 && Rand() < 75 &&
+                doCast(opponent, GetSpell(SWIPE_1)))
+                return;
+
+        }//end doBearActions
+
+        void doCatActions(uint32 diff)
+        {
+            if (me->getPowerType() != POWER_ENERGY) return;
+
+            if (GetHealthPCT(me) < 75)
+                if (HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+
+            uint32 energy = me->GetPower(POWER_ENERGY);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (IsSpellReady(MANGLE_CAT_1, diff) && energy > 45 && HasRole(BOT_ROLE_DPS) && Rand() < 35 &&
+                doCast(opponent, GetSpell(MANGLE_CAT_1)))
+            {
+                SetSpellCooldown(MANGLE_CAT_1, 6000);
+                return;
+            }
+            if (IsSpellReady(RAKE_1, diff) && energy > 40 && HasRole(BOT_ROLE_DPS) && Rand() < 30 &&
+                doCast(opponent, GetSpell(RAKE_1)))
+            {
+                SetSpellCooldown(RAKE_1, 10000);
+                return;
+            }
+            if (IsSpellReady(SHRED_1, diff) && energy > 60 && HasRole(BOT_ROLE_DPS) && !opponent->HasInArc(M_PI, me) && Rand() < 50 &&
+                doCast(opponent, GetSpell(SHRED_1)))
+            {
+                SetSpellCooldown(SHRED_1, 12000);
+                return;
+            }
+            if (IsSpellReady(RIP_1, diff) && energy > 30 && HasRole(BOT_ROLE_DPS) && Rand() < 30 &&
+                doCast(opponent, GetSpell(RIP_1)))
+            {
+                SetSpellCooldown(RIP_1, 15000);
+                return;
+            }
+            if (IsSpellReady(CLAW_1, diff) && energy > 45 && HasRole(BOT_ROLE_DPS) && Rand() < 80 &&
+                doCast(opponent, GetSpell(CLAW_1)))
+                return;
+        }//end doCatActions
+
+        void doBalanceActions(uint32 diff)
+        {
+            removeFeralForm(true, true);
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            //range check to prevent fake casts
+            if (me->GetExactDist(opponent) > 30 || !DamagePossible()) return;
+
+            if (IsSpellReady(HURRICANE_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && Rand() < 35)
+            {
+                Unit* target = FindAOETarget(30, true);
+                if (target && doCast(target, GetSpell(HURRICANE_1)))
+                {
+                    SetSpellCooldown(HURRICANE_1, 5000);
+                    return;
+                }
+                SetSpellCooldown(HURRICANE_1, 2000); //fail
+            }
+            if (uint32 FAERIE_FIRE = GetSpell(FAERIE_FIRE_1))
+            {
+                if (GC_Timer <= diff &&
+                    opponent->getAttackers().size() > 1 &&//check if faerie fire is not useless 50/50
+                    Rand() < 20 && !HasAuraName(opponent, FAERIE_FIRE_1))
+                {
+                    if (doCast(opponent, FAERIE_FIRE))
+                        return;
+                }
+            }
+            if (IsSpellReady(MOONFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 20 &&
+                !HasAuraName(opponent, MOONFIRE_1, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(MOONFIRE_1)))
+                {
+                    SetSpellCooldown(MOONFIRE_1, 5000);
+                    return;
+                }
+            }
+            if (IsSpellReady(STARFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(STARFIRE_1)))
+                {
+                    SetSpellCooldown(STARFIRE_1, 11000);
+                    return;
+                }
+            }
+            if (IsSpellReady(WRATH_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
+            {
+                if (doCast(opponent, GetSpell(WRATH_1)))
+                {
+                    SetSpellCooldown(WRATH_1, uint32(sSpellMgr->GetSpellInfo(GetSpell(WRATH_1))->CalcCastTime()/100 * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 1));
+                    return;
+                }
+            }
+        }
+
+        bool MassGroupHeal(Player* gPlayer, uint32 diff)
+        {
+            if (!gPlayer || GC_Timer > diff) return false;
+            if (IsCasting()) return false; // if I'm already casting
+            bool tranq = IsSpellReady(TRANQUILITY_1, diff, false);
+            bool growt = IsSpellReady(WILD_GROWTH_1, diff, false);
+            if (!tranq && !growt) return false;
+            if (Rand() > 30) return false;
+            Group* pGroup = gPlayer->GetGroup();
+            if (!pGroup) return false;
+            uint8 LHPcount = 0;
+            uint8 pct = 100;
+            Unit* healTarget = NULL;
+            for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->GetMapId() != me->GetMapId() ||
+                    (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+                if (me->GetExactDist(tPlayer) > 39) continue;
+                if (GetHealthPCT(tPlayer) < 80)
+                {
+                    if (GetHealthPCT(tPlayer) < pct)
+                    {
+                        pct = GetHealthPCT(tPlayer);
+                        healTarget = tPlayer;
+                    }
+                    ++LHPcount;
+                    if (LHPcount > 2) break;
+                }
+                if (tPlayer->HaveBot())
+                {
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && bot->IsInWorld() && bot->GetExactDist(me) < 40 && GetHealthPCT(bot) < 80)
+                        {
+                            if (GetHealthPCT(bot) < pct)
+                            {
+                                pct = GetHealthPCT(bot);
+                                healTarget = bot;
+                            }
+                            ++LHPcount;
+                            if (LHPcount > 2) break;
+                        }
+                    }
+                }
+            }
+            if (LHPcount > 2 && tranq &&
+                doCast(me, GetSpell(TRANQUILITY_1)))
+            {
+                SetSpellCooldown(TRANQUILITY_1, 60000);
+                return true;
+            }
+            if (LHPcount > 0 && growt && healTarget &&
+                doCast(healTarget, GetSpell(WILD_GROWTH_1)))
+            {
+                SetSpellCooldown(WILD_GROWTH_1, 6000);
+                return true;
+            }
+            return false;
+        }//end MassGroupHeal
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if ((me->GetShapeshiftForm() == FORM_DIREBEAR || me->GetShapeshiftForm() == FORM_BEAR) &&
+                me->getPowerType() != POWER_RAGE)
+                me->setPowerType(POWER_RAGE);
+            if (me->GetShapeshiftForm() == FORM_CAT && me->getPowerType() != POWER_ENERGY)
+                me->setPowerType(POWER_ENERGY);
+            if (me->GetShapeshiftForm() == FORM_NONE && me->getPowerType() != POWER_MANA)
+                me->setPowerType(POWER_MANA);
+            if (IAmDead()) return;
+            CheckAttackState();
+
+            if (me->GetShapeshiftForm() == FORM_DIREBEAR || me->GetShapeshiftForm() == FORM_BEAR)
+            {
+                rage = me->GetPower(POWER_RAGE);
+                if (ragetimer2 <= diff)
+                {
+                    if (me->IsInCombat() && me->getLevel() >= 30)
+                    {
+                        if (rage < 990)
+                            me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
+                        else
+                            me->SetPower(POWER_RAGE, 1000);
+                    }
+                    ragetimer2 = 2000;
+                }
+                if (ragetimer <= diff)
+                {
+                    if (!me->IsInCombat())
+                    {
+                        if (rage > 10.f*rageLossMult)
+                            me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult)); //-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0);
+                    }
+                    ragetimer = 1500;
+                    if (rage > 1000) me->SetPower(POWER_RAGE, 1000);
+                    if (rage < 10) me->SetPower(POWER_RAGE, 0);
+                }
+            }
+            if (clearcast && me->HasAura(OMEN_OF_CLARITY_BUFF) && !me->IsNonMeleeSpellCast(false))
+            {
+                me->ModifyPower(power, cost);
+                me->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+            warstomp(diff);
+
+            if (Potion_cd <= diff && me->getPowerType() == POWER_MANA && GetManaPCT(me) < 20)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            //Heal master
+            if (GetHealthPCT(master) < 85)
+                HealTarget(master, GetHealthPCT(master), diff);
+            //Innervate
+            doInnervate(diff);
+
+            MassGroupHeal(master, diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                CheckBattleRez(diff);
+            BuffAndHealGroup(master, diff);
+            //CureTarget(master, GetSpell(CURE_POISON_1), diff);
+            CureGroup(master, GetSpell(CURE_POISON_1), diff);
+
+            if (!CheckAttackTarget(CLASS_DRUID))
+                return;
+
+            //debug
+            opponent = me->GetVictim();
+
+            if (GetHealthPCT(me) < 75)
+            {
+                HealTarget(me, GetHealthPCT(me), diff);
+                return;
+            }
+
+            if (IsCasting()) return; //Casting heal or something
+            CheckRoots(diff);
+
+            if (DamagePossible() && opponent != NULL)
+            {
+                Unit* u = opponent->GetVictim();
+                //if the target is attacking us, we want to go bear
+                if (GetSpell(BEAR_FORM_1) && !CCed(opponent) &&
+                    ((u == me || (IsTank() && IsInBotParty(u))) ||
+                    (!me->getAttackers().empty() && (*me->getAttackers().begin()) == opponent && opponent->GetMaxHealth() > me->GetMaxHealth()*2)))
+                {
+                    //if we don't have bear yet
+                    if (me->GetShapeshiftForm() != FORM_DIREBEAR &&
+                        me->GetShapeshiftForm() != FORM_BEAR &&
+                        formtimer <= diff &&
+                        doCast(me, GetSpell(BEAR_FORM_1)))
+                    {
+                        setStats(DRUID_BEAR_FORM);
+                        formtimer = 1500;
+                    }
+                    if (me->GetShapeshiftForm() == FORM_DIREBEAR ||
+                        me->GetShapeshiftForm() == FORM_BEAR)
+                        doBearActions(diff);
+                }
+                else
+                if (GetSpell(CAT_FORM_1) && master->GetVictim() != opponent && u &&
+                    IsTank(u) && u != me &&
+                    opponent->GetMaxHealth() < u->GetMaxHealth()*3)
+                {
+                    //if we don't have cat yet
+                    if (me->GetShapeshiftForm() != FORM_CAT && formtimer <= diff)
+                    {
+                        if (doCast(me, GetSpell(CAT_FORM_1)))
+                        {
+                            setStats(DRUID_CAT_FORM);
+                            formtimer = 1500;
+                        }
+                    }
+                    if (me->GetShapeshiftForm() == FORM_CAT)
+                        doCatActions(diff);
+                }
+                else if (!IsTank())
+                    doBalanceActions(diff);
+            }
+            else if (!IsTank())
+                doBalanceActions(diff);
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (hp > 95) return false;
+            if (!target || target->isDead()) return false;
+            if (IsTank() && hp > 35) return false;
+            if (hp > 50 && me->GetShapeshiftForm() != FORM_NONE) return false; //do not waste heal if in feral or so
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid() - 50*me->GetShapeshiftForm()) return false;
+            if (me->GetExactDist(target) > 40) return false;
+
+            if (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) &&
+                (hp < 15 || (hp < 35 && target->getAttackers().size() > 2)) &&
+                (target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(me, GetSpell(NATURES_SWIFTNESS_1)) && RefreshAura(CRIT_50, 2))
+                {
+                    swiftness = true;
+                    SetSpellCooldown(NATURES_SWIFTNESS_1, 120000); //2 min
+                    if (doCast(target, GetSpell(HEALING_TOUCH_1), true))
+                        Heal_Timer = 3000;
+                    return true;
+                }
+            }
+            if (IsSpellReady(SWIFTMEND_1, diff, false, 3000) &&
+                (hp < 25 || GetLostHP(target) > 5000) &&
+                (HasAuraName(target, REGROWTH_1) || HasAuraName(target, REJUVENATION_1)))
+            {
+                if (doCast(target, GetSpell(SWIFTMEND_1)))
+                {
+                    SetSpellCooldown(SWIFTMEND_1, 10000);
+                    if (GetHealthPCT(target) > 75)
+                        return true;
+                    else if (!target->getAttackers().empty())
+                    {
+                        if (doCast(target, GetSpell(REGROWTH_1)))
+                        {
+                            GC_Timer = 300;
+                            return true;
+                        }
+                    }
+                }
+            }
+            if (hp > 35 && (hp < 75 || GetLostHP(target) > 3000) && Heal_Timer <= diff && GetSpell(NOURISH_1))
+            {
+                switch (urand(1,3))
+                {
+                    case 1:
+                    case 2:
+                        if (doCast(target, GetSpell(NOURISH_1)))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                    case 3:
+                        if (doCast(target, GetSpell(HEALING_TOUCH_1)))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                }
+            }
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = IsTank(target) && boss;
+            bool regrowth = IsSpellReady(REGROWTH_1, diff);
+            if ( ( (hp < 80 || GetLostHP(target) > 3500 || tanking) &&
+                regrowth && !HasAuraName(target, REGROWTH_1, me->GetGUID()) )
+                ||
+                (HasAuraName(target, REGROWTH_1, me->GetGUID()) && HasAuraName(target, REJUVENATION_1, me->GetGUID()) &&
+                (hp < 70 || GetLostHP(target) > 3000) && regrowth))
+            {
+                if (doCast(target, GetSpell(REGROWTH_1)))
+                {
+                    SetSpellCooldown(REGROWTH_1, 2000);
+                    return true;
+                }
+            }
+            if (GetSpell(REJUVENATION_1) && GC_Timer <= diff && hp > 25 &&
+                (hp < 90 || GetLostHP(target) > 2000 || tanking) &&
+                !HasAuraName(target, REJUVENATION_1, me->GetGUID()))
+            {
+                if (doCast(target, GetSpell(REJUVENATION_1)))
+                {
+                    if (!target->getAttackers().empty() && (hp < 75 || GetLostHP(target) > 4000))
+                        if (IsSpellReady(SWIFTMEND_1, diff, false) && doCast(target, GetSpell(SWIFTMEND_1)))
+                            SetSpellCooldown(SWIFTMEND_1, 10000);
+                    GC_Timer = 500;
+                    return true;
+                }
+            }
+            if (IsSpellReady(LIFEBLOOM_1, diff) &&
+                ((hp < 85 && hp > 40) || (hp > 70 && tanking) ||
+                (hp < 70 && hp > 25 && HasAuraName(target, REGROWTH_1) && HasAuraName(target, REJUVENATION_1)) ||
+                (GetLostHP(target) > 1500 && hp > 35)))
+            {
+                Aura* bloom = target->GetAura(GetSpell(LIFEBLOOM_1), me->GetGUID());
+                if ((!bloom || bloom->GetStackAmount() < 3) && doCast(target, GetSpell(LIFEBLOOM_1)))
+                    return true;
+            }
+            if (hp > 30 && (hp < 70 || GetLostHP(target) > 3000) && Heal_Timer <= diff &&
+                doCast(target, GetSpell(HEALING_TOUCH_1)))
+            {
+                Heal_Timer = 3000;
+                return true;
+            }
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 20) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (target && target->IsAlive() && me->GetExactDist(target) < 30)
+            {
+                if (uint32 MARK_OF_THE_WILD = GetSpell(MARK_OF_THE_WILD_1))
+                    if (!HasAuraName(target, MARK_OF_THE_WILD_1))
+                        if (doCast(target, MARK_OF_THE_WILD))
+                            return true;
+                if (uint32 THORNS = GetSpell(THORNS_1))
+                    if (!HasAuraName(target, THORNS_1))
+                        if (doCast(target, THORNS))
+                            return true;
+            }
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || IsCasting() || me->IsMounted()) return;
+
+            RezGroup(GetSpell(REVIVE_1), master);
+
+            //if (Feasting()) return;
+
+            //if (BuffTarget(master, diff))
+            //{
+            //    /*GC_Timer = 800;*/
+            //    return;
+            //}
+            //if (BuffTarget(me, diff))
+            //{
+            //    /*GC_Timer = 800;*/
+            //    return;
+            //}
+        }
+
+        void doInnervate(uint32 diff, uint8 minmanaval = 30)
+        {
+            if (!IsSpellReady(INNERVATE_1, diff) || Rand() > 15)
+                return;
+            if (me->GetShapeshiftForm() != FORM_NONE && (IsTank() || me->getAttackers().size() > 3))
+                return;
+
+            uint32 INNERVATE = GetSpell(INNERVATE_1);
+            Unit* iTarget = NULL;
+
+            if (master->IsInCombat() && master->getPowerType() == POWER_MANA &&
+                GetManaPCT(master) < 20 && !master->HasAura(INNERVATE))
+                iTarget = master;
+            else if (me->IsInCombat() && me->getPowerType() == POWER_MANA &&
+                GetManaPCT(me) < 20 && !me->HasAura(INNERVATE))
+                iTarget = me;
+
+            Group* group = master->GetGroup();
+            if (!iTarget && !group) //first check master's bots
+            {
+                for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+                {
+                    Creature* bot = master->GetBotMap(i)->_Cre();
+                    if (!bot || !bot->IsInCombat() || bot->isDead()) continue;
+                    if (me->GetExactDist(bot) > 30) continue;
+                    if (bot->getPowerType() != POWER_MANA) continue;
+                    if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                    {
+                        iTarget = bot;
+                        break;
+                    }
+                }
+            }
+            if (!iTarget && group) //cycle through player members...
+            {
+                for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (tPlayer == NULL || !tPlayer->IsInWorld() || !tPlayer->IsInCombat() || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (tPlayer->getPowerType() != POWER_MANA) continue;
+                    if (GetManaPCT(tPlayer) < minmanaval && !tPlayer->HasAura(INNERVATE))
+                    {
+                        iTarget = tPlayer;
+                        break;
+                    }
+                    if (iTarget)
+                        break;
+                }
+            }
+            if (!iTarget && group) //... and their bots.
+            {
+                for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (!bot || bot->isDead()) continue;
+                        if (me->GetExactDist(bot) > 30) continue;
+                        if (bot->getPowerType() != POWER_MANA) continue;
+                        if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                        {
+                            iTarget = bot;
+                            break;
+                        }
+                    }
+                    if (iTarget)
+                        break;
+                }
+            }
+
+            //fail
+            if (!iTarget)
+            {
+                SetSpellCooldown(INNERVATE_1, 3000);
+                return;
+            }
+
+            if (doCast(iTarget, INNERVATE))
+            {
+                if (iTarget->GetTypeId() == TYPEID_PLAYER)
+                    me->Whisper("Innervate on You!", LANG_UNIVERSAL, iTarget->ToPlayer());
+                else
+                {
+                    std::ostringstream msg;
+                    msg << "Innervate on " << (iTarget == me ? "myself" : iTarget->GetName()) << '!';
+                    me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master);
+                }
+
+                SetSpellCooldown(INNERVATE_1, iTarget->GetTypeId() == TYPEID_PLAYER ? 60000 : 20000); //1 min if player and 20 sec if bot
+            }
+        }
+
+        void CheckRoots(uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 35) return;
+            if (me->GetShapeshiftForm() != FORM_NONE) return;
+            uint32 ENTANGLING_ROOTS = GetSpell(ENTANGLING_ROOTS_1);
+            if (!ENTANGLING_ROOTS) return;
+            if (FindAffectedTarget(ENTANGLING_ROOTS, me->GetGUID(), 60)) return;
+            if (Unit* target = FindRootTarget(30, ENTANGLING_ROOTS))
+                if (doCast(target, ENTANGLING_ROOTS))
+                    return;
+        }
+
+        void CheckBattleRez(uint32 diff)
+        {
+            if (!IsSpellReady(REBIRTH_1, diff, false) || me->IsMounted() || IsCasting() || Rand() > 10) return;
+
+            Group* gr = master->GetGroup();
+            if (!gr)
+            {
+                Unit* target = master;
+                if (master->IsAlive()) return;
+                if (master->isResurrectRequested()) return; //ressurected
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)master->GetCorpse();
+                if (!target || !target->IsInWorld())
+                    return;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+                    SetSpellCooldown(REBIRTH_1, 1500);
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    me->Whisper("Rezzing You", LANG_UNIVERSAL, master);
+                    SetSpellCooldown(REBIRTH_1, me->getLevel() >= 60 ? 300000 : 600000); //5-10 min (improved possible)
+                }
+                return;
+            }
+            for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                Unit* target = tPlayer;
+                if (!tPlayer || tPlayer->IsAlive()) continue;
+                if (tPlayer->isResurrectRequested()) continue; //ressurected
+                if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)tPlayer->GetCorpse();
+                if (!target || !target->IsInWorld()) continue;
+                if (master->GetMap() != target->FindMap()) continue;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(target->GetMapId(), *target);
+                    SetSpellCooldown(REBIRTH_1, 1500);
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    me->Whisper("Rezzing You", LANG_UNIVERSAL, tPlayer);
+                    SetSpellCooldown(REBIRTH_1, me->getLevel() >= 60 ? 300000 : 600000); //5-10 min (improved possible)
+                    return;
+                }
+            }
+        }
+
+        void setStats(uint8 form, bool init = true)
+        {
+            switch (form)
+            {
+                case DRUID_BEAR_FORM:
+                    me->SetBotClass(DRUID_BEAR_FORM);
+                    if (me->getPowerType() != POWER_RAGE)
+                    {
+                        me->setPowerType(POWER_RAGE);
+                        me->SetMaxPower(POWER_RAGE, 1000);
+                    }
+                    if (me->getLevel() >= 15)
+                        me->SetPower(POWER_RAGE, 200);
+                    else
+                        me->SetPower(POWER_RAGE, 0);
+                    if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK))
+                        RefreshAura(LEADER_OF_THE_PACK);
+                    break;
+                case DRUID_CAT_FORM:
+                    me->SetBotClass(DRUID_CAT_FORM);
+                    if (me->getPowerType() != POWER_ENERGY)
+                    {
+                        me->setPowerType(POWER_ENERGY);
+                        me->SetMaxPower(POWER_ENERGY, 100);
+                        me->SetPower(POWER_ENERGY, 0);
+                    }
+                    if (me->getLevel() >= 15)
+                        me->SetPower(POWER_ENERGY, 60);
+                    else
+                        me->SetPower(POWER_ENERGY, 0);
+                    if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK))
+                        RefreshAura(LEADER_OF_THE_PACK);
+                    RefreshAura(ENERGIZE, me->getLevel()/40 + master->Has310Flyer(false));
+                    break;
+                case CLASS_DRUID:
+                    me->SetBotClass(CLASS_DRUID);
+                    if (me->getPowerType() != POWER_MANA)
+                        me->setPowerType(POWER_MANA);
+                    if (init)
+                        me->SetPower(POWER_MANA, mana);
+                    break;
+            }
+
+            SetStats(false);
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            formtimer = 0;
+
+            clearcast = false;
+            swiftness = false;
+
+            power = POWER_MANA;
+
+            mana = 0;
+            rage = 0;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+
+            ragetimer = 0;
+            ragetimer2 = 0;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_DRUID);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+            if (Heal_Timer > diff)                  Heal_Timer -= diff;
+            if (formtimer > diff)                   formtimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+
+            InitSpellMap(WARSTOMP_1, true);
+
+            InitSpellMap(MARK_OF_THE_WILD_1);
+            InitSpellMap(THORNS_1);
+            InitSpellMap(HEALING_TOUCH_1);
+            InitSpellMap(REGROWTH_1);
+            InitSpellMap(REJUVENATION_1);
+            InitSpellMap(LIFEBLOOM_1);
+            InitSpellMap(NOURISH_1);
+     /*tal*/lvl >= 60 ? InitSpellMap(WILD_GROWTH_1) : RemoveSpell(WILD_GROWTH_1);
+     /*tal*/lvl >= 40 ? InitSpellMap(SWIFTMEND_1) : RemoveSpell(SWIFTMEND_1);
+            InitSpellMap(TRANQUILITY_1);
+            InitSpellMap(REVIVE_1);
+            InitSpellMap(REBIRTH_1);
+            InitSpellMap(BEAR_FORM_1);
+            InitSpellMap(SWIPE_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_BEAR_1) : RemoveSpell(MANGLE_BEAR_1);
+            InitSpellMap(BASH_1);
+            InitSpellMap(CAT_FORM_1);
+            InitSpellMap(CLAW_1);
+            InitSpellMap(RAKE_1);
+            InitSpellMap(SHRED_1);
+            InitSpellMap(RIP_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_CAT_1) : RemoveSpell(MANGLE_CAT_1);
+            InitSpellMap(MOONFIRE_1);
+            InitSpellMap(STARFIRE_1);
+            InitSpellMap(WRATH_1);
+            InitSpellMap(HURRICANE_1);
+            InitSpellMap(FAERIE_FIRE_1);
+            InitSpellMap(CURE_POISON_1);
+            InitSpellMap(INNERVATE_1);
+            InitSpellMap(ENTANGLING_ROOTS_1);
+     /*tal*/lvl >= 30 ? InitSpellMap(NATURES_SWIFTNESS_1) : RemoveSpell(NATURES_SWIFTNESS_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 78)
+                RefreshAura(SPELLDMG2, 3); //+18%
+            else if (level >= 65)
+                RefreshAura(SPELLDMG2, 2); //+12%
+            else if (level >= 50)
+                RefreshAura(SPELLDMG2); //+6%
+            if (level >= 45)
+                RefreshAura(NATURAL_PERFECTION3); //4%
+            else if (level >= 43)
+                RefreshAura(NATURAL_PERFECTION2); //3%
+            else if (level >= 41)
+                RefreshAura(NATURAL_PERFECTION1); //2%
+            if (level >= 50)
+                RefreshAura(LIVING_SEED3); //100%
+            else if (level >= 48)
+                RefreshAura(LIVING_SEED2); //66%
+            else if (level >= 46)
+                RefreshAura(LIVING_SEED1); //33%
+            if (level >= 55)
+                RefreshAura(REVITALIZE3, 5); //75% (15%)x5
+            else if (level >= 53)
+                RefreshAura(REVITALIZE2, 3); //30% (10%)x3
+            else if (level >= 51)
+                RefreshAura(REVITALIZE1, 3); //15%  (5%)x3
+            if (level >= 70)
+                RefreshAura(OMEN_OF_CLARITY, 3); //x3
+            else if (level >= 40)
+                RefreshAura(OMEN_OF_CLARITY, 2); //x2
+            else if (level >= 20)
+                RefreshAura(OMEN_OF_CLARITY); //x1
+            if (level >= 45)
+                RefreshAura(GLYPH_SWIFTMEND); //no comsumption
+            if (level >= 40)
+                RefreshAura(GLYPH_INNERVATE); //no comsumption
+            if (level >= 20)
+                RefreshAura(NATURESGRACE);
+            if (level >= 78)
+            {
+                RefreshAura(T9_RESTO_P4_BONUS);
+                RefreshAura(T8_RESTO_P4_BONUS);
+                RefreshAura(T9_BALANCE_P2_BONUS);
+                RefreshAura(T10_BALANCE_P2_BONUS);
+                RefreshAura(T10_BALANCE_P4_BONUS);
+            }
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case MARK_OF_THE_WILD_1:
+                case THORNS_1:
+                case HEALING_TOUCH_1:
+                case REJUVENATION_1:
+                case LIFEBLOOM_1:
+                case REGROWTH_1:
+                case NOURISH_1:
+                case WILD_GROWTH_1:
+                case SWIFTMEND_1:
+                case TRANQUILITY_1:
+                case CURE_POISON_1:
+                case INNERVATE_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Timers/other
+/*Heal*/uint32 Heal_Timer;
+/*Misc*/uint32 formtimer, ragetimer, ragetimer2;
+/*Chck*/bool clearcast, swiftness;
+/*Misc*/Powers power; uint32 mana, rage;
+/*Misc*/float rageIncomeMult, rageLossMult;
+
+        enum DruidBaseSpells
+        {
+            MARK_OF_THE_WILD_1                  = 1126,
+            THORNS_1                            = 467,
+            HEALING_TOUCH_1                     = 5185,
+            REGROWTH_1                          = 8936,
+            REJUVENATION_1                      = 774,
+            LIFEBLOOM_1                         = 33763,
+            NOURISH_1                           = 50464,
+     /*tal*/WILD_GROWTH_1                       = 48438,
+     /*tal*/SWIFTMEND_1                         = 18562,
+            TRANQUILITY_1                       = 740,
+            REVIVE_1                            = 50769,
+            REBIRTH_1                           = 20484,
+            BEAR_FORM_1                         = 5487,
+            SWIPE_1                             = 779,
+     /*tal*/MANGLE_BEAR_1                       = 33878,
+            BASH_1                              = 5211,
+            CAT_FORM_1                          = 768,
+            CLAW_1                              = 1082,
+            RAKE_1                              = 1822,
+            SHRED_1                             = 5221,
+            RIP_1                               = 1079,
+     /*tal*/MANGLE_CAT_1                        = 33876,
+            MOONFIRE_1                          = 8921,
+            STARFIRE_1                          = 2912,
+            WRATH_1                             = 5176,
+            HURRICANE_1                         = 16914,
+            FAERIE_FIRE_1                       = 770,
+            CURE_POISON_1                       = 8946,
+            INNERVATE_1                         = 29166,
+            ENTANGLING_ROOTS_1                  = 339,
+     /*tal*/NATURES_SWIFTNESS_1                 = 17116,
+            WARSTOMP_1                          = 20549
+        };
+        enum DruidPassives
+        {
+        //Talents
+            OMEN_OF_CLARITY                     = 16864,//clearcast
+            NATURESGRACE                        = 61346,//haste 20% for 3 sec
+            NATURAL_PERFECTION1                 = 33881,
+            NATURAL_PERFECTION2                 = 33882,
+            NATURAL_PERFECTION3                 = 33883,
+            LIVING_SEED1                        = 48496,//rank 1
+            LIVING_SEED2                        = 48499,//rank 2
+            LIVING_SEED3                        = 48500,//rank 3
+            REVITALIZE1                         = 48539,//rank 1
+            REVITALIZE2                         = 48544,//rank 2
+            REVITALIZE3                         = 48545,//rank 3
+  /*Talent*/LEADER_OF_THE_PACK                  = 24932,
+        //Glyphs
+            GLYPH_SWIFTMEND                     = 54824,//no consumption
+            GLYPH_INNERVATE                     = 54832,//self regen
+        //other
+            T9_RESTO_P4_BONUS                   = 67128,//rejuve crits
+            T8_RESTO_P4_BONUS                   = 64760,//rejuve init heal
+            T9_BALANCE_P2_BONUS                 = 67125,//moonfire crits
+            T10_BALANCE_P2_BONUS                = 70718,//omen of doom (15%)
+            T10_BALANCE_P4_BONUS                = 70723,//Languish(DOT)
+            SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            SPELLDMG2/*Earth and Moon - druid*/ = 48511,//rank3 6% dam
+            ENERGIZE                            = 27787,//Rogue Armor Energize (chance: +35 energy on hit)
+            CRIT_50                             = 23434 //50% spell crit
+        };
+        enum DruidSpecial
+        {
+            HURRICANE_DAMAGE                    = 42231,
+  /*Talent*/LEADER_OF_THE_PACK_BUFF             = 24932,
+            //NATURESGRACEBUFF                    = 16886,
+            OMEN_OF_CLARITY_BUFF                = 16870 //434 deprecated
+        };
+    };
+};
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
new file mode 100644
index 0000000..922531a
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
@@ -0,0 +1,1167 @@
+#include "bot_ai.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+/*
+Hunter NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - around 35%
+TODO:
+*/
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new hunter_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct hunter_botAI : public bot_minion_ai
+    {
+        hunter_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_HUNTER) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit* u) { bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting() || Rand() > 35)
+                return;
+
+            Unit* target = NULL;
+
+            if (IsSpellReady(SCATTER_SHOT_1, diff, false, 10000) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
+            {
+                target = FindCastingTarget(15, 0, false, GetSpell(SCATTER_SHOT_1));
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(SCATTER_SHOT_1)))
+                {
+                    SetSpellCooldown(SCATTER_SHOT_1, 20000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            if (!target && IsSpellReady(WYVERN_STING_1, diff, true, 10000) && HasRole(BOT_ROLE_DPS) && Rand() < 70)
+            {
+                target = FindCastingTarget(35, 5, false, GetSpell(WYVERN_STING_1));
+                if (target && doCast(target, GetSpell(WYVERN_STING_1)))
+                {
+                    SetSpellCooldown(WYVERN_STING_1, 40000);
+                    return;
+                }
+            }
+            //if (!target && FREEZING_ARROW && Trap_cd <= 10000 && Rand() < 40)
+            //{
+            //    target = FindCastingTarget(40, 0, false, FREEZING_ARROW);
+            //    temptimer = GC_Timer;
+            //    if (target && doCast(target, FREEZING_ARROW))
+            //    {
+            //        Trap_cd = 20000;
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+            //}
+            if (!target && IsSpellReady(SCARE_BEAST_1, diff, true, 7500) && Rand() < 35)
+            {
+                target = FindCastingTarget(30, 0, false, GetSpell(SCARE_BEAST_1));
+                if (target && doCast(target, GetSpell(SCARE_BEAST_1)))
+                {
+                    SetSpellCooldown(SCARE_BEAST_1, 15000);
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            if (!target && IsSpellReady(SILENCING_SHOT_1, diff, false, 7500) && Rand() < 30)
+            {
+                target = FindCastingTarget(35, 5, false, GetSpell(SILENCING_SHOT_1));
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    SetSpellCooldown(SILENCING_SHOT_1, 15000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void CheckScatter(uint32 diff)
+        {
+            if (!IsSpellReady(SCATTER_SHOT_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 50)
+                return;
+
+            if (Unit* target = FindStunTarget(15))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SCATTER_SHOT_1)))
+                {
+                    SetSpellCooldown(SCATTER_SHOT_1, 20000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SCATTER_SHOT_1, 1000); //fail
+        }
+
+        void CheckWyvernSting(uint32 diff)
+        {
+            if (!IsSpellReady(WYVERN_STING_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 50)
+                return;
+
+            if (Unit* target = FindStunTarget(35))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(WYVERN_STING_1)))
+                {
+                    SetSpellCooldown(WYVERN_STING_1, 40000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(WYVERN_STING_1, 1000); //fail
+        }
+
+        void CheckFreezingArrow(uint32 diff)
+        {
+            //Freezing Trap shares cooldown with traps
+            if (!GetSpell(FREEZING_ARROW_1) || Trap_cd > diff || IsCasting() || Rand() > 75)
+                return;
+
+            if (Unit* target = FindStunTarget(40))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(FREEZING_ARROW_1)))
+                {
+                    GC_Timer = temptimer;
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+
+            Trap_cd = 1000; //fail
+        }
+
+        void CheckTraps(uint32 diff)
+        {
+            if (!GetSpell(FROST_TRAP_1) || Trap_cd > diff || IsCasting() || Rand() > 90)
+                return;
+
+            Unit* target = me->GetVictim();
+            if (!(target && me->GetDistance(target) < 6 && me->HasInArc(M_PI, target) &&
+                IsInBotParty(target->GetVictim())))
+                target = NULL;
+            if (!target)
+                target = FindAOETarget(3.f, true);
+
+            if (target)
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(FROST_TRAP_1)))
+                {
+                    GC_Timer = temptimer;
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+
+            Trap_cd = 500; //fail
+        }
+
+        void CheckScare(uint32 diff)
+        {
+            if (!IsSpellReady(SCARE_BEAST_1, diff) || IsCasting() || Rand() > 35)
+                return;
+
+            if (Unit* scareTarget = FindFearTarget())
+            {
+                if (doCast(scareTarget, GetSpell(SCARE_BEAST_1), true))
+                {
+                    SetSpellCooldown(SCARE_BEAST_1, 15000); //-50% for bot
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SCARE_BEAST_1, 1500); //fail
+        }
+
+        void CheckAspects(uint32 diff)
+        {
+            if (Aspect_Timer > diff || GC_Timer > diff || IsCasting() || Feasting() || Rand() > 35)
+                return;
+
+            uint32 ASPECT_OF_THE_VIPER = GetSpell(ASPECT_OF_THE_VIPER_1);
+            uint32 ASPECT_OF_THE_PACK = GetSpell(ASPECT_OF_THE_PACK_1);
+            if (!ASPECT_OF_THE_VIPER && !ASPECT_OF_THE_PACK)
+                return;
+
+            uint32 needaspect = 0;
+            uint8 pct = GetManaPCT(me);
+
+            if (ASPECT_OF_THE_VIPER && pct < 25)
+                needaspect = ASPECT_OF_THE_VIPER;
+            else if (ASPECT_OF_THE_PACK && (pct > 70 || !Aspect))
+                needaspect = ASPECT_OF_THE_PACK;
+
+            if (!needaspect || (needaspect == Aspect && HasAuraName(me, needaspect)))
+            {
+                Aspect_Timer = 2000;
+                return;
+            }
+
+            if (Aspect)
+                me->RemoveAurasDueToSpell(Aspect);
+
+            if (doCast(me, needaspect))
+            {
+                Aspect = needaspect;
+                GC_Timer = 800;
+                return;
+            }
+        }
+
+        void doDefend(uint32 diff)
+        {
+            //No GCD abilities
+            if (!IsSpellReady(FEIGN_DEATH_1, diff, false) && !IsSpellReady(DETERRENCE_1, diff, false))
+                return;
+            if (IsTank() || Rand() > 35)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+            bool cast = false;
+
+            if (b_attackers.size() == 1)
+            {
+                if (Creature* cre = (*b_attackers.begin())->ToCreature())
+                {
+                    if (cre->isWorldBoss() || cre->IsDungeonBoss() || cre->GetMaxHealth() > me->GetMaxHealth() * 10)
+                    {
+                        cast = true;
+                        //need feign death
+                        SetSpellCooldown(DETERRENCE_1, std::max<uint32>(GetSpellCooldown(DETERRENCE_1), diff + 500));
+                    }
+                }
+            }
+            else
+                cast = (uint8(b_attackers.size()) > (GetHealthPCT(me) > 20 ? 1 : 0));
+
+            if (!cast || b_attackers.empty())
+            {
+                //delay next try
+                SetSpellCooldown(FEIGN_DEATH_1, std::max<uint32>(GetSpellCooldown(FEIGN_DEATH_1), 1000));
+                SetSpellCooldown(DETERRENCE_1, std::max<uint32>(GetSpellCooldown(DETERRENCE_1), 1000));
+                return;
+            }
+
+            if (IsSpellReady(FEIGN_DEATH_1, diff, false) && (*b_attackers.begin())->getAttackers().size() > 1)
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(FEIGN_DEATH_1)))
+                {
+                    SetSpellCooldown(FEIGN_DEATH_1, 20000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(DETERRENCE_1, diff, false))
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(DETERRENCE_1)))
+                {
+                    SetSpellCooldown(DETERRENCE_1, 60000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void CheckAutoShot()
+        {
+            //Auto Shot is always present
+            //if (!AUTO_SHOT)
+            //    return;
+
+            Unit* target = me->GetVictim();
+            if (!target)
+                return;
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsCasting())
+                return;
+
+            if (Spell* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id != AUTO_SHOT_1)
+                {
+                    ////casting some other autorepeat spell, wtf?
+                    //TC_LOG_ERROR("entities.player", "CheckAutoShot(): Bot %s is casting autorepeatable spell %u (%s) during check!",
+                    //    me->GetName().c_str(), shot->GetSpellInfo()->Id, shot->GetSpellInfo()->SpellName[0]);
+                    return;
+                }
+                else if (shot->m_targets.GetUnitTarget() != target)
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+
+            float dist = me->GetExactDist(target);
+            if (dist < 5 || dist > 35)
+                return;
+
+            temptimer = GC_Timer;
+            if (doCast(target, AUTO_SHOT_1))
+            {
+                GC_Timer = temptimer;
+                return;
+            }
+        }
+
+        void CheckTranquil(uint32 diff)
+        {
+            if (!IsSpellReady(TRANQ_SHOT_1, diff, false) || Rand() > 35) //No GCD
+                return;
+
+            //First check current target
+            Unit* target = me->GetVictim();
+            if (target)
+            {
+                Unit::AuraMap const &auras = target->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                {
+                    SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+                    if (spellInfo->Dispel != DISPEL_MAGIC && spellInfo->Dispel != DISPEL_ENRAGE) continue;
+                    if (spellInfo->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(target->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        temptimer = GC_Timer;
+                        //me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                        if (doCast(target, GetSpell(TRANQ_SHOT_1)))
+                        {
+                            SetSpellCooldown(TRANQ_SHOT_1, 6000); //with glyph
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+
+            target = FindTranquilTarget();
+            if (target)
+            {
+                temptimer = GC_Timer;
+                //me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                if (doCast(target, GetSpell(TRANQ_SHOT_1)))
+                {
+                    SetSpellCooldown(TRANQ_SHOT_1, 6000); //with glyph
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(TRANQ_SHOT_1, 2000); //fail
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (!IsSpellReady(SILENCING_SHOT_1, diff, false) || IsCasting() || Rand() > 50) //No GCD
+                return;
+
+            Unit* target = me->GetVictim();
+            if (target && target->IsNonMeleeSpellCast(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    SetSpellCooldown(SILENCING_SHOT_1, 15000); //-5 sec for bot
+                    GC_Timer = temptimer;
+                    //return;
+                }
+
+                return; //succeed or failed, our hightest priority target casts spell and it must be interrupted above all else
+            }
+
+            target = FindCastingTarget(35, 5);
+            if (target)
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    SetSpellCooldown(SILENCING_SHOT_1, 15000); //-5 sec for bot
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SILENCING_SHOT_1, 1000); //fail
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (GetManaPCT(me) < 40 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            //Deterrence check
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
+            {
+                if (!me->isMoving())
+                    GetInPosition(true);
+                return;
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                doDefend(diff);
+
+            CheckAspects(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckTranquil(diff);
+                CheckSilence(diff);
+            }
+
+            if (!CheckAttackTarget(CLASS_HUNTER))
+            {
+                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                return;
+            }
+
+            DoRangedAttack(diff);
+        }
+
+        void DoRangedAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+
+            CheckAutoShot();
+            CheckScare(diff);
+            CheckScatter(diff);
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            //float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //special
+            if (IsSpellReady(SCATTER_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS) && meleedist < 15 && Rand() < 60)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(SCATTER_SHOT_1)))
+                {
+                    SetSpellCooldown(SCATTER_SHOT_1, 20000);
+                    GC_Timer = temptimer;
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                    me->AttackStop();
+                    return;
+                }
+            }
+
+            //MELEE SECTION
+            if (!(meleedist > 5))
+            {
+                //TRAPS
+                CheckTraps(diff);
+
+                //RAPTOR STRIKE
+                if (IsSpellReady(RAPTOR_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(opponent, GetSpell(RAPTOR_STRIKE_1), true))
+                    {
+                        SetSpellCooldown(RAPTOR_STRIKE_1, 6000);
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+                //WING CLIP
+                if (IsSpellReady(WING_CLIP_1, diff) && (!IsTank() || opponent->isMoving()) &&
+                    Rand() < 80 && !opponent->HasAuraWithMechanic(/*(1<<MECHANIC_SNARE)|*/(1<<MECHANIC_ROOT)))
+                {
+                    if (doCast(opponent, GetSpell(WING_CLIP_1)))
+                    {
+                        GC_Timer = 1000;
+                        return;
+                    }
+                }
+                //DISENGAGE
+                if (IsSpellReady(DISENGAGE_1, diff, false) && me->IsInCombat() && !IsTank() &&
+                    !me->getAttackers().empty() && me->HasInArc(M_PI, *me->getAttackers().begin()) && Rand() < 30)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(DISENGAGE_1)))
+                    {
+                        SetSpellCooldown(DISENGAGE_1, 16000); //improved, with glyph
+                        GC_Timer = temptimer;
+                    }
+                }
+
+                return; //don't try to do anything else in melee
+            }
+
+            //RANGED SECTION
+
+            //HUNTERS MARK
+            if (IsSpellReady(HUNTERS_MARK_1, diff, false) && Rand() < 25 &&
+                !HasAuraName(opponent, HUNTERS_MARK_1)) //100 yd range so don't check it
+            {
+                //Hunter's Mark has exclusive GCD
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(HUNTERS_MARK_1)))
+                {
+                    markTarget = opponent;
+                    SetSpellCooldown(HUNTERS_MARK_1, 2000); //1500 + 500 for bot
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+
+            //FREEZING ARROW
+            CheckFreezingArrow(diff);
+            CheckWyvernSting(diff);
+
+            //attack range check 1
+            if (!(meleedist < 45))
+                return;
+
+            //KILL SHOT //No GCD
+            if (IsSpellReady(KILL_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS) && GetHealthPCT(opponent) < 20 && Rand() < 95)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(KILL_SHOT_1)))
+                {
+                    SetSpellCooldown(KILL_SHOT_1, 8000); //with glyph
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            //attack range check 2
+            if (!(meleedist < 35))
+                return;
+
+            //CONCUSSIVE SHOT
+            if (IsSpellReady(CONCUSSIVE_SHOT_1, diff) && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(CONCUSSIVE_SHOT_1)))
+                {
+                    SetSpellCooldown(CONCUSSIVE_SHOT_1, 10000); //improved
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            //DISTRACTING SHOT
+            if (Unit* u = opponent->GetVictim())
+            {
+                if (IsSpellReady(DISTRACTING_SHOT_1, diff, false) && IsTank() && u != me && !CCed(opponent) &&
+                    Rand() < 75 && IsInBotParty(u))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(opponent, GetSpell(DISTRACTING_SHOT_1)))
+                    {
+                        SetSpellCooldown(DISTRACTING_SHOT_1, 8000);
+                        GC_Timer = temptimer;
+                    }
+                }
+            }
+            //BLACK ARROW //custom cd condition
+            //Black Arrow shares cooldown with traps, but we'll have it only partially
+            if (IsSpellReady(BLACK_ARROW_1, diff) && Trap_cd <= 10000 && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetMaxHealth()/3 && Rand() < 75)
+            {
+                if (doCast(opponent, GetSpell(BLACK_ARROW_1)))
+                {
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+            //RAPID FIRE
+            if (IsSpellReady(RAPID_FIRE_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetMaxHealth() / 2 && Rand() < 25)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(RAPID_FIRE_1)))
+                {
+                    SetSpellCooldown(RAPID_FIRE_1, 90000); //1.5 min for bot
+                    GC_Timer = temptimer;
+                }
+            }
+            //EXPLOSIVE SHOT
+            if (IsSpellReady(EXPLOSIVE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                if (doCast(opponent, GetSpell(EXPLOSIVE_SHOT_1)))
+                {
+                    SetSpellCooldown(EXPLOSIVE_SHOT_1, 6000);
+                    return;
+                }
+
+                SetSpellCooldown(EXPLOSIVE_SHOT_1, 500); //fail
+            }
+            //SCORPID STING //custom cd condition
+            if (uint32 SCORPID_STING = GetSpell(SCORPID_STING_1))
+            {
+                if (GC_Timer <= diff && (ScorpidSting_Timer <= diff || stingTargetGuid != opponent->GetGUID()))
+                {
+                    Aura* sSting = opponent->GetAura(SCORPID_STING);
+                    if (sSting && sSting->GetDuration() > 3000)
+                    {
+                        stingTargetGuid = opponent->GetGUID();
+                        SetSpellCooldown(SCORPID_STING_1, 2000);
+                    }
+                    else if (Rand() < 40 && doCast(opponent, SCORPID_STING))
+                    {
+                        stingTargetGuid = opponent->GetGUID();
+                        SetSpellCooldown(SCORPID_STING_1, 18000);
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+            }
+            //CHIMERA SHOT TODO:
+            if (IsSpellReady(CHIMERA_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && stingTargetGuid == opponent->GetGUID() &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) && Rand() < 30)
+            {
+                if (doCast(opponent, GetSpell(CHIMERA_SHOT_1)))
+                {
+                    SetSpellCooldown(CHIMERA_SHOT_1, 9000); //with glyph
+                    return;
+                }
+            }
+            //MULTI-SHOT
+            if (IsSpellReady(MULTISHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 60)
+            {
+                if (Unit* target = FindSplashTarget(35, opponent))
+                {
+                    if (doCast(target, GetSpell(MULTISHOT_1)))
+                    {
+                        SetSpellCooldown(MULTISHOT_1, 8000); //with glyph
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(MULTISHOT_1, 1000); //fail
+            }
+            //VOLLEY
+            if (IsSpellReady(VOLLEY_1, diff) && HasRole(BOT_ROLE_DPS) && !me->isMoving() && Rand() < 25)
+            {
+                if (Unit* target = FindAOETarget(35, true, false))
+                {
+                    if (doCast(target, GetSpell(VOLLEY_1)))
+                    {
+                        SetSpellCooldown(VOLLEY_1, 5000);
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(VOLLEY_1, 1000); //fail
+            }
+            //AIMED SHOT
+            if (IsSpellReady(AIMED_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(AIMED_SHOT_1)))
+                {
+                    SetSpellCooldown(AIMED_SHOT_1, 8000); //with glyph
+                    return;
+                }
+            }
+            //ARCANE SHOT
+            if (IsSpellReady(ARCANE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(ARCANE_SHOT_1)))
+                {
+                    SetSpellCooldown(ARCANE_SHOT_1, 6000);
+                    return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+
+                //Glyph of TrueShot Aura (req lvl 40): 10% additional critical chance for Aimed Shot
+                if (lvl >= 40 && spellId == GetSpell(AIMED_SHOT_1))
+                    aftercrit += 10.f;
+                //Improved Barrage: 12% additional critical chance for Multi-Shot and Aimed Shot
+                if (lvl >= 40 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(MULTISHOT_1)))
+                    aftercrit += 12.f;
+                //Survival Instincts: 4% additional critical chance for Arcane Shot, Steady Shot and Explosive Shot
+                if (lvl >= 15 && (spellId == GetSpell(ARCANE_SHOT_1)/* || spellId == GetSpell(STEADY_SHOT_1)*/ || spellId == GetSpell(EXPLOSIVE_SHOT_1)))
+                    aftercrit += 4.f;
+                //Sniper Training (part 1): 15% additional critical chance for Kill Shot
+                if (lvl >= 50 && spellId == GetSpell(KILL_SHOT_1))
+                    aftercrit += 15.f;
+                //Point of No Escape: 6% additional critical chance on victims of any kind of frost trap (crew this condition)
+                if (lvl >= 50)
+                    aftercrit += 6.f;
+
+                //Savage Strikes: 20% additional critical chance for Raptor Strike, Mongoose Bite and Counterattack
+                if (lvl >= 10 && (spellId == GetSpell(RAPTOR_STRIKE_1)/* || spellId == GetSpell(MONGOOSE_BITE_1) || spellId == GetSpell(COUNTERATTACK_1)*/))
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Mortal Shots: 30% crit damage bonus for all ranged abilities
+                if (lvl >= 15 && attackType == RANGED_ATTACK)
+                    pctbonus += 0.15f;
+                //Marked for Death (part 2): 10% crit damage bonus for Aimed Shot, Arcane Shot, Steady Shot, Kill Shot and Chimera Shot
+                if (lvl >= 55 &&
+                    (spellId == GetSpell(AIMED_SHOT_1) ||
+                    spellId == GetSpell(ARCANE_SHOT_1) ||
+                    //spellId == GetSpell(STEADY_SHOT_1) ||
+                    spellId == GetSpell(KILL_SHOT_1) ||
+                    spellId == GetSpell(CHIMERA_SHOT_1)))
+                    pctbonus += 0.05f;
+            }
+
+            //Ranged Weapon Specialization: 5% bonus damage for ranged attacks
+            if (lvl >= 35 && attackType == RANGED_ATTACK)
+                pctbonus += 0.05f;
+            //Improved Arcane Shot: 15% bonus damage for Arcane Shot
+            if (lvl >= 20 && spellId == GetSpell(ARCANE_SHOT_1))
+                pctbonus += 0.15f;
+            //Rapid Killing (buff): 20% bonus damage for Aimed Shot, Arcane Shot or Chimera Shot (removed in SpellHitTarget())
+            if (lvl >= 20 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(ARCANE_SHOT_1) || spellId == GetSpell(CHIMERA_SHOT_1)) &&
+                me->HasAura(RAPID_KILLING_BUFF))
+                pctbonus += 0.2f;
+            //Barrage: 12% bonus damage for Aimed Shot, Multi-Shot or Volley (removed in SpellHitTarget())
+            if (lvl >= 30 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(MULTISHOT_1) ||
+                spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(VOLLEY_DAMAGE_1))))
+                pctbonus += 0.12f;
+            //Marked for Death (part 1): 5% bonus damage for all ranged shots on marked target
+            if (lvl >= 55 && attackType == RANGED_ATTACK && damageinfo.target == markTarget)
+                pctbonus += 0.05f;
+            //T.N.T: 6% bonus damage for Explosive Shot (handled here) and Black Arrow (can be handler in ApplyClassDamageMultiplierEffect())
+            if (lvl >= 25 && spellId == GetSpell(EXPLOSIVE_SHOT_1))
+                pctbonus += 0.06f;
+            //Sniper Training (part 2): 6% bonus damage for Steady Shot, Aimed Shot, Black Arrow and Explosive Shot (screw aura stuff, just increase)
+            if (lvl >= 50 &&
+                (spellId == GetSpell(AIMED_SHOT_1) ||
+                //spellId == GetSpell(STEADY_SHOT_1) ||
+                //spellId == GetSpell(BLACK_ARROW_1) ||//cannot be handled here
+                spellId == GetSpell(EXPLOSIVE_SHOT_1)))
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+
+            //Thrill of the Hunt additive (stage 1): store mana restore value (50%) while ability crits
+            if (lvl >= 40)
+                (static_cast<ManaRestoreList>(TotH))[spellId] = crit && attackType == RANGED_ATTACK ? spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()) / 2 : 0;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            if (target == me)
+                return;
+
+            uint32 spellId = spell->Id;
+
+            //Thrill of the Hunt additive (stage 1): store mana restore value while ability crits
+            if (me->getLevel() >= 40 && TotH[spellId] > 0 && uint32(TotH[spellId]) < me->GetMaxPower(POWER_MANA))
+            {
+                me->EnergizeBySpell(me, THRILL_OF_THE_HUNT_EFFECT, TotH[spellId], POWER_MANA);
+                TotH[spellId] = 0;
+            }
+
+            if (spellId == GetSpell(WING_CLIP_1))
+            {
+                //zzzOLD Improved Wing Clip (only on creatures): 30% to root target with Wing Clip
+                //normal creatures are rooted for 10 sec, elites+ for 6 sec
+                if (target->GetTypeId() == TYPEID_UNIT)
+                {
+                    if (urand(1,100) <= 30)
+                    {
+                        uint32 clip = target->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_NORMAL ? IMPROVED_WING_CLIP_NORMAL : IMPROVED_WING_CLIP_EX;
+                        me->CastSpell(target, clip, true);
+                    }
+                }
+            }
+            if (spellId == GetSpell(CONCUSSIVE_SHOT_1))
+            {
+                //Improved Concussion Shot rank 2: 2 sec increased daze duration
+                if (Aura* concus = target->GetAura(spellId, me->GetGUID()))
+                {
+                    int32 dur = concus->GetDuration() + 2000;
+                    concus->SetDuration(dur);
+                    concus->SetMaxDuration(dur);
+                }
+
+                //zzzOLD Improved Concussion Shot: chance to stun target for 3 sec
+                if (urand(1,100) <= 15)
+                {
+                    me->CastSpell(target, IMPROVED_CONCUSSION, true);
+                }
+            }
+
+            //Rapid Killing: use up buff manually
+            if (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(ARCANE_SHOT_1) || spellId == GetSpell(CHIMERA_SHOT_1))
+            {
+                if (me->HasAura(RAPID_KILLING_BUFF))
+                    me->RemoveAura(RAPID_KILLING_BUFF, ObjectGuid::Empty, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(RAPID_FIRE_1))
+            {
+                //Rapid Fire (id 28755): 4 sec increased duration
+                if (Aura* rapid = me->GetAura(spellId))
+                {
+                    uint32 dur = rapid->GetDuration() + 4000;
+                    rapid->SetDuration(dur);
+                    rapid->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Trap_cd = 0;
+
+            ScorpidSting_Timer = 0;
+            Aspect_Timer = 0;
+
+            Aspect = 0;
+
+            stingTargetGuid = ObjectGuid::Empty;
+
+            markTarget = NULL;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_HUNTER);
+             }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (Trap_cd > diff)                     Trap_cd -= diff;
+
+            if (ScorpidSting_Timer > diff)          ScorpidSting_Timer -= diff;
+            if (Aspect_Timer > diff)                Aspect_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(AUTO_SHOT_1, true);
+            InitSpellMap(TRANQ_SHOT_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(SILENCING_SHOT_1) : RemoveSpell(SILENCING_SHOT_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(CHIMERA_SHOT_1) : RemoveSpell(CHIMERA_SHOT_1);
+            InitSpellMap(ARCANE_SHOT_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(AIMED_SHOT_1) : RemoveSpell(AIMED_SHOT_1);
+            InitSpellMap(KILL_SHOT_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(EXPLOSIVE_SHOT_1) : RemoveSpell(EXPLOSIVE_SHOT_1);
+            InitSpellMap(MULTISHOT_1);
+            InitSpellMap(VOLLEY_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(SCATTER_SHOT_1) : RemoveSpell(SCATTER_SHOT_1);
+            InitSpellMap(CONCUSSIVE_SHOT_1);
+            InitSpellMap(DISTRACTING_SHOT_1);
+            InitSpellMap(SCORPID_STING_1);
+            //InitSpellMap(VIPER_STING_1);
+            InitSpellMap(RAPID_FIRE_1);
+            InitSpellMap(WING_CLIP_1);
+            InitSpellMap(RAPTOR_STRIKE_1);
+            InitSpellMap(DISENGAGE_1);
+            InitSpellMap(FROST_TRAP_1);
+            InitSpellMap(FREEZING_ARROW_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(WYVERN_STING_1) : RemoveSpell(WYVERN_STING_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(BLACK_ARROW_1) : RemoveSpell(BLACK_ARROW_1);
+            InitSpellMap(HUNTERS_MARK_1);
+            InitSpellMap(SCARE_BEAST_1);
+            InitSpellMap(FEIGN_DEATH_1);
+            InitSpellMap(DETERRENCE_1);
+            //InitSpellMap(ASPECT_OF_THE_VIPER_1);
+  /*Custom*///ASPECT_OF_THE_PACK                      = ASPECT_OF_THE_VIPER ? ASPECT_OF_THE_PACK_1 : 0;
+  /*Custom*/lvl >= 20 ? InitSpellMap(ASPECT_OF_THE_PACK_1, true) : RemoveSpell(ASPECT_OF_THE_PACK_1);
+            //InitSpellMap(ASPECT_OF_THE_DRAGONHAWK_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 20)
+                RefreshAura(RAPID_KILLING); //20%
+            if (level >= 30)
+                RefreshAura(CONCUSSIVE_BARRAGE); //100%
+            if (level >= 40)
+                RefreshAura(PIERCING_SHOTS); //30%
+            if (level >= 40)
+                RefreshAura(TRUESHOT_AURA); //10%
+            if (level >= 45)
+                RefreshAura(RAPID_RECUPERATION); //4%
+            if (level >= 45)
+                RefreshAura(MASTER_MARKSMAN); //5%
+            if (level >= 70)
+                RefreshAura(WILD_QUIVER,3); //36%
+            else if (level >= 60)
+                RefreshAura(WILD_QUIVER,2); //24%
+            else if (level >= 50)
+                RefreshAura(WILD_QUIVER); //12%
+            if (level >= 15)
+                RefreshAura(SUREFOOTED); //30%
+            if (level >= 15)
+                RefreshAura(ENTRAPMENT); //4 sec
+            if (level >= 67)
+                RefreshAura(MASTER_TACTICIAN5,3); //30%
+            else if (level >= 58)
+                RefreshAura(MASTER_TACTICIAN5,2); //20%
+            else if (level >= 50)
+                RefreshAura(MASTER_TACTICIAN5); //10%
+            else if (level >= 49)
+                RefreshAura(MASTER_TACTICIAN4); //8%
+            else if (level >= 48)
+                RefreshAura(MASTER_TACTICIAN3); //6%
+            else if (level >= 47)
+                RefreshAura(MASTER_TACTICIAN2); //4%
+            else if (level >= 46)
+                RefreshAura(MASTER_TACTICIAN1); //2%
+            if (level >= 45)
+                RefreshAura(NOXIOUS_STINGS); //50%
+            if (level >= 55)
+                RefreshAura(HUNTING_PARTY); //100%
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case RAPID_FIRE_1:
+                case FROST_TRAP_1:
+                case ASPECT_OF_THE_PACK_1:
+                case ASPECT_OF_THE_VIPER_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        typedef std::unordered_map<uint32 /*spellId*/, int32 /*manaCost*/> ManaRestoreList;
+        ManaRestoreList TotH;
+        uint32 Trap_cd;
+        uint32 ScorpidSting_Timer, Aspect_Timer;
+        uint32 Aspect;
+        ObjectGuid stingTargetGuid;
+        Unit* markTarget;
+
+        enum HunterBaseSpells
+        {
+            AUTO_SHOT_1                         = 75,
+            TRANQ_SHOT_1                        = 19801,
+            SILENCING_SHOT_1                    = 34490,
+            CHIMERA_SHOT_1                      = 53209,
+            ARCANE_SHOT_1                       = 3044,
+            AIMED_SHOT_1                        = 19434,
+            KILL_SHOT_1                         = 53351,
+            EXPLOSIVE_SHOT_1                    = 53301,
+            MULTISHOT_1                         = 2643,
+            VOLLEY_1                            = 1510,
+            SCATTER_SHOT_1                      = 1991,
+            CONCUSSIVE_SHOT_1                   = 5116,
+            DISTRACTING_SHOT_1                  = 20736,
+            SCORPID_STING_1                     = 3043,
+            //VIPER_STING_1                       = 3034,
+            RAPID_FIRE_1                        = 3045,
+            WING_CLIP_1                         = 2974,
+            RAPTOR_STRIKE_1                     = 2973,
+            DISENGAGE_1                         = 781,
+            FROST_TRAP_1                        = 13809,
+            FREEZING_ARROW_1                    = 60192,
+            WYVERN_STING_1                      = 19386,
+            BLACK_ARROW_1                       = 3674,
+            HUNTERS_MARK_1                      = 1130,
+            SCARE_BEAST_1                       = 1513,
+            FEIGN_DEATH_1                       = 5384,
+            DETERRENCE_1                        = 19263,
+            ASPECT_OF_THE_PACK_1                = 36613,//Aspect of the Spirit Hunter
+            ASPECT_OF_THE_VIPER_1               = 34074
+            //ASPECT_OF_THE_DRAGONHAWK_1          = 61846
+        };
+
+        enum HunterPassives
+        {
+        //Talents
+            RAPID_KILLING                       = 34949,//rank 2
+            CONCUSSIVE_BARRAGE                  = 35102,//rank 2
+            PIERCING_SHOTS                      = 53238,//rank 3
+            TRUESHOT_AURA                       = 19506,
+            RAPID_RECUPERATION                  = 53232,//rank 2
+            MASTER_MARKSMAN                     = 34489,//rank 5
+            WILD_QUIVER                         = 53217,//rank 3
+            SUREFOOTED                          = 24283,//rank 3
+            ENTRAPMENT                          = 19388,//rank 3
+            MASTER_TACTICIAN1                   = 34506,
+            MASTER_TACTICIAN2                   = 34507,
+            MASTER_TACTICIAN3                   = 34508,
+            MASTER_TACTICIAN4                   = 34838,
+            MASTER_TACTICIAN5                   = 34839,
+            NOXIOUS_STINGS                      = 53297,//rank 3
+            HUNTING_PARTY                       = 53292 //rank 3
+        };
+
+        enum HunterSpecial
+        {
+            IMPROVED_CONCUSSION                 = 28445,
+            IMPROVED_WING_CLIP_NORMAL           = 47168,
+            IMPROVED_WING_CLIP_EX               = 35963,
+
+            RAPID_KILLING_BUFF                  = 35099,//rank 2
+            THRILL_OF_THE_HUNT_EFFECT           = 34720,
+            FROST_TRAP_AURA                     = 13810,
+            FREEZING_ARROW_EFFECT               = 60210,
+            //FREEZING_TRAP_EFFECT_1              = 3355,
+            //FREEZING_TRAP_EFFECT_2              = 14308,
+            //FREEZING_TRAP_EFFECT_3              = 14309,
+            VOLLEY_DAMAGE_1                     = 42243 //rank 1
+        };
+    };
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_mage_ai.cpp b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
new file mode 100644
index 0000000..bc74576
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
@@ -0,0 +1,1007 @@
+#include "bot_ai.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Mage NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45%
+TODO: Ice Lance, Deep Freeze, Mana Gems, Pet etc...
+*/
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new mage_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct mage_botAI : public bot_minion_ai
+    {
+        mage_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_MAGE) != SPELL_CAST_OK)
+                return false;
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result && spellId != MANAPOTION && me->HasAura(CLEARCASTBUFF))
+            {
+                cost = m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask());
+                if (cost)
+                    clearcast = true;
+            }
+
+            return result;
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit* u) { bot_ai::JustDied(u); }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void Counter()
+        {
+            Unit* u = me->GetVictim();
+            bool cSpell = IsSpellReady(COUNTERSPELL_1, 0, false, 5000);
+            bool blast = IsSpellReady(FIREBLAST_1, 0, false, 3000) && HasRole(BOT_ROLE_DPS) && !(u && u->ToCreature() && (u->ToCreature()->isWorldBoss() || u->ToCreature()->IsDungeonBoss())) && me->HasAura(IMPACT_BUFF);
+            if (!cSpell && !blast) return;
+            if (u && u->IsNonMeleeSpellCast(false) &&
+                ((cSpell && me->GetDistance(u) < 30) || (blast && me->GetDistance(u) < 30)))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (cSpell && doCast(u, GetSpell(COUNTERSPELL_1)))
+                    SetSpellCooldown(COUNTERSPELL_1, 15000);
+                else if (blast && doCast(u, GetSpell(FIREBLAST_1)))
+                    SetSpellCooldown(FIREBLAST_1, 6000);
+                GC_Timer = temptimer;
+            }
+            else if (cSpell)
+            {
+                if (Unit* target = FindCastingTarget(30))
+                {
+                    temptimer = GC_Timer;
+                    if (me->IsNonMeleeSpellCast(false))
+                        me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(COUNTERSPELL_1)))
+                    {
+                        SetSpellCooldown(COUNTERSPELL_1, 15000);
+                        GC_Timer = temptimer;
+                    }
+                }
+            }
+        }
+
+        void CheckSpellSteal(uint32 diff)
+        {
+            if (!IsSpellReady(SPELLSTEAL_1, diff) || IsCasting() || Rand() > 25) return;
+            Unit* target = FindHostileDispelTarget(30, true);
+            if (target && doCast(target, GetSpell(SPELLSTEAL_1)))
+                GC_Timer = 800;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || Feasting())
+                return;
+
+            if (uint32 DAMPENMAGIC = GetSpell(DAMPENMAGIC_1))
+            {
+                if (!HasAuraName(me, DAMPENMAGIC) &&
+                    doCast(me, DAMPENMAGIC))
+                    return;
+            }
+
+            if (ICEARMOR && !HasAuraName(me, ICEARMOR) &&
+                doCast(me, ICEARMOR))
+                return;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 20) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+
+            if (uint32 ARCANEINTELLECT = GetSpell(ARCANEINTELLECT_1))
+            {
+                if (target->getPowerType() == POWER_MANA && !HasAuraName(target, ARCANEINTELLECT) &&
+                    doCast(target, ARCANEINTELLECT))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            if (clearcast && me->HasAura(CLEARCASTBUFF) && !me->IsNonMeleeSpellCast(false))
+            {
+                me->ModifyPower(POWER_MANA, cost);
+                me->RemoveAurasDueToSpell(CLEARCASTBUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF1))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF1,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF2))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF2,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me) && (!GetSpell(ICEBLOCK_1) || !me->HasAura(GetSpell(ICEBLOCK_1)))) return; //TODO
+
+            CheckBlink(diff);
+            CheckPoly(diff);
+            CheckPots(diff);
+            CureGroup(master, GetSpell(REMOVE_CURSE_1), diff);
+
+            FocusMagic(diff);
+            BuffAndHealGroup(master, diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_MAGE))
+                return;
+
+            CheckPoly2();//this should go AFTER getting opponent
+
+            Counter();
+            CheckSpellSteal(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            Unit* u = me->SelectNearestTarget(20);
+            //ICE_BARRIER
+            uint32 ICE_BARRIER = GetSpell(ICE_BARRIER_1);
+            if (IsSpellReady(ICE_BARRIER_1, diff, false) && u && u->GetVictim() == me && u->GetDistance(me) < 8 &&
+                !me->HasAura(ICE_BARRIER))
+            {
+                if (me->IsNonMeleeSpellCast(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, ICE_BARRIER))
+                {
+                    SetSpellCooldown(ICE_BARRIER_1, 25000);
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            if (!IsSpellReady(ICE_BARRIER_1, diff, false) &&
+                IsSpellReady(BLINK_1, diff, false, 3000) && u && u->GetVictim() == me &&
+                u->GetDistance(me) < 6 && !me->HasAura(ICE_BARRIER))
+            {
+                if (me->IsNonMeleeSpellCast(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, GetSpell(BLINK_1)))
+                {
+                    SetSpellCooldown(BLINK_1, 13000);
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            //ICEBLOCK
+            if (uint32 ICEBLOCK = GetSpell(ICEBLOCK_1))
+            {
+                if (IsSpellReady(ICEBLOCK_1, diff, false, 57000))
+                {
+                    if (((GetManaPCT(me) > 45 && GetHealthPCT(me) > 80) || b_attackers.empty()) &&
+                        me->HasAura(ICEBLOCK))
+                        me->RemoveAurasDueToSpell(ICEBLOCK);
+                }
+
+                if (IsSpellReady(ICEBLOCK_1, diff, false) && !b_attackers.empty() && Rand() < 50 &&
+                    (GetManaPCT(me) < 15 || GetHealthPCT(me) < 45 || b_attackers.size() > 4) &&
+                    !me->HasAura(ICEBLOCK))
+                {
+                    if (me->IsNonMeleeSpellCast(true))
+                        me->InterruptNonMeleeSpells(true);
+                    if (doCast(me, ICEBLOCK))
+                    {
+                        SetSpellCooldown(ICEBLOCK_1, 60000);
+                        Nova_cd = 0; //Glyph of Iceblock
+                        return;
+                    }
+                }
+            }
+
+            if (IsCasting()) return;
+
+            float dist = me->GetExactDist(opponent);
+
+            uint32 FROSTBOLT = GetSpell(FROSTBOLT_1);
+            uint32 FIREBALL = GetSpell(FIREBALL_1);
+            uint32 BLASTWAVE = GetSpell(BLASTWAVE_1);
+            uint32 FROSTNOVA = GetSpell(FROSTNOVA_1);
+            BOLT = (CCed(opponent, true) || !FROSTBOLT) ? FIREBALL : FROSTBOLT;
+            NOVA = BOLT == FROSTBOLT && BLASTWAVE && dist > 5 ? BLASTWAVE : FROSTNOVA ? FROSTNOVA : 0;
+
+            if (IsSpellReady(COMBUSTION_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                (opponent->GetMaxHealth() > master->GetMaxHealth()*6 ||
+                m_attackers.size() > 1 || b_attackers.size() > 2) &&
+                Rand() < 15 && !HasAuraName(me, COMBUSTION_1))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(COMBUSTION_1)))
+                {
+                    SetSpellCooldown(COMBUSTION_1, 60000);
+                    GC_Timer = temptimer;
+                    //Reset timers for fun
+                    ResetSpellCooldown(FIREBLAST_1);
+                    ResetSpellCooldown(DRAGONBREATH_1);
+                    Nova_cd = 0;
+                }
+            }
+            //DAMAGE
+            //PYROBLAST
+            if (IsSpellReady(PYROBLAST_1, diff) && opponent->IsPolymorphed() && HasRole(BOT_ROLE_DPS) &&
+                (b_attackers.size() < 2 || (*b_attackers.begin()) == opponent) &&
+                dist < 35 && Rand() < 75 &&
+                doCast(opponent, GetSpell(PYROBLAST_1)))
+            {
+                SetSpellCooldown(PYROBLAST_1, 7500);
+                //debug
+                SetSpellCooldown(DRAGONBREATH_1, std::max<uint32>(GetSpellCooldown(DRAGONBREATH_1), uint32(float(sSpellMgr->GetSpellInfo(GetSpell(PYROBLAST_1))->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 400)));
+                Nova_cd = std::max<uint32>(Nova_cd, 450);
+                return;
+            }
+            //nova //TODO: SEPARATE
+            u = me->SelectNearestTarget(6.3f);
+            if (NOVA && Nova_cd <= diff && HasRole(BOT_ROLE_DPS) && u && Rand() < 75 && !CCed(u, true) && IsInBotParty(u->GetVictim()))
+            {
+                if (doCast(me, NOVA))
+                {
+                    Nova_cd = 15000;
+                    GetInPosition(true);
+                    return;
+                }
+            }
+            //living bomb
+            if (IsSpellReady(LIVINGBOMB_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 35 && opponent->GetHealth() > me->GetHealth()/2 &&
+                Rand() < 45 && !HasAuraName(opponent, LIVINGBOMB_1, me->GetGUID()) &&
+                doCast(opponent, GetSpell(LIVINGBOMB_1)))
+            {
+                SetSpellCooldown(LIVINGBOMB_1, 6000);
+                GC_Timer = 500;
+                return;
+            }
+            //cone of cold
+            if (IsSpellReady(CONEOFCOLD_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 7 && Rand() < 50 &&
+                me->HasInArc(M_PI*0.75f, opponent) &&
+                doCast(opponent, GetSpell(CONEOFCOLD_1)))
+            {
+                SetSpellCooldown(CONEOFCOLD_1, 8000);
+                GC_Timer = 500;
+                GetInPosition(true);
+                return;
+            }
+            //dragon's breath
+            if (IsSpellReady(DRAGONBREATH_1, diff) && HasRole(BOT_ROLE_DPS) && !CCed(opponent, true) &&
+                ((me->HasInArc(M_PI*0.75f, opponent) && dist < 7) ||
+                (u && u != opponent && me->HasInArc(M_PI*0.75f, u) && IsInBotParty(u->GetVictim()))) &&
+                doCast(me, GetSpell(DRAGONBREATH_1)))
+            {
+                SetSpellCooldown(DRAGONBREATH_1, 25000);
+                GC_Timer = 800;
+                return;
+            }
+            /*//blast wave //TODO Separate again
+            u = me->SelectNearestTarget(8);
+            if (BLASTWAVE != 0 && u && isTimerReady(BlastWave_cd) &&
+                !HasAuraName(u, FROSTNOVA) && !HasAuraName(u, DRAGONBREATH) &&
+                doCast(me, BLASTWAVE))
+            {
+                BlastWave_cd = BLASTWAVE_CD;
+                GC_Timer = 800;
+            }*/
+            //fire blast
+            if (IsSpellReady(FIREBLAST_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 &&
+                Rand() < 20 + 80*(!opponent->isFrozen() && !opponent->HasAuraType(SPELL_AURA_MOD_STUN) && me->HasAura(IMPACT_BUFF)))
+            {
+                if (doCast(opponent, GetSpell(FIREBLAST_1)))
+                {
+                    SetSpellCooldown(FIREBLAST_1, 6000);
+                    GC_Timer = 500;
+                    return;
+                }
+            }
+            //flamestrike - use Improved Flamestrike for instant cast
+            if (IsSpellReady(FLAMESTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && me->HasAura(FIRESTARTERBUFF) && Rand() < 25)
+            {
+                Unit* FStarget = FindAOETarget(30, true, false);
+                if (FStarget && doCast(FStarget, GetSpell(FLAMESTRIKE_1), true))
+                {
+                    me->RemoveAurasDueToSpell(FIRESTARTERBUFF);
+                    GC_Timer = 300;
+                    return;
+                }
+            }
+            //blizzard
+            if (IsSpellReady(BLIZZARD_1, diff, false) && HasRole(BOT_ROLE_DPS) && !me->isMoving() && Rand() < 40)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, GetSpell(BLIZZARD_1)))
+                {
+                    SetSpellCooldown(BLIZZARD_1, 5000);
+                    return;
+                }
+                SetSpellCooldown(BLIZZARD_1, 1500); //fail
+            }
+            //Frost or Fire Bolt
+            if (BOLT && Bolt_cd <= diff && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 75 &&
+                doCast(opponent, BOLT))
+            {
+                Bolt_cd = uint32(float(sSpellMgr->GetSpellInfo(BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200);
+                //debug
+                SetSpellCooldown(DRAGONBREATH_1, std::max<uint32>(GetSpellCooldown(DRAGONBREATH_1), Bolt_cd + 200));
+                Nova_cd = std::max<uint32>(Nova_cd, 450);
+                return;
+            }
+            //Arcane Missiles
+            if (IsSpellReady(ARCANEMISSILES_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && dist < 20 && Rand() < 15 &&
+                doCast(opponent, GetSpell(ARCANEMISSILES_1)))
+                return;
+        }
+
+        void CheckPoly(uint32 diff)
+        {
+            if (polyCheckTimer <= diff)
+            {
+                Polymorph = FindAffectedTarget(GetSpell(POLYMORPH_1), me->GetGUID());
+                polyCheckTimer = 2000;
+            }
+        }
+
+        void CheckPoly2()
+        {
+            if (Polymorph == false && GC_Timer < 500 && GetSpell(POLYMORPH_1))
+            {
+                if (Unit* target = FindPolyTarget(30, me->GetVictim()))
+                {
+                    if (doCast(target, GetSpell(POLYMORPH_1)))
+                    {
+                        Polymorph = true;
+                        polyCheckTimer += 2000;
+                    }
+                }
+            }
+        }
+
+        void CheckPots(uint32 diff)
+        {
+            if (me->IsMounted() || IsCasting())
+                return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (GetManaPCT(me) < 35 && Rand() < 35)
+            {
+                if (IsSpellReady(EVOCATION_1, diff, false) && !me->isMoving() && me->getAttackers().empty() &&
+                    doCast(me, GetSpell(EVOCATION_1)))
+                {
+                    SetSpellCooldown(EVOCATION_1, 60000);
+                    return;
+                }
+                if (Potion_cd <= diff)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, MANAPOTION))
+                    {
+                        Potion_cd = POTION_CD;
+                        GC_Timer = temptimer;
+                    }
+                }
+            }
+        }
+
+        void CheckBlink(uint32 diff)
+        {
+            if (GetBotCommandState() == COMMAND_STAY || me->IsMounted()) return;
+            if (!IsSpellReady(BLINK_1, diff, false) || me->getLevel() < 20 || IsCasting()) return;
+
+            if (!me->IsInCombat() && me->GetExactDist2d(master) > std::max<uint8>(master->GetBotFollowDist(), 35) &&
+                me->HasInArc(M_PI*0.75f, master))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLINK_1)))
+                {
+                    SetSpellCooldown(BLINK_1, 13000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            if (!me->getAttackers().empty() && me->GetExactDist2d(master) > 15)
+            {
+                if (Unit* op = me->SelectNearestTarget(7))
+                {
+                    if (op->GetVictim() == me)
+                    {
+                        me->SetFacingTo(me->GetAngle(master));
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(BLINK_1)))
+                        {
+                            SetSpellCooldown(BLINK_1, 13000);
+                            GC_Timer = temptimer;
+                        }
+                    }
+                }
+            }
+        }
+
+        void FocusMagic(uint32 diff)
+        {
+            if (fmCheckTimer > diff || GC_Timer > diff || me->getLevel() < 20 || IsCasting() || Rand() < 50)
+                return;
+
+            uint32 FOCUSMAGIC = GetSpell(FOCUSMAGIC_1);
+            if (!FOCUSMAGIC)
+                return;
+
+            if (Unit* target = FindAffectedTarget(FOCUSMAGIC, me->GetGUID(), 70, 2))
+            {
+                fmCheckTimer = 15000;
+                return;
+            }
+            else
+            {
+                Group* pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (master->getPowerType() == POWER_MANA && me->GetExactDist(master) < 30 &&
+                        !master->HasAura(FOCUSMAGIC))
+                        target = master;
+                }
+                else
+                {
+                    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || pPlayer->isDead()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (pPlayer->getPowerType() == POWER_MANA && me->GetExactDist(pPlayer) < 30 &&
+                            !pPlayer->HasAura(FOCUSMAGIC))
+                        {
+                            target = pPlayer;
+                            break;
+                        }
+                    }
+                    if (!target)
+                    {
+                        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            for (uint8 i = 0; i != pPlayer->GetMaxNpcBots(); ++i)
+                            {
+                                Creature* cre = pPlayer->GetBotMap(i)->_Cre();
+                                if (!cre || !cre->IsInWorld() || cre == me || cre->isDead()) continue;
+                                if (cre->getPowerType() == POWER_MANA && me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(FOCUSMAGIC))
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (target && doCast(target, FOCUSMAGIC))
+                {
+                    GC_Timer = 500;
+                    fmCheckTimer = 30000;
+                    return;
+                }
+            }
+
+            fmCheckTimer = 5000;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Combustion: 10% per stack
+                if (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask())
+                    if (Aura* combustion = me->GetAura(COMBUSTION_BUFF))
+                        aftercrit += float(combustion->GetStackAmount()*10);
+                //Incineration: 6% additional critical chance for Fire Blast, Scorch, Arcane Blast and Cone of Cold
+                if (lvl >= 10 &&
+                    (spellId == GetSpell(FIREBLAST_1) ||
+                    spellId == GetSpell(CONEOFCOLD_1)/* ||
+                    spellId == ARCANEBLAST ||
+                    spellId == SCORCH*/))
+                    aftercrit += 6.f;
+                //World In Flames: 6% additional critical chance for
+                //Flamestrike, Pyroblast, Blast Wave, Dragon's Breath, Living Bomb, Blizzard and Arcane Explosion
+                if (lvl >= 15 &&
+                    (spellId == GetSpell(FLAMESTRIKE_1) ||
+                    spellId == GetSpell(PYROBLAST_1) ||
+                    spellId == GetSpell(BLASTWAVE_1) ||
+                    spellId == GetSpell(DRAGONBREATH_1)/* ||
+                    spellId == ARCANEXPLOSION ||
+                    spellId == LIVINGBOMB ||    //cannot be handled here
+                    spellId == BLIZZARD*/))    //cannot be handled here
+                    aftercrit += 6.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Spell Power: 50% additional crit damage bonus for All spells
+                if (lvl >= 55)
+                    pctbonus += 0.333f;
+                //Ice Shards: 50% additional crit damage bonus for Frost spells
+                else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                    pctbonus += 0.333f;
+            }
+            //Improved Cone of Cold: 35% bonus damage for Cone of Cold
+            if (lvl >= 30 && spellId == GetSpell(CONEOFCOLD_1))
+                pctbonus += 0.35f;
+            //Fire Power: 10% bonus damage for Fire spells
+            if (lvl >= 35 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            if (!aftercastTargetGuid)
+            {
+                //only players for now
+                if (!aftercastTargetGuid.IsPlayer())
+                {
+                    aftercastTargetGuid.Clear();
+                    return;
+                }
+
+                Player* pTarget = ObjectAccessor::FindPlayer(aftercastTargetGuid);
+                aftercastTargetGuid.Clear();
+
+                if (!pTarget/* || me->GetDistance(pTarget) > 15*/)
+                    return;
+
+                //handle effects
+                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                {
+                    switch (spell->Effects[i].Effect)
+                    {
+                        case SPELL_EFFECT_CREATE_ITEM:
+                        case SPELL_EFFECT_CREATE_ITEM_2:
+                        {
+                            uint32 newitemid = spell->Effects[i].ItemType;
+                            if (newitemid)
+                            {
+                                ItemPosCountVec dest;
+                                ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(newitemid);
+                                if (!pProto)
+                                    return;
+                                uint32 count = pProto->GetMaxStackSize();
+                                uint32 no_space = 0;
+                                InventoryResult msg = pTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, count, &no_space);
+                                if (msg != EQUIP_ERR_OK)
+                                {
+                                    if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
+                                        count -= no_space;
+                                    else
+                                    {
+                                        // if not created by another reason from full inventory or unique items amount limitation
+                                        pTarget->SendEquipError(msg, NULL, NULL, newitemid);
+                                        continue;
+                                    }
+                                }
+                                if (count)
+                                {
+                                    Item* pItem = pTarget->StoreNewItem(dest, newitemid, true, Item::GenerateItemRandomPropertyId(newitemid));
+                                    if (!pItem)
+                                    {
+                                        pTarget->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+                                        continue;
+                                    }
+                                    //unsafe possible
+                                    pItem->SetUInt32Value(ITEM_FIELD_CREATOR, me->GetGUID().GetCounter());
+
+                                    pTarget->SendNewItem(pItem, count, true, false, true);
+                                }
+                            }
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+
+                return;
+            }
+
+            //Winter Veil addition
+            uint32 spellId = spell->Id;
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+            {
+                if (SPELL_SCHOOL_MASK_FROST & spell->GetSchoolMask())
+                    me->AddAura(44755, target); //snowflakes
+
+                if (spellId == GetSpell(FROSTBOLT_1) && urand(1,100) <= 10)
+                    me->CastSpell(target, 25686, true); //10% super snowball
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Bolt_cd = 0;
+            Nova_cd = 0;
+            polyCheckTimer = 0;
+            fmCheckTimer = 0;
+            Polymorph = false;
+            clearcast = false;
+            BOLT = 0;
+            NOVA = 0;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_MAGE);
+           }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (Bolt_cd > diff)                     Bolt_cd -= diff;
+            if (Nova_cd > diff)                     Nova_cd -= diff;
+
+            if (polyCheckTimer > diff)              polyCheckTimer -= diff;
+            if (fmCheckTimer > diff)                fmCheckTimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(DAMPENMAGIC_1);
+            InitSpellMap(ARCANEINTELLECT_1);
+            InitSpellMap(ARCANEMISSILES_1);
+            InitSpellMap(POLYMORPH_1);
+            InitSpellMap(COUNTERSPELL_1);
+            InitSpellMap(SPELLSTEAL_1);
+            InitSpellMap(EVOCATION_1);
+            InitSpellMap(BLINK_1);
+            InitSpellMap(REMOVE_CURSE_1);
+            //InitSpellMap(INVISIBILITY_1);
+            InitSpellMap(FIREBALL_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(BLASTWAVE_1) : RemoveSpell(BLASTWAVE_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(DRAGONBREATH_1) : RemoveSpell(DRAGONBREATH_1);
+            InitSpellMap(FIREBLAST_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(PYROBLAST_1) : RemoveSpell(PYROBLAST_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(LIVINGBOMB_1) : RemoveSpell(LIVINGBOMB_1);
+            InitSpellMap(DAMPENMAGIC_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(COMBUSTION_1) : RemoveSpell(COMBUSTION_1);
+            InitSpellMap(FROSTBOLT_1);
+            InitSpellMap(FROSTNOVA_1);
+            InitSpellMap(CONEOFCOLD_1);
+            InitSpellMap(BLIZZARD_1);
+ /*Special*/ICEARMOR = lvl >= 20 ? InitSpell(me, ICEARMOR_1) : InitSpell(me, FROSTARMOR_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(ICE_BARRIER_1) : RemoveSpell(ICE_BARRIER_1);
+            InitSpellMap(ICEBLOCK_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(FOCUSMAGIC_1) : RemoveSpell(FOCUSMAGIC_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            //Dam+(-Hit)
+            if (level >= 50)
+                RefreshAura(ARCTIC_WINDS,3); //+15%/-15%
+            else if (level >= 25)
+                RefreshAura(ARCTIC_WINDS,2); //+10%/-10%
+            else if (level >= 10)
+                RefreshAura(ARCTIC_WINDS); //+5%/-5%
+            //CHILL
+            if (level >= 30)
+                RefreshAura(WINTERS_CHILL3); //100%
+            else if (level >= 25)
+                RefreshAura(WINTERS_CHILL2); //66%
+            else if (level >= 20)
+                RefreshAura(WINTERS_CHILL1); //33%
+            //Imp Blizzard
+            if (level >= 20)
+                RefreshAura(IMPROVED_BLIZZARD); //50% slow
+            //Frostbite
+            if (level >= 80)
+                FROSTBITE = FROSTBITE3;
+            else if (level >= 50)
+                FROSTBITE = FROSTBITE2;
+            else if (level >= 10)
+                FROSTBITE = FROSTBITE1;
+            if (level >= 60)
+                RefreshAura(FROSTBITE,3); //3x
+            else if (level >= 30)
+                RefreshAura(FROSTBITE,2); //2x
+            else if (level >= 10)
+                RefreshAura(FROSTBITE); //1x
+            //Shattered Barrier
+            if (level >= 45)
+                RefreshAura(SHATTERED_BARRIER);
+            //Bonus
+            if (level >= 65)
+                RefreshAura(ARCANE_INSTABILITY,4); //+12%dmg crit
+            else if (level >= 55)
+                RefreshAura(ARCANE_INSTABILITY,3); //+9%dmg crit
+            else if (level >= 45)
+                RefreshAura(ARCANE_INSTABILITY,2); //+6%dmg crit
+            else if (level >= 35)
+                RefreshAura(ARCANE_INSTABILITY); //+3%dmg crit
+            //Absorb
+            if (level >= 50)
+                RefreshAura(INCANTERS_ABSORPTION3);
+            else if (level >= 45)
+                RefreshAura(INCANTERS_ABSORPTION2);
+            else if (level >= 40)
+                RefreshAura(INCANTERS_ABSORPTION1);
+            //Shatter
+            if (level >= 35)
+                RefreshAura(SHATTER3);
+            else if (level >= 30)
+                RefreshAura(SHATTER2);
+            else if (level >= 25)
+                RefreshAura(SHATTER1);
+            //ClearCasting
+            if (level >= 75)
+                RefreshAura(CLEARCAST,3); //30%
+            else if (level >= 40)
+                RefreshAura(CLEARCAST,2); //20%
+            else if (level >= 15)
+                RefreshAura(CLEARCAST); //10%
+            //Fingers
+            if (level >= 45)
+                RefreshAura(FINGERS_OF_FROST); //15%
+            //Potency
+            if (level >= 40)
+                RefreshAura(ARCANE_POTENCY2); //30% bonus
+            else if (level >= 35)
+                RefreshAura(ARCANE_POTENCY1); //15% bonus
+            //Ignite
+            if (level >= 15)
+                RefreshAura(IGNITE);
+            //Impact
+            if (level >= 60)
+                RefreshAura(IMPACT,2);
+            else if (level >= 20)
+                RefreshAura(IMPACT);
+            //Imp. Counterspell
+            if (level >= 35)
+                RefreshAura(IMPROVED_COUNTERSPELL2); //4 sec
+            else if (level >= 25)
+                RefreshAura(IMPROVED_COUNTERSPELL1); //2 sec
+            //Firestarter
+            if (level >= 55)
+                RefreshAura(FIRESTARTER2); //100% chance
+            else if (level >= 45)
+                RefreshAura(FIRESTARTER1); //50% chance
+            //Spells
+            if (GetSpell(LIVINGBOMB_1))
+                RefreshAura(GLYPH_LIVING_BOMB);
+            if (GetSpell(POLYMORPH_1))
+                RefreshAura(GLYPH_POLYMORPH);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case DAMPENMAGIC_1:
+                case ARCANEINTELLECT_1:
+                case EVOCATION_1:
+                case REMOVE_CURSE_1:
+                case FOCUSMAGIC_1:
+                case FROSTARMOR_1:
+                case ICEARMOR_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Spells
+/*frst*/uint32 ICEARMOR;
+/*exc.*/uint32 BOLT, NOVA;
+/*exc.*/uint32 FROSTBITE;
+        //Timers
+/*exc.*/uint32 Bolt_cd, Nova_cd;
+/*exc.*/uint32 polyCheckTimer, fmCheckTimer;
+        //Check
+/*exc.*/bool Polymorph, clearcast;
+
+        enum MageBaseSpells
+        {
+            DAMPENMAGIC_1                       = 604,
+            ARCANEINTELLECT_1                   = 1459,
+            ARCANEMISSILES_1                    = 5143,
+            POLYMORPH_1                         = 118,
+            COUNTERSPELL_1                      = 2139,
+            SPELLSTEAL_1                        = 30449,
+            EVOCATION_1                         = 12051,
+            BLINK_1                             = 1953,
+            REMOVE_CURSE_1                      = 475,
+            //INVISIBILITY_1                      = 0,
+            FIREBALL_1                          = 133,
+            BLASTWAVE_1                         = 11113,
+            DRAGONBREATH_1                      = 31661,
+            FIREBLAST_1                         = 2136,
+            PYROBLAST_1                         = 11366,
+            LIVINGBOMB_1                        = 44457,
+            FLAMESTRIKE_1                       = 2120,
+            COMBUSTION_1                        = 11129,
+            FROSTBOLT_1                         = 116,
+            FROSTNOVA_1                         = 122,
+            CONEOFCOLD_1                        = 120,
+            BLIZZARD_1                          = 10,
+            FROSTARMOR_1                        = 168,
+            ICEARMOR_1                          = 7302,
+            ICE_BARRIER_1                       = 11426,
+            ICEBLOCK_1                          = 45438,
+            FOCUSMAGIC_1                        = 54646
+        };
+
+        enum MagePassives
+        {
+        //Talents
+            SHATTERED_BARRIER                   = 54787,//rank 2
+            ARCTIC_WINDS                        = 31678,//rank 5
+            WINTERS_CHILL1                      = 11180,
+            WINTERS_CHILL2                      = 28592,
+            WINTERS_CHILL3                      = 28593,
+            FROSTBITE1                          = 11071,
+            FROSTBITE2                          = 12496,
+            FROSTBITE3                          = 12497,
+            IMPROVED_BLIZZARD                   = 12488,//rank 3
+            CLEARCAST /*Arcane Concentration*/  = 12577,//rank 5
+            ARCANE_POTENCY1                     = 31571,
+            ARCANE_POTENCY2                     = 31572,
+            SHATTER1                            = 11170,
+            SHATTER2                            = 12982,
+            SHATTER3                            = 12983,
+            INCANTERS_ABSORPTION1               = 44394,
+            INCANTERS_ABSORPTION2               = 44395,
+            INCANTERS_ABSORPTION3               = 44396,
+            FINGERS_OF_FROST                    = 44545,//rank 2
+            ARCANE_INSTABILITY                  = 15060,//rank 3
+            IMPROVED_COUNTERSPELL1              = 11255,
+            IMPROVED_COUNTERSPELL2              = 12598,
+            IGNITE                              = 12848,
+            FIRESTARTER1                        = 44442,
+            FIRESTARTER2                        = 44443,
+            IMPACT                              = 12358,
+            GLYPH_LIVING_BOMB                   = 63091,
+        //Special
+            GLYPH_POLYMORPH                     = 56375
+        };
+        enum MageSpecial
+        {
+            CLEARCASTBUFF                       = 12536,
+            IMPACT_BUFF                         = 64343,
+            FIRESTARTERBUFF                     = 54741,
+            ARCANE_POTENCY_BUFF1                = 57529,
+            ARCANE_POTENCY_BUFF2                = 57531,
+            COMBUSTION_BUFF                     = 28682
+        };
+    };
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
new file mode 100644
index 0000000..19cca30
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
@@ -0,0 +1,1125 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "WorldSession.h"
+/*
+Paladin NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45-50%
+TODO: Tanking, Shield Abilities, Auras
+*/
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new paladin_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct paladin_botAI : public bot_minion_ai
+    {
+        paladin_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_PALADIN) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void HOFGroup(Player* pTarget, uint32 diff)
+        {
+            if (!IsSpellReady(HOF_1, diff) || IsCasting() || Rand() > 60)
+                return;
+
+            if (Group* pGroup = pTarget->GetGroup())
+            {
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer) continue;
+                    if (HOFTarget(tPlayer, diff))
+                        return;
+                }
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* cre = tPlayer->GetBotMap(i)->_Cre();
+                        if (!cre || !cre->IsInWorld()) continue;
+                        if (HOFTarget(cre, diff))
+                            return;
+                    }
+                }
+            }
+        }
+
+        bool HOFTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOF_1, diff)) return false;
+            if (target->ToCreature() && Rand() > 25) return false;
+            if (me->GetExactDist(target) > 30) return false;//too far away
+            if (HasAuraName(target, HOF_1)) return false;     //Alredy has HOF
+
+            Unit::AuraMap const &auras = target->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator i = auras.begin(); i != auras.end(); ++i)
+            {
+                Aura* aura = i->second;
+                if (aura->IsPassive()) continue;//most
+                if (aura->GetDuration() < 2000) continue;
+                if (AuraApplication* app = aura->GetApplicationOfTarget(target->GetGUID()))
+                    if (app->IsPositive()) continue;
+                SpellInfo const* spellInfo = aura->GetSpellInfo();
+                if (spellInfo->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+                if (me->getLevel() >= 40 && (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_STUN)))
+                {
+                    if (doCast(target, GetSpell(HOF_1)))
+                    {
+                        if (target->ToCreature())
+                            SetSpellCooldown(HOF_1, 10000); //10 sec for selfcast after stun
+                        else
+                            SetSpellCooldown(HOF_1, 15000); //improved
+                        return true;
+                    }
+                }
+       /*else */if (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_SNARE) ||
+                    spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_ROOT))
+                {
+                    uint32 spell = GetSpell(CLEANSE_1) &&
+                        (spellInfo->Dispel == DISPEL_MAGIC ||
+                        spellInfo->Dispel == DISPEL_DISEASE ||
+                        spellInfo->Dispel == DISPEL_POISON) ? GetSpell(CLEANSE_1) : GetSpell(HOF_1);
+
+                    if (doCast(target, spell))
+                    {
+                        if (spell == GetSpell(HOF_1))
+                        {
+                            if (target->ToCreature())
+                                SetSpellCooldown(HOF_1, 5000); //5 sec for bots
+                            else
+                                SetSpellCooldown(HOF_1, 15000); //improved
+                        }
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+        void HOSGroup(Player* hTarget, uint32 diff)
+        {
+            if (!IsSpellReady(HOS_1, diff) || IsCasting() || Rand() > 30)
+                return;
+
+            if (Group* pGroup = hTarget->GetGroup())
+            {
+                bool bots = false;
+                float threat;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* HOSPlayer = itr->GetSource();
+                    if (!HOSPlayer) continue;
+                    if (HOSPlayer->HaveBot())
+                        bots = true;
+                    if (HOSPlayer->isDead()) continue;
+                    if (IsTank(HOSPlayer)) continue; //tanks do not need it
+                    if (!HOSPlayer->IsInWorld() || master->GetMap() != HOSPlayer->FindMap() || me->GetExactDist(HOSPlayer) > 30) continue;
+                    if (HasAuraName(HOSPlayer, HOS_1)) continue;
+                    AttackerSet h_attackers = HOSPlayer->getAttackers();
+                    if (h_attackers.empty()) continue;
+                    for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        threat = (*iter)->getThreatManager().getThreat(HOSPlayer);
+                        if (threat < 25.f) continue;//too small threat
+                        //if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                        if (HOSPlayer->GetDistance((*iter)) > 10) continue;
+                        if (HOSTarget(HOSPlayer, diff))
+                            return;
+                    }//end for
+                }//end for
+                if (!bots) return;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl) continue;
+                    if (!pl->HaveBot()) continue;
+                    if (master->GetMap() != pl->FindMap()) continue;
+                    if (!pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                    for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* cre = pl->GetBotMap(i)->_Cre();
+                        if (!cre || cre->isDead()) continue;
+                        if (IsTank(cre)) continue;
+                        if (me->GetExactDist(cre) > 30) continue;
+                        if (HasAuraName(cre, HOS_1)) continue; //Alredy has HOS
+                        AttackerSet h_attackers = cre->getAttackers();
+                        if (h_attackers.empty()) continue;
+                        for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                        {
+                            if (!(*iter)) continue;
+                            if ((*iter)->isDead()) continue;
+                            if (!(*iter)->CanHaveThreatList()) continue;
+                            threat = (*iter)->getThreatManager().getThreat(cre);
+                            if (threat < 25.f) continue;//too small threat
+                            //if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                            if (cre->GetDistance((*iter)) > 10) continue;
+                            if (HOSTarget(cre, diff))
+                                return;
+                        }//end for
+                    }//end for
+                }//end for
+            }//end if
+        }
+
+        bool HOSTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOS_1, diff) || Rand() > 50) return false;
+            if (IsTank(target)) return false; //tanks do not need it
+            if (IsCasting()) return false; //I'm busy casting
+            if (me->GetExactDist(target) > 30) return false; //too far away
+            if (HasAuraName(target, HOS_1)) return false; //Alredy has HOS
+
+            AttackerSet h_attackers = target->getAttackers();
+            if (h_attackers.empty()) return false; //no aggro
+            float threat;
+            uint8 Tattackers = 0;
+            for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if ((*iter)->isDead()) continue;
+                if (!(*iter)->CanHaveThreatList()) continue;
+                threat = (*iter)->getThreatManager().getThreat(target);
+                if (threat < 25.f) continue; //too small threat
+                //if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                if (target->GetDistance((*iter)) <= 10)
+                    Tattackers++;
+            }
+            if (Tattackers > 0 && doCast(target, GetSpell(HOS_1)))
+            {
+                for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    if ((*iter)->getThreatManager().getThreat(target) > 0.f)
+                        (*iter)->getThreatManager().modifyThreatPercent(target, -(30 + 50*(target->HasAura(586)))); //Fade
+                SetSpellCooldown(HOS_1, target->ToCreature() ? 10000 : 25000);
+                return true;
+            }
+            return false;
+        }
+        //Holy_Shock setup (Modify HERE)
+        bool HS(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOLY_SHOCK_1, diff)) return false;
+            if (IsCasting()) return false;
+            if (target->GetTypeId() == TYPEID_PLAYER && (target->IsCharmed() || target->isPossessed()))
+                return false; //do not damage friends under control
+            if (me->GetExactDist(target) > 40) return false;
+
+            if (doCast(target, GetSpell(HOLY_SHOCK_1)))
+            {
+                if (urand(1,100) > 20) //Daybreak: 20% to not trigger HS CD, only GCD
+                    SetSpellCooldown(HOLY_SHOCK_1, 5000);
+                return true;
+            }
+            return false;
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (!target || target->isDead()) return false;
+            if (hp > 97) return false;
+            //sLog->outBasic("HealTarget() by %s on %s", me->GetName().c_str(), target->GetName().c_str());
+            if (Rand() > 40 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 35) return false;
+            if (IsCasting()) return false;
+            if (IsSpellReady(HAND_OF_PROTECTION_1, diff, false) && target->GetTypeId() == TYPEID_PLAYER &&
+                ((master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID())) || target == master) &&
+                ((hp < 30 && !target->getAttackers().empty()) || (hp < 50 && target->getAttackers().size() > 3)) &&
+                me->GetExactDist(target) < 30 &&
+                !HasAuraName(target, HAND_OF_PROTECTION_1) &&
+                !HasAuraName(target, FORBEARANCE_AURA))
+            {
+                if (doCast(target, GetSpell(HAND_OF_PROTECTION_1)))
+                {
+                    me->Whisper("BOP on you!", LANG_UNIVERSAL, target->ToPlayer());
+                    SetSpellCooldown(HAND_OF_PROTECTION_1, 60000); //1 min
+
+                    //debug
+                    if (!HasAuraName(target, FORBEARANCE_AURA))
+                        me->AddAura(FORBEARANCE_AURA, target);
+                    if (HasAuraName(target, FORBEARANCE_AURA) && !HasAuraName(target, HAND_OF_PROTECTION_1))
+                        me->AddAura(GetSpell(HAND_OF_PROTECTION_1), target);
+                }
+                return true;
+            }
+            else if (hp < 20 && !HasAuraName(target, HAND_OF_PROTECTION_1))
+            {
+                // 20% to cast loh, else just do a Shock
+                switch (rand()%3)
+                {
+                    case 1:
+                        if (IsSpellReady(LAY_ON_HANDS_1, diff, false) && hp < 20 &&
+                            target->GetTypeId() == TYPEID_PLAYER &&
+                            (target->IsInCombat() || !target->getAttackers().empty()) &&
+                            !HasAuraName(target, FORBEARANCE_AURA))
+                        {
+                            if (doCast(target, GetSpell(LAY_ON_HANDS_1)))
+                            {
+                                me->Whisper("Lay of Hands on you!", LANG_UNIVERSAL, target->ToPlayer());
+                                SetSpellCooldown(LAY_ON_HANDS_1, 150000); //2.5 min
+                                return true;
+                            }
+                        }
+                    case 2:
+                        if (GC_Timer > diff) return false;
+                        if (doCast(target, GetSpell(FLASH_OF_LIGHT_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                            return true;
+                    case 3:
+                        if (GC_Timer > diff) return false;
+                        if (HS(target, diff))
+                            return true;
+                }
+            }
+
+            Unit* u = target->GetVictim();
+            if (IsSpellReady(SACRED_SHIELD_1, diff) && target->GetTypeId() == TYPEID_PLAYER &&
+                (hp < 65 || target->getAttackers().size() > 1 || (u && u->GetMaxHealth() > target->GetMaxHealth()*10 && target->IsInCombat())) &&
+                !HasAuraName(target, SACRED_SHIELD_1) &&
+                ((master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID())) || target == master))
+            {
+                Unit* aff = FindAffectedTarget(GetSpell(SACRED_SHIELD_1), me->GetGUID(), 50, 1);//use players since we cast only on them
+                if ((!aff || (aff->getAttackers().empty() && !IsTank(aff))) &&
+                    doCast(target, GetSpell(SACRED_SHIELD_1)))
+                {
+                    SetSpellCooldown(SACRED_SHIELD_1, 3000);
+                    return true;
+                }
+            }
+            if ((hp < 85 || GetLostHP(target) > 6000))
+                if (HS(target, diff))
+                    return true;
+            if ((hp > 35 && (hp < 75 || GetLostHP(target) > 8000)) || (!GetSpell(FLASH_OF_LIGHT_1) && hp < 85))
+                if (doCast(target, GetSpell(HOLY_LIGHT_1)))
+                    return true;
+            if ((hp < 90 || GetLostHP(target) > 1500))
+                if (doCast(target, GetSpell(FLASH_OF_LIGHT_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                    return true;
+            return false;
+        }//end HealTarget
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit* u) { bot_ai::JustDied(u); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            //HOFTarget(me, diff);//self stun cure goes FIRST
+            if (CCed(me)) return;
+
+            if (GetManaPCT(me) < 30 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (GetManaPCT(me) < 40 && IsSpellReady(DIVINE_PLEA_1, diff, false))
+                if (doCast(me, GetSpell(DIVINE_PLEA_1)))
+                    SetSpellCooldown(DIVINE_PLEA_1, 45000);
+
+            CureTarget(me, GetSpell(CLEANSE_1), diff); //maybe unnecessary but this goes FIRST
+            HOFTarget(master, diff); //maybe unnecessary
+            CureTarget(master,  GetSpell(CLEANSE_1), diff); //maybe unnecessary
+            BuffAndHealGroup(master, diff);
+            HOSTarget(master, diff);
+            CureGroup(master,  GetSpell(CLEANSE_1), diff);
+            HOFGroup(master, diff);
+            HOSGroup(master, diff);
+
+            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff
+            if (IsSpellReady(SEAL_OF_COMMAND_1, diff, false) && Rand() < 20 && !HasAuraName(me, SEAL_OF_COMMAND_1) &&
+                doCast(me, GetSpell(SEAL_OF_COMMAND_1)))
+                GC_Timer = 500;
+
+            // Heal myself
+            if (GetHealthPCT(me) < 80)
+                HealTarget(me, GetHealthPCT(me), diff);
+
+            if (!CheckAttackTarget(CLASS_PALADIN))
+                return;
+
+            Repentance(diff);
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted())
+                return;
+
+            RezGroup(GetSpell(REDEMPTION_1), master);
+
+            if (Feasting())
+                return;
+
+            //aura
+            if (master->IsAlive() && me->GetExactDist(master) < 20)
+            {
+                uint8 myAura;
+                uint32 DEVOTION_AURA = GetSpell(DEVOTION_AURA_1);
+                uint32 CONCENTRATION_AURA = GetSpell(CONCENTRATION_AURA_1);
+                if (me->HasAura(DEVOTION_AURA, me->GetGUID()))
+                    myAura = DEVOTIONAURA;
+                else if (me->HasAura(CONCENTRATION_AURA, me->GetGUID()))
+                    myAura = CONCENTRATIONAURA;
+                else myAura = NOAURA;
+
+                if (myAura != NOAURA)
+                    return; //do not bother
+
+                Aura* concAura = master->GetAura(CONCENTRATION_AURA);
+                Aura* devAura = master->GetAura(DEVOTION_AURA);
+                if (devAura && concAura) return;
+                if (devAura && devAura->GetCasterGUID() == me->GetGUID()) return;
+                if (concAura && concAura->GetCasterGUID() == me->GetGUID()) return;
+
+                if ((master->getClass() == CLASS_MAGE ||
+                    master->getClass() == CLASS_PRIEST ||
+                    master->getClass() == CLASS_WARLOCK ||
+                    master->getClass() == CLASS_DRUID || devAura) &&
+                    !concAura &&
+                    doCast(me, CONCENTRATION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+                if (!devAura && doCast(me, DEVOTION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead() || GC_Timer > diff || Rand() > 30) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+            if (HasAuraName(target, BLESSING_OF_WISDOM_1, me->GetGUID()) ||
+                HasAuraName(target, BLESSING_OF_KINGS_1, me->GetGUID()) ||
+                HasAuraName(target, BLESSING_OF_SANCTUARY_1, me->GetGUID()) ||
+                HasAuraName(target, BLESSING_OF_MIGHT_1, me->GetGUID()))
+                return false;
+            //if (HasAuraName(target, "Greater Blessing of Wisdom", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Might", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Kings", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Sanctuary", me->GetGUID()))
+            //    return false;
+
+            uint32 BLESSING_OF_WISDOM = GetSpell(BLESSING_OF_WISDOM_1);
+            uint32 BLESSING_OF_KINGS = GetSpell(BLESSING_OF_KINGS_1);
+            uint32 BLESSING_OF_SANCTUARY = GetSpell(BLESSING_OF_SANCTUARY_1);
+            uint32 BLESSING_OF_MIGHT = GetSpell(BLESSING_OF_MIGHT_1);
+            bool wisdom = HasAuraName(target, BLESSING_OF_WISDOM_1) || HasAuraName(target, GREATER_BLESSING_OF_WISDOM_1);
+            bool kings = HasAuraName(target, BLESSING_OF_KINGS_1) || HasAuraName(target, GREATER_BLESSING_OF_KINGS_1);
+            bool sanctuary = HasAuraName(target, BLESSING_OF_SANCTUARY_1) || HasAuraName(target, GREATER_BLESSING_OF_SANCTUARY_1);
+            bool might = (HasAuraName(target, BLESSING_OF_MIGHT_1) || HasAuraName(target, GREATER_BLESSING_OF_MIGHT_1) || HasAuraName(target, BATTLESHOUT_1));
+
+            uint8 Class = 0;
+            if (target->GetTypeId() == TYPEID_PLAYER)
+                Class = target->ToPlayer()->getClass();
+            else if (target->ToCreature())
+                Class = target->ToCreature()->GetBotClass();
+            switch (Class)
+            {
+                case CLASS_PRIEST:
+                    if (BLESSING_OF_WISDOM && !wisdom && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    break;
+                case CLASS_DEATH_KNIGHT:
+                case CLASS_WARRIOR:
+                case CLASS_PALADIN:
+                case CLASS_ROGUE:
+                case CLASS_HUNTER:
+                case CLASS_SHAMAN:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (!might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    break;
+                default:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (!might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    break;
+            }
+            return false;
+        }
+
+        void Repentance(uint32 diff, Unit* target = NULL)
+        {
+            temptimer = GC_Timer;
+            if (target)
+            {
+                if (IsSpellReady(REPENTANCE_1, diff, false, 25000) && doCast(target, GetSpell(REPENTANCE_1)))
+                    SetSpellCooldown(REPENTANCE_1, 45000);
+            }
+            else if (IsSpellReady(REPENTANCE_1, diff, false))
+            {
+                Unit* u = FindStunTarget();
+                if (u && u->GetVictim() != me && doCast(u, GetSpell(REPENTANCE_1)))
+                    SetSpellCooldown(REPENTANCE_1, 45000);
+            }
+            GC_Timer = temptimer;
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+            if (Rand() > 60)
+                return;
+
+            Unit* target = IsSpellReady(REPENTANCE_1, diff, false, 25000) ? FindCastingTarget(20, 0, false, REPENTANCE_1) : NULL;
+            if (target)
+                Repentance(diff, target); //first check repentance
+            else if (IsSpellReady(TURN_EVIL_1, diff, false, 1500))
+            {
+                target = FindCastingTarget(20, 0, false, TURN_EVIL_1);
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(TURN_EVIL_1), true))
+                {
+                    SetSpellCooldown(TURN_EVIL_1, 3000);
+                    GC_Timer = temptimer;
+                }
+            }
+            else if (IsSpellReady(HOLY_WRATH_1, diff, false, 8000) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(8, 0, false, TURN_EVIL_1); //here we check target as with turn evil cuz of same requirements
+                temptimer = GC_Timer;
+                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
+                {
+                    SetSpellCooldown(HOLY_WRATH_1, 23000 - me->getLevel() * 100); //23 - 0...8 sec (15 sec on 80 as with glyph)
+                    GC_Timer = temptimer;
+                }
+            }
+            else if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff, /*true*/false, 7000))
+            {
+                target = FindCastingTarget(10);
+                if (target && doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                    SetSpellCooldown(HAMMER_OF_JUSTICE_1, 65000 - master->getLevel()*500); //25 sec on 80
+            }
+        }
+
+        void TurnEvil(uint32 diff)
+        {
+            if (!IsSpellReady(TURN_EVIL_1, diff) || IsCasting() || Rand() > 50 ||
+                FindAffectedTarget(GetSpell(TURN_EVIL_1), me->GetGUID(), 50))
+                return;
+            Unit* target = FindUndeadCCTarget(20, TURN_EVIL_1);
+            if (target &&
+                (target != me->GetVictim() || GetHealthPCT(me) < 70 || target->GetVictim() == master) &&
+                doCast(target, GetSpell(TURN_EVIL_1), true))
+            {
+                SetSpellCooldown(TURN_EVIL_1, 3000);
+                return;
+            }
+            else
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                !CCed(opponent) &&
+                opponent->GetVictim() && !IsTank(opponent->GetVictim()) && opponent->GetVictim() != me &&
+                GetHealthPCT(me) < 90 &&
+                doCast(opponent, GetSpell(TURN_EVIL_1), true))
+            {
+                SetSpellCooldown(TURN_EVIL_1, 3000);
+                return;
+            }
+        }
+
+        void Wrath(uint32 diff)
+        {
+            if (!IsSpellReady(HOLY_WRATH_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 50)
+                return;
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                me->GetExactDist(opponent) <= 8 && doCast(me, GetSpell(HOLY_WRATH_1)))
+                SetSpellCooldown(HOLY_WRATH_1, 23000 - me->getLevel() * 100); //23 - 0...8 sec (15 sec on 80 as with glyph)
+            else
+            {
+                Unit* target = FindUndeadCCTarget(8, GetSpell(HOLY_WRATH_1));
+                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
+                    SetSpellCooldown(HOLY_WRATH_1, 23000 - me->getLevel() * 100); //23 - 0...8 sec (15 sec on 80 as with glyph)
+            }
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+            TurnEvil(diff);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //HAMMER OF WRATH //custom GCD check
+            if (IsSpellReady(HOW_1, diff, false) && GC_Timer <= 300 && HasRole(BOT_ROLE_DPS) && Rand() < 30 && GetHealthPCT(opponent) < 19 &&
+                me->GetExactDist(opponent) < 30)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(HOW_1)))
+                {
+                    SetSpellCooldown(HOW_1, 6000); //6 sec
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HAND OF RECKONING //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(HANDOFRECKONING_1, diff, false) && me->GetExactDist(opponent) < 30 &&
+                HasRole(BOT_ROLE_DPS) && u && u != me && !IsTank(u) && Rand() < 50 &&
+                (IsInBotParty(u) || IsTank()))
+            {
+                Creature* cre = opponent->ToCreature();
+                temptimer = GC_Timer;
+                if (((cre && cre->isWorldBoss() && !IsMeleeClass(u->getClass())) ||
+                    GetHealthPCT(u) < GetHealthPCT(me) - 5 || IsTank()) &&
+                    doCast(opponent, GetSpell(HANDOFRECKONING_1)))
+                {
+                    SetSpellCooldown(HANDOFRECKONING_1, IsTank() ? 4000 : 8000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff) && !CCed(opponent) &&
+                me->GetExactDist(opponent) < 10 && Rand() < 20)
+            {
+                if (doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                {
+                    SetSpellCooldown(HAMMER_OF_JUSTICE_1, 65000 - master->getLevel()*500); //25 sec on 80
+                    return;
+                }
+            }
+
+            if (IsSpellReady(JUDGEMENT_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 10 &&
+                Rand() < 50 && me->HasAura(GetSpell(SEAL_OF_COMMAND_1)))
+            {
+                if (doCast(opponent, GetSpell(JUDGEMENT_1)))
+                {
+                    SetSpellCooldown(JUDGEMENT_1, 7000);
+                    return;
+                }
+            }
+
+            if (IsSpellReady(CONSECRATION_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetDistance(opponent) < 7 &&
+                !opponent->isMoving() && Rand() < 50)
+            {
+                if (doCast(me, GetSpell(CONSECRATION_1)))
+                {
+                    SetSpellCooldown(CONSECRATION_1, 8000);
+                    return;
+                }
+            }
+
+            if (IsSpellReady(AVENGING_WRATH_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > (master->GetMaxHealth()*2)/3 && Rand() < 25)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(AVENGING_WRATH_1)))
+                {
+                    SetSpellCooldown(AVENGING_WRATH_1, 60000); //1 min
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(CRUSADER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetDistance(opponent) < 5)
+            {
+                if (doCast(opponent, GetSpell(CRUSADER_STRIKE_1)))
+                {
+                    SetSpellCooldown(CRUSADER_STRIKE_1, 12000 - me->getLevel() * 100);//4 sec on 80
+                    return;
+                }
+            }
+
+            if (IsSpellReady(EXORCISM_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 30 &&
+                (!IsTank() || opponent->GetVictim() == me || opponent->IsVehicle() || opponent->ToPlayer()))
+            {
+                if (doCast(opponent, GetSpell(EXORCISM_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                {
+                    SetSpellCooldown(EXORCISM_1, 7000);
+                    return;
+                }
+            }
+
+            Wrath(diff);
+
+            if (IsSpellReady(DIVINE_STORM_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 7)
+            {
+                if (doCast(opponent, GetSpell(DIVINE_STORM_1)))
+                {
+                    SetSpellCooldown(DIVINE_STORM_1, 10000 - me->getLevel()/4 * 100); //10 - 2 sec
+                    return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Fanaticism: 18% additional critical chance for all Judgements (not shure which check is right)
+                if (lvl >= 45 && (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT || spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT))
+                    aftercrit += 18.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+            //Sanctity of Battle: 15% bonus damage for Exorcism and Crusader Strike
+            if (lvl >= 25 && spellId == GetSpell(EXORCISM_1))
+                pctbonus += 0.15f;
+            //The Art of War (damage part): 10% bonus damage for Judgements, Crusader Strike and Divine Storm
+            if (lvl >= 40 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT ||
+                spellId == GetSpell(CRUSADER_STRIKE_1) ||
+                spellId == GetSpell(DIVINE_STORM_1)))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Sanctified Wrath: 50% additional critical chance for Hammer of Wrath
+                if (lvl >= 45 && spellId == GetSpell(HOW_1))
+                    aftercrit += 50.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if ((spellId == GetSpell(EXORCISM_1) || spellId == GetSpell(FLASH_OF_LIGHT_1)) &&
+                me->HasAura(THE_ART_OF_WAR_BUFF))
+            {
+                //Art of War: consume buff
+                me->RemoveAura(THE_ART_OF_WAR_BUFF, ObjectGuid::Empty, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+
+            if (spellId == GetSpell(BLESSING_OF_KINGS_1) || spellId == GetSpell(BLESSING_OF_MIGHT_1) ||
+                spellId == GetSpell(BLESSING_OF_WISDOM_1) || spellId == GetSpell(BLESSING_OF_SANCTUARY_1))
+            {
+                //Blessings duration 1h
+                if (Aura* bless = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    bless->SetDuration(dur);
+                    bless->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(HOF_1))
+            {
+                //Guardian's Favor part 2 (handled separately)
+                if (Aura* hof = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = hof->GetDuration() + 4000;
+                    hof->SetDuration(dur);
+                    hof->SetMaxDuration(dur);
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            //Custom OnHit() handlers
+
+            if (damageType == DIRECT_DAMAGE)
+            {
+                //The Art of War: 20% on autoattack
+                if (me->getLevel() >= 33)
+                    if (urand(1,100) <= 20)
+                        me->CastSpell(me, THE_ART_OF_WAR_BUFF, true);
+            }
+
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_PALADIN);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(FLASH_OF_LIGHT_1);
+            InitSpellMap(HOLY_LIGHT_1);
+            InitSpellMap(LAY_ON_HANDS_1);
+            InitSpellMap(SACRED_SHIELD_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(HOLY_SHOCK_1) : RemoveSpell(HOLY_SHOCK_1);
+            InitSpellMap(CLEANSE_1);
+            InitSpellMap(REDEMPTION_1);
+            InitSpellMap(HAMMER_OF_JUSTICE_1);
+  /*Talent*/lvl >= 45 ? InitSpellMap(REPENTANCE_1) : RemoveSpell(REPENTANCE_1);
+            InitSpellMap(TURN_EVIL_1);
+            InitSpellMap(HOLY_WRATH_1);
+            InitSpellMap(EXORCISM_1);
+  /*Talent*/lvl >= 25 ? InitSpellMap(SEAL_OF_COMMAND_1) : RemoveSpell(SEAL_OF_COMMAND_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(CRUSADER_STRIKE_1) : RemoveSpell(CRUSADER_STRIKE_1);
+            InitSpellMap(JUDGEMENT_1);
+            InitSpellMap(CONSECRATION_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(DIVINE_STORM_1) : RemoveSpell(DIVINE_STORM_1);
+            InitSpellMap(HOW_1);
+            InitSpellMap(AVENGING_WRATH_1);
+            InitSpellMap(BLESSING_OF_MIGHT_1);
+            InitSpellMap(BLESSING_OF_WISDOM_1);
+            InitSpellMap(BLESSING_OF_KINGS_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(BLESSING_OF_SANCTUARY_1) : RemoveSpell(BLESSING_OF_SANCTUARY_1);
+            InitSpellMap(DEVOTION_AURA_1);
+            InitSpellMap(CONCENTRATION_AURA_1);
+            InitSpellMap(DIVINE_PLEA_1);
+            InitSpellMap(HAND_OF_PROTECTION_1);
+            InitSpellMap(HOF_1);
+            InitSpellMap(HOS_1);
+            InitSpellMap(HANDOFRECKONING_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            //1 - SPD 3% crit 3%
+            if (level >= 78)
+                RefreshAura(SPELLDMG,5); //+15%
+            else if (level >= 75)
+                RefreshAura(SPELLDMG,4); //+12%
+            else if (level >= 55)
+                RefreshAura(SPELLDMG,3); //+9%
+            else if (level >= 35)
+                RefreshAura(SPELLDMG,2); //+6%
+            else if (level >= 15)
+                RefreshAura(SPELLDMG); //+3%
+            //2 - SPD 6%
+            if (level >= 55)
+                RefreshAura(SPELLDMG2,3); //+18%
+            else if (level >= 35)
+                RefreshAura(SPELLDMG2,2); //+12%
+            else if (level >= 15)
+                RefreshAura(SPELLDMG2); //+6%
+            //Talents
+            if (level >= 55)
+                RefreshAura(PURE1);
+            if (level >= 35)
+                RefreshAura(WISE);
+            if (level >= 50)
+                RefreshAura(RECKONING5); //10%
+            else if (level >= 45)
+                RefreshAura(RECKONING4); //8%
+            else if (level >= 40)
+                RefreshAura(RECKONING3); //6%
+            else if (level >= 35)
+                RefreshAura(RECKONING2); //4%
+            else if (level >= 30)
+                RefreshAura(RECKONING1); //2%
+            //if (level >= 50)
+            //    RefreshAura(RIGHTEOUS_VENGEANCE3);
+            //else if (level >= 47)
+            //    RefreshAura(RIGHTEOUS_VENGEANCE2);
+            //else if (level >= 45)
+            //    RefreshAura(RIGHTEOUS_VENGEANCE1);
+            if (level >= 30)
+                RefreshAura(VENGEANCE3);
+            else if (level >= 27)
+                RefreshAura(VENGEANCE2);
+            else if (level >= 25)
+                RefreshAura(VENGEANCE1);
+            if (level >= 60)
+                RefreshAura(SHOFL3);
+            else if (level >= 55)
+                RefreshAura(SHOFL2);
+            else if (level >= 50)
+                RefreshAura(SHOFL1);
+            if (level >= 45)
+                RefreshAura(SACRED_CLEANSING);
+            if (level >= 35)
+                RefreshAura(DIVINE_PURPOSE);
+            if (level >= 25)
+                RefreshAura(VINDICATION2);
+            else if (level >= 20)
+                RefreshAura(VINDICATION1);
+            if (level >= 30)
+                RefreshAura(LAYHANDS);
+            if (level >= 20)
+                RefreshAura(FANATICISM,2); //-60% aggro
+            if (level >= 15)
+                RefreshAura(GLYPH_HOLY_LIGHT); //10% heal
+            //if (level >= 70)
+            //    RefreshAura(PALADIN_T9_2P_BONUS); //Righteous Vengeance Crits
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case FLASH_OF_LIGHT_1:
+                case HOLY_LIGHT_1:
+                case LAY_ON_HANDS_1:
+                case HOF_1:
+                case SACRED_SHIELD_1:
+                case HOLY_SHOCK_1:
+                case CLEANSE_1:
+                case HAND_OF_PROTECTION_1:
+                case HOS_1:
+                case SEAL_OF_COMMAND_1:
+                case DIVINE_PLEA_1:
+                case AVENGING_WRATH_1:
+                case BLESSING_OF_MIGHT_1:
+                case BLESSING_OF_WISDOM_1:
+                case BLESSING_OF_KINGS_1:
+                case BLESSING_OF_SANCTUARY_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+
+        enum PaladinBaseSpells// all orignals
+        {
+            FLASH_OF_LIGHT_1                    = 19750,
+            HOLY_LIGHT_1                        = 635,
+            LAY_ON_HANDS_1                      = 633,
+            REDEMPTION_1                        = 7328,
+            HOF_1  /*Hand of Freedom*/          = 1044,
+            SACRED_SHIELD_1                     = 53601,
+            HOLY_SHOCK_1                        = 20473,
+            CLEANSE_1                           = 4987,
+            HAND_OF_PROTECTION_1                = 1022,
+            HOS_1 /*Hand of salvation*/         = 1038,
+            SEAL_OF_COMMAND_1                   = 20375,
+            HANDOFRECKONING_1                   = 62124,
+            DIVINE_PLEA_1                       = 54428,
+            REPENTANCE_1                        = 20066,
+            TURN_EVIL_1                         = 10326,
+            CRUSADER_STRIKE_1                   = 35395,
+            JUDGEMENT_1                         = 20271,
+            CONSECRATION_1                      = 26573,
+            HAMMER_OF_JUSTICE_1                 = 853,
+            DIVINE_STORM_1                      = 53385,
+            HOW_1   /*Hammer of Wrath*/         = 24275,
+            EXORCISM_1                          = 879,
+            HOLY_WRATH_1                        = 2812,
+            AVENGING_WRATH_1                    = 31884,
+            BLESSING_OF_MIGHT_1                 = 19740,
+            BLESSING_OF_WISDOM_1                = 19742,
+            BLESSING_OF_KINGS_1                 = 20217,
+            BLESSING_OF_SANCTUARY_1             = 20911,
+            DEVOTION_AURA_1                     = 465,
+            CONCENTRATION_AURA_1                = 19746
+        };
+        enum PaladinPassives
+        {
+        //Talents
+            DIVINE_PURPOSE                      = 31872,
+            PURE1                               = 54155, /*Judgements of the Pure*/
+            WISE                                = 31878, /*Judgements of the Wise*/
+            SACRED_CLEANSING                    = 53553,//rank 3
+            RECKONING1                          = 20177,
+            RECKONING2                          = 20179,
+            RECKONING3                          = 20181,
+            RECKONING4                          = 20180,
+            RECKONING5                          = 20182,
+            VINDICATION1                        = 9452 ,//rank 1
+            VINDICATION2                        = 26016,//rank 2
+            LAYHANDS                            = 20235, /*Improved LOH rank 2*/
+            FANATICISM                          = 31881,//rank 3
+            //RIGHTEOUS_VENGEANCE1                = 53380,//rank 1
+            //RIGHTEOUS_VENGEANCE2                = 53381,//rank 2
+            //RIGHTEOUS_VENGEANCE3                = 53382,//rank 3
+            VENGEANCE1                          = 20049,//rank 1
+            VENGEANCE2                          = 20056,//rank 2
+            VENGEANCE3                          = 20057,//rank 3
+            SHOFL1                              = 53501,//Sheath of Light rank 1
+            SHOFL2                              = 53502,//rank 2
+            SHOFL3                              = 53503,//rank 3
+        //Glyphs
+            GLYPH_HOLY_LIGHT                    = 54937,
+        //other
+            SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            SPELLDMG2/*Earth and Moon - druid*/ = 48511 //rank3 6% dam
+        };
+
+        enum PaladinSpecial
+        {
+            NOAURA,
+            DEVOTIONAURA,
+            CONCENTRATIONAURA,
+
+            THE_ART_OF_WAR_BUFF                 = 59578,
+            FORBEARANCE_AURA                    = 25771,
+
+            GREATER_BLESSING_OF_MIGHT_1         = 25782,
+            GREATER_BLESSING_OF_WISDOM_1        = 25894,
+            GREATER_BLESSING_OF_KINGS_1         = 25898,
+            GREATER_BLESSING_OF_SANCTUARY_1     = 25899,
+            BATTLESHOUT_1                       = 6673
+        };
+    };
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_priest_ai.cpp b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
new file mode 100644
index 0000000..efa382b
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
@@ -0,0 +1,1042 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Priest NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 50%
+TODO: maybe remove Divine Spirit or so, too much buffs
+*/
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new priest_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct priest_botAI : public bot_minion_ai
+    {
+        priest_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_PRIEST) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        bool MassGroupHeal(Player* player, uint32 diff)
+        {
+            if (!player->GetGroup()) return false;
+            if (IsCasting()) return false;
+            if (Rand() > 35) return false;
+
+            if (IsSpellReady(DIVINE_HYMN_1, diff, false))
+            {
+                Group* gr = player->GetGroup();
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->IsInWorld() || me->GetMap() != tPlayer->FindMap() ||
+                        tPlayer->IsBeingTeleported() || tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 35) continue;
+                        uint8 pct = 50 + tPlayer->getAttackers().size()*10;
+                        pct = pct < 80 ? pct : 80;
+                        if (GetHealthPCT(tPlayer) < pct && GetLostHP(tPlayer) > 4000)
+                            ++LHPcount;
+                    }
+                    if (LHPcount > 1)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && GetHealthPCT(bot) < 40 && me->GetExactDist(bot) < 30)
+                            ++LHPcount;
+                        if (LHPcount > 1)
+                            break;
+                    }
+                }
+                if (LHPcount > 1 && doCast(me, GetSpell(DIVINE_HYMN_1)))
+                {
+                    SetSpellCooldown(DIVINE_HYMN_1, 180000); //3 min
+                    return true;
+                }
+            }
+            if (GetSpell(PRAYER_OF_HEALING_1))
+            {
+                Group* gr = player->GetGroup();
+                Unit* castTarget = NULL;
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->IsInWorld() || me->GetMap() != tPlayer->GetMap() ||
+                        tPlayer->IsBeingTeleported() || tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 25) continue;
+                        if (GetHealthPCT(tPlayer) < 85)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(tPlayer) < lowestPCT)
+                            lowestPCT = GetHealthPCT(tPlayer);
+                            castTarget = tPlayer;
+                        }
+                    }
+                    if (LHPcount > 2)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && GetHealthPCT(bot) < 70 && me->GetExactDist(bot) < 15)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(bot) < lowestPCT)
+                            lowestPCT = GetHealthPCT(bot);
+                            castTarget = bot;
+                        }
+                        if (LHPcount > 2)
+                            break;
+                    }
+                }
+
+                if (LHPcount > 2 && castTarget && doCast(castTarget, GetSpell(PRAYER_OF_HEALING_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        bool ShieldTarget(Unit* target, uint32 diff)
+        {
+            if (!IsSpellReady(PW_SHIELD_1, diff, false) || IsCasting() || Rand() > 50)
+                return false;
+            if (me->GetExactDist(target) > 40)
+                return false;
+            if (target->getAttackers().empty() && GetHealthPCT(target) > 33 &&
+                !target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (target->HasAura(WEAKENED_SOUL_DEBUFF) || HasAuraName(target, PW_SHIELD_1))
+                return false;
+
+            if (doCast(target, GetSpell(PW_SHIELD_1)))
+            {
+                if (me->getLevel() >= 30 || (target->ToCreature() && target->ToCreature()->GetBotAI()))
+                    SetSpellCooldown(PW_SHIELD_1, 1000);
+                else
+                    SetSpellCooldown(PW_SHIELD_1, 4000);
+                GC_Timer = 800;
+                return true;
+            }
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit* u) { bot_ai::JustDied(u); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            Disperse(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+            DoDevCheck(diff);
+
+            if (GetManaPCT(me) < 33 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            //check possible fear
+            doDefend(diff);
+            //buff and heal master's group
+            MassGroupHeal(master, diff);
+            BuffAndHealGroup(master, diff);
+            CureGroup(master, DISPELMAGIC, diff);
+            CureGroup(master, GetSpell(CURE_DISEASE_1), diff);
+            //ShieldGroup(master);
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckDispel(diff);
+                CheckSilence(diff);
+            }
+
+            if (me->IsInCombat())
+                CheckShackles(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_PRIEST))
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (GetHealthPCT(master) > 90 && GetManaPCT(me) > 35 && GetHealthPCT(me) > 90 &&
+                (m_attackers.size() < 4 || b_attackers.size() + m_attackers.size() < 3) &&
+                !IsCasting())
+                //general rule
+            {
+                opponent = me->GetVictim();
+                if (opponent)
+                {
+                    if (!IsCasting())
+                        StartAttack(opponent);
+                }
+                else
+                    return;
+                float dist = me->GetExactDist(opponent);
+                if (HasRole(BOT_ROLE_DPS) && dist < 30)
+                {
+                    if (IsSpellReady(SW_DEATH_1, diff, false) && Rand() < 50 &&
+                        (GetHealthPCT(opponent) < 15 || opponent->GetHealth() < me->GetMaxHealth()/6) &&
+                        doCast(opponent, GetSpell(SW_DEATH_1)))
+                    {
+                        SetSpellCooldown(SW_DEATH_1, 8000);
+                        return;
+                    }
+                    if (IsSpellReady(SW_PAIN_1, diff) && Rand() < 25 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/4 &&
+                        !HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(SW_PAIN_1)))
+                        return;
+                    if (IsSpellReady(VAMPIRIC_TOUCH_1, diff) && Rand() < 50 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/4 &&
+                        !HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(VAMPIRIC_TOUCH_1)))
+                        return;
+                    if (IsSpellReady(DEVOURING_PLAGUE_1, diff) && !Devcheck && Rand() < 30 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/3 &&
+                        !HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(DEVOURING_PLAGUE_1)))
+                        return;
+                    if (IsSpellReady(MIND_BLAST_1, diff) && Rand() < 35 &&
+                        (!GetSpell(VAMPIRIC_TOUCH_1) || HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID())) &&
+                        doCast(opponent, GetSpell(MIND_BLAST_1)))
+                    {
+                        SetSpellCooldown(MIND_BLAST_1, 6000);
+                        return;
+                    }
+                    if (IsSpellReady(MIND_FLAY_1, diff, false) && !me->isMoving() && Rand() < 20 &&
+                        (opponent->isMoving() || opponent->GetHealth() < me->GetMaxHealth()/5 ||
+                        (HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) && HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()))) &&
+                        doCast(opponent, GetSpell(MIND_FLAY_1)))
+                    {
+                        SetSpellCooldown(MIND_FLAY_1, 2500);
+                        return;
+                    }
+                    if (IsSpellReady(MIND_SEAR_1, diff, false) && !me->isMoving() && !opponent->isMoving() && dist < 35 && Rand() < 50 &&
+                        HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) &&
+                        HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()))
+                    {
+                        if (Unit* u = FindSplashTarget(30, opponent))
+                            if (doCast(u, GetSpell(MIND_SEAR_1)))
+                                return;
+                    }
+                }//endif opponent
+            }//endif damage
+            //check horror after dots/damage
+            if (IsSpellReady(PSYCHIC_HORROR_1, diff, false) &&
+                opponent->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                opponent->GetHealth() > me->GetMaxHealth()/5 && !CCed(opponent) && Rand() < 30 &&
+                me->GetExactDist(opponent) < 30 && !HasAuraName(opponent, PSYCHIC_HORROR_1))
+            {
+                if (doCast(opponent, GetSpell(PSYCHIC_HORROR_1)))
+                {
+                    SetSpellCooldown(PSYCHIC_HORROR_1, 60000);
+                    return;
+                }
+            }
+        }//end UpdateAI
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL))
+                return false;
+            if (hp > 98)
+                return false;
+            if (!target || !target->IsAlive() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid())
+                return false;
+
+            //GUARDIAN SPIRIT
+            if (IsSpellReady(GUARDIAN_SPIRIT_1, diff, false) && target->IsInCombat() &&
+                !target->getAttackers().empty() && hp < (5 + std::min(20, uint8(target->getAttackers().size())*5)) &&
+                ((master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID())) || target == master) &&
+                Rand() < 80 && !target->HasAura(GetSpell(GUARDIAN_SPIRIT_1)))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(GUARDIAN_SPIRIT_1)))
+                {
+                    GC_Timer = temptimer;
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        me->Whisper("Guardian Spirit on you!", LANG_UNIVERSAL, target->ToPlayer());
+                        SetSpellCooldown(GUARDIAN_SPIRIT_1, 90000); //1.5 min
+                    }
+                    else
+                    {
+                        std::ostringstream msg;
+                        msg << "Guardian Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
+                        me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master);
+                        SetSpellCooldown(GUARDIAN_SPIRIT_1, 30000); //30 sec for creatures
+                    }
+
+                    return true;
+                }
+            }
+
+            if (IsCasting()) return false;
+
+            //PAIN SUPPRESSION
+            if (hp < 35 && IsSpellReady(PAIN_SUPPRESSION_1, diff, false) &&
+                (target->IsInCombat() || !target->getAttackers().empty()) && Rand() < 50 &&
+                !target->HasAura(GetSpell(PAIN_SUPPRESSION_1)))
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(PAIN_SUPPRESSION_1)))
+                {
+                    GC_Timer = temptimer;
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        me->Whisper("Pain Suppression on you!", LANG_UNIVERSAL, target->ToPlayer());
+                        SetSpellCooldown(PAIN_SUPPRESSION_1, 60000); //60 sec
+                    }
+                    else
+                    {
+                        std::ostringstream msg;
+                        msg << "Guardin Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
+                        me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master);
+                        SetSpellCooldown(PAIN_SUPPRESSION_1, 15000); //15 sec for creatures
+                    }
+
+                    return true;
+                }
+            }
+
+            //Now Heals Requires GCD
+            if ((hp < 80 || !target->getAttackers().empty()) &&
+                ShieldTarget(target, diff))
+                return true;
+
+            //PENANCE/Greater Heal
+            if (hp < 75 || GetLostHP(target) > 4000)
+            {
+                if (IsSpellReady(PENANCE_1, diff, false) && !me->isMoving() && Rand() < 80 &&
+                    (target->GetTypeId() != TYPEID_PLAYER ||
+                    !(target->ToPlayer()->IsCharmed() || target->ToPlayer()->isPossessed())) &&
+                    doCast(target, GetSpell(PENANCE_1)))
+                {
+                    SetSpellCooldown(PENANCE_1, 8000);
+                    return true;
+                }
+                else if (HEAL && Heal_Timer <= diff && GC_Timer <= diff && hp > 50 && Rand() < 70 &&
+                    doCast(target, HEAL))
+                {
+                    Heal_Timer = 2500;
+                    return true;
+                }
+            }
+            //Flash Heal
+            if (IsSpellReady(FLASH_HEAL_1, diff) &&
+                ((hp > 75 && hp < 90) || hp < 50 || GetLostHP(target) > 1500) &&
+                doCast(target, GetSpell(FLASH_HEAL_1)))
+                return true;
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = IsTank(target) && boss;
+            //Renew
+            if (IsSpellReady(RENEW_1, diff) &&
+                ((hp < 98 && hp > 70) || GetLostHP(target) > 500 || tanking) &&
+                !HasAuraName(target, RENEW_1, me->GetGUID()) &&
+                doCast(target, GetSpell(RENEW_1)))
+            {
+                GC_Timer = 800;
+                return true;
+            }
+
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!target || !target->IsInWorld() || target->isDead() ||
+                GC_Timer > diff || me->GetExactDist(target) > 30 || Rand() > 20)
+                return false;
+
+            if (IsSpellReady(FEAR_WARD_1, false) && !target->HasAura(GetSpell(FEAR_WARD_1)) &&
+                doCast(target, GetSpell(FEAR_WARD_1)))
+            {
+                SetSpellCooldown(FEAR_WARD_1, target->GetTypeId() == TYPEID_PLAYER ? 60000 : 30000); //30sec for bots
+                GC_Timer = 800;
+                return true;
+            }
+
+            if (target == me)
+            {
+                uint32 INNER_FIRE = GetSpell(INNER_FIRE_1);
+                if (INNER_FIRE && !me->HasAura(INNER_FIRE) &&
+                    doCast(me, INNER_FIRE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+                uint32 VAMPIRIC_EMBRACE = GetSpell(VAMPIRIC_EMBRACE_1);
+                if (VAMPIRIC_EMBRACE && !me->HasAura(VAMPIRIC_EMBRACE) &&
+                    doCast(me, VAMPIRIC_EMBRACE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (uint32 PW_FORTITUDE = GetSpell(PW_FORTITUDE_1))
+            {
+                if (!HasAuraName(target, PW_FORTITUDE) &&
+                    doCast(target, PW_FORTITUDE))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+            if (uint32 SHADOW_PROTECTION = GetSpell(SHADOW_PROTECTION_1))
+            {
+                if (!HasAuraName(target, SHADOW_PROTECTION) &&
+                    doCast(target, SHADOW_PROTECTION))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+            if (uint32 DIVINE_SPIRIT = GetSpell(DIVINE_SPIRIT_1))
+            {
+                if (!HasAuraName(target, DIVINE_SPIRIT) &&
+                    doCast(target, DIVINE_SPIRIT))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || Rand() > 50)
+                return;
+
+            RezGroup(GetSpell(RESURRECTION_1), master);
+
+            //if (Feasting())
+            //    return;
+
+            //if (BuffTarget(master, diff))
+            //    return;
+            //if (BuffTarget(me, diff))
+            //    return;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (!DISPELMAGIC || CheckDispelTimer > diff || Rand() > 25 || IsCasting())
+                return;
+
+            Unit* target = FindHostileDispelTarget();
+            if (target && doCast(target, DISPELMAGIC))
+                CheckDispelTimer = 1000;
+
+            CheckDispelTimer = 3000; //fail
+        }
+
+        void CheckShackles(uint32 diff)
+        {
+            if (!IsSpellReady(SHACKLE_UNDEAD_1, diff) || IsCasting() || Rand() > 50)
+                return;
+
+            uint32 SHACKLE_UNDEAD = GetSpell(SHACKLE_UNDEAD_1);
+            if (FindAffectedTarget(SHACKLE_UNDEAD, me->GetGUID()))
+            {
+                Shackle_Timer = 1500;
+                return;
+            }
+            Unit* target = FindUndeadCCTarget(30, SHACKLE_UNDEAD);
+            if (target && doCast(target, SHACKLE_UNDEAD))
+            {
+                Shackle_Timer = 3000;
+                GC_Timer = 800;
+            }
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (IsCasting()) return;
+            temptimer = GC_Timer;
+            if (IsSpellReady(SILENCE_1, diff, false))
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, GetSpell(SILENCE_1)))
+                        SetSpellCooldown(SILENCE_1, 30000);
+            }
+            else if (IsSpellReady(PSYCHIC_HORROR_1, diff, false, 20000))
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, GetSpell(PSYCHIC_HORROR_1)))
+                        SetSpellCooldown(PSYCHIC_HORROR_1, 60000);
+            }
+            GC_Timer = temptimer;
+        }
+
+        void doDefend(uint32 diff)
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            //fear master's attackers
+            if (IsSpellReady(PSYCHIC_SCREAM_1, diff, false))
+            {
+                if (!m_attackers.empty() && (!IsTank(master) || GetHealthPCT(master) < 75))
+                {
+                    uint8 tCount = 0;
+                    for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                    {
+                        SetSpellCooldown(PSYCHIC_SCREAM_1, 22000);
+                        return;
+                    }
+                }
+
+                // Defend myself (psychic horror)
+                if (!b_attackers.empty())
+                {
+                    uint8 tCount = 0;
+                    for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 0 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                    {
+                        SetSpellCooldown(PSYCHIC_SCREAM_1, 22000);
+                        return;
+                    }
+                }
+            }
+            // Heal myself
+            if (GetHealthPCT(me) < 98 && !b_attackers.empty())
+            {
+                if (ShieldTarget(me, diff)) return;
+
+                if (IsSpellReady(FADE_1, diff, false) && me->IsInCombat())
+                {
+                    if (b_attackers.empty()) return;
+                    uint8 Tattackers = 0;
+                    for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->ToCreature()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if (me->GetExactDist((*iter)) < 15)
+                            Tattackers++;
+                    }
+                    if (Tattackers > 0)
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(FADE_1)))
+                        {
+                            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                                if ((*iter)->getThreatManager().getThreat(me) > 0.f)
+                                    (*iter)->getThreatManager().modifyThreatPercent(me, -50);
+                            SetSpellCooldown(FADE_1, 10000);
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                if (GetHealthPCT(me) < 90 && HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            }
+        }
+
+        void DoDevCheck(uint32 diff)
+        {
+            if (DevcheckTimer <= diff)
+            {
+                Devcheck = FindAffectedTarget(GetSpell(DEVOURING_PLAGUE_1), me->GetGUID());
+                DevcheckTimer = 5000;
+            }
+        }
+
+        void Disperse(uint32 diff)
+        {
+            if (!IsSpellReady(DISPERSION_1, diff) || IsCasting() || Rand() > 60)
+                return;
+            if ((me->getAttackers().size() > 3 && !IsSpellReady(FADE_1, diff, false) && GetHealthPCT(me) < 90) ||
+                (GetHealthPCT(me) < 20 && me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                (GetManaPCT(me) < 30) ||
+                (me->getAttackers().size() > 1 && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(DISPERSION_1)))
+                    SetSpellCooldown(DISPERSION_1, 60000);
+                GC_Timer = temptimer;
+                return;
+            }
+
+            SetSpellCooldown(DISPERSION_1, 2000); //fail
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //434 new
+                //Improved Fire Blast (part 1): 8% additional crit chance for Fire Blast
+                //if (lvl >= 11 && spellId == FLAMESTRIKE)
+                //    aftercrit += 8.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                ////!!!spell damage is not yet critical and will be multiplied by 1.5
+                ////so we should put here bonus damage mult /1.5
+                ////Ice Shards: 50% additional crit damage bonus for Frost spells
+                //else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                //    pctbonus += 0.333f;
+            }
+            //Twin Disciplines (damage part): 6% bonus damage for shadow and holy spells
+            if (lvl >= 13)
+                if ((SPELL_SCHOOL_MASK_HOLY & spellInfo->GetSchoolMask()) ||
+                    (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask()))
+                    pctbonus += 0.06f;
+            //Twisted Faith (part 1): 2% bonus damage for shadow spells
+            if (lvl >= 21 && (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask()))
+                pctbonus += 0.02f;
+            //Mind Melt (part 1): 30% bonus damage for Shadow Word: Death
+            if (lvl >= 41 && spellId == GetSpell(SW_DEATH_1))
+                pctbonus += 0.3f;
+
+            //Glyph of Mind Flay: 10% damage bonus for Mind Flay
+            if (lvl >= 25 && spellId == GetSpell(MIND_FLAY_1))
+                pctbonus += 0.1f;
+
+            //other
+            if (spellId == SW_DEATH_BACKLASH)
+            {
+                //T13 Shadow 2P Bonus (Shadow Word: Death), part 2
+                if (lvl >= 60) //buffed
+                    pctbonus -= 0.95f;
+                //Pain and Suffering (part 2): 40% reduced backlash damage
+                if (lvl >= 50)
+                    pctbonus -= 0.4f;
+
+                pctbonus = std::min<float>(pctbonus, 1.0f);
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Strength of Soul: direct heals reduce Weakened Soul duration on target by 4 sec
+            if (spellId == HEAL || spellId == GetSpell(FLASH_HEAL_1))
+            {
+                if (me->getLevel() >= 51)
+                {
+                    if (Aura* soul = target->GetAura(WEAKENED_SOUL_DEBUFF))
+                    {
+                        if (soul->GetDuration() > 4000)
+                            soul->SetDuration(soul->GetDuration() - 4000);
+                        else
+                            target->RemoveAura(soul, AURA_REMOVE_BY_EXPIRE);
+                    }
+                }
+            }
+
+            //Pain and Suffering (part 1, 335 version): 100% to refresh Shadow Word: Pain on target hit by Mind Flay
+            if (spellId == GetSpell(MIND_FLAY_1))
+                if (me->getLevel() >= 51)
+                    if (Aura* pain = target->GetAura(GetSpell(SW_PAIN_1), me->GetGUID()))
+                        pain->RefreshDuration();
+
+            if (spellId == GetSpell(FEAR_WARD_1))
+            {
+                //2 minutes bonus duration for Fear Ward
+                if (Aura* ward = target->GetAura(GetSpell(FEAR_WARD_1), me->GetGUID()))
+                {
+                    uint32 dur = ward->GetDuration() + 120000;
+                    ward->SetDuration(dur);
+                    ward->SetMaxDuration(dur);
+                }
+            }
+
+            if (spellId == GetSpell(INNER_FIRE_1) || spellId == GetSpell(VAMPIRIC_EMBRACE_1) || spellId == GetSpell(PW_FORTITUDE_1) ||
+                spellId == GetSpell(SHADOW_PROTECTION_1) || spellId == GetSpell(DIVINE_SPIRIT_1))
+            {
+                //1 hour duration for all buffs
+                if (Aura* buff = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    buff->SetDuration(dur);
+                    buff->SetMaxDuration(dur);
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Shackle_Timer = 0;
+
+            CheckDispelTimer = 0;
+            DevcheckTimer = 0;
+
+            Devcheck = false;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_PRIEST);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (Heal_Timer > diff)                  Heal_Timer -= diff;
+            if (Shackle_Timer > diff)               Shackle_Timer -= diff;
+
+            if (CheckDispelTimer > diff)            CheckDispelTimer -= diff;
+            if (DevcheckTimer > diff)               DevcheckTimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            DISPELMAGIC = lvl >= 70 ? MASS_DISPEL_1 : InitSpell(me, DISPEL_MAGIC_1);
+            InitSpellMap(CURE_DISEASE_1);
+            InitSpellMap(FEAR_WARD_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(PAIN_SUPPRESSION_1) : RemoveSpell(PAIN_SUPPRESSION_1);
+            InitSpellMap(PSYCHIC_SCREAM_1);
+            InitSpellMap(FADE_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(PSYCHIC_HORROR_1) : RemoveSpell(PSYCHIC_HORROR_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(SILENCE_1) : RemoveSpell(SILENCE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(PENANCE_1) : RemoveSpell(PENANCE_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(VAMPIRIC_EMBRACE_1) : RemoveSpell(VAMPIRIC_EMBRACE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(DISPERSION_1) : RemoveSpell(DISPERSION_1);
+            InitSpellMap(MIND_SEAR_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(GUARDIAN_SPIRIT_1) : RemoveSpell(GUARDIAN_SPIRIT_1);
+            InitSpellMap(SHACKLE_UNDEAD_1);
+            HEAL = lvl >= 40 ? InitSpell(me, GREATER_HEAL_1) : lvl >= 16 ? InitSpell(me, NORMAL_HEAL_1) : InitSpell(me, LESSER_HEAL_1);
+            InitSpellMap(RENEW_1);
+            InitSpellMap(FLASH_HEAL_1);
+            InitSpellMap(PRAYER_OF_HEALING_1);
+            InitSpellMap(DIVINE_HYMN_1);
+            InitSpellMap(RESURRECTION_1);
+            InitSpellMap(PW_SHIELD_1);
+            InitSpellMap(INNER_FIRE_1);
+            InitSpellMap(PW_FORTITUDE_1);
+            InitSpellMap(SHADOW_PROTECTION_1);
+            InitSpellMap(DIVINE_SPIRIT_1);
+            InitSpellMap(SW_PAIN_1);
+            InitSpellMap(MIND_BLAST_1);
+            InitSpellMap(SW_DEATH_1);
+            InitSpellMap(DEVOURING_PLAGUE_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(MIND_FLAY_1) : RemoveSpell(MIND_FLAY_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(VAMPIRIC_TOUCH_1) : RemoveSpell(VAMPIRIC_TOUCH_1);
+        }
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 65)
+                RefreshAura(BORROWED_TIME); //25%haste/40%bonus
+            if (level >= 55)
+                RefreshAura(DIVINE_AEGIS); //30%
+            if (level >= 55)
+                RefreshAura(EMPOWERED_RENEW3); //15%
+            else if (level >= 50)
+                RefreshAura(EMPOWERED_RENEW2); //10%
+            else if (level >= 45)
+                RefreshAura(EMPOWERED_RENEW1); //5%
+            if (level >= 45)
+                RefreshAura(BODY_AND_SOUL1); //30%
+            if (level >= 50)
+                RefreshAura(PAINANDSUFFERING3); //100%
+            else if (level >= 48)
+                RefreshAura(PAINANDSUFFERING2); //66%
+            else if (level >= 45)
+                RefreshAura(PAINANDSUFFERING1); //33%
+            if (level >= 50)
+                RefreshAura(MISERY3); //3%
+            else if (level >= 48)
+                RefreshAura(MISERY2); //2%
+            else if (level >= 45)
+                RefreshAura(MISERY1); //1%
+            if (level >= 45)
+                RefreshAura(GRACE); //100%
+            if (level >= 35)
+                RefreshAura(IMPROVED_DEVOURING_PLAGUE); //30%
+            if (level >= 25)
+                RefreshAura(INSPIRATION3); //10%
+            else if (level >= 23)
+                RefreshAura(INSPIRATION2); //6%
+            else if (level >= 20)
+                RefreshAura(INSPIRATION1); //3%
+            if (level >= 30)
+                RefreshAura(SHADOW_WEAVING3); //100%
+            else if (level >= 28)
+                RefreshAura(SHADOW_WEAVING2); //66%
+            else if (level >= 25)
+                RefreshAura(SHADOW_WEAVING1); //33%
+            if (level >= 15)
+            {
+                RefreshAura(GLYPH_SW_PAIN);
+                RefreshAura(GLYPH_PW_SHIELD); //20% heal
+            }
+            if (level >= 40)
+                RefreshAura(SHADOWFORM); //allows dots to crit, passive
+            if (level >= 70)
+                RefreshAura(PRIEST_T10_2P_BONUS);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case DISPEL_MAGIC_1:
+                case MASS_DISPEL_1:
+                case CURE_DISEASE_1:
+                case FEAR_WARD_1:
+                case PAIN_SUPPRESSION_1:
+                case FADE_1:
+                case PENANCE_1:
+                case VAMPIRIC_EMBRACE_1:
+                case DISPERSION_1:
+                case GUARDIAN_SPIRIT_1:
+                case LESSER_HEAL_1:
+                case NORMAL_HEAL_1:
+                case GREATER_HEAL_1:
+                case RENEW_1:
+                case FLASH_HEAL_1:
+                case PRAYER_OF_HEALING_1:
+                case DIVINE_HYMN_1:
+                case PW_SHIELD_1:
+                case INNER_FIRE_1:
+                case PW_FORTITUDE_1:
+                case SHADOW_PROTECTION_1:
+                case DIVINE_SPIRIT_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 DISPELMAGIC, HEAL;
+        uint32 Heal_Timer, Shackle_Timer;
+/*Misc*/uint16 CheckDispelTimer, DevcheckTimer;
+/*Misc*/bool Devcheck;
+
+        enum PriestBaseSpells
+        {
+            DISPEL_MAGIC_1                      = 527,
+            MASS_DISPEL_1                       = 32375,
+            CURE_DISEASE_1                      = 528,
+            FEAR_WARD_1                         = 6346,
+  /*Talent*/PAIN_SUPPRESSION_1                  = 33206,
+            PSYCHIC_SCREAM_1                    = 8122,
+            FADE_1                              = 586,
+  /*Talent*/PSYCHIC_HORROR_1                    = 64044,
+  /*Talent*/SILENCE_1                           = 15487,
+  /*Talent*/PENANCE_1                           = 47540,
+  /*Talent*/VAMPIRIC_EMBRACE_1                  = 15286,
+  /*Talent*/DISPERSION_1                        = 47585,
+            MIND_SEAR_1                         = 48045,
+  /*Talent*/GUARDIAN_SPIRIT_1                   = 47788,
+            SHACKLE_UNDEAD_1                    = 9484,
+            LESSER_HEAL_1                       = 2050,
+            NORMAL_HEAL_1                       = 2054,
+            GREATER_HEAL_1                      = 2060,
+            RENEW_1                             = 139,
+            FLASH_HEAL_1                        = 2061,
+            PRAYER_OF_HEALING_1                 = 596,
+            DIVINE_HYMN_1                       = 64843,
+            RESURRECTION_1                      = 2006,
+            PW_SHIELD_1                         = 17,
+            INNER_FIRE_1                        = 588,
+            PW_FORTITUDE_1                      = 1243,
+            SHADOW_PROTECTION_1                 = 976,
+            DIVINE_SPIRIT_1                     = 14752,
+            SW_PAIN_1                           = 589,
+            MIND_BLAST_1                        = 8092,
+            SW_DEATH_1                          = 32379,
+            DEVOURING_PLAGUE_1                  = 2944,
+  /*Talent*/MIND_FLAY_1                         = 15407,
+  /*Talent*/VAMPIRIC_TOUCH_1                    = 34914
+        };
+        enum PriestPassives
+        {
+            SHADOWFORM  /*For DOT crits*/   = 49868,
+        //Talents
+            IMPROVED_DEVOURING_PLAGUE       = 63627,//rank 3
+            MISERY1                         = 33191,
+            MISERY2                         = 33192,
+            MISERY3                         = 33193,
+            PAINANDSUFFERING1               = 47580,
+            PAINANDSUFFERING2               = 47581,
+            PAINANDSUFFERING3               = 47582,
+            SHADOW_WEAVING1                 = 15257,
+            SHADOW_WEAVING2                 = 15331,
+            SHADOW_WEAVING3                 = 15332,
+            DIVINE_AEGIS                    = 47515,//rank 3
+            BORROWED_TIME                   = 52800,//rank 5
+            GRACE                           = 47517,//rank 2
+            EMPOWERED_RENEW1                = 63534,
+            EMPOWERED_RENEW2                = 63542,
+            EMPOWERED_RENEW3                = 63543,
+            INSPIRATION1                    = 14892,
+            INSPIRATION2                    = 15362,
+            INSPIRATION3                    = 15363,
+            BODY_AND_SOUL1                  = 64127,
+        //Glyphs
+            GLYPH_SW_PAIN                   = 55681,
+            GLYPH_PW_SHIELD                 = 55672,
+        //other
+            PRIEST_T10_2P_BONUS             = 70770 //33% renew
+        };
+        enum PriestSpecial
+        {
+            IMPROVED_DEVOURING_PLAGUE_DAMAGE= 63675,
+            MIND_SEAR_DAMAGE                = 49821,
+            SW_DEATH_BACKLASH               = 32409,
+            WEAKENED_SOUL_DEBUFF            = 6788
+        };
+    };
+};
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
new file mode 100644
index 0000000..da2504e
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
@@ -0,0 +1,884 @@
+#include "bot_ai.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Rogue NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 25% maybe...
+TODO:
+*/
+#define DMGMIN              1
+#define DMGMAX              2
+#define MAX_COMBO_POINTS    5
+#define EVISCERATE_MAX_RANK 12
+const uint32 EVSCRDamage[EVISCERATE_MAX_RANK+1][MAX_COMBO_POINTS+1][DMGMAX+1] =
+{
+    { { 0,0,0 }, { 0,0,0 },     { 0,0,0 },      { 0,0,0 },       { 0,0,0 },       { 0,0,0 }       },
+    { { 0,0,0 }, { 0,6,11 },    { 0,12,16 },    { 0,17,22 },     { 0,22,28 },     { 0,28,34 }     },
+    { { 0,0,0 }, { 0,14,23 },   { 0,26,34 },    { 0,37,46 },     { 0,48,58 },     { 0,60,70 }     },
+    { { 0,0,0 }, { 0,25,49 },   { 0,45,59 },    { 0,64,79 },     { 0,83,99 },     { 0,103,119 }   },
+    { { 0,0,0 }, { 0,41,62 },   { 0,73,93 },    { 0,104,125 },   { 0,135,157 },   { 0,167,189 }   },
+    { { 0,0,0 }, { 0,60,91 },   { 0,106,136 },  { 0,151,182 },   { 0,196,228 },   { 0,242,274 }   },
+    { { 0,0,0 }, { 0,93,138 },  { 0,165,209 },  { 0,236,281 },   { 0,307,353 },   { 0,379,425 }   },
+    { { 0,0,0 }, { 0,144,213 }, { 0,255,323 },  { 0,365,434 },   { 0,475,545 },   { 0,586,656 }   },
+    { { 0,0,0 }, { 0,199,296 }, { 0,351,447 },  { 0,502,599 },   { 0,653,751 },   { 0,805,903 }   },
+    { { 0,0,0 }, { 0,224,333 }, { 0,395,503 },  { 0,565,674 },   { 0,735,845 },   { 0,906,1016 }  },
+    { { 0,0,0 }, { 0,245,366 }, { 0,431,551 },  { 0,616,737 },   { 0,801,923 },   { 0,987,1109 }  },
+    { { 0,0,0 }, { 0,405,614 }, { 0,707,915 },  { 0,1008,1217 }, { 0,1309,1519 }, { 0,1611,1821 } },
+    { { 0,0,0 }, { 0,497,752 }, { 0,868,1122 }, { 0,1238,1493 }, { 0,1608,1864 }, { 0,1979,2235 } }
+};
+#define RUPTURE_MAX_RANK    9
+const uint32 RuptureDamage[RUPTURE_MAX_RANK+1][MAX_COMBO_POINTS+1] =
+{
+    { 0, 0,   0,   0,    0,    0    },
+    { 0, 41,  61,  86,   114,  147  },
+    { 0, 61,  91,  128,  170,  219  },
+    { 0, 89,  131, 182,  240,  307  },
+    { 0, 129, 186, 254,  331,  419  },
+    { 0, 177, 256, 350,  457,  579  },
+    { 0, 273, 381, 506,  646,  803  },
+    { 0, 325, 461, 620,  800,  1003 },
+    { 0, 489, 686, 914,  1171, 1459 },
+    { 0, 581, 816, 1088, 1395, 1739 }
+};
+
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new rogue_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct rogue_botAI : public bot_minion_ai
+    {
+        rogue_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_ROGUE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit* u) { comboPoints = 0; tempComboPoints = 0; bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/)
+        {}
+
+        //This method should be used to emulate energy usage reduction
+        void modenergy(int32 mod, bool set = false)
+        {
+            //can't set enery to -x (2 cases)
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && energy < uint32(abs(mod)))
+            {
+                mod = 0;
+                set = true;
+            }
+
+            if (set)
+                energy = mod;
+            else
+                energy += mod;
+
+            energy = std::min<uint32>(energy, 100);
+            me->SetPower(POWER_ENERGY, energy);
+        }
+
+        uint32 getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+            return energy;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_ROGUE))
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            comboPoints = std::min<uint8>(comboPoints, 5);
+            //AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //Blade Flurry (434 deprecated)
+            if (IsSpellReady(BLADE_FLURRY_1, diff, false) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                Rand() < 30 && getenergy() >= 25 && FindSplashTarget(7, opponent))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLADE_FLURRY_1)))
+                {
+                    SetSpellCooldown(BLADE_FLURRY_1, 75000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //KICK
+            if (IsSpellReady(KICK_1, diff, false) && meleedist <= 5 && Rand() < 80 && getenergy() >= 25 &&
+                opponent->IsNonMeleeSpellCast(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(KICK_1)))
+                {
+                    SetSpellCooldown(KICK_1, 8000); //improved
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+            //SHADOWSTEP
+            if (IsSpellReady(SHADOWSTEP_1, diff, false) && HasRole(BOT_ROLE_DPS) && dist < 25 &&
+                (opponent->GetVictim() != me || opponent->GetTypeId() == TYPEID_PLAYER) &&
+                Rand() < 30 && getenergy() >= 10)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(SHADOWSTEP_1)))
+                {
+                    SetSpellCooldown(SHADOWSTEP_1, 20000);
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+            //BACKSTAB
+            if (IsSpellReady(BACKSTAB_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints < 4 &&
+                /*Rand() < 90 && */getenergy() >= 60 && !opponent->HasInArc(M_PI, me))
+            {
+                if (doCast(opponent, GetSpell(BACKSTAB_1)))
+                    return;
+            }
+            //SINISTER STRIKE
+            if (IsSpellReady(SINISTER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints < 5 &&
+                Rand() < 25 && getenergy() >= 45)
+            {
+                if (doCast(opponent, GetSpell(SINISTER_STRIKE_1)))
+                    return;
+            }
+            //SLICE AND DICE
+            if (IsSpellReady(SLICE_DICE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && comboPoints > 1 && getenergy() >= 25 &&
+                (b_attackers.size() <= 1 || !IsSpellReady(BLADE_FLURRY_1, diff)) && Rand() < 30)
+            {
+                if (doCast(opponent, GetSpell(SLICE_DICE_1)))
+                    return;
+            }
+            //KIDNEY SHOT
+            if (IsSpellReady(KIDNEY_SHOT_1, diff) && meleedist <= 5 && comboPoints > 0 &&
+                !CCed(opponent) && getenergy() >= 25 && ((Rand() < 15 + comboPoints*15 && opponent->GetVictim() == me && comboPoints > 2) || opponent->IsNonMeleeSpellCast(false)))
+            {
+                if (doCast(opponent, GetSpell(KIDNEY_SHOT_1)))
+                    return;
+            }
+            //EVISCERATE
+            if (IsSpellReady(EVISCERATE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints > 2 &&
+                getenergy() >= 35 && Rand() < comboPoints*15)
+            {
+                uint32 EVISCERATE = GetSpell(EVISCERATE_1);
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(EVISCERATE);
+                uint8 rank = spellInfo->GetRank();
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                float combo = float(comboPoints);
+                int32 damage = int32(urand(EVSCRDamage[rank][comboPoints][DMGMIN], EVSCRDamage[rank][comboPoints][DMGMAX]));//base damage
+                damage += irand(int32(ap*combo*0.03f), int32(ap*combo*0.07f));//ap bonus
+
+                currentSpell = EVISCERATE;
+                me->CastCustomSpell(opponent, EVISCERATE, &damage, NULL, NULL, false);
+                return;
+            }
+            //MUTILATE
+            //if (isTimerReady(Mutilate_Timer) && energy>60)
+            //{
+            //    // TODO: calculate correct dmg for mutilate (dont forget poison bonus)
+            //    // for now use same formula as evicerate
+            //    uint32 base_attPower = me->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+            //    //float minDmg = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            //    float minDmg = me->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+            //    int damage = irand(int32(base_attPower*7*0.03f),int32(base_attPower*7*0.08f))+minDmg+me->getLevel();
+
+            //    // compensate for lack of attack power
+            //    damage = damage*(rand()%4+1);
+
+            //    me->CastCustomSpell(opponent, MUTILATE, &damage, NULL, NULL, false, NULL, NULL);
+
+            //    //doCast (me, MUTILATE);
+            //    Mutilate_Timer = 10;
+            //    comboPoints+=3;
+            //    energy -= 60;
+            //}
+
+            //RUPTURE
+            if (IsSpellReady(RUPTURE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints > 3 && getenergy() >= 25 &&
+                opponent->GetHealth() > me->GetMaxHealth()/3 && Rand() < (50 + 70 * opponent->isMoving()))
+            {
+                uint32 RUPTURE = GetSpell(RUPTURE_1);
+                //no damage range for rupture
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(RUPTURE);
+                uint8 rank = spellInfo->GetRank();
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                float AP_per_combo[6] = {0.0f, 0.015f, 0.024f, 0.03f, 0.03428571f, 0.0375f};
+                float divider[6] = {0.0f, 4.f, 5.f, 6.f, 7.f, 8.f};//duration/2 = number of ticks
+                int32 damage = int32(RuptureDamage[rank][comboPoints]/divider[comboPoints]);//base damage
+                damage += int32(ap*AP_per_combo[comboPoints]);//ap bonus is strict - applied to every tick
+
+                currentSpell = RUPTURE;
+                me->CastCustomSpell(opponent, RUPTURE, &damage, NULL, NULL, false);
+                return;
+            }
+            //DISMANTLE
+            if (IsSpellReady(DISMANTLE_1, diff, false) && meleedist <= 5 && opponent->GetTypeId() == TYPEID_PLAYER &&
+                Rand() < 20 && getenergy() >= 25 && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) || opponent->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(DISMANTLE_1)))
+                {
+                    SetSpellCooldown(DISMANTLE_1, 60000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Puncturing Wounds: 30% additional critical chance for Backstab
+                if (lvl >= 15 && spellId == GetSpell(BACKSTAB_1))
+                    aftercrit += 30.f;
+                //Puncturing Wounds: 15% additional critical chance for Mutilate
+                else if (spellId == GetSpell(MUTILATE_1))
+                    aftercrit += 15.f;
+                //Glyph of Eviscerate: 10% additional critical chance for Eviscerate
+                else if (spellId == GetSpell(EVISCERATE_1))
+                    aftercrit += 10.f;
+                //Improved Ambush: 60% additional critical chance for Ambush
+                //else if (spellId == AMBUSH)
+                //    crit_chance += 60.f;
+                if (lvl >= 50 && spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS) && me->HasAura(TURN_THE_TABLES_EFFECT))
+                    aftercrit += 6.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Lethality: 30% crit damage bonus for non-stealth combo-generating abilities (on 25 lvl)
+                if (lvl >= 25 && !(spellInfo->Attributes & SPELL_ATTR0_ONLY_STEALTHED) &&
+                    spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS))
+                    pctbonus += 0.15f;
+            }
+            //Shadowstep: 20% bonus damage to all abilities once
+            //if (shadowstep == true)
+            //{
+            //    shadowstep = false;
+            //    me->RemoveAurasDueToSpell(SHADOWSTEP_EFFECT_DAMAGE);
+            //    pctbonus += 0.2f;
+            //}
+            //Find Weakness: 6% bonus damage to all abilities
+            if (lvl >= 45)
+                pctbonus += 0.06f;
+            //DeathDealer set bonus: 15% damage bonus for Eviscerate
+            if (lvl >= 60 && spellId == GetSpell(EVISCERATE_1))
+                pctbonus += 0.15f;
+            //Imoroved Eviscerate: 20% damage bonus for Eviscerate
+            if (spellId == GetSpell(EVISCERATE_1))
+                pctbonus += 0.2f;
+            //Opportunity: 20% damage bonus for Backstab, Mutilate, Garrote and Ambush
+            if (spellId == GetSpell(BACKSTAB_1) || spellId == GetSpell(MUTILATE_1)/* ||
+                spellId == GARROTE || spellId == AMBUSH*/)
+                pctbonus += 0.2f;
+            //Aggression: 15% damage bonus for Sinister Strike, Backstab and Eviscerate
+            if (lvl >= 30 && (spellId == GetSpell(SINISTER_STRIKE_1) || spellId == GetSpell(BACKSTAB_1) || spellId == GetSpell(EVISCERATE_1)))
+                pctbonus += 0.15f;
+            //Blood Spatter: 30% bonus damage for Rupture and Garrote
+            if (lvl >= 15 && (spellId == GetSpell(RUPTURE_1)/* || spellId == GARROTE*/))
+                pctbonus += 0.3f;
+            //Serrated Blades: 30% bonus damage for Rupture
+            if (lvl >= 20 && spellId == GetSpell(RUPTURE_1))
+                pctbonus += 0.3f;
+            //Surprise Attacks: 10% bonus damage for Sinister Strike, Backstab, Shiv, Hemmorhage and Gouge
+            if (lvl >= 50 && (spellId == GetSpell(SINISTER_STRIKE_1) || spellId == GetSpell(BACKSTAB_1)/* ||
+                spellId == SHIV || spellId == HEMMORHAGE || spellId == GOUGE*/))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            uint32 WOUND_POISON = GetSpell(WOUND_POISON_1);
+            uint32 MIND_NUMBING_POISON = GetSpell(MIND_NUMBING_POISON_1);
+            if (!WOUND_POISON && !MIND_NUMBING_POISON)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                if (victim && me->GetExactDist(victim) <= 40)
+                {
+                    switch (rand()%2)
+                    {
+                        case 0:
+                            break;
+                        case 1:
+                        {
+                            switch (rand()%2)
+                            {
+                                case 0:
+                                    if (WOUND_POISON)
+                                    {
+                                        currentSpell = WOUND_POISON;
+                                        DoCast(victim, WOUND_POISON, true);
+                                    }
+                                    break;
+                                case 1:
+                                    if (MIND_NUMBING_POISON)
+                                    {
+                                        currentSpell = MIND_NUMBING_POISON;
+                                        DoCast(victim, MIND_NUMBING_POISON, true);
+                                    }
+                                    break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //combo points use up
+            if (spellId == GetSpell(SLICE_DICE_1))
+            {
+                SetSpellCooldown(SLICE_DICE_1, 15000 + (tempComboPoints-1)*4500);
+                GC_Timer = 800;
+
+                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
+                {
+                    uint32 dur = dice->GetDuration();
+                    dur += tempComboPoints * 3000; //use cp
+                    dur += 6000; // Glyph of Slice and Dice
+                    dur = (dur * 3) / 2; //Improved Slice and Dice
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                }
+            }
+            else if (spellId == GetSpell(RUPTURE_1))
+            {
+                SetSpellCooldown(RUPTURE_1, 8000 + (tempComboPoints-1)*2000 + 4000);
+                GC_Timer = 800;
+
+                if (Aura* rupture = target->GetAura(GetSpell(RUPTURE_1), me->GetGUID()))
+                {
+                    uint32 dur = rupture->GetDuration() + tempComboPoints*2000; //use cp
+                    dur += 4000; //Glyph of Rupture
+                    rupture->SetDuration(dur);
+                    rupture->SetMaxDuration(dur);
+                }
+            }
+            else if (spellId == GetSpell(KIDNEY_SHOT_1))
+            {
+                SetSpellCooldown(KIDNEY_SHOT_1, 20000);
+
+                if (Aura* kidney = target->GetAura(GetSpell(KIDNEY_SHOT_1), me->GetGUID()))
+                {
+                    uint32 dur = kidney->GetDuration() + tempComboPoints*1000;
+                    kidney->SetDuration(dur);
+                    kidney->SetMaxDuration(dur);
+                }
+            }
+
+            if (currentSpell == 0)
+                return;
+
+            //BONUS CP MANAGEMENT
+
+            //if (spellId == EVISCERATE || spellId == KIDNEY_SHOT || spellId == SLICE_DICE || spellId == RUPTURE/* || spellId == EXPOSE_ARMOR || spellId == ENVENOM*/)
+            //Relentless Strikes
+            if (spell->NeedsComboPoints())
+            {
+                //std::ostringstream msg;
+                //msg << "casting ";
+                //if (spellId == EVISCERATE)
+                //    msg << "Eviscerate, ";
+                //else if (spellId == RUPTURE)
+                //    msg << "Rupture, ";
+                //else if (spellId == SLICE_DICE)
+                //    msg << "Slice and Dice, ";
+                //else if (spellId == KIDNEY_SHOT)
+                //    msg << "Kidney Shot, ";
+                ////else if (spellId == EXPOSE_ARMOR)
+                ////    msg << "Expose Armor, ";
+                ////else if (spellId == ENVENOM)
+                ////    msg << "Envenom, ";
+                //msg << "combo points: " << uint32(std::min<uint32>(comboPoints,5));
+                //me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+                if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
+                {
+                    currentSpell = RELENTLESS_STRIKES_EFFECT;
+                    DoCast(me, RELENTLESS_STRIKES_EFFECT, true);
+                }
+                tempComboPoints = comboPoints;
+                //CP adding effects are handled before actual finisher so use temp value
+                //std::ostringstream msg2;
+                //msg2 << "cp set to 0";
+                if (tempAddCP)
+                {
+                    //msg2 << " + " << uint32(tempAddCP) << " (temp)";
+                    comboPoints = tempAddCP;
+                    tempAddCP = 0;
+                }
+                else
+                    comboPoints = 0;
+                //me->Whisper(msg2.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+            }
+            else if (spellId == GetSpell(SINISTER_STRIKE_1) ||
+                spellId == GetSpell(BACKSTAB_1)/* ||
+                spellId == GOUGE ||
+                spellId == HEMORRHAGE*/)
+            {
+                ++comboPoints;
+                //std::ostringstream msg;
+                //msg << "1 cp generated ";
+                //if (spellId == SINISTER_STRIKE)
+                //    msg << "(Sinister Strike)";
+                //else if (spellId == BACKSTAB)
+                //    msg << "(Backstab)";
+                //msg << " set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == GetSpell(MUTILATE_1)/* ||
+                spellId == AMBUSH*/)
+            {
+                comboPoints += 2;
+                //std::ostringstream msg;
+                //msg << "2 cp generated (Mutilate), set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == SEAL_FATE_EFFECT || spellId == RUTHLESSNESS_EFFECT)
+            {
+                ++tempAddCP;
+                //std::ostringstream msg;
+                //msg << "1 temp cp generated ";
+                //if (spellId == SEAL_FATE_EFFECT)
+                //    msg << "(Seal Fate)";
+                //else if (spellId == RUTHLESSNESS_EFFECT)
+                //    msg << "(Ruthleness)";
+                //me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+            }
+
+            //Glyph of Sinister Strike (20% to add cp on hit)
+            //Seal Fate means crit so this glyph is enabled from lvl 35)
+            //as addition always add cp on ss crit
+            if (currentSpell == GetSpell(SINISTER_STRIKE_1) && (spellId == SEAL_FATE_EFFECT || urand(0,100) >= 20))
+            {
+                ++tempAddCP;
+                //me->Whisper("1 temp cp generated (glyph of SS)", LANG_UNIVERSAL, master->GetGUID());
+            }
+
+            //ENERGY COST REDUCTION
+
+            if (spellId == GetSpell(SINISTER_STRIKE_1))
+            {
+                //Improved Sinister Strike
+                //instead of restoring energy we should override current value
+                if (me->getLevel() >= 10)
+                    modenergy(-40, true);//45 - 5
+            }
+            //Slaughter from the Shadows energy restore
+            //instead of restoring energy we should override current value
+            if (me->getLevel() >= 55)
+            {
+                if (spellId == GetSpell(BACKSTAB_1)/* || spellId == AMBUSH*/)
+                    modenergy(-40, true);
+                //else if (spellId == HEMORRHAGE)
+                //    modenergy(-30, true);
+            }
+
+            //OTHER
+
+            if (spellId == GetSpell(EVISCERATE_1))
+            {
+                //Eviscerate speedup
+                GC_Timer = 800;
+
+                //Serrated Blades: Eviscerate has 20% chance per cp to refresh Rupture
+                //getting cheaty - remove roll
+                //getting cheaty - increase duration
+                //if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
+                {
+                    if (Aura* rupture = target->GetAura(GetSpell(RUPTURE_1), me->GetGUID()))
+                    {
+                        int32 dur = rupture->GetMaxDuration() + 2000;
+                        dur = std::min<int32>(dur, 30000);
+                        rupture->SetDuration(dur);
+                        rupture->SetMaxDuration(dur);
+                        SetSpellCooldown(RUPTURE_1, dur - 2000);
+                    }
+                }
+            }
+
+            //Cut to the Chase: Eviscerate and Envenom will refresh Slice and Dice duration
+            //getting cheaty - increase duration
+            if (spellId == GetSpell(EVISCERATE_1)/* || spellId == ENVENOM*/)
+            {
+                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
+                {
+                    int32 dur = dice->GetMaxDuration() + 2000;
+                    dur = std::min<int32>(dur, 59000);
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                    SetSpellCooldown(SLICE_DICE_1, dur - 2000);
+                }
+            }
+
+            //Murderous Intent: When Backstabbing enemy that is below 35% hp, instantly restoring 30 energy
+            if (spellId == GetSpell(BACKSTAB_1))
+            {
+                if (target->HealthBelowPct(35))
+                {
+                    //since talent doesn't work just restore energy manually
+                    //DoCast(me, MURDEROUS_INTENT_EFFECT, true);
+                    modenergy(30);
+                }
+            }
+
+            //Waylay
+            if ((spellId == GetSpell(BACKSTAB_1)/* || spellId == AMBUSH*/) &&
+                me->getLevel() >= 20)
+            {
+                DoCast(target, WAYLAY_EFFECT, true);
+            }
+
+            //if (spellId == SHADOWSTEP)
+            //{
+            //    Shadowstep_eff_Timer = 10000;
+            //    shadowstep = true;
+            //}
+
+            //move behind on Kidney Shot and Gouge (optionally)
+            if (spellId == GetSpell(KIDNEY_SHOT_1)/* || spellId == GOUGE*/)
+                if (MoveBehind(*target))
+                    wait = 3;
+
+            if (spellId == currentSpell)
+                currentSpell = 0;
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            comboPoints = 0;
+            tempComboPoints = 0;
+            tempAddCP = 0;
+
+            tempDICE = false;
+            //shadowstep = false;
+
+            me->setPowerType(POWER_ENERGY);
+            //10 energy gained per stack
+            RefreshAura(GLADIATOR_VIGOR, 10);
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_ROGUE);
+            }
+
+            me->SetPower(POWER_ENERGY, me->GetMaxPower(POWER_ENERGY));
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+            //if (Shadowstep_eff_Timer > diff)        Shadowstep_eff_Timer -= diff;
+            //else if (shadowstep)                    shadowstep = false;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(BACKSTAB_1);
+            InitSpellMap(SINISTER_STRIKE_1);
+            InitSpellMap(SLICE_DICE_1);
+            InitSpellMap(EVISCERATE_1);
+            InitSpellMap(KICK_1);
+            InitSpellMap(RUPTURE_1);
+            InitSpellMap(KIDNEY_SHOT_1);
+            lvl >= 50 ? InitSpellMap(MUTILATE_1) : RemoveSpell(MUTILATE_1);
+            lvl >= 50 ? InitSpellMap(SHADOWSTEP_1) : RemoveSpell(SHADOWSTEP_1);
+            InitSpellMap(DISMANTLE_1);
+            lvl >= 30 ? InitSpellMap(BLADE_FLURRY_1) : RemoveSpell(BLADE_FLURRY_1);
+
+            InitSpellMap(WOUND_POISON_1);
+            InitSpellMap(MIND_NUMBING_POISON_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            //if (level >= 78)
+            //    RefreshAura(ROGUE_ARMOR_ENERGIZE,2);
+            //else if (level >= 60)
+            //    RefreshAura(ROGUE_ARMOR_ENERGIZE);
+            if (level >= 70)
+                RefreshAura(COMBAT_POTENCY5,2);
+            else if (level >= 55)
+                RefreshAura(COMBAT_POTENCY5);
+            else if (level >= 52)
+                RefreshAura(COMBAT_POTENCY4);
+            else if (level >= 49)
+                RefreshAura(COMBAT_POTENCY3);
+            else if (level >= 47)
+                RefreshAura(COMBAT_POTENCY2);
+            else if (level >= 45)
+                RefreshAura(COMBAT_POTENCY1);
+            if (level >= 35)
+                RefreshAura(SEAL_FATE5);
+            else if (level >= 32)
+                RefreshAura(SEAL_FATE4);
+            else if (level >= 29)
+                RefreshAura(SEAL_FATE3);
+            else if (level >= 27)
+                RefreshAura(SEAL_FATE2);
+            else if (level >= 25)
+                RefreshAura(SEAL_FATE1);
+            if (level >= 78)
+                RefreshAura(VITALITY,4);
+            else if (level >= 70)
+                RefreshAura(VITALITY,3);
+            else if (level >= 55)
+                RefreshAura(VITALITY,2);
+            else if (level >= 40)
+                RefreshAura(VITALITY);
+            if (level >= 55)
+                RefreshAura(TURN_THE_TABLES);
+            if (level >= 40)
+                RefreshAura(DEADLY_BREW);
+            if (level >= 35)
+                RefreshAura(BLADE_TWISTING1);//allow rank 1 only
+            if (level >= 35)
+                RefreshAura(QUICK_RECOVERY2);
+            else if (level >= 30)
+                RefreshAura(QUICK_RECOVERY1);
+            if (level >= 30)
+                RefreshAura(IMPROVED_KIDNEY_SHOT);
+            if (level >= 10)
+                RefreshAura(GLYPH_BACKSTAB);
+            if (level >= 10)
+                RefreshAura(SURPRISE_ATTACKS);
+
+            //On 25 get Glyph of Vigor
+            if (level >= 25)
+                RefreshAura(ROGUE_VIGOR,2);
+            else if (level >= 20)
+                RefreshAura(ROGUE_VIGOR);
+        }
+
+    private:
+        uint32 energy;
+        uint8 comboPoints, tempComboPoints, tempAddCP;
+        bool tempDICE/*, shadowstep*/;
+
+        enum RogueBaseSpells
+        {
+            BACKSTAB_1                          = 53,
+            SINISTER_STRIKE_1                   = 1757,
+            SLICE_DICE_1                        = 5171,
+            EVISCERATE_1                        = 2098,
+            KICK_1                              = 1766,
+            RUPTURE_1                           = 1943,
+            KIDNEY_SHOT_1                       = 408,
+  /*Talent*/MUTILATE_1                          = 1329,
+  /*Talent*/SHADOWSTEP_1                        = 36554,
+            DISMANTLE_1                         = 51722,
+            BLADE_FLURRY_1                      = 33735,
+        //Special
+            WOUND_POISON_1                      = 13218,
+            MIND_NUMBING_POISON_1               = 5760
+        };
+
+        enum RoguePassives
+        {
+            //Talents
+            SEAL_FATE1                          = 14189,
+            SEAL_FATE2                          = 14190,
+            SEAL_FATE3                          = 14193,
+            SEAL_FATE4                          = 14194,
+            SEAL_FATE5                          = 14195,
+            COMBAT_POTENCY1                     = 35541,
+            COMBAT_POTENCY2                     = 35550,
+            COMBAT_POTENCY3                     = 35551,
+            COMBAT_POTENCY4                     = 35552,
+            COMBAT_POTENCY5                     = 35553,
+            QUICK_RECOVERY1                     = 31244,
+            QUICK_RECOVERY2                     = 31245,
+            BLADE_TWISTING1                     = 31124,
+            //BLADE_TWISTING2                     = 31126,
+            VITALITY                            = 61329,//rank 3
+            DEADLY_BREW                         = 51626,//rank 2
+            IMPROVED_KIDNEY_SHOT                = 14176,//rank 3
+            TURN_THE_TABLES                     = 51629,//rank 3
+            SURPRISE_ATTACKS                    = 32601,
+            ROGUE_VIGOR                         = 14983,
+            //Other
+            //ROGUE_ARMOR_ENERGIZE/*Deathmantle*/ = 27787,
+            GLADIATOR_VIGOR                     = 21975,
+            GLYPH_BACKSTAB                      = 56800
+        };
+
+        enum RogueSpecial
+        {
+            RELENTLESS_STRIKES_EFFECT           = 14181,
+            RUTHLESSNESS_EFFECT                 = 14157,
+            SEAL_FATE_EFFECT                    = 14189,
+            //SHADOWSTEP_EFFECT_DAMAGE            = 36563,
+            TURN_THE_TABLES_EFFECT              = 52910,//'rank 3'
+            WAYLAY_EFFECT                       = 51693,
+            //434
+            MURDEROUS_INTENT_EFFECT             = 79132
+        };
+    };
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
new file mode 100644
index 0000000..cac1936
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
@@ -0,0 +1,1383 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "Totem.h"
+#include "WorldSession.h"
+
+/*
+Shaman NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - around 30%
+TODO:
+*/
+enum TotemSlot
+{
+    T_FIRE  = 0,//m_SummonSlot[1]
+    T_EARTH = 1,//m_SummonSlot[2]
+    T_WATER = 2,//m_SummonSlot[3]
+    T_AIR   = 3,//m_SummonSlot[4]
+    MAX_TOTEMS
+};
+struct TotemParam
+{
+    TotemParam() : effradius(0.f) {}
+    Position pos;
+    float effradius;
+};
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new shaman_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct shaman_botAI : public bot_minion_ai
+    {
+        shaman_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_SHAMAN) != SPELL_CAST_OK)
+                return false;
+
+            bool maelstrom = false;
+            if (!triggered)
+                maelstrom = (MaelstromCount >= 5 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) || spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(HEALING_WAVE_1) || spellId == GetSpell(LESSER_HEALING_WAVE_1) ||
+                spellId == GetSpell(CHAIN_HEAL_1) || spellId == GetSpell(HEX_1)));
+
+            triggered |= maelstrom;
+
+            bool result = bot_ai::doCast(victim, spellId, triggered, me->GetGUID());
+
+            if (result && maelstrom)
+            {
+                MaelstromCount = 0;
+                me->RemoveAurasDueToSpell(MAELSTROM_WEAPON_BUFF, ObjectGuid::Empty, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+
+            return result;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit* u) { bot_ai::JustDied(u); }
+
+        bool Shielded(Unit* target) const
+        {
+            return
+                (HasAuraName(target, WATER_SHIELD_1) ||
+                HasAuraName(target, EARTH_SHIELD_1) ||
+                HasAuraName(target, LIGHTNING_SHIELD_1));
+        }
+
+        void CheckBloodlust(uint32 diff)
+        {
+            if (!IsSpellReady(BLOODLUST_1, diff, false) || me->GetDistance(master) > 18 || IsCasting() || Rand() > 15)
+                return;
+            if (!me->IsInCombat() || !master->IsInCombat())
+                return;
+
+            if (HasAuraName(master, BLOODLUST_1))
+            {
+                SetSpellCooldown(BLOODLUST_1, GetSpellCooldown(BLOODLUST_1) + 3000);
+                return;
+            }
+
+            if (Unit* u = me->GetVictim())
+            {
+                Creature* cre = u->ToCreature();
+                if (u->GetMaxHealth() > me->GetHealth() * 2 ||
+                    (cre && (cre->IsDungeonBoss() || cre->isWorldBoss())) ||
+                    me->getAttackers().size() + master->getAttackers().size() > 5)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(BLOODLUST_1)))
+                    {
+                        GC_Timer = temptimer;
+                        SetSpellCooldown(BLOODLUST_1, 180000); //3 min
+                        return;
+                    }
+                }
+            }
+
+            SetSpellCooldown(BLOODLUST_1, 2000); //fail
+        }
+
+        void CheckTotems(uint32 diff)
+        {
+            //update rate
+            if (Rand() > 25)
+                return;
+            //Unsummon
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0)
+                {
+                    if (master->GetDistance2d(_totems[i].second.pos.m_positionX, _totems[i].second.pos.m_positionY) > _totems[i].second.effradius &&
+                        me->GetDistance2d(_totems[i].second.pos.m_positionX, _totems[i].second.pos.m_positionY) > _totems[i].second.effradius)
+                    {
+                        Unit* to = ObjectAccessor::FindConnectedPlayer(_totems[i].first);
+                        if (!to)
+                        {
+                            _totems[i].first = ObjectGuid::Empty;
+                            //TC_LOG_ERROR("entities.player", "%s has lost totem in slot %u! Despawned normally?", me->GetName().c_str(), i);
+                            continue;
+                        }
+
+                        to->ToTotem()->UnSummon();
+                    }
+                }
+            }
+            if (GC_Timer > diff || IsCasting() || me->GetDistance(master) > 15 || Feasting())
+                return;
+            //Summon
+            //TODO: role-based totems (attack/heal)
+            if (me->IsInCombat())
+            {
+                if (GetSpell(WINDFURY_TOTEM_1) && !_totems[T_AIR].first && !master->m_SummonSlot[T_AIR+1])
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(WINDFURY_TOTEM_1)))
+                    {
+                        if (me->getLevel() >= 57)
+                            GC_Timer = temptimer;
+                        return;
+                    }
+                }
+
+                if (!_totems[T_EARTH].first && !master->m_SummonSlot[T_EARTH+1])
+                {
+                    if (GetSpell(STRENGTH_OF_EARTH_TOTEM_1))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(STRENGTH_OF_EARTH_TOTEM_1)))
+                        {
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (GetSpell(STONESKIN_TOTEM_1))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(STONESKIN_TOTEM_1)))
+                        {
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+
+                if (!_totems[T_FIRE].first && !master->m_SummonSlot[T_FIRE+1])
+                {
+                    if (IsSpellReady(TOTEM_OF_WRATH_1, diff, false))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(TOTEM_OF_WRATH_1)))
+                        {
+                            //bot's poor AI cannot use totems wisely so just reduce CD on this
+                            SetSpellCooldown(TOTEM_OF_WRATH_1, 30000); //30 sec, old 5 min
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (IsSpellReady(SEARING_TOTEM_1, diff, false))
+                    {
+                        if (Unit* u = me->GetVictim())
+                        {
+                            if (HasRole(BOT_ROLE_DPS) && me->GetExactDist(u) < (u->isMoving() ? 10 : 25))
+                            {
+                                temptimer = GC_Timer;
+                                if (doCast(me, GetSpell(SEARING_TOTEM_1)))
+                                {
+                                    SetSpellCooldown(SEARING_TOTEM_1, 20000);
+                                    if (me->getLevel() >= 57)
+                                        GC_Timer = temptimer;
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            if (!me->isMoving() && !master->isMoving())
+            {
+                if (!_totems[T_WATER].first && !master->m_SummonSlot[T_WATER+1])
+                {
+                    uint8 manapct = GetManaPCT(master);
+                    uint8 hppct = GetHealthPCT(master);
+                    if (GetSpell(HEALINGSTREAM_TOTEM_1) && hppct < 98 && master->getPowerType() != POWER_MANA &&
+                        (hppct < 25 || manapct > hppct))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(HEALINGSTREAM_TOTEM_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (GetSpell(MANASPRING_TOTEM_1) && (manapct < 97 || GetManaPCT(me) < 90))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(MANASPRING_TOTEM_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+        }
+
+        void CheckThunderStorm(uint32 diff)
+        {
+            if (!IsSpellReady(THUNDERSTORM_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 25)
+                return;
+
+            //case 1: low mana
+            if (GetManaPCT(me) < 15)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                {
+                    GC_Timer = temptimer;
+                    SetSpellCooldown(THUNDERSTORM_1, 25000); //45 - 20 = 25 sec for mana restore
+                }
+                return;
+            }
+
+            //case 2: knock attackers
+            if (IsTank()) //pretty stupid idea I think
+                return;
+
+            //AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            if (b_attackers.empty())
+                return;
+
+            uint8 tCount = 0;
+            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if (me->GetExactDist((*iter)) > 9) continue;
+                if (CCed(*iter)) continue;
+                if (me->IsValidAttackTarget(*iter))
+                {
+                    ++tCount;
+                    break;
+                }
+            }
+
+            if (tCount > 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                {
+                    GC_Timer = temptimer;
+                    SetSpellCooldown(THUNDERSTORM_1, 40000); //45 - 5 = 40 sec for knock
+                }
+                return;
+            }
+        }
+
+        void CheckManaTide(uint32 diff)
+        {
+            if (!IsSpellReady(MANA_TIDE_TOTEM_1, diff, false) || IsCasting() || Rand() > 20)
+                return;
+
+            Group* group = master->GetGroup();
+            if (!group)
+                return;
+
+            uint8 LMPcount = 0;
+            uint8 members = group->GetMembersCount();
+            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->GetMapId() != me->GetMapId() ||
+                    (!tPlayer->IsAlive() && !tPlayer->HaveBot())) continue;
+                if (me->GetExactDist(tPlayer) > 20) continue;
+                if (tPlayer->getPowerType() != POWER_MANA) continue;
+                if (GetManaPCT(tPlayer) < 35)
+                {
+                    ++LMPcount;
+                    if (LMPcount > 3 || LMPcount > members / 3) break;
+                }
+                if (tPlayer->HaveBot())
+                {
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && bot->IsInWorld() && bot->getPowerType() == POWER_MANA &&
+                            bot->GetExactDist(me) < 20 && GetManaPCT(bot) < 35)
+                        {
+                            ++LMPcount;
+                            if (LMPcount > 3 || LMPcount > members / 3) break;
+                        }
+                    }
+                }
+            }
+
+            if (LMPcount > 3 || LMPcount > members / 3)
+            {
+                if (_totems[T_WATER].first != 0)
+                {
+                    Unit* to = ObjectAccessor::FindConnectedPlayer(_totems[T_WATER].first);
+                    if (!to)
+                        _totems[T_WATER].first = ObjectGuid::Empty;
+                    else
+                        to->ToTotem()->UnSummon();
+                }
+                if (doCast(me, GetSpell(MANA_TIDE_TOTEM_1)))
+                {
+                    SetSpellCooldown(MANA_TIDE_TOTEM_1, 60000); //1 min
+                    return;
+                }
+            }
+
+            SetSpellCooldown(MANA_TIDE_TOTEM_1, 3000); //fail
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckThunderStorm(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            CheckHexy(diff);
+            CheckEarthy(diff);
+
+            if (GetManaPCT(me) < 30 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            CheckBloodlust(diff);
+            BuffAndHealGroup(master, diff);
+            CureGroup(master, CURE_TOXINS, diff);
+            CheckManaTide(diff);
+            CheckTotems(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+                CheckDispel(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff myself
+            if (GetSpell(LIGHTNING_SHIELD_1) && !IsTank() && !Shielded(me))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(LIGHTNING_SHIELD_1)))
+                    GC_Timer = temptimer;
+            }
+            //heal myself
+            if (GetHealthPCT(me) < 80)
+                HealTarget(me, GetHealthPCT(me), diff);
+
+            if (!CheckAttackTarget(CLASS_SHAMAN))
+                return;
+
+            CheckHexy2(diff);
+
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (!IsSpellReady(WIND_SHEAR_1, diff, false) || Rand() > 60)
+                return;
+
+            Unit* u = me->GetVictim();
+            if (u && u->IsNonMeleeSpellCast(false))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(u, GetSpell(WIND_SHEAR_1)))
+                {
+                    SetSpellCooldown(WIND_SHEAR_1, 5000); //improved
+                    GC_Timer = temptimer;
+                }
+            }
+            else if (Unit* target = FindCastingTarget(25))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(WIND_SHEAR_1)))
+                {
+                    SetSpellCooldown(WIND_SHEAR_1, 5000);
+                    GC_Timer = temptimer;
+                }
+            }
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            if (IsCasting()) return;
+
+            //STORMSTRIKE
+            if (IsSpellReady(STORMSTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && IsMelee() && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(STORMSTRIKE_1)))
+                {
+                    SetSpellCooldown(STORMSTRIKE_1, 6000); //improved
+                    return;
+                }
+            }
+            //SHOCKS
+            if ((GetSpell(FLAME_SHOCK_1) || GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1)) &&
+                IsSpellReady(FLAME_SHOCK_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 && Rand() < 30)
+            {
+                temptimer = GC_Timer;
+
+                bool canFlameShock = (GetSpell(FLAME_SHOCK_1) != 0);
+                if (canFlameShock)
+                {
+                    if (Aura* fsh = opponent->GetAura(GetSpell(FLAME_SHOCK_1), me->GetGUID()))
+                        if (fsh->GetDuration() > 3000)
+                            canFlameShock = false;
+                }
+
+                if (canFlameShock)
+                {
+                    if (doCast(opponent, GetSpell(FLAME_SHOCK_1)))
+                    {
+                        SetSpellCooldown(FLAME_SHOCK_1, 3000); //improved twice
+                        SetSpellCooldown(EARTH_SHOCK_1, 3000); //improved twice
+                        SetSpellCooldown(FROST_SHOCK_1, 3000); //improved twice
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+                else if (GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1))
+                {
+                    uint32 SHOCK = !GetSpell(FROST_SHOCK_1) ? GetSpell(EARTH_SHOCK_1) : RAND(GetSpell(EARTH_SHOCK_1), GetSpell(FROST_SHOCK_1));
+                    if (SHOCK && !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)) &&
+                        !opponent->HasAura(SHOCK))
+                    {
+                        if (doCast(opponent, SHOCK))
+                        {
+                            SetSpellCooldown(FLAME_SHOCK_1, 3000); //improved twice
+                            SetSpellCooldown(EARTH_SHOCK_1, 3000); //improved twice
+                            SetSpellCooldown(FROST_SHOCK_1, 3000); //improved twice
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+            //LAVA BURST
+            if (IsSpellReady(LAVA_BURST_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(LAVA_BURST_1)))
+                {
+                    SetSpellCooldown(LAVA_BURST_1, 8000);
+                    return;
+                }
+            }
+
+            if (GetManaPCT(me) < 15 || (MaelstromCount < 5 && IsMelee()))
+                return;
+
+            //CHAIN LIGHTNING
+            if (IsSpellReady(CHAIN_LIGHTNING_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(CHAIN_LIGHTNING_1)))
+                {
+                    SetSpellCooldown(CHAIN_LIGHTNING_1, 3500); //improved
+                    return;
+                }
+            }
+            //LIGHTNING BOLT
+            if (IsSpellReady(LIGHTNING_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30)
+            {
+                uint32 LIGHTNING_BOLT = GetSpell(LIGHTNING_BOLT_1);
+                if (doCast(opponent, LIGHTNING_BOLT))
+                {
+                    SetSpellCooldown(LIGHTNING_BOLT_1, uint32(float(sSpellMgr->GetSpellInfo(LIGHTNING_BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200));
+                    return;
+                }
+            }
+        }
+
+        void CheckHexy(uint32 diff)
+        {
+            if (HexyCheckTimer <= diff)
+            {
+                Hexy = FindAffectedTarget(GetSpell(HEX_1), me->GetGUID());
+                HexyCheckTimer = 2000;
+            }
+        }
+
+        void CheckHexy2(uint32 diff)
+        {
+            if (Hexy == false && me->GetVictim() && IsSpellReady(HEX_1, diff, false))
+            {
+                if (Unit* target = FindPolyTarget(20, me->GetVictim()))
+                {
+                    if (doCast(target, GetSpell(HEX_1)))
+                    {
+                        Hexy = true;
+                        SetSpellCooldown(HEX_1, 30000); //45 - 15 = 30 sec for bots
+                        HexyCheckTimer += 2000;
+                    }
+                }
+            }
+        }
+
+        void CheckEarthy(uint32 diff)
+        {
+            if (EarthyCheckTimer <= diff)
+            {
+                Unit* u = FindAffectedTarget(GetSpell(EARTH_SHIELD_1), me->GetGUID(), 90.f, 2);
+                Earthy = (u && (IsTank(u) || u == master));
+                EarthyCheckTimer = 1000;
+            }
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 50 || me->IsMounted()) return;
+
+            RezGroup(GetSpell(ANCESTRAL_SPIRIT_1), master);
+
+            if (Feasting()) return;
+
+            if (Shielded(me) && Rand() < 25)
+            {
+                Aura* shield = NULL;
+                uint32 SHIELD = HasRole(BOT_ROLE_DPS) ? GetSpell(LIGHTNING_SHIELD_1) : 0;
+                if (SHIELD)
+                    shield = me->GetAura(SHIELD);
+                if (!shield && IsTank() && GetSpell(EARTH_SHIELD_1))
+                {
+                    SHIELD = GetSpell(EARTH_SHIELD_1);
+                    shield = me->GetAura(SHIELD);
+                }
+                if (!shield && GetSpell(WATER_SHIELD_1))
+                {
+                    SHIELD = GetSpell(WATER_SHIELD_1);
+                    shield = me->GetAura(SHIELD);
+                }
+                if (shield && shield->GetCharges() < 5)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, SHIELD))
+                    {
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!GetSpell(WATER_WALKING_1) && !GetSpell(WATER_BREATHING_1) && !GetSpell(EARTH_SHIELD_1))
+                return false;
+
+            if (GC_Timer > diff || !target || !target->IsAlive() || Rand() > 40)
+                return false;
+
+            if (GetSpell(EARTH_SHIELD_1) && Earthy == false && (target == master || IsTank(target)) &&
+                (target->IsInCombat() || !target->isMoving()) &&
+                me->GetExactDist(target) < 40 && Rand() < 75)
+            {
+                bool cast = !Shielded(target);
+                if (!cast)
+                    if (Aura* eShield = target->GetAura(GetSpell(EARTH_SHIELD_1)))
+                        if (eShield->GetCharges() < 5)
+                            cast = true;
+                if (cast && doCast(target, GetSpell(EARTH_SHIELD_1)))
+                {
+                    Earthy = true;
+                    //GC_Timer = 800;
+                    return true;
+                }
+            }
+
+            if (me->GetExactDist(target) > 30) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (target->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+            {
+                //bots don't need water breathing
+                if (GetSpell(WATER_BREATHING_1) && target->GetTypeId() == TYPEID_PLAYER &&
+                    !target->HasAuraType(SPELL_AURA_WATER_BREATHING) &&
+                    doCast(target, GetSpell(WATER_BREATHING_1)))
+                {
+                    //GC_Timer = 800;
+                    return true;
+                }
+                //water walking breaks on any damage
+                if (GetSpell(WATER_WALKING_1) && target->getAttackers().empty() &&
+                    !target->HasAuraType(SPELL_AURA_WATER_WALK) &&
+                    doCast(target, GetSpell(WATER_WALKING_1)))
+                {
+                    //GC_Timer = 800;
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (!IsSpellReady(PURGE_1, diff, false) || IsCasting() || Rand() > 35)
+                return;
+
+            Unit* target = FindHostileDispelTarget();
+            if (target && doCast(target, GetSpell(PURGE_1)))
+                SetSpellCooldown(PURGE_1, 1000);
+
+            SetSpellCooldown(PURGE_1, 3000);
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL))
+                return false;
+            if (hp > 97)
+                return false;
+            if (!target || !target->IsAlive() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid())
+                return false;
+
+            //PLACEHOLDER: Instant spell req. interrupt current spell
+
+            if (IsCasting()) return false;
+
+            if (IsSpellReady(LESSER_HEALING_WAVE_1, diff) &&
+                ((hp > 70 && hp < 85) || hp < 50 || GetLostHP(target) > 1800) && Rand() < 75)
+            {
+                if (doCast(target, GetSpell(LESSER_HEALING_WAVE_1)))
+                    return true;
+            }
+            if (IsSpellReady(HEALING_WAVE_1, diff) &&
+                hp > 40 && (hp < 75 || GetLostHP(target) > 4000) && Rand() < 65)
+            {
+                if (doCast(target, GetSpell(HEALING_WAVE_1)))
+                    return true;
+            }
+            if (IsSpellReady(CHAIN_HEAL_1, diff) &&
+                ((hp > 40 && hp < 90) || GetLostHP(target) > 1300) && Rand() < 120)
+            {
+                if (IsSpellReady(RIPTIDE_1, diff, false) && (hp < 85 || GetLostHP(target) > 2500) &&
+                    !target->HasAura(GetSpell(RIPTIDE_1)))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(target, GetSpell(RIPTIDE_1), true))
+                    {
+                        SetSpellCooldown(RIPTIDE_1, 5000);
+                        if (doCast(target, GetSpell(CHAIN_HEAL_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                }
+                else if (doCast(target, GetSpell(CHAIN_HEAL_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                ////Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+                //if (lvl >= 15 && spellId == CLEAVE /*|| spellId == HEROICSTRIKE || spellId == THUNDERCLAP*/)
+                //    aftercrit += 15.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                if (lvl >= 21)
+                    pctbonus += 0.25f;
+            }
+
+            //SHAMAN_T8_ENCHANCEMENT_2P_BONUS: 20% bonus damage for Lava Lash and Stormstrike
+            if (lvl >= 60 &&
+                (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND/* || spellId == LAVA_LASH*/))
+                pctbonus += 0.2f;
+
+            //custom bonus to make stormstrike useful
+            if (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND)
+                pctbonus += 1.0f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Call of Thunder: 5% additional critical chance for Lightning Bolt, Chain Lightning and Thunderstorm,
+                if (lvl >= 30 &&
+                    (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                    spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                    spellId == GetSpell(THUNDERSTORM_1)))
+                    aftercrit += 5.f;
+                //Tidal Mastery (part 2): 5% additional critical chance for lightning spells
+                if (lvl >= 25 && (SPELL_SCHOOL_MASK_NATURE & spellInfo->GetSchoolMask()))
+                    aftercrit += 5.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                if (lvl >= 21)
+                    pctbonus += 0.333f;
+                //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+                if (lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+                    pctbonus += 0.16f;
+            }
+            //Concussion: 5% bonus damage for Lightning Bolt, Chain Lightning, Thunderstorm, Lava Burst and Shocks
+            if (lvl >= 10 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(THUNDERSTORM_1) ||
+                spellId == GetSpell(LAVA_BURST_1) ||
+                spellId == GetSpell(EARTH_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1) ||
+                spellId == GetSpell(FLAME_SHOCK_1)))
+                pctbonus += 0.05f;
+            //Call of Flame (part 2): 6% bonus damage for Lava burst
+            if (lvl >= 15 && spellId == GetSpell(LAVA_BURST_1))
+                pctbonus += 0.06f;
+            //Storm, Earth and fire (part 3): 60% bonus damage for Flame Shock (periodic damage in fact but who cares?)
+            if (lvl >= 40 && spellId == GetSpell(FLAME_SHOCK_1))
+                pctbonus += 0.6f;
+            //Booming Echoes (part 2): 20% bonus damage for Flame Shock and Frost Shock (direct damage)
+            if (lvl >= 45 &&
+                (spellId == GetSpell(FLAME_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1)))
+                pctbonus += 0.2f;
+
+            //flat damage mods (temp)
+            ////Shamanism: 25% bonus damage from bonus damage effects for Lightning Bolt, Chain Lightning and Lava Burst
+            //if (lvl >= 55 &&
+            //    (spellId == LIGHTNING_BOLT ||
+            //    spellId == CHAIN_LIGHTNING ||
+            //    spellId == LAVA_BURST))
+            //    fdamage += float(m_spellpower / 4);
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void OnBotDespawn(Creature* summon)
+        {
+            if (!summon)
+            {
+                UnsummonAll();
+                return;
+            }
+
+            TempSummon* totem = summon->ToTempSummon();
+            if (!totem || !totem->ToTotem())
+            {
+                TC_LOG_ERROR("entities.player", "SummonedCreatureDespawn(): Shaman bot %s has despawned summon %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:
+                    slot = T_FIRE;
+                    break;
+                case SUMMON_TYPE_TOTEM_EARTH:
+                    slot = T_EARTH;
+                    break;
+                case SUMMON_TYPE_TOTEM_WATER:
+                    slot = T_WATER;
+                    break;
+                case SUMMON_TYPE_TOTEM_AIR:
+                    slot = T_AIR;
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "SummonedCreatureDespawn(): Shaman bot %s has despawned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
+                    return;
+            }
+
+            _totems[slot].first = ObjectGuid::Empty;
+        }
+
+        void OnBotSummon(Creature* summon)
+        {
+            TempSummon* totem = summon->ToTempSummon();
+            if (!totem || !totem->ToTotem())
+            {
+                TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned creature %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            totem->SetCreatorGUID(me->GetGUID());
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:
+                    slot = T_FIRE;
+                    break;
+                case SUMMON_TYPE_TOTEM_EARTH:
+                    slot = T_EARTH;
+                    break;
+                case SUMMON_TYPE_TOTEM_WATER:
+                    slot = T_WATER;
+                    break;
+                case SUMMON_TYPE_TOTEM_AIR:
+                    slot = T_AIR;
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
+                    return;
+            }
+
+            float radius = 0.f;
+            if (SpellInfo const* info = sSpellMgr->GetSpellInfo(summon->m_spells[0]))
+                if (SpellRadiusEntry const* entry = info->Effects[0].RadiusEntry)
+                    radius = entry->RadiusMax;
+
+            _totems[slot].first = summon->GetGUID();
+            _totems[slot].second.pos.Relocate(*summon);
+            _totems[slot].second.effradius = std::max<float>(radius, 20.f) + 5.f;
+
+            //TC_LOG_ERROR("entities.player", "shaman bot: summoned %s (type %u) at x='%f', y='%f', z='%f'",
+            //    summon->GetName().c_str(), slot, _totems[slot].second.GetPositionX(), _totems[slot].second.GetPositionY(), _totems[slot].second.GetPositionZ());
+
+            summon->SetDisplayId(me->GetModelForTotem(PlayerTotemType(totem->m_Properties->Id)));
+            master->m_SummonSlot[++slot] = ObjectGuid::Empty;
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Maelstrom Weapon improved: 10% to gain full stack and 30% to add an extra stack
+            if (spellId == MAELSTROM_WEAPON_BUFF)
+            {
+                if (Aura* mwb = me->GetAura(MAELSTROM_WEAPON_BUFF))
+                {
+                    uint32 stacks = mwb->GetStackAmount();
+                    if (stacks < 5)
+                    {
+                        if (urand(1,100) <= 10)
+                            mwb->ModStackAmount(5);
+                        if (urand(1,100) <= 30)
+                            mwb->ModStackAmount(1);
+                    }
+
+                    MaelstromCount = mwb->GetStackAmount();
+                }
+
+                MaelstromTimer = 30000; //30 sec duration then reset
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            //Shields improvement, replaces Static Shock (part 2) and Improved Earth Shield (part 1)
+            if (spellId == GetSpell(LIGHTNING_SHIELD_1) ||
+                spellId == GetSpell(EARTH_SHIELD_1)/* ||
+                spellId == GetSpell(WATER_SHIELD_1)*/)
+            {
+                if (Aura* shield = target->GetAura(spellId, me->GetGUID()))
+                {
+                    shield->SetCharges(shield->GetCharges() + 12);
+                }
+            }
+            //Lightning Overload: 20% cast SAME spell with no mana! make sure this does not proc on itself!
+            if (me->getLevel() >= 40 && (spellId == GetSpell(LIGHTNING_SHIELD_1) || spellId == GetSpell(CHAIN_LIGHTNING_1)))
+            {
+                bool cast = (urand(1,100) <= 20);
+                if (spellId == GetSpell(LIGHTNING_BOLT_1))
+                {
+                    if (LOvBolt == false)
+                    {
+                        if (cast)
+                        {
+                            LOvBolt = true;
+                            me->CastSpell(target, spellId, true);
+                        }
+                    }
+                    else
+                        LOvBolt = false;
+                }
+                if (spellId == GetSpell(CHAIN_LIGHTNING_1))
+                {
+                    if (LOvChain == false)
+                    {
+                        if (cast)
+                        {
+                            LOvChain = true;
+                            me->CastSpell(target, spellId, true);
+                        }
+                    }
+                    else
+                        LOvChain = false;
+                }
+            }
+            if (spellId == GetSpell(STORMSTRIKE_1))
+            {
+                //Windfury: 10% chance
+                if (WindfuryTimer == 0 && me->getLevel() >= 30)
+                {
+                    if (urand(0,100) < 10)
+                        WindfuryTimer = 1000;
+
+                    if (WindfuryTimer > 0)
+                        me->CastSpell(target, WINDFURY_PROC, true);
+                }
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE)
+            {
+                //Windfury: 10% chance
+                if (WindfuryTimer == 0 && me->getLevel() >= 30)
+                {
+                    if (urand(0,100) < 10)
+                        WindfuryTimer = 1000;
+
+                    if (WindfuryTimer > 0)
+                        me->CastSpell(victim, WINDFURY_PROC, true);
+                }
+            }
+
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void UnsummonAll()
+        {
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0)
+                {
+                    Unit* to = ObjectAccessor::FindConnectedPlayer(_totems[i].first);
+                    if (!to)
+                    {
+                        //TC_LOG_ERROR("entities.player", "%s has no totem in slot %u during remove!", me->GetName().c_str(), i);
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                }
+            }
+        }
+
+        void Reset()
+        {
+            HexyCheckTimer = 3000;
+            EarthyCheckTimer = 2000;
+            MaelstromTimer = 0;
+            WindfuryTimer = 0;
+
+            MaelstromCount = 0;
+
+            Hexy = false;
+            Earthy = false;
+            LOvBolt = false;
+            LOvChain = false;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_SHAMAN);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (HexyCheckTimer > diff)          HexyCheckTimer -= diff;
+            if (EarthyCheckTimer > diff)        EarthyCheckTimer -= diff;
+
+            if (MaelstromTimer > diff)          MaelstromTimer -= diff;
+            else if (MaelstromCount > 0)        MaelstromCount = 0;
+
+            if (WindfuryTimer > diff)           WindfuryTimer -= diff;
+            else                                WindfuryTimer = 0;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(HEALING_WAVE_1);
+            InitSpellMap(CHAIN_HEAL_1);
+            InitSpellMap(LESSER_HEALING_WAVE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(RIPTIDE_1) : RemoveSpell(RIPTIDE_1);
+            InitSpellMap(ANCESTRAL_SPIRIT_1);
+            CURE_TOXINS = lvl >= 39 ? CLEANSE_SPIRIT_1 : InitSpell(me, CURE_TOXINS_1);
+            InitSpellMap(FLAME_SHOCK_1);
+            InitSpellMap(EARTH_SHOCK_1);
+            InitSpellMap(FROST_SHOCK_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(STORMSTRIKE_1) : RemoveSpell(STORMSTRIKE_1);
+            InitSpellMap(LIGHTNING_BOLT_1);
+            InitSpellMap(CHAIN_LIGHTNING_1);
+            InitSpellMap(LAVA_BURST_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(THUNDERSTORM_1) : RemoveSpell(THUNDERSTORM_1);
+            InitSpellMap(LIGHTNING_SHIELD_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(EARTH_SHIELD_1) : RemoveSpell(EARTH_SHIELD_1);
+     /*NYI*///InitSpellMap(WATER_SHIELD_1);
+            InitSpellMap(WATER_BREATHING_1);
+            InitSpellMap(WATER_WALKING_1);
+  /*CUSTOM*/lvl >= 60 ? InitSpellMap(BLOODLUST_1) : RemoveSpell(BLOODLUST_1);
+            InitSpellMap(PURGE_1);
+            InitSpellMap(WIND_SHEAR_1);
+            InitSpellMap(HEX_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(STONESKIN_TOTEM_1) : RemoveSpell(STONESKIN_TOTEM_1);
+            InitSpellMap(HEALINGSTREAM_TOTEM_1);
+            InitSpellMap(MANASPRING_TOTEM_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(SEARING_TOTEM_1) : RemoveSpell(SEARING_TOTEM_1);
+            InitSpellMap(WINDFURY_TOTEM_1);
+            InitSpellMap(STRENGTH_OF_EARTH_TOTEM_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(TOTEM_OF_WRATH_1) : RemoveSpell(TOTEM_OF_WRATH_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(MANA_TIDE_TOTEM_1) : RemoveSpell(MANA_TIDE_TOTEM_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 58)
+                RefreshAura(ELEMENTAL_WARDING,2); //12%
+            else if (level >= 15)
+                RefreshAura(ELEMENTAL_WARDING); //6%
+            if (level >= 18)
+                RefreshAura(ELEMENTAL_DEVASTATION3); //9%
+            else if (level >= 15)
+                RefreshAura(ELEMENTAL_DEVASTATION2); //6%
+            else if (level >= 12)
+                RefreshAura(ELEMENTAL_DEVASTATION1); //3%
+            if (level >= 30)
+                RefreshAura(ANCESTRAL_KNOWLEDGE,3); //30%
+            else if (level >= 20)
+                RefreshAura(ANCESTRAL_KNOWLEDGE,2); //20%
+            else if (level >= 10)
+                RefreshAura(ANCESTRAL_KNOWLEDGE); //10%
+            if (level >= 25)
+                RefreshAura(TOUGHNESS); //10%, 30%
+            if (level >= 29)
+                RefreshAura(FLURRY5); //30%
+            else if (level >= 28)
+                RefreshAura(FLURRY4); //24%
+            else if (level >= 27)
+                RefreshAura(FLURRY3); //18%
+            else if (level >= 26)
+                RefreshAura(FLURRY2); //12%
+            else if (level >= 25)
+                RefreshAura(FLURRY1); //6%
+            if (level >= 50)
+                RefreshAura(WEAPON_MASTERY,3); //30%
+            else if (level >= 40)
+                RefreshAura(WEAPON_MASTERY,2); //20%
+            else if (level >= 30)
+                RefreshAura(WEAPON_MASTERY); //10%
+            if (level >= 45)
+                RefreshAura(STATIC_SHOCK,2); //12%
+            else if (level >= 41)
+                RefreshAura(STATIC_SHOCK); //6%
+            if (level >= 20)
+                RefreshAura(ANCESTRAL_HEALING); //10%
+            if (level >= 50)
+                RefreshAura(ANCESTRAL_AWAKENING); //30%
+
+            if (level >= 70)
+                RefreshAura(SHAMAN_T10_RESTO_4P); //25%
+
+            if (level >= 40)
+            {
+                if (level >= 70)
+                    RefreshAura(MAELSTROM_WEAPON5,2);
+                else if (level >= 60)
+                    RefreshAura(MAELSTROM_WEAPON5);
+                else if (level >= 55)
+                    RefreshAura(MAELSTROM_WEAPON4);
+                else if (level >= 50)
+                    RefreshAura(MAELSTROM_WEAPON3);
+                else if (level >= 45)
+                    RefreshAura(MAELSTROM_WEAPON2);
+                else// if (level >= 40)
+                    RefreshAura(MAELSTROM_WEAPON1);
+
+                RefreshAura(UNLEASHED_RAGE);
+                RefreshAura(IMPROVED_STORMSTRIKE); //20%
+                RefreshAura(ELEMENTAL_OATH);
+            }
+
+            EARTHLIVING_WEAPON =
+                level >= 70 ? EARTHLIVING_WEAPON_PASSIVE_6 :
+                level >= 50 ? EARTHLIVING_WEAPON_PASSIVE_5 :
+                level >= 30 ? EARTHLIVING_WEAPON_PASSIVE_4 : 0;
+            if (EARTHLIVING_WEAPON)
+            {
+                me->RemoveAurasDueToSpell(EARTHLIVING_WEAPON_PASSIVE_4);
+                me->RemoveAurasDueToSpell(EARTHLIVING_WEAPON_PASSIVE_5);
+                me->RemoveAurasDueToSpell(EARTHLIVING_WEAPON_PASSIVE_6);
+                RefreshAura(EARTHLIVING_WEAPON, 3);
+            }
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case HEALING_WAVE_1:
+                case CHAIN_HEAL_1:
+                case LESSER_HEALING_WAVE_1:
+                case RIPTIDE_1:
+                case CURE_TOXINS_1:
+                case CLEANSE_SPIRIT_1:
+                case BLOODLUST_1:
+                case WATER_SHIELD_1:
+                case MANA_TIDE_TOTEM_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        typedef std::pair<ObjectGuid /*guid*/, TotemParam /*param*/> BotTotem;
+        BotTotem _totems[MAX_TOTEMS];
+        uint32 CURE_TOXINS;
+        uint32 EARTHLIVING_WEAPON;
+        //Timers
+        uint32 HexyCheckTimer, EarthyCheckTimer, MaelstromTimer, WindfuryTimer;
+        uint8 MaelstromCount;
+        bool Hexy, Earthy, LOvChain, LOvBolt;
+
+        enum ShamanBaseSpells
+        {
+            HEALING_WAVE_1                      = 331,
+            CHAIN_HEAL_1                        = 1064,
+            LESSER_HEALING_WAVE_1               = 8004,
+            RIPTIDE_1                           = 61295,
+            ANCESTRAL_SPIRIT_1                  = 2008,
+            CURE_TOXINS_1                       = 526,
+            CLEANSE_SPIRIT_1                    = 51886,
+            FLAME_SHOCK_1                       = 8050,
+            EARTH_SHOCK_1                       = 8042,
+            FROST_SHOCK_1                       = 8056,
+            STORMSTRIKE_1                       = 17364,
+            LIGHTNING_BOLT_1                    = 403,
+            CHAIN_LIGHTNING_1                   = 421,
+            LAVA_BURST_1                        = 51505,
+            THUNDERSTORM_1                      = 51490,
+            LIGHTNING_SHIELD_1                  = 324,
+            EARTH_SHIELD_1                      = 974,
+            WATER_SHIELD_1                      = 52127,
+            WATER_BREATHING_1                   = 131,
+            WATER_WALKING_1                     = 546,
+            //BLOODLUST_1                         = 54516,//custom, moved to specials
+            PURGE_1                             = 370,
+            WIND_SHEAR_1                        = 57994,
+            HEX_1                               = 51514,
+            STONESKIN_TOTEM_1                   = 8071,
+            HEALINGSTREAM_TOTEM_1               = 5394,
+            MANASPRING_TOTEM_1                  = 5675,
+            SEARING_TOTEM_1                     = 3599,
+            WINDFURY_TOTEM_1                    = 8512,
+            STRENGTH_OF_EARTH_TOTEM_1           = 8075,
+            TOTEM_OF_WRATH_1                    = 30706,
+            MANA_TIDE_TOTEM_1                   = 16190
+        };
+
+        enum ShamanPassives
+        {
+            //Elemental
+            ELEMENTAL_DEVASTATION1              = 30160,
+            ELEMENTAL_DEVASTATION2              = 29179,
+            ELEMENTAL_DEVASTATION3              = 29180,
+            ELEMENTAL_WARDING                   = 28998,//rank 3
+            ELEMENTAL_OATH                      = 51470,//rank 2
+            //Enchancement
+            ANCESTRAL_KNOWLEDGE                 = 17489,//rank 5
+            TOUGHNESS                           = 16309,//rank 5
+            FLURRY1                             = 16256,
+            FLURRY2                             = 16281,
+            FLURRY3                             = 16282,
+            FLURRY4                             = 16283,
+            FLURRY5                             = 16284,
+            WEAPON_MASTERY                      = 29086,//rank 3
+            UNLEASHED_RAGE                      = 30809,//rank 3
+            STATIC_SHOCK                        = 51527,//rank 3
+            IMPROVED_STORMSTRIKE                = 51522,//rank 2
+            MAELSTROM_WEAPON1                   = 51528,
+            MAELSTROM_WEAPON2                   = 51529,
+            MAELSTROM_WEAPON3                   = 51530,
+            MAELSTROM_WEAPON4                   = 51531,
+            MAELSTROM_WEAPON5                   = 51532,
+            //Restoration
+            ANCESTRAL_HEALING                   = 16240,//rank 3
+            ANCESTRAL_AWAKENING                 = 51558,//rank 3
+            //Special
+            SHAMAN_T10_RESTO_4P                 = 70808 //Chain Heal HoT
+        };
+
+        enum ShamanSpecial
+        {
+            //2 extra white attacks
+            //100 yd
+            //"Increases attack power for 1.50 sec"
+            //Warning! can proc even from itself!
+            WINDFURY_PROC                       = 32910,
+            //"Increases melee,ranged and spell casting speed by 35%
+            //for all party members. Lasts 20 sec."
+            //250 mana, 20 yd
+            //affects raid
+            //no penalty
+            BLOODLUST_1                         = 54516,
+            //20% chance to put HoT on healed target over 12 sec
+            EARTHLIVING_WEAPON_PASSIVE_4        = 52005,//348 base hp
+            EARTHLIVING_WEAPON_PASSIVE_5        = 52007,//456 base hp
+            EARTHLIVING_WEAPON_PASSIVE_6        = 52008,//652 base hp
+
+            MAELSTROM_WEAPON_BUFF               = 53817,
+            STORMSTRIKE_DAMAGE                  = 32175,
+            STORMSTRIKE_DAMAGE_OFFHAND          = 32176
+        };
+    };
+};
+
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
new file mode 100644
index 0000000..6df41aa
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
@@ -0,0 +1,547 @@
+#include "bot_ai.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Warlock NpcBot (reworked by Graff onlysuffering@gmail.com)
+Voidwalker pet AI included
+Complete - 3%
+TODO:
+*/
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warlock_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct warlock_botAI : public bot_minion_ai
+    {
+        warlock_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit* u) { me->SetBotsPetDied(); bot_ai::JustDied(u); }
+        void DoNonCombatActions() { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+            feartimer = std::max<uint32>(feartimer, 1000);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            ////if pet is dead or unreachable
+            //Creature* m_botsPet = me->GetBotsPet();
+            //if (!m_botsPet || m_botsPet->FindMap() != master->GetMap() || (me->GetDistance2d(m_botsPet) > sWorld->GetMaxVisibleDistanceOnContinents() - 20.f))
+            //    if (master->getLevel() >= 10 && !me->IsInCombat() && !IsCasting() && !me->IsMounted())
+            //        SummonBotsPet(PET_VOIDWALKER);
+
+            //TODO: implement healthstone
+            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (GetManaPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(CLASS_WARLOCK))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            //TODO: add more damage spells
+
+            if (feartimer <= diff && GC_Timer <= diff)
+            { CheckFear(); feartimer = 2000; }
+
+            if (IsSpellReady(RAIN_OF_FIRE_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && Rand() < 25)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, GetSpell(RAIN_OF_FIRE_1)))
+                {
+                    SetSpellCooldown(RAIN_OF_FIRE_1, 5000);
+                    return;
+                }
+                SetSpellCooldown(RAIN_OF_FIRE_1, 2000);//fail
+            }
+
+            float dist = me->GetExactDist(opponent);
+
+            if (IsSpellReady(CURSE_OF_THE_ELEMENTS_1, diff) && dist < 30 && Rand() < 15 &&
+                !HasAuraName(opponent, CURSE_OF_THE_ELEMENTS_1) &&
+                doCast(opponent, GetSpell(CURSE_OF_THE_ELEMENTS_1)))
+            {
+                GC_Timer = 800;
+                return;
+            }
+
+            if (IsSpellReady(CORRUPTION_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 25 &&
+                !opponent->HasAura(GetSpell(CORRUPTION_1), me->GetGUID()) &&
+                doCast(opponent, GetSpell(CORRUPTION_1)))
+                return;
+
+            if (IsSpellReady(HAUNT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 25 &&
+                !opponent->HasAura(GetSpell(HAUNT_1), me->GetGUID()) &&
+                doCast(opponent, GetSpell(HAUNT_1)))
+            {
+                SetSpellCooldown(HAUNT_1, 8000);
+                return;
+            }
+
+            if (GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 15 && !Afflicted(opponent))
+            {
+                if (GetSpellCooldown(CONFLAGRATE_1) <= 8000 && doCast(opponent, GetSpell(IMMOLATE_1)))
+                    return;
+                else if (doCast(opponent, GetSpell(UNSTABLE_AFFLICTION_1)))
+                    return;
+            }
+
+            if (IsSpellReady(CONFLAGRATE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 35 &&
+                HasAuraName(opponent, IMMOLATE_1) &&
+                doCast(opponent, GetSpell(CONFLAGRATE_1)))
+            {
+                SetSpellCooldown(CONFLAGRATE_1, 8000);
+                return;
+            }
+
+            if (IsSpellReady(CHAOS_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 50 &&
+                doCast(opponent, GetSpell(CHAOS_BOLT_1)))
+            {
+                SetSpellCooldown(CHAOS_BOLT_1, me->getLevel() < 80 ? 10000 : 8000);
+                return;
+            }
+
+            if (IsSpellReady(SHADOW_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 &&
+                doCast(opponent, GetSpell(SHADOW_BOLT_1)))
+                return;
+        }
+
+        uint8 Afflicted(Unit* target)
+        {
+            if (!target || target->isDead()) return 0;
+            bool aff = HasAuraName(target, UNSTABLE_AFFLICTION_1, me->GetGUID());
+            bool imm = HasAuraName(target, IMMOLATE_1, me->GetGUID());
+            if (imm) return 1;
+            if (aff) return 2;
+            return 0;
+        }
+
+        void CheckFear()
+        {
+            uint32 FEAR = GetSpell(FEAR_1);
+            if (Unit* u = FindAffectedTarget(FEAR, me->GetGUID()))
+                if (Aura* aura = u->GetAura(FEAR, me->GetGUID()))
+                    if (aura->GetDuration() > 3000)
+                        return;
+            Unit* feartarget = FindFearTarget();
+            if (feartarget && doCast(feartarget, FEAR))
+                return;
+        }
+
+        //void SummonedCreatureDies(Creature* summon, Unit* /*killer*/)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPetDied();
+        //}
+
+        //void SummonedCreatureDespawn(Creature* summon)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPet(NULL);
+        //}
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                ////Shatter: frozen targets crit
+                //if (lvl >= 11 && damageinfo.target && damageinfo.target->isFrozen())
+                //    aftercrit *= 4.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                ////!!!spell damage is not yet critical and will be multiplied by 1.5
+                ////so we should put here bonus damage mult /1.5
+                ////Spell Power: 50% additional crit damage bonus for All spells
+                //if (lvl >= 55)
+                //    pctbonus += 0.333f;
+            }
+            //if (lvl >= 11 && spellId == FROSTBOLT && damageinfo.target && damageinfo.target->isFrozen())
+            //    pctbonus *= 0.2f;
+
+            ////Spellpower bonus damage (temp)
+            //if (m_spellpower > 0)
+            //{
+            //    if (spellId == SHADOW_BOLT)
+            //        fdamage += m_spellpower * 1.38f;
+            //    else if (spellId == IMMOLATE)
+            //        fdamage += m_spellpower * 0.75f; //guessed
+            //    else if (spellId == CONFLAGRATE)
+            //        fdamage += m_spellpower * 2.75f; //guessed
+            //    else if (spellId == CHAOS_BOLT)
+            //        fdamage += m_spellpower * 2.25f * 1.24f;
+            //    else if (spellId == RAIN_OF_FIRE || spellId == 42223)
+            //        fdamage += m_spellpower * 0.25f * 4.f;
+            //    else if (spellId == HAUNT)
+            //        fdamage += m_spellpower * 1.75f;
+            //}
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierEffect(SpellInfo const* /*spellInfo*/, uint8 /*effect_index*/, float& /*value*/) const
+        {
+            //uint32 spellId = spellInfo->Id;
+
+            //float pct_mod = 1.f;
+
+            //Spellpower bonus damage (temp)
+            //if (spellInfo->Effects[effect_index].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE)
+            //{
+            //    if (spellId == CORRUPTION)
+            //        value += m_spellpower * 1.35f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //    else if (spellId == IMMOLATE)
+            //        value += m_spellpower * 1.59f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //    else if (spellId == UNSTABLE_AFFLICTION)
+            //        value += m_spellpower * 1.68f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //}
+
+            //value *= pct_mod;
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            feartimer = 0;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_WARLOCK);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (feartimer > diff)                   feartimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(CURSE_OF_THE_ELEMENTS_1);
+            InitSpellMap(SHADOW_BOLT_1);
+            InitSpellMap(IMMOLATE_1);
+            lvl >= 40 ? InitSpellMap(CONFLAGRATE_1) : RemoveSpell(CONFLAGRATE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(CHAOS_BOLT_1) : RemoveSpell(CHAOS_BOLT_1);
+            InitSpellMap(RAIN_OF_FIRE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(HAUNT_1) : RemoveSpell(HAUNT_1);
+            InitSpellMap(CORRUPTION_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(UNSTABLE_AFFLICTION_1) : RemoveSpell(UNSTABLE_AFFLICTION_1);
+            InitSpellMap(FEAR_1);
+        }
+
+        //TODO
+        void ApplyClassPassives() { }
+
+    private:
+        //Timers
+        uint32 feartimer;
+
+        enum WarlockBaseSpells
+        {
+            CURSE_OF_THE_ELEMENTS_1             = 1490,
+            SHADOW_BOLT_1                       = 686,
+            IMMOLATE_1                          = 348,
+            CONFLAGRATE_1                       = 17962,
+            CHAOS_BOLT_1                        = 50796,
+            RAIN_OF_FIRE_1                      = 5740,
+            HAUNT_1                             = 59164,
+            CORRUPTION_1                        = 172,
+            UNSTABLE_AFFLICTION_1               = 30404,
+            FEAR_1                              = 6215
+        };
+        enum WarlockPassives
+        {
+        };
+    };
+};
+
+class voidwalker_bot : public CreatureScript
+{
+public:
+    voidwalker_bot() : CreatureScript("voidwalker_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new voidwalker_botAI(creature);
+    }
+
+    struct voidwalker_botAI : public bot_pet_ai
+    {
+        voidwalker_botAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_NONE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { m_creatureOwner->SetBotsPetDied(); }
+        void DoNonCombatActions() { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            if (CCed(me)) return;
+
+            //TODO: add checks to help owner
+
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(PET_TYPE_VOIDWALKER))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //TORMENT
+            if (IsSpellReady(TORMENT_1, diff, false) && meleedist < 5 && !IsTank(opponent->GetVictim()))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(TORMENT_1)))
+                {
+                    SetSpellCooldown(TORMENT_1, 5000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (m_creatureOwner->IsAIEnabled)
+                if (bot_minion_ai* ai = m_creatureOwner->GetBotMinionAI())
+                    ai->OnOwnerDamagedBy(u);
+        }
+
+        //debug
+        //void ListSpells(ChatHandler* ch) const
+        //{
+        //    ch->PSendSysMessage("Spells list:");
+        //    ch->PSendSysMessage("Torment: %u", TORMENT);
+        //    ch->PSendSysMessage("End of spells list.");
+        //}
+
+        void Reset()
+        {
+            if (master && m_creatureOwner)
+            {
+                SetStats(true);
+                ApplyPassives(PET_TYPE_VOIDWALKER);
+                ApplyClassPassives();
+                SetBaseArmor(162 * master->getLevel());
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            InitSpellMap(TORMENT_1);
+        }
+
+        void ApplyClassPassives() { }
+
+    private:
+        //Timers
+
+        enum VoidwalkerBaseSpells
+        {
+            TORMENT_1                           = 3716
+        };
+        enum VoidwalkerPassives
+        {
+        };
+    };
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+    new voidwalker_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
new file mode 100644
index 0000000..c4acdd4
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
@@ -0,0 +1,1144 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Warrior NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 40-45%
+TODO: Thunder Clap, Piercing Howl, Challenging Shout, other tanking stuff
+*/
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warrior_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct warrior_botAI : public bot_minion_ai
+    {
+        warrior_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            if (ragetimer2 <= diff)
+            {
+                if (me->IsInCombat() && me->getLevel() >= 20)
+                {
+                    if (getrage() < 990)
+                        me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
+                    else
+                        me->SetPower(POWER_RAGE, 1000);//max
+                }
+                ragetimer2 = 2000;
+            }
+            if (ragetimer <= diff)
+            {
+                if (!me->IsInCombat() && !HasAuraName(me, BLOODRAGE_1))
+                {
+                    if (getrage() > uint32(10.f*rageLossMult))
+                        me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult));//-1 rage per 1.5 sec
+                    else
+                        me->SetPower(POWER_RAGE, 0);//min
+                }
+                ragetimer = 1500;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            CheckIntervene(diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_WARRIOR))
+            {
+                if (!IsTank() && !me->IsInCombat() && battleStance != true && master->getAttackers().empty() &&
+                    stancetimer <= diff && Rand() < 25)
+                    stanceChange(diff, 1);
+                return;
+            }
+
+            if (IsSpellReady(BATTLESHOUT_1, diff) && getrage() > 100 && Rand() < 30 &&
+                !HasAuraName(master, BATTLESHOUT_1) && !HasAuraName(master, BLESSING_OF_MIGHT_1) &&
+                !HasAuraName(master, GREATER_BLESSING_OF_MIGHT_1) && master->IsWithinLOSInMap(me))
+            {
+                if (doCast(me, GetSpell(BATTLESHOUT_1)))
+                {
+                    SetSpellCooldown(BATTLESHOUT_1, 25000);
+                    return;
+                }
+            }
+
+            if (IsSpellReady(BLOODRAGE_1, diff, false) && me->IsInCombat() && getrage() < 600 &&
+                Rand() < 20 && !me->HasAura(ENRAGED_REGENERATION_1))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLOODRAGE_1)))
+                {
+                    SetSpellCooldown(BLOODRAGE_1, 40000);
+                    GC_Timer = temptimer;
+                }
+            }
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u)
+        {
+            //victorious state emulation
+            if (me->getLevel() >= 5 && u->getLevel() + 9 >= me->getLevel())
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, VICTORIOUS_SPELL, true))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit* u) { bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void modrage(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && rage < uint32(abs(mod)))
+            {
+                //debug set rage to 0
+                mod = 0;
+                set = true;
+                return;
+            }
+
+            if (set)
+                rage = mod ? mod*10 : 0;
+            else
+                rage += mod*10;
+
+            me->SetPower(POWER_RAGE, rage);
+        }
+
+        uint32 getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            return rage;
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_DISORIENTED)))
+            {
+                if (IsSpellReady(BERSERKERRAGE_1, diff) && Rand() < 35 && !me->HasAura(ENRAGED_REGENERATION_1) &&
+                    doCast(me, GetSpell(BERSERKERRAGE_1)))
+                {
+                    SetSpellCooldown(BERSERKERRAGE_1, 25000);
+                    if (me->getLevel() >= 40)
+                        doCast(me, 58096, true); //Berserker Rage Effect (434 unused)
+                    return;
+                }
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            //Keep defensive stance if tank
+            if (IsTank() && defensiveStance != true && stancetimer <= diff)
+                stanceChange(diff, 2);
+            //SelfHeal
+            if (IsSpellReady(ENRAGED_REGENERATION_1, diff) && getrage() > 150 && GetHealthPCT(me) < 40 &&
+                Rand() < 40 && me->HasAuraWithMechanic(uint32(1<<MECHANIC_ENRAGED)))
+            {
+                if (doCast(me, GetSpell(ENRAGED_REGENERATION_1)))
+                {
+                    SetSpellCooldown(ENRAGED_REGENERATION_1, 90000);
+                    GC_Timer = 500;
+                    return;
+                }
+            }
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+            //charge + warbringer
+            if (IsSpellReady(CHARGE_1, diff, false) && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+                (me->getLevel() >= 50 ||
+                (!me->IsInCombat() && (battleStance || stanceChange(diff, 1)))))
+            {
+                temptimer = GC_Timer;
+                if (me->getLevel() >= 29)
+                    me->RemoveMovementImpairingAuras();
+                if (doCast(opponent, GetSpell(CHARGE_1), me->IsInCombat()))
+                {
+                    SetSpellCooldown(CHARGE_1, 12000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //intercept
+            if (IsSpellReady(INTERCEPT_1, diff, false) && !IsTank() &&
+                getrage() > 100 && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+                !CCed(opponent) && (berserkerStance || stanceChange(diff, 3)))
+            {
+                if (doCast(opponent, GetSpell(INTERCEPT_1)))
+                {
+                    SetSpellCooldown(INTERCEPT_1, 20000);
+                    return;
+                }
+            }
+            //SelfHeal 2
+            if (IsSpellReady(VICTORY_RUSH_1, diff) && VICTORIOUS && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                (b_attackers.size() <= 1 || (GetHealthPCT(me) < std::max<int32>(100 - b_attackers.size() * 10, 75))))
+            {
+                if (doCast(opponent, GetSpell(VICTORY_RUSH_1)))
+                    return;
+            }
+            //FEAR
+            if (IsSpellReady(INTIMIDATING_SHOUT_1, diff) && Rand() < 70 && getrage() > 250)
+            {
+                if (opponent->IsNonMeleeSpellCast(false, false, true) && dist <= 8 &&
+                    !(opponent->ToCreature() && opponent->ToCreature()->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                {
+                    if (doCast(opponent, GetSpell(INTIMIDATING_SHOUT_1)))
+                    {
+                        SetSpellCooldown(INTIMIDATING_SHOUT_1, 45000);
+                        return;
+                    }
+                }
+                Unit* fearTarget = NULL;
+                bool triggered = false;
+                uint8 tCount = 0;
+                //fear master's attackers
+                if (!m_attackers.empty() &&
+                    ((master->getClass() != CLASS_DEATH_KNIGHT &&
+                    master->getClass() != CLASS_WARRIOR &&
+                    master->getClass() != CLASS_PALADIN) ||
+                    GetHealthPCT(master) < 70))
+                {
+                    for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 1) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
+                    {
+                        SetSpellCooldown(INTIMIDATING_SHOUT_1, 45000);
+                        return;
+                    }
+                }
+                //Defend myself
+                if (b_attackers.size() > 1)
+                {
+                    tCount = 0;
+                    fearTarget = NULL;
+                    triggered = false;
+                    for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 0) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 0 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
+                    {
+                        SetSpellCooldown(INTIMIDATING_SHOUT_1, 45000);
+                        return;
+                    }
+                }
+            }//end FEAR
+            //OVERPOWER
+            if (IsSpellReady(OVERPOWER_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50 && getrage() > 50 && meleedist <= 5 &&
+                (battleStance || stancetimer <= diff))
+            {
+                if (me->HasAura(TASTE_FOR_BLOOD_BUFF))
+                {
+                    if (battleStance || stanceChange(diff, 1))
+                    {
+                        if (doCast(opponent, GetSpell(OVERPOWER_1)))
+                        {
+                            me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
+                            return;
+                        }
+                    }
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //HAMSTRING
+            if (IsSpellReady(HAMSTRING_1, diff) && Rand() < 50 && getrage() > 100 && meleedist <= 5 && opponent->isMoving() &&
+                (battleStance || berserkerStance || stancetimer <= diff) &&
+                !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (battleStance || berserkerStance || stanceChange(diff, 5))
+                    if (doCast(opponent, GetSpell(HAMSTRING_1)))
+                        return;
+            }
+            //UBERS
+            //Dont use RETA unless capable circumstances
+            if (HasRole(BOT_ROLE_DPS) && Rand() < 20)
+            {
+                if (IsSpellReady(RETALIATION_1, diff) && b_attackers.size() > 4 &&
+                    (battleStance || stanceChange(diff, 1)))
+                {
+                    if (doCast(me, GetSpell(RETALIATION_1)))
+                    {
+                        SetSpellCooldown(RETALIATION_1, 150000);
+                        SetSpellCooldown(RECKLESSNESS_1, 150000);
+                        return;
+                    }
+                }
+                //Dont use RECKL unless capable circumstances
+                if (IsSpellReady(RECKLESSNESS_1, diff) && !IsTank() &&
+                    (m_attackers.size() > 3 || opponent->GetHealth() > me->GetHealth() * 10) &&
+                    (berserkerStance || stanceChange(diff, 3)))
+                {
+                    if (doCast(me, GetSpell(RECKLESSNESS_1)))
+                    {
+                        SetSpellCooldown(RETALIATION_1, 150000);
+                        SetSpellCooldown(RECKLESSNESS_1, 150000);
+                        return;
+                    }
+                }
+            }
+            //DEATHWISH
+            if (IsSpellReady(DEATHWISH_1, diff) && getrage() > 100 && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetHealth()/2 && Rand() < 20 &&
+                !me->HasAura(ENRAGED_REGENERATION_1))
+            {
+                if (doCast(me, GetSpell(DEATHWISH_1)))
+                {
+                    SetSpellCooldown(DEATHWISH_1, 144000);
+                    return;
+                }
+            }
+            //TAUNT //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(TAUNT_1, diff, false) && u && u != me && !IsTank(u) && dist <= 30 &&
+                !CCed(opponent) && !IsTankingClass(u->getClass()) && (IsInBotParty(u) || IsTank()) &&
+                (defensiveStance || (stancetimer <= diff && stanceChange(diff, 2))))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(TAUNT_1), true))
+                {
+                    SetSpellCooldown(TAUNT_1, 8000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //EXECUTE
+            if (IsSpellReady(EXECUTE_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && getrage() > 150 && meleedist <= 5 &&
+                Rand() < 70 &&GetHealthPCT(opponent) < 20 &&
+                (battleStance || berserkerStance || (stancetimer <= diff && stanceChange(diff, 5))))
+            {
+                if (doCast(opponent, GetSpell(EXECUTE_1)))
+                {
+                    //sudden death
+                    if (me->getLevel() >= 50 && getrage() <= 400)
+                        modrage(10, true);
+                    else if (getrage() > 300)
+                        modrage(-30);
+                    else
+                        modrage(0, true);
+                    return;
+                }
+            }
+            //SUNDER //custom cd condition
+            if (GetSpell(SUNDER_1) && GC_Timer <= diff && getrage() > 150 &&
+                (getrage() > 500 || IsSpellReady(SUNDER_1,diff, false)) &&
+                meleedist <= 5 && IsTank() && opponent->GetHealth() > me->GetMaxHealth() && Rand() < 35)
+            {
+                Aura* sunder = opponent->GetAura(GetSpell(SUNDER_1), me->GetGUID());
+                if ((!sunder || sunder->GetStackAmount() < 5 || sunder->GetDuration() < 15000) &&
+                    doCast(opponent, GetSpell(SUNDER_1)))
+                {
+                    SetSpellCooldown(SUNDER_1, 7000);
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            //SS //no GCD //no rage (glyph)
+            if (IsSpellReady(SWEEPING_STRIKES_1, diff, false) && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 25 &&
+                (battleStance || berserkerStance || stancetimer <= diff) &&
+                (b_attackers.size() > 1 || FindSplashTarget(7, opponent)))
+            {
+                temptimer = GC_Timer;
+                if ((battleStance || berserkerStance || stanceChange(diff, 5)) &&
+                    doCast(me, GetSpell(SWEEPING_STRIKES_1), true))
+                {
+                    SetSpellCooldown(SWEEPING_STRIKES_1, 30000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //WHIRLWIND
+            if (IsSpellReady(WHIRLWIND_1, diff) && getrage() >= 250 && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 50 &&
+               (FindSplashTarget(7, opponent) || (getrage() > 800 && dist <= 7)) &&
+               (berserkerStance || stancetimer <= diff))
+            {
+                if ((berserkerStance || stanceChange(diff, 3)) &&
+                    doCast(me, GetSpell(WHIRLWIND_1)))
+                {
+                    SetSpellCooldown(WHIRLWIND_1, 6500);
+                    return;
+                }
+            }
+            //BLADESTORM
+            if (IsSpellReady(BLADESTORM_1, diff) && HasRole(BOT_ROLE_DPS) &&
+               getrage() >= 250 && (Rand() < 20 || me->HasAura(RECKLESSNESS_1)) &&
+               (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()))
+            {
+                if (doCast(me, GetSpell(BLADESTORM_1)))
+                {
+                    SetSpellCooldown(BLADESTORM_1, 60000);
+                    return;
+                }
+            }
+            //Mortal Strike
+            if (IsSpellReady(MORTALSTRIKE_1, diff) && getrage() > 300 && HasRole(BOT_ROLE_DPS) && meleedist <= 5)
+            {
+                if (doCast(opponent, GetSpell(MORTALSTRIKE_1)))
+                {
+                    SetSpellCooldown(MORTALSTRIKE_1, 7000);
+                    ResetSpellCooldown(SLAM_1); //reset here
+                }
+            }
+            //Slam
+            if (IsSpellReady(SLAM_1, diff))
+            {
+                bool triggered = (GetSpellCooldown(MORTALSTRIKE_1) == 7000);
+                if (getrage() > 150 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && Rand() < (30 + triggered * 30))
+                {
+                    if (doCast(opponent, GetSpell(SLAM_1), true))
+                    {
+                        SetSpellCooldown(SLAM_1, 3000); //must be > 7000/2
+                        modrage(-15);
+                        return;
+                    }
+                }
+            }
+            //PUMMEL
+            if (IsSpellReady(PUMMEL_1, diff, false) && Rand() < 80 && getrage() > 100 && meleedist <= 5 &&
+                opponent->IsNonMeleeSpellCast(false) &&
+                (berserkerStance || stancetimer <= diff))
+            {
+                temptimer = GC_Timer;
+                if ((berserkerStance || stanceChange(diff, 3)) &&
+                    doCast(opponent, GetSpell(PUMMEL_1)))
+                {
+                    SetSpellCooldown(PUMMEL_1, 10000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //REND
+            if (IsSpellReady(REND_1, diff) && Rand() < 50 && getrage() > 100 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                opponent->GetHealth() > me->GetHealth()/2 &&
+                !opponent->HasAura(GetSpell(REND_1), me->GetGUID()) &&
+                (battleStance || defensiveStance || (stancetimer <= diff && stanceChange(diff, 4))))
+            {
+                if (doCast(opponent, GetSpell(REND_1)))
+                    return;
+            }
+            //CLEAVE //no GCD
+            if (IsSpellReady(CLEAVE_1, diff, false) && getrage() > 200 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && Rand() < 30)
+            {
+                temptimer = GC_Timer;
+                u = FindSplashTarget(5);
+                if (u && doCast(opponent, GetSpell(CLEAVE_1)))
+                {
+                    SetSpellCooldown(CLEAVE_1, me->getAttackTimer(BASE_ATTACK)); //once per swing, prevents rage loss
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            else {}//HEROIC STRIKE placeholder
+            //DISARM DEPRECATED
+            /*if (disarm_cd <= diff && meleedist < 5 &&
+                (opponent->GetVictim()->GetGUID() == master->GetGUID() ||
+                opponent->GetVictim()->GetGUID() == m_creature->GetGUID()) &&
+                getrage() > 15 &&
+                !HasAuraName(opponent, GetSpellName(DISARM)) &&
+                GC_Timer <= diff)
+            {
+                if (opponent->getClass() == CLASS_ROGUE  ||
+                    opponent->getClass() == CLASS_WARRIOR   ||
+                    opponent->getClass() == CLASS_SHAMAN    ||
+                    opponent->getClass() == CLASS_PALADIN)
+                {
+                    if (defensiveStance == true)
+                    {
+                        doCast(opponent, DISARM, true);
+                        //rage -= 100;
+                        disarm_cd = DISARM_CD;
+                    }
+                    else stanceChange(diff, 2);
+                }
+            }*/
+        }//end Attack
+
+        void CheckIntervene(uint32 diff)
+        {
+            if (IsSpellReady(INTERVENE_1, diff, false) && getrage() > 100 &&
+                Rand() < (IsTank() ? 80 : 30) &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                if (!master->IsInCombat() && master->getAttackers().empty() && master->isMoving())
+                {
+                    float mydist = me->GetExactDist(master);
+                    if (mydist < 24 && mydist > 19 && (defensiveStance || stanceChange(diff, 2)))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                        {
+                            SetSpellCooldown(INTERVENE_1, 20000);
+                            GC_Timer = temptimer;
+                            Follow(true);
+                            return;
+                        }
+                    }
+                }
+                Group* gr = master->GetGroup();
+                if (!gr)
+                {
+                    if (GetHealthPCT(master) < 95 && !master->getAttackers().empty() &&
+                        me->getAttackers().size() <= master->getAttackers().size())
+                    {
+                        float dist = me->GetExactDist(master);
+                        if (dist > 25 || dist < 10) return;
+                        if (!(defensiveStance || stanceChange(diff, 2))) return;
+                        temptimer = GC_Timer;
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                        {
+                            SetSpellCooldown(INTERVENE_1, 20000);
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                else
+                {
+                    bool Bots = false;
+                    float dist;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        if (tPlayer->HaveBot())
+                            Bots = true;
+                        if (tPlayer->isDead() || GetHealthPCT(tPlayer) > 90 || IsTank(tPlayer)) continue;
+                        if (tPlayer->getAttackers().size() < me->getAttackers().size()) continue;
+                        dist = me->GetExactDist(tPlayer);
+                        if (dist > 24 || dist < 10) continue;
+                        if (defensiveStance || stanceChange(diff, 2))
+                        {
+                            temptimer = GC_Timer;
+                            if (doCast(tPlayer, GetSpell(INTERVENE_1)))
+                            {
+                                SetSpellCooldown(INTERVENE_1, 20000);
+                                GC_Timer = temptimer;
+                                return;
+                            }
+                        }
+                    }
+                    if (!Bots) return;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer || !tPlayer->HaveBot()) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                        {
+                            Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                            if (!bot || !bot->IsInWorld() || bot == me || bot->isDead()) continue;
+                            if (GetHealthPCT(bot) > 90 || IsTank(bot)) continue;
+                            dist = me->GetExactDist(bot);
+                            if (dist > 25 || dist < 10) continue;
+                            if (bot->getAttackers().size() <= me->getAttackers().size()) continue;
+                            if (defensiveStance || stanceChange(diff, 2))
+                            {
+                                temptimer = GC_Timer;
+                                if (doCast(bot, GetSpell(INTERVENE_1)))
+                                {
+                                    SetSpellCooldown(INTERVENE_1, 20000 / 2);
+                                    GC_Timer = temptimer;
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        bool stanceChange(uint32 diff, uint8 stance)
+        {
+            if (!(stancetimer <= diff) || !stance)
+                return false;
+
+            if (stance == 5)
+            {
+                if (urand(1,100) > 50)
+                    stance = 1;
+                else
+                    stance = me->getLevel() < 30 ? 1 : (urand(1,100) > 75 ? 3 : 1);
+            }
+            else if (stance == 4)
+            {
+                if (urand(1,100) > 50)
+                    stance = 1;
+                else
+                    stance = IsTank() ? 2 : 1;
+            }
+
+            if (stance == 2 && me->getLevel() < 10)
+                return false;
+            if (stance == 3 && me->getLevel() < 30)
+                return false;
+
+            temptimer = GC_Timer;
+            //stance mastery impl
+            uint32 temprage = 0;
+            uint32 myrage = me->GetPower(POWER_RAGE);
+            if (me->getLevel() >= 20)
+                temprage = myrage > 250 ? 250 : myrage;
+            else if (me->getLevel() >= 15)
+                temprage = myrage > 100 ? 100 : myrage;
+            switch (stance)
+            {
+                case 1:
+                    if (doCast(me, GetSpell(BATTLESTANCE_1)))
+                    {
+                        if (me->HasAura(BATTLESTANCE_1))
+                        {
+                            battleStance = true;
+                            defensiveStance = false;
+                            berserkerStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 2100 - me->getLevel()*20;//500 on 80
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 2:
+                    if (doCast(me, GetSpell(DEFENSIVESTANCE_1)))
+                    {
+                        if (me->HasAura(DEFENSIVESTANCE_1))
+                        {
+                            defensiveStance = true;
+                            battleStance = false;
+                            berserkerStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 2100 - me->getLevel()*20;//500 on 80
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 3:
+                    if (doCast(me, GetSpell(BERSERKERSTANCE_1)))
+                    {
+                        if (me->HasAura(BERSERKERSTANCE_1))
+                        {
+                            berserkerStance = true;
+                            battleStance = false;
+                            defensiveStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 2100 - me->getLevel()*20;//500 on 80
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+            GC_Timer = temptimer;
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+                if (lvl >= 15 && spellId == GetSpell(CLEAVE_1) /*|| spellId == HEROICSTRIKE || spellId == THUNDERCLAP*/)
+                    aftercrit += 15.f;
+                //Improved Overpower: 50% additional critical chance for Overpower
+                if (lvl >= 20 && spellId == GetSpell(OVERPOWER_1))
+                    aftercrit += 50.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Impale: 20% crit damage bonus for all abilities
+                if (lvl >= 20)
+                    pctbonus += 0.10f;
+            }
+
+            //Improved Rend: 20% bonus damage for Rend
+            if (spellId == GetSpell(REND_1))
+                pctbonus += 0.2f;
+            //Improved Whirlwind: 20% bonus damage for Whirlwind
+            if (lvl >= 40 && spellId == GetSpell(WHIRLWIND_1))
+                pctbonus += 0.2f;
+            //Glyph of Mortal Strike: 10% bonus damage for Mortal Strike
+            if (lvl >= 40 && spellId == GetSpell(MORTALSTRIKE_1))
+                pctbonus += 0.1f;
+            //Unrelenting Assault (part 2): 20% bonus damage for Overpower and Revenge
+            if (lvl >= 45 && (spellId == GetSpell(OVERPOWER_1)/* || spellId == REVENGE*/))
+                pctbonus += 0.2f;
+            //Improved Mortal Strike: 10% bonus damage for Mortal Strike
+            if (lvl >= 45 && spellId == GetSpell(MORTALSTRIKE_1))
+                pctbonus += 0.1f;
+            //Undending Fury: 10% bonus damage for Whirlwind, Slam and Bloodthirst
+            if (lvl >= 55 && (spellId == GetSpell(WHIRLWIND_1) || spellId == GetSpell(SLAM_1) /*|| spellId == BLOODTHIRST*/))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            switch (spell->Id)
+            {
+                case VICTORIOUS_SPELL:
+                    VICTORIOUS = true;
+                    break;
+                default:
+                    break;
+            }
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(OVERPOWER_1))
+            {
+                //Unrelenting Assault
+                if (UNRELENTING_ASSAULT && target->HasUnitState(UNIT_STATE_CASTING))
+                    target->CastSpell(target, UNRELENTING_ASSAULT_SPELL, true);
+            }
+            if (spellId == GetSpell(BATTLESHOUT_1)/* || spellId == COMMANDINGSHOUT*/)
+            {
+                //Glyph of Battle/Command + 2 min duration (8 for bots)
+                if (Aura* shout = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = shout->GetDuration() + 480000;
+                    shout->SetDuration(dur);
+                    shout->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(REND_1))
+            {
+                //Glyph of Rending + 6 sec duration
+                if (Aura* rend = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = rend->GetDuration() + 6000;
+                    rend->SetDuration(dur);
+                    rend->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(INTERVENE_1))
+            {
+                //Glyph of Intervene + 1 bonus charge (2 for bots)
+                if (Aura* vene = target->GetAura(spellId, me->GetGUID()))
+                {
+                    vene->SetCharges(vene->GetCharges() + 2);
+                }
+            }
+            if (spellId == GetSpell(VICTORY_RUSH_1))
+            {
+                me->RemoveAura(VICTORIOUS_SPELL);
+                VICTORIOUS = false;
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            stancetimer = 0;
+            ragetimer = 1500;
+            ragetimer2 = 3000;
+
+            battleStance = true;
+            defensiveStance = false;
+            berserkerStance = false;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            me->setPowerType(POWER_RAGE);
+            rage = 0;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_WARRIOR);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (stancetimer > diff)                 stancetimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            //InitSpellMap(CHALLENGING_SHOUT_1);
+            InitSpellMap(INTIMIDATING_SHOUT_1);
+            InitSpellMap(ENRAGED_REGENERATION_1);
+            InitSpellMap(CHARGE_1);
+            InitSpellMap(OVERPOWER_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(TAUNT_1) : RemoveSpell(TAUNT_1);
+            //InitSpellMap(DISARM_1);
+            InitSpellMap(BLOODRAGE_1);
+            InitSpellMap(BERSERKERRAGE_1);
+            InitSpellMap(INTERCEPT_1);
+            InitSpellMap(CLEAVE_1);
+            InitSpellMap(HAMSTRING_1);
+            InitSpellMap(INTERVENE_1);
+            InitSpellMap(WHIRLWIND_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(BLADESTORM_1) : RemoveSpell(BLADESTORM_1);
+            InitSpellMap(BATTLESHOUT_1);
+            InitSpellMap(REND_1);
+            InitSpellMap(EXECUTE_1);
+            InitSpellMap(PUMMEL_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(MORTALSTRIKE_1) : RemoveSpell(MORTALSTRIKE_1);
+            InitSpellMap(SLAM_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(SUNDER_1) : RemoveSpell(SUNDER_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(SWEEPING_STRIKES_1) : RemoveSpell(SWEEPING_STRIKES_1);
+            InitSpellMap(BATTLESTANCE_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(DEFENSIVESTANCE_1) : RemoveSpell(DEFENSIVESTANCE_1);
+   /*Quest*/lvl >= 30 ? InitSpellMap(BERSERKERSTANCE_1) : RemoveSpell(BERSERKERSTANCE_1);
+            InitSpellMap(RECKLESSNESS_1);
+            InitSpellMap(RETALIATION_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(DEATHWISH_1) : RemoveSpell(DEATHWISH_1);
+            InitSpellMap(VICTORY_RUSH_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 70)
+                RefreshAura(WC5); //10%
+            else if (level >= 68)
+                RefreshAura(WC4); //8%
+            else if (level >= 66)
+                RefreshAura(WC3); //6%
+            else if (level >= 64)
+                RefreshAura(WC2); //4%
+            else if (level >= 62)
+                RefreshAura(WC1); //2%
+            if (level >= 39)
+                RefreshAura(FLURRY5); //30%
+            else if (level >= 38)
+                RefreshAura(FLURRY4); //24%
+            else if (level >= 37)
+                RefreshAura(FLURRY3); //18%
+            else if (level >= 36)
+                RefreshAura(FLURRY2); //12%
+            else if (level >= 35)
+                RefreshAura(FLURRY1); //6%
+            if (level >= 60)
+                RefreshAura(SWORD_SPEC5,2);//twice
+            else if (level >= 50)
+                RefreshAura(SWORD_SPEC5);//once
+            else if (level >= 45)
+                RefreshAura(SWORD_SPEC4);//once
+            else if (level >= 40)
+                RefreshAura(SWORD_SPEC3);//once
+            else if (level >= 35)
+                RefreshAura(SWORD_SPEC2);//once
+            else if (level >= 30)
+                RefreshAura(SWORD_SPEC1);//once
+            if (level >= 60)
+                RefreshAura(RAMPAGE);
+            if (level >= 55)
+                RefreshAura(TRAUMA2); //30%
+            else if (level >= 35)
+                RefreshAura(TRAUMA1); //15%
+            if (level >= 35)
+                UNRELENTING_ASSAULT = true;
+            if (level >= 45)
+                RefreshAura(BLOOD_FRENZY);
+            if (level >= 40)
+                RefreshAura(SECOND_WIND);
+            if (level >= 40)
+                RefreshAura(TOUGHNESS,2); //-60%
+            else if (level >= 15)
+                RefreshAura(TOUGHNESS); //-30%
+            if (level >= 40)
+                RefreshAura(IMP_HAMSTRING,2); //30%
+            else if (level >= 35)
+                RefreshAura(IMP_HAMSTRING); //15%
+            if (level >= 30)
+                RefreshAura(TASTE_FOR_BLOOD3); //100%
+            else if (level >= 28)
+                RefreshAura(TASTE_FOR_BLOOD2); //66%
+            else if (level >= 25)
+                RefreshAura(TASTE_FOR_BLOOD1); //33%
+            if (level >= 30)
+                RefreshAura(BLOOD_CRAZE3);
+            else if (level >= 25)
+                RefreshAura(BLOOD_CRAZE2);
+            else if (level >= 20)
+                RefreshAura(BLOOD_CRAZE1);
+            //BloodRage Absorb
+            if (level >= 60)
+                RefreshAura(WARRIOR_T10_4P);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case ENRAGED_REGENERATION_1:
+                case BLOODRAGE_1:
+                case BERSERKERRAGE_1:
+                case BATTLESHOUT_1:
+                //case SWEEPING_STRIKES_1: //unable - need stance
+                case RETALIATION_1:
+                case RECKLESSNESS_1:
+                case DEATHWISH_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+/*tmrs*/uint32 stancetimer, ragetimer, ragetimer2;
+/*misc*/uint32 rage;
+/*misc*/float rageIncomeMult, rageLossMult;
+/*Chck*/bool battleStance, defensiveStance, berserkerStance, UNRELENTING_ASSAULT, VICTORIOUS;
+
+        enum WarriorBaseSpells
+        {
+            //CHALLENGING_SHOUT_1                     = 1161,
+            INTIMIDATING_SHOUT_1                    = 5246,
+            ENRAGED_REGENERATION_1                  = 55694,
+            CHARGE_1                                = 11578,
+            OVERPOWER_1                             = 7384,
+            TAUNT_1                                 = 355,
+            //DISARM_1                                = 676,
+            BLOODRAGE_1                             = 2687,
+            BERSERKERRAGE_1                         = 18499,
+            INTERCEPT_1                             = 20252,
+            CLEAVE_1                                = 845,
+            HAMSTRING_1                             = 1715,
+            INTERVENE_1                             = 3411,
+            WHIRLWIND_1                             = 1680,
+            BLADESTORM_1                            = 46924,
+            BATTLESHOUT_1                           = 6673,
+            REND_1                                  = 772,
+            EXECUTE_1                               = 5308,
+            PUMMEL_1                                = 6552,
+            MORTALSTRIKE_1                          = 12294,
+            SLAM_1                                  = 1464,
+            SUNDER_1                                = 7386,
+            SWEEPING_STRIKES_1                      = 12328,
+            BATTLESTANCE_1                          = 2457,
+            DEFENSIVESTANCE_1                       = 71,
+            BERSERKERSTANCE_1                       = 2458,
+            RECKLESSNESS_1                          = 13847,//1719, original warrior spell
+            RETALIATION_1                           = 22857,//20230, original warrior spell
+            DEATHWISH_1                             = 12292,
+            VICTORY_RUSH_1                          = 34428
+        };
+        enum WarriorPassives
+        {
+        //Talents
+            WC1  /*WRECKING CREW1*/                 = 46867,
+            WC2  /*WRECKING CREW2*/                 = 56611,
+            WC3  /*WRECKING CREW3*/                 = 56612,
+            WC4  /*WRECKING CREW4*/                 = 56613,
+            WC5  /*WRECKING CREW5*/                 = 56614,
+            FLURRY1                                 = 16256,
+            FLURRY2                                 = 16281,
+            FLURRY3                                 = 16282,
+            FLURRY4                                 = 16283,
+            FLURRY5                                 = 16284,
+            SWORD_SPEC1                             = 12281,
+            SWORD_SPEC2                             = 12812,
+            SWORD_SPEC3                             = 12813,
+            SWORD_SPEC4                             = 12814,
+            SWORD_SPEC5                             = 12815,
+            BLOOD_CRAZE1                            = 16487,
+            BLOOD_CRAZE2                            = 16489,
+            BLOOD_CRAZE3                            = 16492,
+            TASTE_FOR_BLOOD1                        = 56636,
+            TASTE_FOR_BLOOD2                        = 56637,
+            TASTE_FOR_BLOOD3                        = 56638,
+            UNRELENTING_ASSAULT1                    = 46859,
+            UNRELENTING_ASSAULT2                    = 46860,
+            TRAUMA1                                 = 46854,
+            TRAUMA2                                 = 46855,
+            BLOOD_FRENZY                            = 29859,
+            RAMPAGE                                 = 29801,
+            SECOND_WIND                             = 29838,//rank 2
+            TOUGHNESS                               = 12764,//rank 5
+            IMP_HAMSTRING                           = 23695,//rank 3
+        //other
+            WARRIOR_T10_4P                          = 70844
+        };
+        enum WarriorSpecial
+        {
+            TASTE_FOR_BLOOD_BUFF                    = 60503,
+            LAMBS_TO_THE_SLAUGHTER_BUFF             = 84586,
+            UNRELENTING_ASSAULT_SPELL               = 65925,//64849
+            VICTORIOUS_SPELL                        = 32216,
+            //COLOSSUS_SMASH_EFFECT                   = 108126,
+            SWORD_SPECIALIZATION_TRIGGERED          = 16459,
+
+            BLESSING_OF_MIGHT_1                     = 19740,
+            GREATER_BLESSING_OF_MIGHT_1             = 25782
+        };
+    };
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/game/AI/NpcBots/botcommands.cpp b/src/server/game/AI/NpcBots/botcommands.cpp
new file mode 100644
index 0000000..594e646
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommands.cpp
@@ -0,0 +1,660 @@
+/*
+Name: script_bot_commands
+%Complete: ???
+Comment: Npcbot related commands
+Category: commandscripts/custom/
+*/
+
+#include "bot_ai.h"
+#include "bothelper.h"
+#include "Chat.h"
+#include "Config.h"
+#include "Group.h"
+#include "Language.h"
+#include "Player.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+#include "PlayerbotAI.h"
+
+class script_bot_commands : public CommandScript
+{
+public:
+    script_bot_commands() : CommandScript("script_bot_commands") { }
+
+    std::vector<ChatCommand> GetCommands() const
+    {
+        static std::vector<ChatCommand> npcbotCommandTable =
+        {
+            { "add",        rbac::RBAC_PERM_COMMAND_NPCBOT_ADD,     false, &HandleNpcBotAddCommand,             ""},
+            { "remove",     rbac::RBAC_PERM_COMMAND_NPCBOT_REMOVE,  false, &HandleNpcBotRemoveCommand,          ""},
+            { "reset",      rbac::RBAC_PERM_COMMAND_NPCBOT_RESET,   false, &HandleNpcBotResetCommand,           ""},
+            { "command",    rbac::RBAC_PERM_COMMAND_NPCBOT_CMD,     false, &HandleNpcBotCommandCommand,         ""},
+            { "distance",   rbac::RBAC_PERM_COMMAND_NPCBOT_DIST,    false, &HandleNpcBotDistanceCommand,        ""},
+            { "info",       rbac::RBAC_PERM_COMMAND_NPCBOT_INFO,    false, &HandleNpcBotInfoCommand,            ""},
+            { "helper",     rbac::RBAC_PERM_COMMAND_NPCBOT_HELPER,  false, &HandleBotHelperCommand,             ""},
+            { "revive",     rbac::RBAC_PERM_COMMAND_NPCBOT_REVIVE,  false, &HandleNpcBotReviveCommand,          ""},
+        };
+        static std::vector<ChatCommand> commandTable =
+        {
+            { "bot",        SEC_PLAYER,                             false, &HandlePlayerbotCommand,             ""},
+            { "npcbot",     rbac::RBAC_PERM_COMMAND_NPCBOT,         false, NULL,                                "", npcbotCommandTable},
+        };
+        return commandTable;
+    }
+
+    //static bool HandleReloadEquipsCommand(ChatHandler* handler, const char* /*args*/)
+    //{
+    //    sLog->outInfo(LOG_FILTER_GENERAL, "Re-Loading Creature Equips...");
+    //    sObjectMgr->LoadEquipmentTemplates();
+    //    handler->SendGlobalGMSysMessage("DB table `creature_equip_template` (creature equipment) reloaded.");
+    //    return true;
+    //}
+    static bool HandlePlayerbotCommand(ChatHandler* handler, const char* args)
+    {
+        if (!handler->GetSession())
+        {
+            handler->PSendSysMessage("You may only add bots from an active session");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!*args)
+        {
+            handler->PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* player = handler->GetSession()->GetPlayer();
+
+        char* cmd = strtok ((char*)args, " ");
+        if (!cmd)
+        {
+            handler->PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        std::string cmdStr = cmd;
+
+        if (cmdStr.compare("tele") == 0 || cmdStr.compare("teleport") == 0 || cmdStr.compare("summ") == 0 || cmdStr.compare("summon") == 0)
+        {
+            if (handler->GetSession()->m_playerBots.empty())
+            {
+                handler->PSendSysMessage("You Have No Playerbots!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            PlayerbotChatHandler ch(player->GetSession());
+            for (PlayerBotMap::const_iterator itr = handler->GetSession()->GetPlayerBotsBegin(); itr != handler->GetSession()->GetPlayerBotsEnd(); ++itr)
+            {
+                Player* botPlayer = itr->second;
+                if (!botPlayer)
+                    continue;
+                ch.teleport(*botPlayer);
+                //botPlayer->TeleportTo(*player);
+            }
+            return true;
+        }
+        char* charname = strtok (NULL, " ");
+        if (!charname)
+        {
+            handler->PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        std::string charnameStr = charname;
+
+        ObjectGuid guid;
+
+       if (charnameStr.compare("all") != 0)
+       {
+           if (!normalizePlayerName(charnameStr))
+               return false;
+
+           guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+           if (guid == 0 || (guid == handler->GetSession()->GetPlayer()->GetGUID()))
+           {
+               handler->PSendSysMessage(LANG_PLAYER_NOT_FOUND);
+               handler->SetSentErrorMessage(true);
+               return false;
+           }
+
+           ObjectGuid::LowType accountId = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+           if (accountId != handler->GetSession()->GetAccountId())
+           {
+               handler->PSendSysMessage("You may only add bots from the same account.");
+               handler->SetSentErrorMessage(true);
+               return false;
+           }
+       }
+
+        if (cmdStr.compare("add") == 0 || cmdStr.compare("login") == 0)
+        {
+            if (charnameStr.compare("all") == 0)
+            {
+                std::list<std::string>* names;
+                names = handler->GetSession()->GetPlayer()->GetCharacterList();
+                std::list<std::string>::iterator iter,next;
+                for (iter = names->begin(); iter != names->end(); iter++)
+                {
+                    std::stringstream arg;
+                    arg << "add " << (*iter).c_str();
+                    HandlePlayerbotCommand(handler, arg.str().c_str());
+                }
+                handler->PSendSysMessage("Bots added successfully.");
+                return true;
+            }
+            else
+            {
+                guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+                if (player->GetSession()->GetPlayerBot(guid) != NULL)
+                {
+                    handler->PSendSysMessage("Bot already exists in world.");
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+                player->GetSession()->AddPlayerBot(guid);
+            }
+        }
+        else if (cmdStr.compare("remove") == 0 || cmdStr.compare("logout") == 0)
+        {
+            if (charnameStr.compare("all") == 0)
+            {
+                std::list<std::string>* names = new std::list<std::string>;
+                for (PlayerBotMap::const_iterator iter = handler->GetSession()->GetPlayerBotsBegin(); iter != handler->GetSession()->GetPlayerBotsEnd(); ++iter)
+                {
+                    names->push_back(iter->second->GetName());
+                }
+                std::list<std::string>::iterator iter, next;
+                for (iter = names->begin(); iter != names->end(); iter++)
+                {
+                    std::stringstream arg;
+                    arg << "remove " << (*iter).c_str();
+                    HandlePlayerbotCommand(handler, arg.str().c_str());
+                }
+                return true;
+            }
+            else
+            {
+                guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+                if (!handler->GetSession()->GetPlayerBot(guid))
+                {
+                    handler->PSendSysMessage("Bot can not be removed because bot does not exist in world.");
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+                handler->GetSession()->LogoutPlayerBot(guid);
+                handler->PSendSysMessage("Bot removed successfully.");
+                return true;
+            }
+        }
+        else if (cmdStr == "co" || cmdStr == "combatorder")
+        {
+            Unit* target = NULL;
+            char* orderChar = strtok(NULL, " ");
+            if (!orderChar || handler->GetSession()->m_playerBots.empty())
+            {
+                handler->PSendSysMessage("|cffff0000Syntax error:|cffffffff .bot co <botName> <order=reset|tank|assist|heal|protect> [targetPlayer]");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            std::string orderStr = orderChar;
+            if (orderStr == "protect" || orderStr == "assist")
+            {
+                char* targetChar = strtok(NULL, " ");
+                ObjectGuid targetGUID = handler->GetSession()->GetPlayer()->GetTarget();
+                if (!targetChar && !targetGUID)
+                {
+                    handler->PSendSysMessage("|cffff0000Combat orders protect and assist expect a target either by selection or by giving target player in command string!");
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+                if (targetChar)
+                {
+                    std::string targetStr = targetChar;
+                    targetGUID = sObjectMgr->GetPlayerGUIDByName(targetStr.c_str());
+                }
+                target = ObjectAccessor::GetUnit(*handler->GetSession()->GetPlayer(), targetGUID);
+                if (!target)
+                {
+                    handler->PSendSysMessage("|cffff0000Invalid target for combat order protect or assist!");
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+            }
+            //if (handler->GetSession()->GetPlayerBot(guid) == NULL)
+            //{
+            //    handler->PSendSysMessage("|cffff0000Bot can not receive combat order because bot does not exist in world.");
+            //    handler->SetSentErrorMessage(true);
+            //    return false;
+            //}
+            //if (mgr)
+            PlayerBotMap::const_iterator itr;
+            for (itr = handler->GetSession()->GetPlayerBotsBegin(); itr != handler->GetSession()->GetPlayerBotsEnd(); ++itr)
+                if (Player* bot = ObjectAccessor::GetPlayer(*player, itr->first))
+                    bot->GetPlayerbotAI()->SetCombatOrderByStr(orderStr, target);
+        }
+        return true;
+    }
+
+    static bool HandleBotHelperCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        handler->SetSentErrorMessage(true);
+        if (/*player->IsInCombat() ||*/
+            player->isDead() ||
+            !player->IsAlive() ||
+            player->IsInFlight() ||
+            player->IsCharmed() ||
+            bot_ai::CCed(player))
+        {
+            handler->SendSysMessage("You cannot do this right now");
+            return false;
+        }
+        //close current menu
+        player->PlayerTalkClass->SendCloseGossip();
+        if (player->GetTrader())
+            player->GetSession()->SendCancelTrade();
+
+        BotHelper* hlpr = player->GetBotHelper();
+        if (!hlpr)
+        {
+            hlpr = new BotHelper(player);
+            player->SetBotHelper(hlpr);
+        }
+        return hlpr->OnGossipHello(player);
+    }
+
+    static bool HandleNpcBotInfoCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->GetTarget())
+        {
+            handler->PSendSysMessage(".npcbot info");
+            handler->PSendSysMessage("Lists NpcBots count of each class owned by selected player. You can use this on self and your party members");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* master = owner->GetSelectedPlayer();
+        if (!master || (owner->GetGroup() ? !owner->GetGroup()->IsMember(master->GetGUID()) : master->GetGUID() != owner->GetGUID()))
+        {
+            handler->PSendSysMessage("You should select self or one of your party members.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!master->HaveBot())
+        {
+            handler->PSendSysMessage("%s has no NpcBots!", master->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Listing NpcBots for %s", master->GetName().c_str());
+        handler->PSendSysMessage("Owned NpcBots: %u", master->GetNpcBotsCount());
+        for (uint8 i = CLASS_WARRIOR; i != MAX_CLASSES; ++i)
+        {
+            uint8 count = 0;
+            uint8 alivecount = 0;
+            for (uint8 pos = 0; pos != master->GetMaxNpcBots(); ++pos)
+            {
+                if (Creature* cre = master->GetBotMap(pos)->_Cre())
+                {
+                    if (cre->GetBotClass() == i)
+                    {
+                        ++count;
+                        if (cre->IsAlive())
+                            ++alivecount;
+                    }
+                }
+            }
+            char const* bclass;
+            switch (i)
+            {
+            case CLASS_WARRIOR:         bclass = "Warriors";        break;
+            case CLASS_PALADIN:         bclass = "Paladins";        break;
+            case CLASS_MAGE:            bclass = "Mages";           break;
+            case CLASS_PRIEST:          bclass = "Priests";         break;
+            case CLASS_WARLOCK:         bclass = "Warlocks";        break;
+            case CLASS_DRUID:           bclass = "Druids";          break;
+            case CLASS_DEATH_KNIGHT:    bclass = "Death Knights";    break;
+            case CLASS_ROGUE:           bclass = "Rogues";          break;
+            case CLASS_SHAMAN:          bclass = "Shamans";         break;
+            case CLASS_HUNTER:          bclass = "Hunters";         break;
+            default:                    bclass = "Unknown Class";   break;
+            }
+            if (count > 0)
+                handler->PSendSysMessage("%s: %u (alive: %u)", bclass, count, alivecount);
+        }
+        return true;
+    }
+
+    static bool HandleNpcBotDistanceCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            if (owner->HaveBot())
+            {
+                handler->PSendSysMessage("bot follow distance is %u", owner->GetBotFollowDist());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage(".npcbot distance");
+            handler->PSendSysMessage("Sets 'distance to target' at which bots will follow you");
+            handler->PSendSysMessage("if set to 0, bots will not attack anything unless you point them");
+            handler->PSendSysMessage("min: 0, max: 75");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* distance = strtok((char*)args, " ");
+        int8 dist = -1;
+
+        if (distance)
+            dist = (int8)atoi(distance);
+
+        if (dist >= 0 && dist <= 75)
+        {
+            owner->SetBotFollowDist(dist);
+            if (!owner->IsInCombat() && owner->HaveBot())
+            {
+                for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+                {
+                    Creature* cre = owner->GetBotMap(i)->_Cre();
+                    if (!cre || !cre->IsInWorld()) continue;
+                    owner->SendBotCommandState(cre, COMMAND_FOLLOW);
+                }
+            }
+            Group* gr = owner->GetGroup();
+            if (gr && owner->GetMap()->Instanceable() && /*gr->isRaidGroup() &&*/ gr->IsLeader(owner->GetGUID()))
+            {
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (pl && pl->IsInWorld() && pl->GetMap() == owner->GetMap())
+                    {
+                        pl->SetBotFollowDist(dist);
+                        if (!pl->IsInCombat() && pl->HaveBot())
+                        {
+                            for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+                            {
+                                Creature* cre = pl->GetBotMap(i)->_Cre();
+                                if (!cre || !cre->IsInWorld()) continue;
+                                pl->SendBotCommandState(cre, COMMAND_FOLLOW);
+                            }
+                        }
+                    }
+                }
+            }
+            handler->PSendSysMessage("bot follow distance set to %u", dist);
+            return true;
+        }
+        handler->SendSysMessage("follow distance should be between 0 and 75");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotCommandCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            handler->PSendSysMessage(".npcbot command <command>");
+            handler->PSendSysMessage("Forces npcbots to either follow you or hold position.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* command = strtok((char*)args, " ");
+        int8 state = -1;
+        if (!strncmp(command, "s", 2) || !strncmp(command, "st", 3) || !strncmp(command, "stay", 5) || !strncmp(command, "stand", 6))
+            state = COMMAND_STAY;
+        else if (!strncmp(command, "f", 2) || !strncmp(command, "follow", 7) || !strncmp(command, "fol", 4) || !strncmp(command, "fo", 3))
+            state = COMMAND_FOLLOW;
+        if (state >= 0 && owner->HaveBot())
+        {
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature* cre = owner->GetBotMap(i)->_Cre();
+                if (!cre || !cre->IsInWorld()) continue;
+                owner->SendBotCommandState(cre, CommandStates(state));
+            }
+            return true;
+        }
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotRemoveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObjectGuid guid = owner->GetTarget();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot remove");
+            handler->PSendSysMessage("Remove selected npcbots. Select yourself to remove all npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (guid == owner->GetGUID())
+        {
+            if (owner->HaveBot())
+            {
+                for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+                    owner->RemoveBot(owner->GetBotMap(i)->_Guid(), true);
+
+                if (!owner->HaveBot())
+                {
+                    handler->PSendSysMessage("Npcbots successfully removed");
+                    handler->SetSentErrorMessage(true);
+                    return true;
+                }
+                handler->PSendSysMessage("Some npcbots were not removed!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage("Npcbots are not found!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* cre = ObjectAccessor::GetCreature(*owner, guid);
+        if (cre && cre->GetIAmABot())
+        {
+            Player* master = cre->GetBotOwner();
+            if (!master || (master->GetGUID() != owner->GetGUID()))
+            {
+                handler->PSendSysMessage("You can only remove your own bots");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            uint8 pos = master->GetNpcBotSlot(guid);
+            master->RemoveBot(cre->GetGUID(), true);
+            if (master->GetBotMap(pos)->_Cre() == NULL)
+            {
+                handler->PSendSysMessage("NpcBot successfully removed");
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->PSendSysMessage("NpcBot was NOT removed for some stupid reason!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        handler->PSendSysMessage("You should select self or your npcbot!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotResetCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Player* master = NULL;
+        bool all = false;
+        ObjectGuid guid = owner->GetTarget();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot reset");
+            handler->PSendSysMessage("Reset selected npcbot, or all npcbots if used on self");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (guid.IsPlayer())
+        {
+            master = owner;
+            all = true;
+        }
+        else if (guid.IsCreature())
+        {
+            if (Creature* cre = ObjectAccessor::GetCreature(*owner, guid))
+                master = cre->GetBotOwner();
+        }
+        if (master && master->GetGUID() == owner->GetGUID())
+        {
+            if (!master->HaveBot())
+            {
+                handler->PSendSysMessage("Npcbots are not found!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            {
+                if (all)
+                    master->RemoveBot(master->GetBotMap(i)->_Guid());
+                else if (master->GetBotMap(i)->_Guid() == guid)
+                {
+                    master->RemoveBot(guid);
+                    break;
+                }
+            }
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot reset");
+        handler->PSendSysMessage("Reset selected npcbot. Cannot be used in combat");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+    //For debug purposes only
+    static bool HandleNpcBotReviveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (owner->InBattleground())
+        {
+            handler->PSendSysMessage("Bot revival is disabled in pvp matches");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!owner->IsInFlight() && owner->HaveBot())
+        {
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature* bot = owner->GetBotMap(i)->_Cre();
+                if (bot && !bot->IsAlive())
+                {
+                    owner->SetBot(bot);
+                    owner->CreateBot(0, 0, 0, true);
+                }
+            }
+            handler->PSendSysMessage("NpcBots revived");
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot revive");
+        handler->PSendSysMessage("Revive your npcbots if you are all hopelessly dead");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotAddCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        ObjectGuid sel = owner->GetTarget();
+        if (!*args || sel != owner->GetGUID())
+        {
+            handler->PSendSysMessage(".npcbot add");
+            handler->PSendSysMessage("Allows to create npcbot of given class, you should select yourself");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->RestrictBots())
+        {
+            handler->GetSession()->SendNotification("This place is restricted for NpcBots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->isDead())
+        {
+            owner->GetSession()->SendNotification("You're dead!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetGroup() && owner->GetGroup()->isRaidGroup() && owner->GetGroup()->IsFull())
+        {
+            handler->PSendSysMessage("Group is full, aborted");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetNpcBotsCount() >= owner->GetMaxNpcBots())
+        {
+            handler->PSendSysMessage("NpcBots limit exceed");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* bclass = strtok((char*)args, " ");
+        uint8 botclass = CLASS_NONE;
+
+        if (!strncmp(bclass, "deathknight", 12) || !strncmp(bclass, "deathk", 7) || !strncmp(bclass, "death", 6) || !strncmp(bclass, "deat", 5) ||
+            !strncmp(bclass, "dea", 4) || !strncmp(bclass, "dk", 3) || !strncmp(bclass, "de", 3))
+            botclass = CLASS_DEATH_KNIGHT;
+        else if (!strncmp(bclass, "druid", 6) || !strncmp(bclass, "dru", 4) || !strncmp(bclass, "dr", 3))
+            botclass = CLASS_DRUID;
+        else if (!strncmp(bclass, "hunter", 7) || !strncmp(bclass, "hunt", 5) || !strncmp(bclass, "hun", 4) || !strncmp(bclass, "hu", 3))
+            botclass = CLASS_HUNTER;
+        else if (!strncmp(bclass, "mage", 5) || !strncmp(bclass, "ma", 3))
+            botclass = CLASS_MAGE;
+        else if (!strncmp(bclass, "paladin", 8) || !strncmp(bclass, "pal", 4) || !strncmp(bclass, "pa", 3))
+            botclass = CLASS_PALADIN;
+        else if (!strncmp(bclass, "priest", 7) || !strncmp(bclass, "pri", 4) || !strncmp(bclass, "pr", 3))
+            botclass = CLASS_PRIEST;
+        else if (!strncmp(bclass, "rogue", 6) || !strncmp(bclass, "rog", 4) || !strncmp(bclass, "ro", 3))
+            botclass = CLASS_ROGUE;
+        else if (!strncmp(bclass, "shaman", 7) || !strncmp(bclass, "sham", 5) || !strncmp(bclass, "sha", 4) || !strncmp(bclass, "sh", 3))
+            botclass = CLASS_SHAMAN;
+        else if (!strncmp(bclass, "warlock", 8) || !strncmp(bclass, "warl", 5) || !strncmp(bclass, "lock", 5))
+            botclass = CLASS_WARLOCK;
+        else if (!strncmp(bclass, "warrior", 8) || !strncmp(bclass, "warr", 5))
+            botclass = CLASS_WARRIOR;
+
+        if (botclass == CLASS_NONE)
+        {
+            handler->PSendSysMessage("Wrong bot class");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        else if (botclass == CLASS_DEATH_KNIGHT && owner->getLevel() < 55)
+        {
+            handler->PSendSysMessage("Death Knights will not join you until you reach level 55...");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint8 bots = owner->GetNpcBotsCount();
+        owner->CreateNPCBot(botclass);
+        owner->RefreshBot(0);
+        if (owner->GetNpcBotsCount() > bots)
+        {
+            if (owner->IsInCombat())
+                handler->PSendSysMessage("NpcBot successfully created (%s). Will appear out of combat", owner->GetName().c_str());
+            else
+                handler->PSendSysMessage("NpcBot successfully created (%s).", owner->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage("NpcBot is NOT created for some reason!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+};
+
+void AddSC_script_bot_commands()
+{
+    new script_bot_commands();
+}
diff --git a/src/server/game/AI/NpcBots/botgiver.cpp b/src/server/game/AI/NpcBots/botgiver.cpp
new file mode 100644
index 0000000..6aaea74
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botgiver.cpp
@@ -0,0 +1,340 @@
+#include "ScriptMgr.h"
+#include "ScriptedGossip.h"
+#include "ObjectMgr.h"
+#include "Config.h"
+#include "Group.h"
+#include "Player.h"
+#include "WorldSession.h"
+
+/*
+script_bot_giver (reworked by Graff onlysuffering@mail.ru)
+Complete - ???
+Category - creature_script/bots
+*/
+const uint8 GroupIcons[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080,
+};
+class script_bot_giver : public CreatureScript
+{
+public:
+    script_bot_giver() : CreatureScript("script_bot_giver") { }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        switch (sender)
+        {
+            case 6006: SendCreateNPCBotMenu(player, creature, action); break;
+            case 6001: SendCreateNPCBot(player, creature, action); break;
+            case 6002: SendCreatePlayerBotMenu(player, creature, action); break;
+            case 6003: SendCreatePlayerBot(player, creature, action); break;
+
+            case 6004: SendRemovePlayerBotMenu(player, creature, action); break;
+            case 6005: SendRemovePlayerBot(player, creature, action); break;
+            case 6007: SendRemoveNPCBotMenu(player, creature, action); break;
+            case 6008: SendRemoveNPCBot(player, creature, action); break;
+
+            case 6009: SendBotHelpWhisper(player, creature, action); break;
+        }
+        return true;
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        WorldSession* session = player->GetSession();
+        uint8 count = 0;
+        uint8 maxcount = sConfigMgr->GetIntDefault("Bot.MaxPlayerbots", 9);
+        bool allowPBots = sConfigMgr->GetBoolDefault("Bot.EnablePlayerBots", true);
+        bool allowNBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true);
+
+        for (PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+        {
+            if (count == 0)
+                player->ADD_GOSSIP_ITEM(0, "Abandon my Player", 6004, GOSSIP_ACTION_INFO_DEF + 100);
+            ++count;
+        }
+        if (count < maxcount && allowPBots)
+            player->ADD_GOSSIP_ITEM(0, "Recruit a Player", 6002, GOSSIP_ACTION_INFO_DEF + 1);
+
+        maxcount = player->GetMaxNpcBots();
+        if (player->HaveBot())
+        {
+            count = player->GetNpcBotsCount();
+            if (count > 0)
+                player->ADD_GOSSIP_ITEM(0, "Abandon my Minion", 6007, GOSSIP_ACTION_INFO_DEF + 101);
+            if (count < maxcount && allowNBots)
+                player->ADD_GOSSIP_ITEM(0, "Recruit a Minion", 6006, GOSSIP_ACTION_INFO_DEF + 2);
+        }
+        else if (allowNBots)
+            player->ADD_GOSSIP_ITEM(0, "Recruit a Minion", 6006, GOSSIP_ACTION_INFO_DEF + 2);
+
+        player->ADD_GOSSIP_ITEM(0, "Tell me about these bots", 6009, GOSSIP_ACTION_INFO_DEF + 200);
+
+        player->PlayerTalkClass->SendGossipMenu(8446, creature->GetGUID());
+        return true;
+    }
+
+    static void SendCreatePlayerBot(Player* player, Creature*  /*creature*/, uint32 action)
+    {
+        std::list<std::string>* names = player->GetCharacterList();
+        if (names == NULL || names->empty())
+        {
+            player->CLOSE_GOSSIP_MENU();
+            return;
+        }
+
+        int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+
+        for (std::list<std::string>::iterator iter = names->begin(); iter != names->end(); iter++)
+        {
+            if (x == 0)
+            {
+                ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName((*iter).c_str());
+                if (player->GetSession()->GetPlayerBot(guid) != NULL)
+                    return;
+                player->GetSession()->AddPlayerBot(guid);
+            }
+            else
+            {
+                if (x == 1)
+                {
+                    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName((*iter).c_str());
+                    if (player->GetSession()->GetPlayerBot(guid) != NULL)
+                        return;
+                    player->GetSession()->AddPlayerBot(guid);
+                    break;
+                }
+                --x;
+            }
+        }
+        player->CLOSE_GOSSIP_MENU();
+    }
+
+    static void SendCreatePlayerBotMenu(Player* player, Creature* creature, uint32 /*action*/)
+    {
+        std::list<std::string>* names = player->GetCharacterList();
+        if (names == NULL || names->empty())
+        {
+            player->CLOSE_GOSSIP_MENU();
+            return;
+        }
+
+        player->PlayerTalkClass->ClearMenus();
+        player->ADD_GOSSIP_ITEM(9, "ADD ALL" , 6003, GOSSIP_ACTION_INFO_DEF + 1);
+        int8 x = 2;
+
+        for (std::list<std::string>::iterator iter = names->begin(); iter != names->end(); iter++)
+        {
+            player->ADD_GOSSIP_ITEM(9, (*iter).c_str() , 6003, GOSSIP_ACTION_INFO_DEF + x);
+            ++x;
+        }
+        player->PlayerTalkClass->SendGossipMenu(8446, creature->GetGUID());
+    } //end SendCreatePlayerBotMenu
+
+    static void SendRemovePlayerBotAll(Player* player, Creature* creature)
+    {
+        for (int8 x = 2; x<=10; x++ )
+        {
+            SendRemovePlayerBot(player, creature, GOSSIP_ACTION_INFO_DEF + 2);
+        }
+    }
+
+    static void SendRemoveNPCBot(Player* player, Creature*  /*creature*/, uint32 action)
+    {
+        int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+        if (x == 0)
+        {
+            player->CLOSE_GOSSIP_MENU();
+            for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+            return;
+        }
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+        {
+            if (x == 1 && player->GetBotMap(i)->_Cre())
+            {
+                player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+                break;
+            }
+            --x;
+        }
+        player->CLOSE_GOSSIP_MENU();
+    }
+
+    static void SendRemovePlayerBot(Player* player, Creature* creature, uint32 action)
+    {
+        int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+
+        if (x == 0)
+        {
+            SendRemovePlayerBotAll(player, creature);
+            return;
+        }
+
+        WorldSession* session = player->GetSession();
+        for (PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+        {
+            if (x == 1 && itr->second)
+            {
+                session->LogoutPlayerBot(itr->second->GetGUID());
+                break;
+            }
+            --x;
+        }
+        player->CLOSE_GOSSIP_MENU();
+    } //end SendRemovePlayerBot
+
+    static void SendRemovePlayerBotMenu(Player* player, Creature* creature, uint32 /*action*/)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        player->ADD_GOSSIP_ITEM(9, "REMOVE ALL", 6005, GOSSIP_ACTION_INFO_DEF + 1);
+
+        uint8 x = 2;
+        WorldSession* session = player->GetSession();
+        for (PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+        {
+            Player* bot = itr->second;
+            player->ADD_GOSSIP_ITEM(9, bot->GetName(), 6005, GOSSIP_ACTION_INFO_DEF + x);
+            ++x;
+        }
+        player->PlayerTalkClass->SendGossipMenu(8446, creature->GetGUID());
+    } //end SendRemovePlayerBotMenu
+
+    static void SendRemoveNPCBotMenu(Player* player, Creature* creature, uint32 /*action*/)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        if (player->GetNpcBotsCount() == 1)
+        {
+            for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+            player->CLOSE_GOSSIP_MENU();
+            return;
+        }
+        player->ADD_GOSSIP_ITEM(9, "REMOVE ALL", 6008, GOSSIP_ACTION_INFO_DEF + 1);
+
+        uint8 x = 2;
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = player->GetBotMap(i)->_Cre();
+            if (!bot) continue;
+            player->ADD_GOSSIP_ITEM(9, bot->GetName(), 6008, GOSSIP_ACTION_INFO_DEF + x);
+            ++x;
+        }
+        player->PlayerTalkClass->SendGossipMenu(8446, creature->GetGUID());
+    }
+
+    static void SendCreateNPCBot(Player* player, Creature*  /*creature*/, uint32 action)
+    {
+        uint8 bot_class = 0;
+        if (action == GOSSIP_ACTION_INFO_DEF + 1)//"Back"
+        {
+            player->CLOSE_GOSSIP_MENU();
+            return;
+        }
+        else if (action == GOSSIP_ACTION_INFO_DEF + 2)
+            bot_class = CLASS_WARRIOR;
+        //else if (action == GOSSIP_ACTION_INFO_DEF + 3)
+        //    bot_class = CLASS_HUNTER;
+        else if (action == GOSSIP_ACTION_INFO_DEF + 4)
+            bot_class = CLASS_PALADIN;
+        //else if (action == GOSSIP_ACTION_INFO_DEF + 5)
+        //    bot_class = CLASS_SHAMAN;
+        else if (action == GOSSIP_ACTION_INFO_DEF + 6)
+            bot_class = CLASS_ROGUE;
+        else if (action == GOSSIP_ACTION_INFO_DEF + 7)
+            bot_class = CLASS_DRUID;
+        else if (action == GOSSIP_ACTION_INFO_DEF + 8)
+            bot_class = CLASS_MAGE;
+        else if (action == GOSSIP_ACTION_INFO_DEF + 9)
+            bot_class = CLASS_PRIEST;
+        else if (action == GOSSIP_ACTION_INFO_DEF + 10)
+            bot_class = CLASS_WARLOCK;
+        //else if (action == GOSSIP_ACTION_INFO_DEF + 11)
+        //    bot_class = CLASS_DEATH_KNIGHT;
+
+        if (bot_class != 0)
+            player->CreateNPCBot(bot_class);
+        player->CLOSE_GOSSIP_MENU();
+        return;
+    }
+
+    static void SendCreateNPCBotMenu(Player* player, Creature* creature, uint32 /*action*/)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        player->ADD_GOSSIP_ITEM(9, "Recruit a Warrior", 6001, GOSSIP_ACTION_INFO_DEF + 2);
+        //player->ADD_GOSSIP_ITEM(9, "Recruit a Hunter", 6001, GOSSIP_ACTION_INFO_DEF + 3);
+        player->ADD_GOSSIP_ITEM(9, "Recruit a Paladin", 6001, GOSSIP_ACTION_INFO_DEF + 4);
+        //player->ADD_GOSSIP_ITEM(9, "Recruit a Shaman", 6001, GOSSIP_ACTION_INFO_DEF + 5);
+        player->ADD_GOSSIP_ITEM(9, "Recruit a Rogue", 6001, GOSSIP_ACTION_INFO_DEF + 6);
+        player->ADD_GOSSIP_ITEM(3, "Recruit a Druid", 6001, GOSSIP_ACTION_INFO_DEF + 7);
+        player->ADD_GOSSIP_ITEM(3, "Recruit a Mage", 6001, GOSSIP_ACTION_INFO_DEF + 8);
+        player->ADD_GOSSIP_ITEM(3, "Recruit a Priest", 6001, GOSSIP_ACTION_INFO_DEF + 9);
+        player->ADD_GOSSIP_ITEM(3, "Recruit a Warlock", 6001, GOSSIP_ACTION_INFO_DEF + 10);
+        //player->ADD_GOSSIP_ITEM(9, "Recruit a Death Knight", 1, GOSSIP_ACTION_INFO_DEF + 11);
+        player->PlayerTalkClass->SendGossipMenu(8446, creature->GetGUID());
+    }
+
+    static void SendBotHelpWhisper(Player* player, Creature* creature, uint32 /*action*/)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        //Basic
+        std::string msg1 = "To see list of Playerbot commands whisper 'help' to one of your playerbots";
+        std::string msg2 = "To see list of available npcbot commands type .npcbot or .npcb";
+        std::string msg3 = "You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan";
+        creature->Whisper(msg1.c_str(), LANG_UNIVERSAL, player);
+        creature->Whisper(msg2.c_str(), LANG_UNIVERSAL, player);
+        creature->Whisper(msg3.c_str(), LANG_UNIVERSAL, player);
+        //Heal Icons
+        uint8 mask = sConfigMgr->GetIntDefault("Bot.HealTargetIconsMask", 8);
+        std::string msg4 = "";
+        if (mask == 255)
+        {
+            msg4 = "If you want your npcbots to heal someone out of your party set any raid target icon on them";
+            creature->Whisper(msg4.c_str(), LANG_UNIVERSAL, player);
+        }
+        else if (mask != 0)
+        {
+            msg4 = "If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ";
+            std::string iconrow = "";
+            uint8 count = 0;
+            for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            {
+                if (mask & GroupIcons[i])
+                {
+                    if (count != 0)
+                        iconrow += ", ";
+                    ++count;
+                    switch (i)
+                    {
+                        case 0: iconrow += "star"; break;
+                        case 1: iconrow += "circle"; break;
+                        case 2: iconrow += "diamond"; break;
+                        case 3: iconrow += "triangle"; break;
+                        case 4: iconrow += "moon"; break;
+                        case 5: iconrow += "square"; break;
+                        case 6: iconrow += "cross"; break;
+                        case 7: iconrow += "skull"; break;
+                        //debug
+                        default: iconrow += "unknown icon"; break;
+                    }
+                }
+            }
+            msg4 += iconrow;
+            creature->Whisper(msg4.c_str(), LANG_UNIVERSAL, player);
+        }
+        //End
+    }
+};
+
+//This function is called when the player clicks an option on the gossip menu
+void AddSC_script_bot_giver()
+{
+    new script_bot_giver();
+}
diff --git a/src/server/game/AI/NpcBots/bothelper.cpp b/src/server/game/AI/NpcBots/bothelper.cpp
new file mode 100644
index 0000000..eaff56f
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bothelper.cpp
@@ -0,0 +1,421 @@
+/*
+Bot Helper by Graff (onlysuffering@gmail.com)
+Type: empty-type player-to-self dialog-like manager for npcbot mod
+Complete: ???
+Category: scripts/custom/bots
+*/
+
+#include "bothelper.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "Language.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "ScriptedCreature.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+
+const uint8 GroupIcons[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+enum HelperActions
+{
+    ACTION_ENABLE                                               = 1,
+    ACTION_DISABLE                                              = 2,
+    ACTION_TOGGLE                                               = 3
+};
+
+enum BotgiverTexIDs
+{
+    ABANDON_MINION                                              = 3,
+    RECRUIT_MINION                                              = 4,
+    HELP_STR                                                    = 5,
+    ADD_ALL                                                     = 6,
+    REMOVE_ALL                                                  = 7,
+    RECRUIT_WARRIOR                                             = 8,
+    RECRUIT_HUNTER                                              = 9,
+    RECRUIT_PALADIN                                             = 10,
+    RECRUIT_SHAMAN                                              = 11,
+    RECRUIT_ROGUE                                               = 12,
+    RECRUIT_DRUID                                               = 13,
+    RECRUIT_MAGE                                                = 14,
+    RECRUIT_PRIEST                                              = 15,
+    RECRUIT_WARLOCK                                             = 16,
+    RECRUIT_DEATH_KNIGHT                                        = 17,
+    ABOUT_BASIC_STR1                                            = 18,
+    ABOUT_BASIC_STR2                                            = 19,
+    //ABOUT_BASIC_STR3                                            = 20,
+    ABOUT_ICONS_STR1                                            = 21,
+    ABOUT_ICONS_STR2                                            = 22,
+    ICON_STRING_STAR                                            = 23,
+    ICON_STRING_CIRCLE                                          = 24,
+    ICON_STRING_DIAMOND                                         = 25,
+    ICON_STRING_TRIANGLE                                        = 26,
+    ICON_STRING_MOON                                            = 27,
+    ICON_STRING_SQUARE                                          = 28,
+    ICON_STRING_CROSS                                           = 29,
+    ICON_STRING_SKULL                                           = 30,
+    ICON_STRING_UNKNOWN                                         = 31,
+    NO_MORE_AVAILABLE                                           = 32,
+    ONE_MORE_AVAILABLE                                          = 33,
+    SOME_MORE_AVAILABLE                                         = 34,
+    ONE_AVAILABLE                                               = 35,
+    SOME_AVAILABLE                                              = 36,
+
+    ENABLE_STRING,
+    DISABLE_STRING,
+    TOGGLE_STRING,
+    BACK_STRING,
+    ALL_STRING,
+    MAX_STRINGS
+};
+
+enum HelperGossip
+{
+    SENDER_CREATE_NBOT_MENU                                     = 1,
+    SENDER_CREATE_NBOT                                          = 2,
+    SENDER_REMOVE_NBOT_MENU                                     = 7,
+    SENDER_REMOVE_NBOT                                          = 8,
+
+    SENDER_INFO_WHISPER                                         = 9,
+
+    SENDER_MAIN_PAGE,
+    MAX_SENDERS
+};
+
+BotHelper::BotHelper(Player* const master) : _master(master) { }
+BotHelper::~BotHelper() {}
+
+bool BotHelper::OnGossipSelect(Player* player, uint32 sender, uint32 action)
+{
+    switch (sender)
+    {
+        case SENDER_MAIN_PAGE:                          OnGossipHello(player);                              break;
+
+        case SENDER_CREATE_NBOT_MENU:                   SendCreateNPCBotMenu(player, action);               break;
+        case SENDER_CREATE_NBOT:                        SendCreateNPCBot(player, action);                   break;
+        case SENDER_REMOVE_NBOT_MENU:                   SendRemoveNPCBotMenu(player, action);               break;
+        case SENDER_REMOVE_NBOT:                        SendRemoveNPCBot(player, action);                   break;
+
+        case SENDER_INFO_WHISPER:                       SendBotHelpWhisper(player, action);                 break;
+
+        default:
+            break;
+    }
+    return true;
+}
+
+bool BotHelper::OnGossipHello(Player* player)
+{
+    player->PlayerTalkClass->ClearMenus(); //in case of return;
+
+    uint8 count = 0;
+
+    uint8 maxNBcount = player->GetMaxNpcBots();
+
+    bool allowNBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true) && !player->RestrictBots();
+
+    std::string tempstr;
+
+    if (player->HaveBot())
+    {
+        count = player->GetNpcBotsCount();
+        if (count > 0)
+        {
+            tempstr = "Abandon my Minion";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(4, 0, GetLocaleStringForTextID(tempstr, ABANDON_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_REMOVE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 4, "", 0);
+        }
+        if (count < maxNBcount && allowNBots)
+        {
+            tempstr = "Recruit a Minion";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(2, 0, GetLocaleStringForTextID(tempstr, RECRUIT_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 2, "", 0);
+        }
+    }
+    else if (allowNBots && maxNBcount != 0)
+    {
+        tempstr = "Recruit a Minion";
+        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(2, 0, GetLocaleStringForTextID(tempstr, RECRUIT_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 2, "", 0);
+    }
+
+    tempstr = "Help";
+    player->PlayerTalkClass->GetGossipMenu().AddMenuItem(6, 0, GetLocaleStringForTextID(tempstr, HELP_STR, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_INFO_WHISPER, GOSSIP_ACTION_INFO_DEF + 6, "", 0);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+    return true;
+}
+
+void BotHelper::SendRemoveNPCBot(Player* player, uint32 action)
+{
+    int8 x = action - GOSSIP_ACTION_INFO_DEF;
+    if (x == 1)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+        return;
+    }
+    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+    {
+        if (!player->GetBotMap(i)->_Cre())
+            continue;
+        if (x == 2)
+        {
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+            break;
+        }
+        --x;
+    }
+    player->CLOSE_GOSSIP_MENU();
+}
+
+void BotHelper::SendRemoveNPCBotMenu(Player* player, uint32 /*action*/)
+{
+    player->PlayerTalkClass->ClearMenus();
+    if (player->GetNpcBotsCount() == 1)
+    {
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+        player->CLOSE_GOSSIP_MENU();
+        return;
+    }
+    std::string tempstr = "REMOVE ALL";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, REMOVE_ALL, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_REMOVE_NBOT, GOSSIP_ACTION_INFO_DEF + 1);
+
+    uint8 x = 2;
+    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+    {
+        Creature* bot = player->GetBotMap(i)->_Cre();
+        if (!bot) continue;
+        player->ADD_GOSSIP_ITEM(9, bot->GetName(), SENDER_REMOVE_NBOT, GOSSIP_ACTION_INFO_DEF + x);
+        ++x;
+    }
+
+    tempstr = "BACK";
+    player->ADD_GOSSIP_ITEM(0, GetLocaleStringForTextID(tempstr, BACK_STRING, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_MAIN_PAGE, GOSSIP_ACTION_INFO_DEF + x);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+}
+
+void BotHelper::SendCreateNPCBot(Player* player, uint32 action)
+{
+    uint8 bot_class = 0;
+    if (action == GOSSIP_ACTION_INFO_DEF + 1)//"Back"
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return;
+    }
+    else if (action == GOSSIP_ACTION_INFO_DEF + 2)
+        bot_class = CLASS_WARRIOR;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 3)
+        bot_class = CLASS_HUNTER;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 4)
+        bot_class = CLASS_PALADIN;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 5)
+        bot_class = CLASS_SHAMAN;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 6)
+        bot_class = CLASS_ROGUE;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 7)
+        bot_class = CLASS_DRUID;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 8)
+        bot_class = CLASS_MAGE;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 9)
+        bot_class = CLASS_PRIEST;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 10)
+        bot_class = CLASS_WARLOCK;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 11)
+        bot_class = CLASS_DEATH_KNIGHT;
+
+    if (bot_class != 0)
+        player->CreateNPCBot(bot_class);
+    player->CLOSE_GOSSIP_MENU();
+    return;
+}
+
+void BotHelper::SendCreateNPCBotMenu(Player* player, uint32 /*action*/)
+{
+    std::string cost = player->GetNpcBotCostStr();
+    player->PlayerTalkClass->ClearMenus();
+
+    std::string tempstr = "Recruit a Warrior ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_WARRIOR, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 2);
+    tempstr = "Recruit a Hunter ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_HUNTER, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 3);
+    tempstr = "Recruit a Paladin ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_PALADIN, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 4);
+    tempstr = "Recruit a Shaman ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_SHAMAN, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 5);
+    tempstr = "Recruit a Rogue ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_ROGUE, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 6);
+    tempstr = "Recruit a Druid ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_DRUID, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 7);
+    tempstr = "Recruit a Mage ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_MAGE, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 8);
+    tempstr = "Recruit a Priest ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_PRIEST, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 9);
+    tempstr = "Recruit a Warlock ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_WARLOCK, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 10);
+    if (player->getLevel() >= 55)
+    {
+        tempstr = "Recruit a Death Knight ";
+        player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_DEATH_KNIGHT, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 11);
+    }
+
+    std::ostringstream buff;
+    uint8 bots = player->GetNpcBotsCount();
+    uint8 maxNBcount = player->GetMaxNpcBots();
+    uint32 freeNBSlots = maxNBcount - bots;
+
+    if (freeNBSlots == 0)
+    {
+        tempstr = "no more bots available";
+        buff << GetLocaleStringForTextID(tempstr, NO_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+    }
+    else
+    {
+        buff << freeNBSlots;
+        buff << ' ';
+        if (freeNBSlots == 1)
+        {
+            if (bots == 0)
+            {
+                tempstr = "bot available";
+                buff << GetLocaleStringForTextID(tempstr, ONE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+            else
+            {
+                tempstr = "more bot available";
+                buff << GetLocaleStringForTextID(tempstr, ONE_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+        }
+        else
+        {
+            if (bots == 0)
+            {
+                tempstr = "bots available";
+                buff << GetLocaleStringForTextID(tempstr, SOME_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+            else
+            {
+                tempstr = "more bots available";
+                buff << GetLocaleStringForTextID(tempstr, SOME_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+        }
+    }
+    player->ADD_GOSSIP_ITEM(0, buff.str(), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 12);
+
+    tempstr = "BACK";
+    player->ADD_GOSSIP_ITEM(0, GetLocaleStringForTextID(tempstr, BACK_STRING, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_MAIN_PAGE, GOSSIP_ACTION_INFO_DEF + 13);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+}
+
+void BotHelper::SendBotHelpWhisper(Player* player, uint32 /*action*/)
+{
+    player->CLOSE_GOSSIP_MENU();
+    ChatHandler ch(player->GetSession());
+    //Basic
+    std::string tempstr = "To see list of available npcbot commands type .npcbot or .npcb";
+    std::string msg2 = GetLocaleStringForTextID(tempstr, ABOUT_BASIC_STR2, player->GetSession()->GetSessionDbLocaleIndex());
+    ch.SendSysMessage(msg2.c_str());
+    //Heal Icons
+    uint8 mask = sConfigMgr->GetIntDefault("Bot.HealTargetIconsMask", 8);
+    std::string msg4 = "";
+    if (mask == 255)
+    {
+        tempstr = "If you want your npcbots to heal someone out of your party set any raid target icon on them";
+        msg4 = GetLocaleStringForTextID(tempstr, ABOUT_ICONS_STR1, player->GetSession()->GetSessionDbLocaleIndex());
+        ch.SendSysMessage(msg4.c_str());
+    }
+    else if (mask != 0)
+    {
+        tempstr = "If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ";
+        msg4 = GetLocaleStringForTextID(tempstr, ABOUT_ICONS_STR2, player->GetSession()->GetSessionDbLocaleIndex());
+        std::string iconrow = "";
+        uint8 count = 0;
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+        {
+            if (mask & GroupIcons[i])
+            {
+                if (count != 0)
+                    iconrow += ", ";
+                ++count;
+                switch (i)
+                {
+                    case 0:
+                        tempstr = "star";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_STAR, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 1:
+                        tempstr = "circle";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_CIRCLE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 2:
+                        tempstr = "diamond";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_DIAMOND, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 3:
+                        tempstr = "triangle";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_TRIANGLE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 4:
+                        tempstr = "moon";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_MOON, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 5:
+                        tempstr = "square";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_SQUARE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 6:
+                        tempstr = "cross";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_CROSS, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 7:
+                        tempstr = "skull";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_SKULL, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    default:
+                        tempstr = "unknown icon";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_UNKNOWN, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                }
+            }
+        }
+        msg4 += iconrow;
+        ch.SendSysMessage(msg4.c_str());
+    }
+}
+
+std::string BotHelper::GetLocaleStringForTextID(std::string& textValue, uint32 textId, int32 localeIdx)
+{
+    if (textId >= MAX_STRINGS)
+    {
+        TC_LOG_ERROR("misc", "botgiver:GetLocaleStringForTextID:: unknown text id: %u!", textId);
+        return textValue;
+    }
+
+    if (localeIdx == DEFAULT_LOCALE)
+        return textValue; //use default
+
+    if (localeIdx < 0)
+    {
+        TC_LOG_ERROR("misc", "botgiver:GetLocaleStringForTextID:: unknown locale: %i! Sending default locale text...", localeIdx);
+        return textValue;
+    }
+
+    uint32 idxEntry = MAKE_PAIR32(60000, textId);
+    if (GossipMenuItemsLocale const* no = sObjectMgr->GetGossipMenuItemsLocale(idxEntry))
+        ObjectMgr::GetLocaleString(no->OptionText, localeIdx, textValue);
+    return textValue;
+}
diff --git a/src/server/game/AI/NpcBots/bothelper.h b/src/server/game/AI/NpcBots/bothelper.h
new file mode 100644
index 0000000..1310b4d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bothelper.h
@@ -0,0 +1,32 @@
+#ifndef _BOTHLP_H
+#define _BOTHLP_H
+
+#include "Common.h"
+
+class Player;
+
+class BotHelper
+{
+    public:
+        BotHelper(Player* const master);
+        ~BotHelper();
+
+        Player* GetOwner() const { return _master; }
+
+        static bool OnGossipHello(Player* player);
+        static bool OnGossipSelect(Player* player, uint32 sender, uint32 action);
+
+    private:
+        static void SendRemoveNPCBot(Player* player, uint32 action);
+        static void SendRemoveNPCBotMenu(Player* player, uint32 /*action*/);
+        static void SendCreateNPCBot(Player* player, uint32 action);
+        static void SendCreateNPCBotMenu(Player* player, uint32 /*action*/);
+
+
+        static void SendBotHelpWhisper(Player* player, uint32 /*action*/);
+        static std::string GetLocaleStringForTextID(std::string& textValue, uint32 textId, int32 localeIdx = 0);
+
+        Player* const _master;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotAI.cpp
new file mode 100644
index 0000000..b43467d
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotAI.cpp
@@ -0,0 +1,11882 @@
+/*
+Name:       PlayerBot AI Core by Graff (onlysuffering@gmail.com)
+Converted:  from original blueboy's Playerbots: https://github.com/blueboy/portal/
+Revision:   bbbd930771eb48804f96651f5e15a098b2cecb43
+last merge:
+09-08-2012 blueBoy's Playerbots: e13fb1bd41111f99ad39aa54a0b28751efb4f2cd
+*/
+#include "PlayerbotAI.h"
+#include "Config.h"
+#include "GridNotifiersImpl.h"
+#include "CellImpl.h"
+#include "PlayerbotDeathKnightAI.h"
+#include "PlayerbotDruidAI.h"
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotMageAI.h"
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotPriestAI.h"
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotShamanAI.h"
+#include "PlayerbotWarlockAI.h"
+#include "PlayerbotWarriorAI.h"
+#include "Pet.h"
+#include "Player.h"
+#include "Group.h"
+#include "GroupMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "GossipDef.h"
+#include "AuctionHouseMgr.h"
+#include <iomanip>
+#include "GameEventMgr.h"
+#include "Language.h"
+#include "ScriptMgr.h"
+
+bool PlayerbotChatHandler::revive(Player& botPlayer)
+{
+    botPlayer.ResurrectPlayer(1.0f); botPlayer.SpawnCorpseBones(); botPlayer.SaveToDB(); return true;
+}
+bool PlayerbotChatHandler::teleport(const Player& botPlayer)
+{
+    return HandleSummonCommand(this, botPlayer.GetName().c_str());
+}
+bool PlayerbotChatHandler::teleport(Player &botPlayer, WorldObject &obj)
+{
+    botPlayer.Relocate(obj); return true;
+}
+bool PlayerbotChatHandler::HandleSummonCommand(ChatHandler* handler, char const* args)
+{
+    Player* target;
+    ObjectGuid targetGuid;
+    std::string targetName;
+    if (!handler->extractPlayerTarget((char*)args, &target, &targetGuid, &targetName))
+        return false;
+
+    Player* _player = handler->GetSession()->GetPlayer();
+    if (target == _player || targetGuid == _player->GetGUID())
+    {
+        handler->PSendSysMessage(LANG_CANT_TELEPORT_SELF);
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (target)
+    {
+        std::string nameLink = handler->playerLink(targetName);
+
+        if (target->IsBeingTeleported())
+        {
+            handler->PSendSysMessage(LANG_IS_TELEPORTED, nameLink.c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Map* map = handler->GetSession()->GetPlayer()->GetMap();
+
+        if (map->IsBattlegroundOrArena())
+        {
+            //// only allow if gm mode is on
+            //if (!_player->isGameMaster())
+            //{
+            //    handler->PSendSysMessage(LANG_CANNOT_GO_TO_BG_GM, nameLink.c_str());
+            //    handler->SetSentErrorMessage(true);
+            //    return false;
+            //}
+            // if both players are in different bgs
+            /*else */if (target->GetBattlegroundId() && handler->GetSession()->GetPlayer()->GetBattlegroundId() != target->GetBattlegroundId())
+                target->LeaveBattleground(false); // Note: should be changed so target gets no Deserter debuff
+
+            // all's well, set bg id
+            // when porting out from the bg, it will be reset to 0
+            target->SetBattlegroundId(handler->GetSession()->GetPlayer()->GetBattlegroundId(), handler->GetSession()->GetPlayer()->GetBattlegroundTypeId());
+            // remember current position as entry point for return at bg end teleportation
+            if (!target->GetMap()->IsBattlegroundOrArena())
+                target->SetBattlegroundEntryPoint();
+        }
+        else if (map->IsDungeon())
+        {
+            Map* map = target->GetMap();
+
+            if (map->Instanceable() && map->GetInstanceId() != map->GetInstanceId())
+                target->UnbindInstance(map->GetInstanceId(), target->GetDungeonDifficulty(), true);
+
+            //// we are in instance, and can summon only player in our group with us as lead
+            //if (!handler->GetSession()->GetPlayer()->GetGroup() || !target->GetGroup() ||
+            //    (target->GetGroup()->GetLeaderGUID() != handler->GetSession()->GetPlayer()->GetGUID()) ||
+            //    (handler->GetSession()->GetPlayer()->GetGroup()->GetLeaderGUID() != handler->GetSession()->GetPlayer()->GetGUID()))
+            //    // the last check is a bit excessive, but let it be, just in case
+            //{
+            //    handler->PSendSysMessage(LANG_CANNOT_SUMMON_TO_INST, nameLink.c_str());
+            //    handler->SetSentErrorMessage(true);
+            //    return false;
+            //}
+        }
+
+        //handler->PSendSysMessage(LANG_SUMMONING, nameLink.c_str(), "");
+        //if (handler->needReportToTarget(target))
+        //    ChatHandler(target).PSendSysMessage(LANG_SUMMONED_BY, handler->playerLink(_player->GetName()).c_str());
+
+        // stop flight if need
+        if (target->IsInFlight())
+        {
+            target->GetMotionMaster()->MovementExpired();
+            target->CleanupAfterTaxiFlight();
+        }
+        // save only in non-flight case
+        else
+            target->SaveRecallPosition();
+
+        // before GM
+        float x, y, z;
+        handler->GetSession()->GetPlayer()->GetClosePoint(x, y, z, target->GetObjectSize());
+        target->TeleportTo(handler->GetSession()->GetPlayer()->GetMapId(), x, y, z, target->GetOrientation());
+        target->SetPhaseMask(handler->GetSession()->GetPlayer()->GetPhaseMask(), true);
+    }
+    else
+    {
+        //std::string nameLink = handler->playerLink(targetName);
+        WorldLocation loc;
+        uint16 zoneId = 0;
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER_POSITION);
+        //handler->PSendSysMessage(LANG_SUMMONING, nameLink.c_str(), handler->GetTrinityString(LANG_OFFLINE));
+        stmt->setUInt16(1, handler->GetSession()->GetPlayer()->GetMapId());
+        stmt->setUInt16(2, handler->GetSession()->GetPlayer()->GetZoneId());
+        stmt->setFloat(3, handler->GetSession()->GetPlayer()->GetPositionX());
+        stmt->setFloat(4, handler->GetSession()->GetPlayer()->GetPositionY());
+        stmt->setFloat(5, handler->GetSession()->GetPlayer()->GetPositionZ());
+        trans->Append(stmt);
+        // in point where GM stay
+
+        Player::SavePositionInDB(loc, zoneId, targetGuid, trans);
+    }
+
+    return true;
+}
+bool PlayerbotChatHandler::HandleQuestRemove(ChatHandler* handler, const char* args)
+{
+    Player* player = handler->getSelectedPlayer();
+    if (!player)
+    {
+        handler->SendSysMessage(LANG_NO_CHAR_SELECTED);
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .removequest #entry'
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = handler->extractKeyFromLink((char*)args, "Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* quest = sObjectMgr->GetQuestTemplate(entry);
+
+    if (!quest)
+    {
+        handler->PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    // remove all quest entries for 'entry' from quest log
+    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 logQuest = player->GetQuestSlotQuestId(slot);
+        if (logQuest == entry)
+        {
+            player->SetQuestSlot(slot, 0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            player->TakeQuestSourceItem(logQuest, false);
+        }
+    }
+
+    player->RemoveActiveQuest(entry);
+    player->RemoveRewardedQuest(entry);
+
+    handler->SendSysMessage(LANG_COMMAND_QUEST_REMOVED);
+    return true;
+}
+
+PlayerbotAI::PlayerbotAI(Player* const master, Player* const bot) :
+    m_master(master), m_bot(bot), m_classAI(0), m_ignoreAIUpdatesUntilTime(0),
+    m_combatOrder(ORDERS_NONE), m_ScenarioType(SCENARIO_PVEEASY),
+    m_TimeDoneEating(0), m_TimeDoneDrinking(0),
+    m_CurrentlyCastingSpellId(0), m_spellIdCommand(0),
+    m_targetGuidCommand(ObjectGuid::Empty), m_taxiMaster(ObjectGuid::Empty)
+{
+
+    // load config variables
+    m_changeFaction = sConfigMgr->GetBoolDefault("Bot.ChangeFaction", true);
+
+    m_confMaxNumBots = sConfigMgr->GetIntDefault("Bot.MaxNumBots", 9);
+    m_confDebugWhisper = sConfigMgr->GetBoolDefault("Bot.DebugWhisper", false);
+    m_confFollowDistance[0] = sConfigMgr->GetFloatDefault("Bot.FollowDistanceMin", 0.5f);
+    m_confFollowDistance[1] = sConfigMgr->GetFloatDefault("Bot.FollowDistanceMax", 1.0f);
+    m_confCollectCombat = sConfigMgr->GetBoolDefault("Bot.Collect.Combat", true);
+    m_confCollectQuest = sConfigMgr->GetBoolDefault("Bot.Collect.Quest", true);
+    m_confCollectProfession = sConfigMgr->GetBoolDefault("Bot.Collect.Profession", true);
+    m_confCollectLoot = sConfigMgr->GetBoolDefault("Bot.Collect.Loot", true);
+    m_confCollectSkin = sConfigMgr->GetBoolDefault("Bot.Collect.Skin", true);
+    m_confCollectObjects = sConfigMgr->GetBoolDefault("Bot.Collect.Objects", true);
+    gConfigSellLevelDiff = sConfigMgr->GetIntDefault("PlayerbotAI.SellAll.LevelDiff", 10);
+    m_confCollectDistanceMax = sConfigMgr->GetIntDefault("Bot.Collect.DistanceMax", 50);
+    if (m_confCollectDistanceMax > 100)
+    {
+        //sLog->outError("Playerbot: Bot.Collect.DistanceMax higher than allowed. Using 100");
+        m_confCollectDistanceMax = 100;
+    }
+    m_confCollectDistance = sConfigMgr->GetIntDefault("Bot.Collect.Distance", 25);
+    if (m_confCollectDistance > m_confCollectDistanceMax)
+    {
+        //sLog->outError("Playerbot: Bot.Collect.Distance higher than Bot.Collect.DistanceMax. Using DistanceMax value");
+        m_confCollectDistance = m_confCollectDistanceMax;
+    }
+    m_confSellGarbage = sConfigMgr->GetBoolDefault("Bot.SellGarbage", true);
+    // set bot state
+    m_botState = BOTSTATE_NORMAL;
+
+    // reset some pointers
+    m_targetChanged = false;
+    m_targetType = TARGET_NORMAL;
+    m_targetCombat = 0;
+    m_targetAssist = 0;
+    m_targetProtect = 0;
+
+    // set collection options
+    m_collectionFlags = 0;
+    //m_collectDist = m_confCollectDistance;
+    if (m_confCollectCombat)
+        SetCollectFlag(COLLECT_FLAG_COMBAT);
+    if (m_confCollectQuest)
+        SetCollectFlag(COLLECT_FLAG_QUEST);
+    if (m_confCollectProfession)
+        SetCollectFlag(COLLECT_FLAG_PROFESSION);
+    if (m_confCollectLoot)
+        SetCollectFlag(COLLECT_FLAG_LOOT);
+    if (m_confCollectSkin && m_bot->HasSkill(SKILL_SKINNING))
+        SetCollectFlag(COLLECT_FLAG_SKIN);
+    if (m_confCollectObjects)
+        SetCollectFlag(COLLECT_FLAG_NEAROBJECT);
+
+    // set needed item list
+    SetQuestNeedItems();
+    SetQuestNeedCreatures();
+
+    // start following master (will also teleport bot to master)
+    SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+
+    //add bot to group
+    ChatHandler ch(master->GetSession());
+    if (Group *group = master->GetGroup())
+    {
+        if (!group->IsMember(m_bot->GetGUID()))
+        {
+            if (!group->IsFull())
+            {
+                if (!group->AddMember(m_bot))
+                {
+                    ch.PSendSysMessage("Playerbot %u is not added cuz group is full! #1", m_bot->GetGUID().GetCounter());
+                    return;
+                }
+            }
+            else if (!group->isRaidGroup())
+            {
+                group->ConvertToRaid();
+                if (!group->AddMember(m_bot))
+                {
+                    ch.PSendSysMessage("Playerbot %u is not added! #2", m_bot->GetGUID().GetCounter());
+                    //master->GetSession()->LogoutPlayerBot(m_bot->GetGUID());
+                    return;
+                }
+            }
+            else//raid group is full
+            {
+                ch.PSendSysMessage("Playerbot %u is not added cuz group is full! #2", m_bot->GetGUID().GetCounter());
+                //master->GetSession()->LogoutPlayerBot(m_bot->GetGUID());
+                return;
+            }
+        }
+    }
+    else
+    {
+        group = new Group;
+        if (!group->Create(master))
+        {
+            delete group;
+            return;
+        }
+
+        //critical part
+        sGroupMgr->AddGroup(group);
+
+        if (!group->AddMember(m_bot))
+        {
+            ch.PSendSysMessage("Playerbot %u is not added! #2", m_bot->GetGUID().GetCounter());
+            //master->GetSession()->LogoutPlayerBot(m_bot->GetGUID());
+            return;
+        }
+    }
+
+    // get class specific ai
+    switch (m_bot->getClass())
+    {
+        case CLASS_PRIEST:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPriestAI(m_master, m_bot, this);
+            break;
+        case CLASS_MAGE:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotMageAI(m_master, m_bot, this);
+            break;
+        case CLASS_WARLOCK:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarlockAI(m_master, m_bot, this);
+            break;
+        case CLASS_WARRIOR:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarriorAI(m_master, m_bot, this);
+            break;
+        case CLASS_SHAMAN:
+            if (m_bot->GetSpec() == SHAMAN_SPEC_ENHANCEMENT)
+                m_combatStyle = COMBAT_MELEE;
+            else
+                m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotShamanAI(m_master, m_bot, this);
+            break;
+        case CLASS_PALADIN:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPaladinAI(m_master, m_bot, this);
+            break;
+        case CLASS_ROGUE:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotRogueAI(m_master, m_bot, this);
+            break;
+        case CLASS_DRUID:
+            if (m_bot->GetSpec() == DRUID_SPEC_FERAL)
+                m_combatStyle = COMBAT_MELEE;
+            else
+                m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDruidAI(m_master, m_bot, this);
+            break;
+        case CLASS_HUNTER:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotHunterAI(m_master, m_bot, this);
+            ASPECT_OF_THE_MONKEY = initSpell(ASPECT_OF_THE_MONKEY_1);
+            break;
+        case CLASS_DEATH_KNIGHT:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDeathKnightAI(m_master, m_bot, this);
+            break;
+    }
+
+    HERB_GATHERING      = initSpell(HERB_GATHERING_1);
+    MINING              = initSpell(MINING_1);
+    SKINNING            = initSpell(SKINNING_1);
+
+    ClearActiveTalentSpec();
+}
+
+PlayerbotAI::~PlayerbotAI()
+{
+    if (m_classAI) delete m_classAI;
+}
+
+// finds spell ID for matching substring args
+// in priority of full text match, spells not taking reagents, and highest rank
+uint32 PlayerbotAI::getSpellId(const char* args, bool master) const
+{
+    if (!*args)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = 0;
+    if (master)
+        loc = m_master->GetSession()->GetSessionDbcLocale();
+    else
+        loc = m_bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
+            continue;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo || pSpellInfo->IsPassive())
+            continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if (name.empty() || !Utf8FitTo(name, wnamepart))
+            continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length());
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0);
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0)
+        {
+            if (isExactMatch && !foundExactMatch) {}
+            else if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    return foundSpellId;
+}
+
+uint32 PlayerbotAI::getPetSpellId(const char* args) const
+{
+    if (!*args)
+        return 0;
+
+    Pet* pet = m_bot->GetPet();
+    if (!pet)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if (itr->second.state == PETSPELL_REMOVED || sSpellMgr->GetSpellInfo(spellId)->IsPassive())
+            continue;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if (name.empty() || !Utf8FitTo(name, wnamepart))
+            continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0) ? true : false;
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0)
+        {
+            if (isExactMatch && !foundExactMatch) {}
+            else if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    return foundSpellId;
+}
+
+uint32 PlayerbotAI::initSpell(uint32 spellId) const
+{
+    // Check if bot knows this spell
+    if (!m_bot->HasSpell(spellId))
+        return 0;
+
+    uint32 next = 0;
+    SpellChainNode const *Node = sSpellMgr->GetSpellChainNode(spellId);
+    next = Node && Node->next ? Node->next->Id : 0;
+    //const SpellInfo *const spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (next == 0 || !m_bot->HasSpell(next))
+    {
+        //// Add spell to spellrange map
+        //Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+        //float range = spellInfo->GetMaxRange(spellInfo->IsPositive());
+        //m_bot->ApplySpellMod(spellId, SPELLMOD_RANGE, range, spell);
+        //m_spellRangeMap.insert(std::pair<uint32, float>(spellId, range));
+        //delete spell;
+        ////sLog->outBasic("Pbot::InitSpell() proceed spell %u (%s): returned %u (%s)", spellId, spellInfo->SpellName[0], spellId, spellInfo->SpellName[0]);
+        return spellId;
+    }
+    else
+    {
+        //sLog->outBasic("Pbot::InitSpell() proceed spell %u (%s): forwarding to %u (%s)", spellId, spellInfo->SpellName[0], next, sSpellMgr->GetSpellInfo(next)->SpellName[0]);
+        return initSpell(next);
+    }
+    //return (next == 0) ? spellId : next;
+}
+
+// Pet spells do not form chains like player spells.
+// One of the options to initialize a spell is to use spell icon id
+uint32 PlayerbotAI::initPetSpell(uint32 spellIconId)
+{
+    Pet * pet = m_bot->GetPet();
+
+    if (!pet)
+        return 0;
+
+    for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        const uint32 spellId = itr->first;
+
+        if (itr->second.state == PETSPELL_REMOVED || sSpellMgr->GetSpellInfo(spellId)->IsPassive())
+            continue;
+
+        const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (pSpellInfo->SpellIconID == spellIconId)
+            return spellId;
+    }
+
+    // Nothing found
+    return 0;
+}
+
+/*
+ * Send list of the equipment in bot's inventory not currently equipped.
+ * This is called when the master is inspecting the bot.
+ */
+void PlayerbotAI::SendNotEquipList(Player& /*player*/)
+{
+    // find all unequipped items and put them in
+    // a vector of dynamically created lists where the vector index is from 0-18
+    // and the list contains Item* that can be equipped to that slot
+    // Note: each dynamically created list in the vector must be deleted at end
+    // so NO EARLY RETURNS!
+    // see enum EquipmentSlots in Player.h to see what equipment slot each index in vector
+    // is assigned to. (The first is EQUIPMENT_SLOT_HEAD=0, and last is EQUIPMENT_SLOT_TABARD=18)
+    std::list<Item*>* equip[19];
+    for (uint8 i = 0; i < 19; ++i)
+        equip[i] = NULL;
+
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        uint16 dest;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+        if (msg != EQUIP_ERR_OK)
+            continue;
+
+        // the dest looks like it includes the old loc in the 8 higher bits
+        // so casting it to a uint8 strips them
+        int8 equipSlot = uint8(dest);
+        if (!(equipSlot >= 0 && equipSlot < 19))
+            continue;
+
+        // create a list if one doesn't already exist
+        if (equip[equipSlot] == NULL)
+            equip[equipSlot] = new std::list<Item*>;
+
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        itemListForEqSlot->push_back(pItem);
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (!pItem)
+                    continue;
+
+                uint16 dest;
+                uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+                if (msg != EQUIP_ERR_OK)
+                    continue;
+
+                int8 equipSlot = uint8(dest);
+                if (!(equipSlot >= 0 && equipSlot < 19))
+                    continue;
+
+                // create a list if one doesn't already exist
+                if (equip[equipSlot] == NULL)
+                    equip[equipSlot] = new std::list<Item*>;
+
+                std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+                itemListForEqSlot->push_back(pItem);
+            }
+    }
+
+    ChatHandler ch(m_master->GetSession());
+    bool bAnyEquippable = false;
+
+    const std::string descr[] = { "head", "neck", "shoulders", "body", "chest",
+                                  "waist", "legs", "feet", "wrists", "hands", "finger1", "finger2",
+                                  "trinket1", "trinket2", "back", "mainhand", "offhand", "ranged",
+                                  "tabard" };
+
+    // now send client all items that can be equipped by slot
+    for (uint8 equipSlot = 0; equipSlot < 19; ++equipSlot)
+    {
+        if (equip[equipSlot] == NULL)
+            continue;
+
+        if (!bAnyEquippable)
+        {
+            TellMaster("Here's all the items in my inventory that I can equip:");
+            bAnyEquippable = true;
+        }
+
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        std::ostringstream out;
+        out << descr[equipSlot] << ": ";
+        for (std::list<Item*>::iterator it = itemListForEqSlot->begin(); it != itemListForEqSlot->end(); ++it)
+        {
+            if ((*it))
+                MakeItemLink((*it), out, true);
+            //const ItemTemplate* const pItemProto = (*it)->GetTemplate();
+            //std::string itemName = pItemProto->Name1;
+            //ItemLocalization(itemName, pItemProto->ItemId);
+            //out << " |cffffffff|Hitem:" << pItemProto->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+        }
+        ch.SendSysMessage(out.str().c_str());
+
+        delete itemListForEqSlot; // delete list of Item*
+    }
+
+    if (!bAnyEquippable)
+        TellMaster("There are no items in my inventory that I can equip.");
+}
+
+void PlayerbotAI::FollowAutoReset(Player& /*player*/)
+{
+    if (FollowAutoGo != 0)
+    {
+        FollowAutoGo = 3;
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+    }
+}
+
+void PlayerbotAI::AutoUpgradeEquipment(Player& /*player*/) // test for autoequip
+{
+    ChatHandler ch(m_master->GetSession());
+    std::ostringstream out;
+    std::ostringstream msg;
+    uint32 calc = .10;
+    if (AutoEquipPlug != 1)
+        if (AutoEquipPlug == 2)
+            AutoEquipPlug = 0;
+        else
+            return;
+    // check equipped items for anything that is worn and UNequip them first if possible
+    for (uint8 eqslot = EQUIPMENT_SLOT_START; eqslot < EQUIPMENT_SLOT_END; eqslot++)
+    {
+        Item* const eqitem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, eqslot);
+        if (!eqitem)
+            continue;
+        // if item durability is less than 10% of max durability, UNequip it.
+        if (eqitem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY) > 0 && eqitem->GetUInt32Value(ITEM_FIELD_DURABILITY) <= (calc * eqitem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY)))
+        {
+            ItemPosCountVec sDest;
+            InventoryResult msg = m_bot->CanStoreItem( NULL_BAG, NULL_SLOT, sDest, eqitem, false );
+            if(msg == EQUIP_ERR_OK)
+            {
+                m_bot->RemoveItem(INVENTORY_SLOT_BAG_0, eqslot, true);
+                m_bot->StoreItem( sDest, eqitem, true );
+            }
+            else
+            {
+                m_bot->SendEquipError(msg, eqitem, NULL);
+            }
+        }
+    }
+    // Find equippable items in main backpack one at a time
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+        // if item durability is less than 10% of max durability, ignore it..
+        if (pItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY) > 0 && pItem->GetUInt32Value(ITEM_FIELD_DURABILITY) <= (calc * pItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY)))
+        {
+            MakeItemLink(pItem, out, true);
+            continue;
+        }
+        uint32 spellId = 0;
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            if (pItem->GetTemplate()->Spells[i].SpellId > 0)
+            {
+                spellId = pItem->GetTemplate()->Spells[i].SpellId;
+                break;
+            }
+        }
+        if (pItem->GetTemplate()->Flags & ITEM_PROTO_FLAG_OPENABLE && spellId == 0)
+        {
+            std::string oops = "Oh.. Look!! Theres something Inside this!!!";
+            m_bot->Say(oops, LANG_UNIVERSAL);
+            UseItem(pItem);
+            continue;
+        }
+        if (uint32 questid = pItem->GetTemplate()->StartQuest)
+        {
+            Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+            if (m_bot->GetQuestStatus(questid) == QUEST_STATUS_COMPLETE)
+                continue;
+            else if (!m_bot->CanTakeQuest(qInfo, false))
+            {
+                std::string oops = "Great..more junk..can I get rid of this please?";
+                m_bot->Say(oops, LANG_UNIVERSAL);
+                continue;
+            }
+            UseItem(pItem);
+        }
+        uint16 dest;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+        if (msg != EQUIP_ERR_OK)
+            continue;
+        int8 equipSlot = uint8(dest);
+        if (!(equipSlot >= 0 && equipSlot < 19))
+            continue;
+        Item* const pItem2 = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, equipSlot); // do we have anything equipped of this type?
+        if (!pItem2)// no item to compare to see if has stats useful for this bots class/style so check for stats and equip if possible
+        {
+            ItemTemplate const *pProto2 = pItem->GetTemplate();
+            if (!ItemStatComparison(pProto2, pProto2))
+                continue;
+            EquipItem(pItem); //no item equipped so equip new one and go to next item.
+            continue;
+        }
+        // we have an equippable item, ..now lets send it to the comparison function to see if its better than we have on.
+        AutoEquipComparison(pItem, pItem2); //pItem is new item, pItem2 is equipped item.
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (!pItem)
+                    continue;
+                // if item durability is less than 10% of max durability, ignore it..
+                if (pItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY) > 0 && pItem->GetUInt32Value(ITEM_FIELD_DURABILITY) <= (calc * pItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY)))
+                {
+                    MakeItemLink(pItem, out, true);
+                    continue;
+                }
+                uint16 dest;
+                uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+                if (msg != EQUIP_ERR_OK)
+                    continue;
+                int8 equipSlot = uint8(dest);
+                if (!(equipSlot >= 0 && equipSlot < 19))
+                    continue;
+                Item* const pItem2 = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, equipSlot); // do we have anything equipped of this type?
+                if (!pItem2)
+                {
+                    ItemTemplate const *pProto2 = pItem->GetTemplate();
+                    if (!ItemStatComparison(pProto2, pProto2))
+                        continue;
+                    EquipItem(pItem); //no item equipped so equip new one if useable stats and go to next item.
+                    continue;
+                }
+                // we have an equippable item, but something else is equipped..now lets send it to the comparison function to see if its better than we have on.
+                AutoEquipComparison(pItem, pItem2); //pItem is new item, pItem2 is equipped item.
+            }
+    }
+    if (out.str().size() != 0)
+    {
+        std::ostringstream tmp;
+        tmp << "|h|cff00ffff _______________________________________ ";
+        ch.SendSysMessage(tmp.str().c_str());
+        ch.SendSysMessage(out.str().c_str());
+        ch.SendSysMessage(tmp.str().c_str());
+        TellMaster("These items are worn too badly to use.");// check inventory items.. we'll deal with equipped items elsewhere
+    }
+    InspectUpdate();
+}
+void PlayerbotAI::AutoEquipComparison(Item *pItem, Item *pItem2)
+{
+    const static uint32 item_armor_skills[MAX_ITEM_SUBCLASS_ARMOR] =
+    {
+        0, SKILL_CLOTH, SKILL_LEATHER, SKILL_MAIL, SKILL_PLATE_MAIL, 0, SKILL_SHIELD, 0, 0, 0, 0
+    };
+    ItemTemplate const *pProto = pItem2->GetTemplate(); // equipped item if any
+    ItemTemplate const *pProto2 = pItem->GetTemplate(); // new item to compare
+    // DEBUG_LOG("Item Class (%s)",(pProto->Class == ITEM_CLASS_WEAPON ? "Weapon" : "Not Weapon"));
+    switch (pProto->Class)
+    {
+    case ITEM_CLASS_WEAPON:
+        {
+            // DEBUG_LOG("Current Item DPS (%f) Equippable Item DPS (%f)",pProto->getDPS(),pProto2->getDPS());
+            // m_bot->GetSkillValue(pProto->RequiredSkill) < m_bot->GetSkillValue(pProto2->RequiredSkill)
+            if (pProto->getDPS() < pProto2->getDPS())   // if new item has a better DPS
+            {
+                EquipItem(pItem);
+                pProto = pProto2; // ensure that the item with the highest DPS is equipped
+            }
+            break;
+        }
+    case ITEM_CLASS_ARMOR:
+        {
+            if (pProto->ItemLevel < pProto2->ItemLevel && pProto->Armor <= pProto2->Armor && m_bot->HasSkill(item_armor_skills[pProto2->SubClass]) &&
+                !m_bot->HasSkill(item_armor_skills[pProto2->SubClass + 1])) // itemlevel + armour + armour class
+            {
+                // First check to see if this item has stats, and if the bot REALLY wants to lose its old item
+                if (pProto2->StatsCount > 0)
+                {
+                    if (!ItemStatComparison(pProto, pProto2))
+                        return; // stats on equipped item are better, OR stats are not useful for this bots class/style
+                }
+                EquipItem(pItem);
+                break;
+            }
+            // now in case they are same itemlevel, but one is better than the other..
+            if (pProto->ItemLevel == pProto2->ItemLevel && pProto->Quality < pProto2->Quality && pProto->Armor <= pProto2->Armor &&
+                m_bot->HasSkill(item_armor_skills[pProto2->SubClass]) && !m_bot->HasSkill(item_armor_skills[pProto2->SubClass + 1])) // itemlevel + armour + armour class
+            {
+                // First check to see if this item has stats, and if the bot REALLY wants to lose its old item
+                if (pProto2->StatsCount > 0)
+                {
+                    if (!ItemStatComparison(pProto, pProto2))
+                        return; // stats on equipped item are better, OR stats are not useful for this bots class/style
+                }
+                EquipItem(pItem);
+                break;
+            }
+            if (pProto->ItemLevel <= pProto2->ItemLevel && pProto->Quality < pProto2->Quality && pProto->Armor > pProto2->Armor &&
+                m_bot->HasSkill(item_armor_skills[pProto2->SubClass]) && !m_bot->HasSkill(item_armor_skills[pProto2->SubClass + 1])) // itemlevel + armour + armour class
+            {
+                // First check to see if this item has stats, and if the bot REALLY wants to lose its old item
+                if (pProto2->StatsCount > 0)
+                {
+                    if (!ItemStatComparison(pProto, pProto2))
+                        return; // stats on equipped item are better, OR stats are not useful for this bots class/style
+                }
+                EquipItem(pItem);
+                break;
+            }
+        }
+    }
+    InspectUpdate();
+}
+bool PlayerbotAI::ItemStatComparison(const ItemTemplate *pProto, const ItemTemplate *pProto2)
+{
+    uint8 isclass = 0; // 1= caster 2 = hybrid 3 = melee
+    uint8 ishybrid = 0;
+    uint8 olditemscore = 0;
+    uint8 newitemscore = 0;
+    // get class and style to make it easier to compare later
+    switch (m_bot->getClass())
+    {
+    case CLASS_SHAMAN:
+        {
+            isclass = 2;
+            ishybrid = 1; // hybrid caster
+            break;
+        }
+    case CLASS_PRIEST:
+        {
+            isclass = 1;
+            break;
+        }
+    case CLASS_MAGE:
+        {
+            isclass = 1;
+            break;
+        }
+    case CLASS_WARLOCK:
+        {
+            isclass = 1;
+            break;
+        }
+    case CLASS_DRUID:
+        {
+            ishybrid = 1;
+            isclass = 2; // caster
+            break;
+        }
+    }
+    switch (m_bot->getClass())
+    {
+    case CLASS_WARRIOR:
+    case CLASS_ROGUE:
+        isclass = 3; // melee
+        break;
+    }
+    switch (m_bot->getClass())
+    {
+    case CLASS_HUNTER:
+        isclass = 2;
+        ishybrid = 2;
+    case CLASS_PALADIN:
+    case CLASS_DEATH_KNIGHT:
+        isclass = 2; // hybrid melee
+        ishybrid = 1;
+        break;
+    }
+    for (int i = 0; i < MAX_ITEM_PROTO_STATS; ++i) // item can only have 10 stats. We check each stat slot available for stat and type.
+    {
+        uint32 itemmod = pProto->ItemStat[i].ItemStatType; // equipped item stats if any
+        uint32 itemmod2 = pProto2->ItemStat[i].ItemStatType; // newitem stats
+        //if (!itemmod) // if no stat type in this slot, continue to next slot
+        //   continue;
+        // caster stats
+        if (itemmod == ITEM_MOD_MANA || itemmod == ITEM_MOD_INTELLECT || itemmod == ITEM_MOD_SPIRIT || itemmod == ITEM_MOD_HIT_SPELL_RATING ||
+            itemmod == ITEM_MOD_CRIT_SPELL_RATING || itemmod == ITEM_MOD_HASTE_SPELL_RATING || itemmod == ITEM_MOD_SPELL_DAMAGE_DONE ||
+            itemmod == ITEM_MOD_MANA_REGENERATION || itemmod == ITEM_MOD_SPELL_POWER || itemmod == ITEM_MOD_SPELL_PENETRATION ||
+            itemmod2 == ITEM_MOD_MANA || itemmod2 == ITEM_MOD_INTELLECT || itemmod2 == ITEM_MOD_SPIRIT || itemmod2 == ITEM_MOD_HIT_SPELL_RATING ||
+            itemmod2 == ITEM_MOD_CRIT_SPELL_RATING || itemmod2 == ITEM_MOD_HASTE_SPELL_RATING || itemmod2 == ITEM_MOD_SPELL_DAMAGE_DONE ||
+            itemmod2 == ITEM_MOD_MANA_REGENERATION || itemmod2 == ITEM_MOD_SPELL_POWER || itemmod2 == ITEM_MOD_SPELL_PENETRATION)
+        {
+            switch (isclass) // 1 caster, 2 hybrid, 3 melee
+            {
+            case 1:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+
+                    break;
+                }
+            case 2:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (ishybrid != 2) //not a hunter
+                    {
+                        if (itemmod == itemmod2) //same stat type
+                        {
+                            if (itemmodval < itemmodval2) // which one has the most
+                            {
+                                if (olditemscore > 0)
+                                    olditemscore = (olditemscore - 1);
+                                newitemscore = (newitemscore + 1);
+                            }
+                            else
+                            {
+                                if (newitemscore > 0)
+                                    newitemscore = (newitemscore - 1);
+                                olditemscore = (olditemscore + 1);
+                            }
+                        }
+                        else
+                        {
+                            if (itemmod)
+                                olditemscore = (olditemscore + 1);
+                            if (itemmod2)
+                                newitemscore = (newitemscore + 1);
+                        }
+                    }
+                    else //is a hunter
+                    {
+                        if (itemmod)
+                        {
+                            if (olditemscore > 0) //we dont want any negative returns
+                                olditemscore = (olditemscore - 1);
+                        }
+                        if (itemmod2)
+                        {
+                            if (newitemscore > 0) //we dont want any negative returns
+                                newitemscore = (newitemscore - 1);
+                        }
+                    }
+                    break;
+                }  // pure melee need nothing from this list.
+            case 3:
+                {
+                    if (itemmod)
+                    {
+                        if (olditemscore > 0) //we dont want any negative returns
+                            olditemscore = (olditemscore - 1);
+                    }
+                    if (itemmod2)
+                    {
+                        if (newitemscore > 0) //we dont want any negative returns
+                            newitemscore = (newitemscore - 1);
+                    }
+                    break;
+                }
+            default:
+                break;
+            }
+        }
+        // melee only stats (warrior/rogue) or stats that only apply to melee style combat
+        if (itemmod == ITEM_MOD_HEALTH || itemmod == ITEM_MOD_AGILITY || itemmod == ITEM_MOD_STRENGTH ||
+            itemmod == ITEM_MOD_DEFENSE_SKILL_RATING || itemmod == ITEM_MOD_DODGE_RATING || itemmod == ITEM_MOD_PARRY_RATING ||
+            itemmod == ITEM_MOD_BLOCK_RATING ||    itemmod == ITEM_MOD_HIT_MELEE_RATING || itemmod == ITEM_MOD_CRIT_MELEE_RATING ||
+            itemmod == ITEM_MOD_HIT_TAKEN_MELEE_RATING || itemmod == ITEM_MOD_HIT_TAKEN_RANGED_RATING ||itemmod == ITEM_MOD_HIT_TAKEN_SPELL_RATING ||
+            itemmod == ITEM_MOD_CRIT_TAKEN_MELEE_RATING || itemmod == ITEM_MOD_CRIT_TAKEN_RANGED_RATING ||
+            itemmod == ITEM_MOD_CRIT_TAKEN_SPELL_RATING || itemmod == ITEM_MOD_HASTE_MELEE_RATING ||
+            itemmod == ITEM_MOD_HIT_TAKEN_RATING || itemmod == ITEM_MOD_CRIT_TAKEN_RATING || itemmod == ITEM_MOD_ATTACK_POWER ||
+            itemmod == ITEM_MOD_BLOCK_VALUE || itemmod2 == ITEM_MOD_HEALTH || itemmod2 == ITEM_MOD_AGILITY || itemmod2 == ITEM_MOD_STRENGTH ||
+            itemmod2 == ITEM_MOD_DEFENSE_SKILL_RATING || itemmod2 == ITEM_MOD_DODGE_RATING || itemmod2 == ITEM_MOD_PARRY_RATING ||
+            itemmod2 == ITEM_MOD_BLOCK_RATING ||    itemmod2 == ITEM_MOD_HIT_MELEE_RATING || itemmod2 == ITEM_MOD_CRIT_MELEE_RATING ||
+            itemmod2 == ITEM_MOD_HIT_TAKEN_MELEE_RATING || itemmod2 == ITEM_MOD_HIT_TAKEN_RANGED_RATING ||itemmod2 == ITEM_MOD_HIT_TAKEN_SPELL_RATING ||
+            itemmod2 == ITEM_MOD_CRIT_TAKEN_MELEE_RATING || itemmod2 == ITEM_MOD_CRIT_TAKEN_RANGED_RATING ||
+            itemmod2 == ITEM_MOD_CRIT_TAKEN_SPELL_RATING || itemmod2 == ITEM_MOD_HASTE_MELEE_RATING ||
+            itemmod2 == ITEM_MOD_HIT_TAKEN_RATING || itemmod2 == ITEM_MOD_CRIT_TAKEN_RATING || itemmod2 == ITEM_MOD_ATTACK_POWER ||
+            itemmod2 == ITEM_MOD_BLOCK_VALUE)
+        {
+            switch (isclass) // 1 caster, 2 hybrid, 3 melee
+            {
+            case 1:
+                {
+                    if (itemmod)
+                    {
+                        if (olditemscore > 0) //we dont want any negative returns
+                            olditemscore = (olditemscore - 1);
+                    }
+                    if (itemmod2)
+                    {
+                        if (newitemscore > 0) //we dont want any negative returns
+                            newitemscore = (newitemscore - 1);
+                    }
+                    break;
+                }
+            case 2:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+                    break;
+                }
+            case 3:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+
+                    break;
+                }
+            default:
+                break;
+            }
+        }
+        // stats which aren't strictly caster or melee (hybrid perhaps or style dependant)
+        if (itemmod == ITEM_MOD_HIT_RATING || itemmod == ITEM_MOD_CRIT_RATING ||
+            itemmod == ITEM_MOD_RESILIENCE_RATING || itemmod == ITEM_MOD_HASTE_RATING || itemmod == ITEM_MOD_EXPERTISE_RATING ||
+            itemmod == ITEM_MOD_ARMOR_PENETRATION_RATING || itemmod == ITEM_MOD_HEALTH_REGEN ||    itemmod == ITEM_MOD_STAMINA ||
+            itemmod2 == ITEM_MOD_HIT_RATING || itemmod2 == ITEM_MOD_CRIT_RATING || itemmod2 == ITEM_MOD_RESILIENCE_RATING ||
+            itemmod2 == ITEM_MOD_HASTE_RATING || itemmod2 == ITEM_MOD_EXPERTISE_RATING || itemmod2 == ITEM_MOD_ARMOR_PENETRATION_RATING ||
+            itemmod2 == ITEM_MOD_HEALTH_REGEN || itemmod2 == ITEM_MOD_STAMINA)
+        {
+            switch (isclass) // 1 caster, 2 hybrid, 3 melee
+            {
+            case 1:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+                    break;
+                }
+            case 2:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+                    break;
+                }
+            case 3:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+                    break;
+                }
+            default:
+                break;
+            }
+            }
+            // stats relating to ranged only
+            if (itemmod == ITEM_MOD_HIT_RANGED_RATING || itemmod == ITEM_MOD_CRIT_RANGED_RATING || itemmod == ITEM_MOD_HASTE_RANGED_RATING ||
+                itemmod == ITEM_MOD_RANGED_ATTACK_POWER || itemmod2 == ITEM_MOD_HIT_RANGED_RATING || itemmod2 == ITEM_MOD_CRIT_RANGED_RATING ||
+                itemmod2 == ITEM_MOD_HASTE_RANGED_RATING || itemmod2 == ITEM_MOD_RANGED_ATTACK_POWER)
+            {
+                switch (isclass) // 1 caster, 2 hybrid, 3 melee
+                {
+                case 1:
+                {
+                    if (itemmod)
+                    {
+                        if (olditemscore > 0) //we dont want any negative returns
+                            olditemscore = (olditemscore - 1);
+                    }
+                    if (itemmod2)
+                    {
+                        if (newitemscore > 0) //we dont want any negative returns
+                            newitemscore = (newitemscore - 1);
+                    }
+                    break;
+                }
+            case 2:
+                {
+                    if (ishybrid != 2) //not a hunter
+                    {
+                        if (itemmod)
+                        {
+                            if (olditemscore > 0) //we dont want any negative returns
+                                olditemscore = (olditemscore - 1);
+                        }
+                        if (itemmod2)
+                        {
+                            if (newitemscore > 0) //we dont want any negative returns
+                                newitemscore = (newitemscore - 1);
+                        }
+                    }
+                    else //is a hunter
+                    {
+                        uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                        uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                        if (itemmod == itemmod2) //same stat type
+                        {
+                            if (itemmodval < itemmodval2) // which one has the most
+                            {
+                                if (olditemscore > 0)
+                                    olditemscore = (olditemscore - 1);
+                                newitemscore = (newitemscore + 1);
+                            }
+                            else
+                            {
+                                if (newitemscore > 0)
+                                    newitemscore = (newitemscore - 1);
+                                olditemscore = (olditemscore + 1);
+                            }
+                        }
+                        else
+                        {
+                            if (itemmod)
+                                olditemscore = (olditemscore + 1);
+                            if (itemmod2)
+                                newitemscore = (newitemscore + 1);
+                        }
+                    }
+                    break;
+                }
+            case 3:
+                {
+                    if (itemmod)
+                    {
+                        if (olditemscore > 0) //we dont want any negative returns
+                            olditemscore = (olditemscore - 1);
+                    }
+                    if (itemmod2)
+                    {
+                        if (newitemscore > 0) //we dont want any negative returns
+                            newitemscore = (newitemscore - 1);
+                    }
+                    break;
+                }
+            default:
+                break;
+            }
+        }
+    }
+    if (olditemscore <= newitemscore)
+        return true;
+    else
+        return false;
+}
+
+void PlayerbotAI::SendQuestNeedList()
+{
+    std::ostringstream out;
+
+    for (BotNeedItem::iterator itr = m_needItemList.begin(); itr != m_needItemList.end(); ++itr)
+    {
+        ItemTemplate const* pItemProto = sObjectMgr->GetItemTemplate(itr->first);
+        if (pItemProto)
+        {
+            std::string itemName = pItemProto->Name1;
+            ItemLocalization(itemName, pItemProto->ItemId);
+
+            out << " " << itr->second << "x|cffffffff|Hitem:" << pItemProto->ItemId
+                << ":0:0:0:0:0:0:0" << "|h[" << itemName
+                << "]|h|r";
+        }
+    }
+
+    for (BotNeedItem::iterator itr = m_needCreatureOrGOList.begin(); itr != m_needCreatureOrGOList.end(); ++itr)
+    {
+        CreatureTemplate const* cInfo = sObjectMgr->GetCreatureTemplate(itr->first);
+        if (cInfo)
+        {
+            std::string creatureName = cInfo->Name;
+            CreatureLocalization(creatureName, cInfo->Entry);
+            out << " " << itr->second << "x|cFFFFFF00|Hcreature_entry:" << itr->first << "|h[" << creatureName << "]|h|r";
+        }
+
+        if (m_bot->HasQuestForGO(itr->first))
+        {
+            GameObjectTemplate const* gInfo = sObjectMgr->GetGameObjectTemplate(itr->first);
+            if (gInfo)
+            {
+                std::string gameobjectName = gInfo->name;
+                GameObjectLocalization(gameobjectName, gInfo->entry);
+                out << " " << itr->second << "x|cFFFFFF00|Hgameobject_entry:" << itr->first << "|h[" << gameobjectName << "]|h|r";
+            }
+        }
+    }
+
+    TellMaster("Here's a list of all things needed for quests:");
+    if (!out.str().empty())
+        TellMaster(out.str().c_str());
+}
+
+bool PlayerbotAI::IsItemUseful(uint32 itemid)
+{
+    const static uint32 item_weapon_skills[MAX_ITEM_SUBCLASS_WEAPON] =
+    {
+        SKILL_AXES,     SKILL_2H_AXES,  SKILL_BOWS,          SKILL_GUNS,      SKILL_MACES,
+        SKILL_2H_MACES, SKILL_POLEARMS, SKILL_SWORDS,        SKILL_2H_SWORDS, 0,
+        SKILL_STAVES,   0,              0,                   SKILL_UNARMED,   0,
+        SKILL_DAGGERS,  SKILL_THROWN,   SKILL_ASSASSINATION, SKILL_CROSSBOWS, SKILL_WANDS,
+        SKILL_FISHING
+    };
+
+    const static uint32 item_armor_skills[MAX_ITEM_SUBCLASS_ARMOR] =
+    {
+        0, SKILL_CLOTH, SKILL_LEATHER, SKILL_MAIL, SKILL_PLATE_MAIL, 0, SKILL_SHIELD, 0, 0, 0, 0
+    };
+
+    ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(itemid);
+    if (!pProto || pProto->Quality < ITEM_QUALITY_NORMAL)
+        return false;
+
+    // do we already have the max allowed of item if more than zero?
+    if (pProto->MaxCount > 0 && m_bot->HasItemCount(itemid, pProto->MaxCount, true))
+        return false;
+
+    // quest related items
+    if (pProto->StartQuest > 0 && HasCollectFlag(COLLECT_FLAG_QUEST))
+        return true;
+
+    switch (pProto->Class)
+    {
+        case ITEM_CLASS_WEAPON:
+            if (pProto->SubClass >= MAX_ITEM_SUBCLASS_WEAPON)
+                return false;
+            else
+                return m_bot->HasSkill(item_weapon_skills[pProto->SubClass]);
+            break;
+        case ITEM_CLASS_ARMOR:
+            if (pProto->SubClass >= MAX_ITEM_SUBCLASS_ARMOR)
+                return false;
+            else
+                return (m_bot->HasSkill(item_armor_skills[pProto->SubClass]) && !m_bot->HasSkill(item_armor_skills[pProto->SubClass + 1]));
+            break;
+        case ITEM_CLASS_QUEST:
+            if (!HasCollectFlag(COLLECT_FLAG_QUEST))
+                break;
+        case ITEM_CLASS_KEY:
+            return true;
+        case ITEM_CLASS_GEM:
+            if ((m_bot->HasSkill(SKILL_BLACKSMITHING) ||
+                 m_bot->HasSkill(SKILL_ENGINEERING) ||
+                 m_bot->HasSkill(SKILL_JEWELCRAFTING)))
+                return true;
+            break;
+        case ITEM_CLASS_TRADE_GOODS:
+            if (!HasCollectFlag(COLLECT_FLAG_PROFESSION))
+                break;
+
+            switch (pProto->SubClass)
+            {
+                case ITEM_SUBCLASS_PARTS:
+                case ITEM_SUBCLASS_EXPLOSIVES:
+                case ITEM_SUBCLASS_DEVICES:
+                    if (m_bot->HasSkill(SKILL_ENGINEERING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_JEWELCRAFTING:
+                    if (m_bot->HasSkill(SKILL_JEWELCRAFTING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_CLOTH:
+                    if (m_bot->HasSkill(SKILL_TAILORING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_LEATHER:
+                    if (m_bot->HasSkill(SKILL_LEATHERWORKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_METAL_STONE:
+                    if ((m_bot->HasSkill(SKILL_BLACKSMITHING) ||
+                         m_bot->HasSkill(SKILL_ENGINEERING) ||
+                         m_bot->HasSkill(SKILL_MINING)))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_MEAT:
+                    if (m_bot->HasSkill(SKILL_COOKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_HERB:
+                    if ((m_bot->HasSkill(SKILL_HERBALISM) ||
+                         m_bot->HasSkill(SKILL_ALCHEMY) ||
+                         m_bot->HasSkill(SKILL_INSCRIPTION)))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ELEMENTAL:
+                    return true;    // pretty much every profession uses these a bit
+                case ITEM_SUBCLASS_ENCHANTING:
+                    if (m_bot->HasSkill(SKILL_ENCHANTING))
+                        return true;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case ITEM_CLASS_RECIPE:
+        {
+            if (!HasCollectFlag(COLLECT_FLAG_PROFESSION))
+                break;
+
+            // skip recipes that we have
+            if (m_bot->HasSpell(pProto->Spells[2].SpellId))
+                break;
+
+            switch (pProto->SubClass)
+            {
+                case ITEM_SUBCLASS_LEATHERWORKING_PATTERN:
+                    if (m_bot->HasSkill(SKILL_LEATHERWORKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_TAILORING_PATTERN:
+                    if (m_bot->HasSkill(SKILL_TAILORING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ENGINEERING_SCHEMATIC:
+                    if (m_bot->HasSkill(SKILL_ENGINEERING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_BLACKSMITHING:
+                    if (m_bot->HasSkill(SKILL_BLACKSMITHING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_COOKING_RECIPE:
+                    if (m_bot->HasSkill(SKILL_COOKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ALCHEMY_RECIPE:
+                    if (m_bot->HasSkill(SKILL_ALCHEMY))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_FIRST_AID_MANUAL:
+                    if (m_bot->HasSkill(SKILL_FIRST_AID))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ENCHANTING_FORMULA:
+                    if (m_bot->HasSkill(SKILL_ENCHANTING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_FISHING_MANUAL:
+                    if (m_bot->HasSkill(SKILL_FISHING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_JEWELCRAFTING_RECIPE:
+                    if (m_bot->HasSkill(SKILL_JEWELCRAFTING))
+                        return true;
+                    break;
+                default:
+                    break;
+            }
+        }
+        default:
+            break;
+    }
+
+    return false;
+}
+
+void PlayerbotAI::ReloadAI()
+{
+    switch (m_bot->getClass())
+    {
+        case CLASS_PRIEST:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPriestAI(m_master, m_bot, this);
+            break;
+        case CLASS_MAGE:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotMageAI(m_master, m_bot, this);
+            break;
+        case CLASS_WARLOCK:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarlockAI(m_master, m_bot, this);
+            break;
+        case CLASS_WARRIOR:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarriorAI(m_master, m_bot, this);
+            break;
+        case CLASS_SHAMAN:
+            if (m_classAI) delete m_classAI;
+            if (m_bot->GetSpec() == SHAMAN_SPEC_ENHANCEMENT)
+                m_combatStyle = COMBAT_MELEE;
+            else
+                m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotShamanAI(m_master, m_bot, this);
+            break;
+        case CLASS_PALADIN:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPaladinAI(m_master, m_bot, this);
+            break;
+        case CLASS_ROGUE:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotRogueAI(m_master, m_bot, this);
+            break;
+        case CLASS_DRUID:
+            if (m_classAI) delete m_classAI;
+            if (m_bot->GetSpec() == DRUID_SPEC_FERAL)
+                m_combatStyle = COMBAT_MELEE;
+            else
+                m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDruidAI(m_master, m_bot, this);
+            break;
+        case CLASS_HUNTER:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotHunterAI(m_master, m_bot, this);
+            break;
+        case CLASS_DEATH_KNIGHT:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDeathKnightAI(m_master, m_bot, this);
+            break;
+    }
+
+    HERB_GATHERING      = initSpell(HERB_GATHERING_1);
+    MINING              = initSpell(MINING_1);
+    SKINNING            = initSpell(SKINNING_1);
+}
+
+void PlayerbotAI::SendOrders(Player& /*player*/)
+{
+    std::ostringstream out;
+
+    if (!m_combatOrder)
+        out << "Got no combat orders!";
+    else if (m_combatOrder & ORDERS_TANK)
+        out << "I TANK";
+    else if (m_combatOrder & ORDERS_ASSIST)
+        out << "I ASSIST " << (m_targetAssist ? m_targetAssist->GetName() : "unknown");
+    else if (m_combatOrder & ORDERS_HEAL)
+        out << "I HEAL and DISPEL";
+    else if (m_combatOrder & ORDERS_NODISPEL)
+        out << "I HEAL and WON'T DISPEL";
+    else if (m_combatOrder & ORDERS_PASSIVE)
+        out << "I'M PASSIVE";
+    if ((m_combatOrder & ORDERS_PRIMARY) && (m_combatOrder & ORDERS_SECONDARY))
+        out << " and ";
+    if (m_combatOrder & ORDERS_PROTECT)
+        out << "I PROTECT " << (m_targetProtect ? m_targetProtect->GetName() : "unknown");
+    out << ".";
+
+    if (m_confDebugWhisper)
+    {
+        out << " " << (IsInCombat() ? "I'm in COMBAT! " : "Not in combat. ");
+        out << "Current state is ";
+        if (m_botState == BOTSTATE_NORMAL)
+            out << "NORMAL";
+        else if (m_botState == BOTSTATE_COMBAT)
+            out << "COMBAT";
+        else if (m_botState == BOTSTATE_TAME)
+            out << "TAMING";
+        else if (m_botState == BOTSTATE_DEAD)
+            out << "DEAD";
+        else if (m_botState == BOTSTATE_DEADRELEASED)
+            out << "RELEASED";
+        else if (m_botState == BOTSTATE_LOOTING)
+            out << "LOOTING";
+        else if (m_botState == BOTSTATE_FLYING)
+            out << "FLYING";
+        out << ". Movement order is ";
+        if (m_movementOrder == MOVEMENT_NONE)
+            out << "NONE";
+        else if (m_movementOrder == MOVEMENT_FOLLOW)
+            out << "FOLLOW " << (m_followTarget ? m_followTarget->GetName() : "unknown");
+        else if (m_movementOrder == MOVEMENT_STAY)
+            out << "STAY";
+        out << ". Got " << m_attackerInfo.size() << " attacker(s) in list.";
+        out << " Next action in " << (m_ignoreAIUpdatesUntilTime - time(NULL)) << "sec.";
+    }
+
+    TellMaster(out.str().c_str());
+}
+
+// handle outgoing packets the server would send to the client
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+        case MSG_MOVE_TELEPORT_ACK:
+        {
+            HandleTeleportAck();
+            return;
+        }
+
+        case SMSG_DUEL_WINNER:
+        {
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_APPLAUD);
+            return;
+        }
+        case SMSG_DUEL_COMPLETE:
+        {
+            m_ignoreAIUpdatesUntilTime = time(NULL) + 4;
+            m_ScenarioType = SCENARIO_PVEEASY;
+            ReloadAI();
+            m_bot->GetMotionMaster()->Clear(true);
+            return;
+        }
+        case SMSG_DUEL_OUTOFBOUNDS:
+        {
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_CHICKEN);
+            return;
+        }
+        case SMSG_DUEL_REQUESTED:
+        {
+            m_ignoreAIUpdatesUntilTime = 0;
+            WorldPacket p(packet);
+            ObjectGuid flagGuid;
+            p >> flagGuid;
+            ObjectGuid playerGuid;
+            p >> playerGuid;
+            Player* pPlayer = ObjectAccessor::FindPlayer(playerGuid);
+            if (canObeyCommandFrom(*pPlayer))
+            {
+                m_bot->GetMotionMaster()->Clear(true);
+                WorldPacket* const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+                *packet << flagGuid;
+                m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+
+                // follow target in casting range
+                float angle = frand(0, float(M_PI));
+                float dist = frand(4, 10);
+
+                m_bot->GetMotionMaster()->Clear(true);
+                m_bot->GetMotionMaster()->MoveFollow(pPlayer, dist, angle);
+
+                m_bot->SetSelection(playerGuid);
+                m_ignoreAIUpdatesUntilTime = time(NULL) + 4;
+                m_ScenarioType = SCENARIO_DUEL;
+            }
+            return;
+        }
+
+        case SMSG_PET_TAME_FAILURE:
+        {
+            // sLog->outDebug(LOG_FILTER_NONE, "SMSG_PET_TAME_FAILURE");
+            WorldPacket p(packet);
+            uint8 reason;
+            p >> reason;
+
+            switch (reason)
+            {
+                case PETTAME_INVALIDCREATURE:           // = 1,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Invalid Creature");
+                    break;
+                case PETTAME_TOOMANY:                   // = 2,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Too many Creature");
+                    break;
+                case PETTAME_CREATUREALREADYOWNED:      // = 3,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature already owned");
+                    break;
+                case PETTAME_NOTTAMEABLE:               // = 4,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature not tameable");
+                    break;
+                case PETTAME_ANOTHERSUMMONACTIVE:       // = 5,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Another summon active");
+                    break;
+                case PETTAME_UNITSCANTTAME:             // = 6,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Unit cant tame");
+                    break;
+                case PETTAME_NOPETAVAILABLE:            // = 7,    // not used in taming
+                    //sLog->outDebug(LOG_FILTER_NONE, "No pet available");
+                    break;
+                case PETTAME_INTERNALERROR:             // = 8,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Internal error");
+                    break;
+                case PETTAME_TOOHIGHLEVEL:              // = 9,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature level too high");
+                    break;
+                case PETTAME_DEAD:                      // = 10,   // not used in taming
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature dead");
+                    break;
+                case PETTAME_NOTDEAD:                   // = 11,   // not used in taming
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature not dead");
+                    break;
+                case PETTAME_CANTCONTROLEXOTIC:         // = 12,   // 3.x
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature exotic");
+                    break;
+                case PETTAME_UNKNOWNERROR:              // = 13
+                    //sLog->outDebug(LOG_FILTER_NONE, "Unknown error");
+                    break;
+            }
+            return;
+        }
+
+        case SMSG_BUY_FAILED:
+        {
+            WorldPacket p(packet); // 8+4+4+1
+            ObjectGuid vendorguid;
+            p >> vendorguid;
+            uint32 itemid;
+            p >> itemid;
+            uint8 msg;
+            p >> msg; // error msg
+            p.resize(13);
+
+            switch (msg)
+            {
+                case BUY_ERR_CANT_FIND_ITEM:
+                    break;
+                case BUY_ERR_ITEM_ALREADY_SOLD:
+                    break;
+                case BUY_ERR_NOT_ENOUGHT_MONEY:
+                {
+                    Announce(CANT_AFFORD);
+                    break;
+                }
+                case BUY_ERR_SELLER_DONT_LIKE_YOU:
+                    break;
+                case BUY_ERR_DISTANCE_TOO_FAR:
+                    break;
+                case BUY_ERR_ITEM_SOLD_OUT:
+                    break;
+                case BUY_ERR_CANT_CARRY_MORE:
+                {
+                    Announce(INVENTORY_FULL);
+                    break;
+                }
+                case BUY_ERR_RANK_REQUIRE:
+                    break;
+                case BUY_ERR_REPUTATION_REQUIRE:
+                    break;
+            }
+            return;
+        }
+
+        case SMSG_AUCTION_COMMAND_RESULT:
+        {
+            uint32 auctionId, Action, ErrorCode;
+            std::string action[3] = {"Creating", "Cancelling", "Bidding"};
+            std::ostringstream out;
+
+            WorldPacket p(packet);
+            p >> auctionId;
+            p >> Action;
+            p >> ErrorCode;
+            p.resize(12);
+
+            switch (ErrorCode)
+            {
+                case ERR_AUCTION_OK:
+                {
+                    out << "|cff1eff00|h" << action[Action] << " was successful|h|r";
+                    break;
+                }
+                case ERR_AUCTION_NOT_ENOUGHT_MONEY:
+                {
+                    out << "|cffff0000|hWhile " << action[Action] << ", I didn't have enough money|h|r";
+                    break;
+                }
+                case ERR_AUCTION_ITEM_NOT_FOUND:
+                {
+                    out << "|cffff0000|hItem was not found!|h|r";
+                    break;
+                }
+                case ERR_AUCTION_BID_OWN:
+                {
+                    out << "|cffff0000|hI cannot bid on my own auctions!|h|r";
+                    break;
+                }
+            }
+            TellMaster(out.str().c_str());
+            return;
+        }
+
+        case SMSG_INVENTORY_CHANGE_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint8 err;
+            p >> err;
+
+            if (err != EQUIP_ERR_OK)
+            {
+                switch (err)
+                {
+                    case EQUIP_ERR_CANT_CARRY_MORE_OF_THIS:
+                        TellMaster("I can't carry anymore of those.");
+                        return;
+                    case EQUIP_ERR_MISSING_REAGENT:
+                        TellMaster("I'm missing some reagents for that.");
+                        return;
+                    case EQUIP_ERR_ITEM_LOCKED:
+                        TellMaster("That item is locked.");
+                        return;
+                    case EQUIP_ERR_ALREADY_LOOTED:
+                        TellMaster("That is already looted.");
+                        return;
+                    case EQUIP_ERR_INVENTORY_FULL:
+                    {
+                        if (m_inventory_full)
+                            return;
+
+                        TellMaster("My inventory is full.");
+                        m_inventory_full = true;
+                        return;
+                    }
+                    case EQUIP_ERR_NOT_IN_COMBAT:
+                        TellMaster("I can't use that in combat.");
+                        return;
+                    case EQUIP_ERR_LOOT_CANT_LOOT_THAT_NOW:
+                        TellMaster("I can't get that now.");
+                        return;
+                    case EQUIP_ERR_ITEM_UNIQUE_EQUIPABLE:
+                        TellMaster("I can only have one of those equipped.");
+                        return;
+                    case EQUIP_ERR_BANK_FULL:
+                        TellMaster("My bank is full.");
+                        return;
+                    case EQUIP_ERR_ITEM_NOT_FOUND:
+                        TellMaster("I can't find the item.");
+                        return;
+                    case EQUIP_ERR_TOO_FAR_AWAY_FROM_BANK:
+                        TellMaster("I'm too far from the bank.");
+                        return;
+                    case EQUIP_ERR_NONE:
+                        TellMaster("I can't use it on that");
+                        return;
+                    default:
+                        TellMaster("I can't use that.");
+                        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: HandleBotOutgoingPacket - SMSG_INVENTORY_CHANGE_FAILURE: %u", err);
+                        return;
+                }
+            }
+        }
+
+        case SMSG_CAST_FAILED:
+        {
+            WorldPacket p(packet);
+            uint8 castCount;
+            uint32 spellId;
+            uint8 result;
+            std::ostringstream out;
+
+            p >> castCount >> spellId >> result;
+
+            if (result != SPELL_CAST_OK)
+            {
+                switch (result)
+                {
+                    case SPELL_FAILED_INTERRUPTED:  // 40
+                        //sLog->outDebug(LOG_FILTER_NONE, "spell interrupted (%u)",result);
+                        return;
+
+                    case SPELL_FAILED_BAD_TARGETS:  // 12
+                    {
+                        // sLog->outDebug(LOG_FILTER_NONE, "[%s]bad target (%u) for spellId (%u) & m_CurrentlyCastingSpellId (%u)",m_bot->GetName(),result,spellId,m_CurrentlyCastingSpellId);
+                        Spell* const pSpell = GetCurrentSpell();
+                        if (pSpell)
+                            pSpell->cancel();
+                        return;
+                    }
+                    case SPELL_FAILED_REQUIRES_SPELL_FOCUS: // 102
+                    {
+                        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+                        if (!spellInfo)
+                            return;
+
+                        switch (spellInfo->RequiresSpellFocus) // SpellFocusObject.dbc id
+                        {
+                            case 1:  // need an anvil
+                                out << "|cffff0000I require an anvil.";
+                                break;
+                            case 2:  // need a loom
+                                out << "|cffff0000I require a loom.";
+                                break;
+                            case 3:  // need forge
+                                out << "|cffff0000I require a forge.";
+                                break;
+                            case 4:  // need cooking fire
+                                out << "|cffff0000I require a cooking fire.";
+                                break;
+                            default:
+                                out << "|cffff0000I Require Spell Focus on " << spellInfo->RequiresSpellFocus;
+                        }
+                        break;
+                    }
+                    case SPELL_FAILED_CANT_BE_DISENCHANTED:  // 14
+                    {
+                        out << "|cffff0000Item cannot be disenchanted.";
+                        break;
+                    }
+                    case SPELL_FAILED_CANT_BE_MILLED:  // 16
+                    {
+                        out << "|cffff0000I cannot mill that.";
+                        break;
+                    }
+                    case SPELL_FAILED_CANT_BE_PROSPECTED:  // 17
+                    {
+                        out << "|cffff0000There are no gems in this.";
+                        break;
+                    }
+                    case SPELL_FAILED_EQUIPPED_ITEM_CLASS:  // 29
+                    {
+                        out << "|cffff0000That item is not a valid target.";
+                        break;
+                    }
+                    case SPELL_FAILED_NEED_MORE_ITEMS:  // 55
+                    {
+                        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+                        if (!spellInfo)
+                            return;
+
+                        ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(m_itemTarget);
+                        if (!pProto)
+                            return;
+
+                        out << "|cffff0000Requires 5 " << pProto->Name1 << ".";
+                        m_itemTarget = 0;
+                        break;
+                    }
+                    case SPELL_FAILED_REAGENTS:
+                    {
+                        out << "|cffff0000I don't have the reagents";
+                        break;
+                    }
+                    default:
+                        //sLog->outDebug(LOG_FILTER_NONE, "[%s] SMSG_CAST_FAIL: unknown (%u)", m_bot->GetName(), result);
+                        return;
+                }
+            }
+            TellMaster(out.str().c_str());
+            return;
+        }
+
+        case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint8 castCount;
+            uint32 spellId;
+            ObjectGuid casterGuid;
+
+            //packetfix
+            p >> casterGuid;
+            if (casterGuid != m_bot->GetGUID())
+                return;
+
+            p >> castCount >> spellId;
+            if (m_CurrentlyCastingSpellId == spellId)
+            {
+                m_ignoreAIUpdatesUntilTime = time(NULL);
+                m_CurrentlyCastingSpellId = 0;
+            }
+            return;
+        }
+
+        // if a change in speed was detected for the master
+        // make sure we have the same mount status
+        //case SMSG_FORCE_RUN_SPEED_CHANGE:
+        //{
+        //    WorldPacket p(packet);
+        //    ObjectGuid guid;
+        //    //guid = extractGuid(p);
+
+        //    p >> guid;
+
+        //    if (guid != m_master->GetGUID())
+        //        return;
+        //    if (m_master->IsMounted() && !m_bot->IsMounted())
+        //    {
+        //        //Player Part
+        //        Unit::AuraEffectList const& AuraList = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        //        if (!AuraList.empty())
+        //        {
+        //            int32 master_speed1 = AuraList.front()->GetSpellInfo()->Effects[0].BasePoints;
+        //            int32 master_speed2 = AuraList.front()->GetSpellInfo()->Effects[1].BasePoints;
+        //            int32 master_speed3 = AuraList.front()->GetSpellInfo()->Effects[2].BasePoints;
+
+        //            //Bot Part
+        //            uint32 spellMount = 0;
+        //            for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+        //            {
+        //                if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
+        //                    continue;
+        //                uint32 spellId = itr->first;
+        //                SpellInfo const *pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        //                if (!pSpellInfo || pSpellInfo->IsPassive())
+        //                    continue;
+
+        //                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        //                {
+        //                    if (pSpellInfo->Effects[i].ApplyAuraName == SPELL_AURA_MOUNTED)
+        //                    {
+        //                        int32 points = pSpellInfo->Effects[i].BasePoints;
+        //                        if (points == master_speed1 ||
+        //                            points == master_speed2 ||
+        //                            points == master_speed3)
+        //                        {
+        //                            spellMount = spellId;
+        //                            break;
+        //                        }
+        //                    }
+        //                }
+        //            }
+        //            if (spellMount)
+        //                m_bot->CastSpell(m_bot, spellMount, true);
+        //            else
+        //                SendWhisper("Cannot find approriate mount!", *m_master);
+        //        }
+        //    }
+        //    else if (!m_master->IsMounted() && m_bot->IsMounted())
+        //    {
+        //        WorldPacket emptyPacket;
+        //        m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);  //updated code
+        //    }
+        //    return;
+        //}
+
+        // handle flying acknowledgement
+        //case SMSG_MOVE_SET_CAN_FLY:
+        //{
+        //    WorldPacket p(packet);
+        //    ObjectGuid guid;
+        //    //packetfix
+        //    //guid = extractGuid(p);
+
+        //    p >> guid;
+        //    if (guid != m_bot->GetGUID())
+        //        return;
+        //    m_bot->m_movementInfo.AddMovementFlag(MOVEMENTFLAG_FLYING);
+        //    //m_bot->SetSpeed(MOVE_RUN, m_master->GetSpeed(MOVE_FLIGHT) +0.1f, true);
+        //    return;
+        //}
+
+        // handle dismount flying acknowledgement
+        //case SMSG_MOVE_UNSET_CAN_FLY:
+        //{
+        //    WorldPacket p(packet);
+        //    ObjectGuid guid;
+        //    //packetfix
+        //    //guid = extractGuid(p);
+
+        //    p >> guid;
+        //    if (guid != m_bot->GetGUID())
+        //        return;
+        //    m_bot->m_movementInfo.RemoveMovementFlag(MOVEMENTFLAG_FLYING);
+        //    //m_bot->SetSpeed(MOVE_RUN,m_master->GetSpeedRate(MOVE_RUN),true);
+        //    return;
+        //}
+
+        // If the leader role was given to the bot automatically give it to the master
+        // if the master is in the group, otherwise leave group
+        case SMSG_GROUP_SET_LEADER:
+        {
+            WorldPacket p(packet);
+            std::string name;
+            p >> name;
+            if (m_bot->GetGroup() && name == m_bot->GetName())
+            {
+                if (m_bot->GetGroup()->IsMember(m_master->GetGUID()))
+                {
+                    p.resize(8);
+                    p << m_master->GetGUID();
+                    m_bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                }
+                else
+                {
+                    p.clear(); // not really needed
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p); // packet not used updated code
+                }
+            }
+            return;
+        }
+
+        // If the master leaves the group, then the bot leaves too
+        case SMSG_PARTY_COMMAND_RESULT:
+        {
+            WorldPacket p(packet);
+            uint32 operation;
+            p >> operation;
+            std::string member;
+            p >> member;
+            uint32 result;
+            p >> result;
+            p.clear();
+            if (operation == PARTY_OP_LEAVE)
+                if (member == m_master->GetName())
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p);  // packet not used updated code
+            return;
+        }
+
+        // Handle Group invites (auto accept if master is in group, otherwise decline & send message
+        case SMSG_GROUP_INVITE:
+        {
+            //if (const Group* const grp = m_bot->GetGroupInvite())
+            //{
+            //    Player* inviter = ObjectAccessor::FindPlayer(grp->GetLeaderGUID());
+            //    if (!inviter)
+            //        return;
+
+            //    WorldPacket p;
+            //    if (!canObeyCommandFrom(*inviter))
+            //    {
+            //        std::string buf = "I can't accept your invite unless you first invite my master ";
+            //        buf += m_master->GetName();
+            //        buf += ".";
+            //        SendWhisper(buf, *inviter);
+            //        m_bot->GetSession()->HandleGroupDeclineOpcode(p); // packet not used
+            //    }
+            //    else
+            //        m_bot->GetSession()->HandleGroupAcceptOpcode(p);  // packet not used
+            //}
+            return;
+        }
+
+        // Handle when another player opens the trade window with the bot
+        // also sends list of tradable items bot can trade if bot is allowed to obey commands from
+        case SMSG_TRADE_STATUS:
+        {
+            if (m_bot->GetTrader() == NULL)
+                break;
+
+            WorldPacket p(packet);
+            uint32 status;
+            p >> status;
+            p.resize(4);
+
+            if (status == TRADE_STATUS_TRADE_ACCEPT)
+            {
+                m_bot->GetSession()->HandleAcceptTradeOpcode(p);  // packet not used
+                SetQuestNeedItems();
+            }
+
+            else if (status == TRADE_STATUS_BEGIN_TRADE)
+            {
+                m_bot->GetSession()->HandleBeginTradeOpcode(p); // packet not used
+
+                if (!canObeyCommandFrom(*(m_bot->GetTrader())))
+                {
+                    // TODO: Really? What if I give a bot all my junk so it's inventory is full when a nice green/blue/purple comes along?
+                    SendWhisper("I'm not allowed to trade you any of my items, but you are free to give me money or items.", *(m_bot->GetTrader()));
+                    return;
+                }
+
+                // list out items available for trade
+                std::ostringstream out;
+                std::list<std::string> lsItemsTradable;
+                std::list<std::string> lsItemsUntradable;
+
+                // list out items in main backpack
+                for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+                {
+                    const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                    if (pItem)
+                    {
+                        MakeItemLink(pItem, out, true);
+                        if (pItem->CanBeTraded())
+                            lsItemsTradable.push_back(out.str());
+                        else
+                            lsItemsUntradable.push_back(out.str());
+                        out.str("");
+                    }
+                }
+
+                // list out items in other removable backpacks
+                for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+                {
+                    const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                    if (pBag)
+                        // Very cool, but unnecessary
+                        //const ItemTemplate* const pBagProto = pBag->GetTemplate();
+                        //std::string bagName = pBagProto->Name1;
+                        //ItemLocalization(bagName, pBagProto->ItemId);
+
+                        for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                        {
+                            const Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                            if (pItem)
+                            {
+                                MakeItemLink(pItem, out, true);
+                                if (pItem->CanBeTraded())
+                                    lsItemsTradable.push_back(out.str());
+                                else
+                                    lsItemsUntradable.push_back(out.str());
+                                out.str("");
+                            }
+                        }
+                }
+
+                ChatHandler ch(m_bot->GetTrader()->GetSession());
+                out.str("");
+                out << "Items I have but cannot trade:";
+                uint32 count = 0;
+                for (std::list<std::string>::iterator iter = lsItemsUntradable.begin(); iter != lsItemsUntradable.end(); iter++)
+                {
+                    out << (*iter);
+                    // Why this roundabout way of posting max 20 items per whisper? To keep the list scrollable.
+                    count++;
+                    if (count % 20 == 0)
+                    {
+                        ch.SendSysMessage(out.str().c_str());
+                        out.str("");
+                    }
+                }
+                if (count > 0)
+                    ch.SendSysMessage(out.str().c_str());
+
+                out.str("");
+                out << "I could give you:";
+                count = 0;
+                for (std::list<std::string>::iterator iter = lsItemsTradable.begin(); iter != lsItemsTradable.end(); iter++)
+                {
+                    out << (*iter);
+                    // Why this roundabout way of posting max 20 items per whisper? To keep the list scrollable.
+                    count++;
+                    if (count % 20 == 0)
+                    {
+                        ch.SendSysMessage(out.str().c_str());
+                        out.str("");
+                    }
+                }
+                if (count > 0)
+                    ch.SendSysMessage(out.str().c_str());
+                else
+                    ch.SendSysMessage("I have nothing to give you.");
+
+                // calculate how much money bot has
+                // send bot the message
+                uint32 copper = m_bot->GetMoney();
+                out.str("");
+                out << "I have |cff00ff00" << Cash(copper) << "|r";
+                SendWhisper(out.str().c_str(), *(m_bot->GetTrader()));
+            }
+            return;
+        }
+
+        case SMSG_SPELL_START:
+        {
+            WorldPacket p(packet);
+
+            //packetfix
+            ObjectGuid castItemGuid;
+            ObjectGuid casterGuid;
+            p >> castItemGuid;
+            p >> casterGuid;
+            if (casterGuid != m_bot->GetGUID())
+                return;
+
+            uint8 castCount;
+            p >> castCount;
+            uint32 spellId;
+            p >> spellId;
+            uint32 castFlags;
+            p >> castFlags;
+            uint32 msTime;
+            p >> msTime;
+
+            const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (!pSpellInfo)
+                return;
+
+            if (pSpellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED)
+                return;
+
+            m_ignoreAIUpdatesUntilTime = time(NULL) + (msTime / 1000) + 1;
+
+            return;
+        }
+
+        case SMSG_SPELL_GO:
+        {
+            WorldPacket p(packet);
+
+            //packetfix
+            ObjectGuid castItemGuid;
+            ObjectGuid casterGuid;
+            p >> castItemGuid;
+            p >> casterGuid;
+            if (casterGuid != m_bot->GetGUID())
+                return;
+
+            uint8 castCount;
+            p >> castCount;
+            uint32 spellId;
+            p >> spellId;
+            uint32 castFlags;
+            p >> castFlags;
+            uint32 msTime;
+            p >> msTime;
+
+            return;
+        }
+
+        // if someone tries to resurrect, then accept
+        case SMSG_RESURRECT_REQUEST:
+        {
+            if (!m_bot->IsAlive())
+            {
+                WorldPacket p(packet);
+                ObjectGuid guid;
+                p >> guid;
+
+                WorldPacket* const packet = new WorldPacket(CMSG_RESURRECT_RESPONSE, 8 + 1);
+                *packet << guid;
+                *packet << uint8(1);                        // accept
+                m_bot->GetSession()->QueuePacket(packet);   // queue the packet to get around race condition
+
+                // set back to normal
+                SetState(BOTSTATE_NORMAL);
+                SetIgnoreUpdateTime(0);
+            }
+            return;
+        }
+
+        case SMSG_LOOT_RESPONSE:
+        {
+            WorldPacket p(packet); // (8+1+4+1+1+4+4+4+4+4+1)
+            ObjectGuid guid;
+            uint8 loot_type;
+            uint32 gold;
+            uint8 items;
+
+            p >> guid;      // 8 corpse guid
+            p >> loot_type; // 1 loot type
+            p >> gold;      // 4 money on corpse
+            p >> items;     // 1 number of items on corpse
+
+            if (gold > 0)
+            {
+                WorldPacket* const packet = new WorldPacket(CMSG_LOOT_MONEY, 0);
+                m_bot->GetSession()->QueuePacket(packet);
+            }
+
+            for (uint8 i = 0; i < items; ++i)
+            {
+                uint32 itemid;
+                uint32 itemcount;
+                uint8 lootslot_type;
+                uint8 itemindex;
+
+                p >> itemindex;         // 1 counter
+                p >> itemid;            // 4 itemid
+                p >> itemcount;         // 4 item stack count
+                p.read_skip<uint32>();  // 4 item model
+                p.read_skip<uint32>();  // 4 randomSuffix
+                p.read_skip<uint32>();  // 4 randomPropertyId
+                p >> lootslot_type;     // 1 LootSlotType
+
+                if (lootslot_type != LOOT_SLOT_TYPE_ALLOW_LOOT && lootslot_type != LOOT_SLOT_TYPE_OWNER)
+                    continue;
+
+                // skinning or collect loot flag = just auto loot everything for getting object
+                // corpse = run checks
+                if (loot_type == LOOT_SKINNING || HasCollectFlag(COLLECT_FLAG_LOOT) ||
+                    (loot_type == LOOT_CORPSE && (IsInQuestItemList(itemid) || IsItemUseful(itemid))))
+                {
+                    WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_LOOT_ITEM, 1);
+                    *packet << itemindex;
+                    m_bot->GetSession()->QueuePacket(packet);
+                }
+            }
+
+            // release loot
+            WorldPacket* const packet = new WorldPacket(CMSG_LOOT_RELEASE, 8);
+            *packet << guid;
+            m_bot->GetSession()->QueuePacket(packet);
+
+            return;
+        }
+
+        case SMSG_LOOT_RELEASE_RESPONSE:
+        {
+            WorldPacket p(packet);
+            ObjectGuid guid;
+
+            p >> guid;
+
+            if (guid == m_lootCurrent)
+            {
+                Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+
+                if (c && c->GetCreatureTemplate()->SkinLootId && c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE)/*!c->lootForSkin*/)
+                {
+                    uint32 reqSkill = c->GetCreatureTemplate()->GetRequiredLootSkill();
+                    // check if it is a leather skin and if it is to be collected (could be ore or herb)
+                    if (m_bot->HasSkill(reqSkill) && ((reqSkill != SKILL_SKINNING) ||
+                        (HasCollectFlag(COLLECT_FLAG_SKIN) && reqSkill == SKILL_SKINNING)))
+                    {
+                        // calculate skill requirement
+                        uint32 skillValue = m_bot->GetPureSkillValue(reqSkill);
+                        uint32 targetLevel = c->getLevel();
+                        uint32 reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+                        if (skillValue >= reqSkillValue)
+                        {
+                            if (m_lootCurrent != m_lootPrev)    // if this wasn't previous loot try again
+                            {
+                                m_lootPrev = m_lootCurrent;
+                                SetIgnoreUpdateTime(0);
+                                return; // so that the DoLoot function is called again to get skin
+                            }
+                        }
+                        else
+                            TellMaster("My skill is %u but it requires %u", skillValue, reqSkillValue);
+                    }
+                }
+
+                // if previous is current, clear
+                if (m_lootPrev == m_lootCurrent)
+                    m_lootPrev = ObjectGuid::Empty;
+                // clear current target
+                m_lootCurrent = ObjectGuid::Empty;
+                // clear movement
+                m_bot->GetMotionMaster()->Clear();
+                m_bot->GetMotionMaster()->MoveIdle();
+                SetIgnoreUpdateTime(0);
+            }
+
+            return;
+        }
+
+        case SMSG_BUY_ITEM:
+        {
+            WorldPacket p(packet);  // (8+4+4+4
+            ObjectGuid vguid;
+            p >> vguid;
+            uint32 vendorslot;
+            p >> vendorslot;
+            p.resize(20);
+
+            vendorslot = vendorslot - 1;
+            Creature *pCreature = m_bot->GetNPCIfCanInteractWith(vguid, UNIT_NPC_FLAG_VENDOR);
+            if (!pCreature)
+                return;
+
+            VendorItemData const* vItems = pCreature->GetVendorItems();
+            if (!vItems || vItems->Empty())
+                return;
+
+            uint32 vCount = vItems ? vItems->GetItemCount() : 0;
+
+            if (vendorslot >= vCount)
+                return;
+
+            VendorItem const* crItem = vendorslot < vCount ? vItems->GetItem(vendorslot) : NULL;
+            if (!crItem)
+                return;
+
+            ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(crItem->item);
+            if (pProto)
+            {
+                std::ostringstream out;
+                out << "|cff009900" << "I received item: |r";
+                MakeItemLink(pProto, out);
+                TellMaster(out.str().c_str());
+            }
+            return;
+        }
+
+        case SMSG_ITEM_PUSH_RESULT:
+        {
+            WorldPacket p(packet);  // (8+4+4+4+1+4+4+4+4+4+4)
+            ObjectGuid guid;
+
+            p >> guid;              // 8 player guid
+            if (m_bot->GetGUID() != guid)
+                return;
+
+            uint8 bagslot;
+            uint32 itemslot, itemid, count, totalcount, received, created;
+
+            p >> received;          // 4 0=looted, 1=from npc
+            p >> created;           // 4 0=received, 1=created
+            p.read_skip<uint32>();  // 4 IsShowChatMessage
+            p >> bagslot;           // 1 bagslot
+            p >> itemslot;          // 4 item slot, but when added to stack: 0xFFFFFFFF
+            p >> itemid;            // 4 item entry id
+            p.read_skip<uint32>();  // 4 SuffixFactor
+            p.read_skip<uint32>();  // 4 random item property id
+            p >> count;             // 4 count of items
+            p >> totalcount;        // 4 count of items in inventory
+
+            ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(itemid);
+            if (pProto)
+            {
+                std::ostringstream out;
+                if (received == 1)
+                {
+                    if (created == 1)
+                        out << "|cff009900" << "I created: |r";
+                    else
+                        out << "|cff009900" << "I received: |r";
+                    MakeItemLink(pProto, out);
+                    TellMaster(out.str().c_str());
+                    Player* const bot = GetPlayerBot();
+                    AutoUpgradeEquipment(*bot);
+                }
+            }
+
+            if (IsInQuestItemList(itemid))
+            {
+                m_needItemList[itemid] = (m_needItemList[itemid] - count);
+                if (m_needItemList[itemid] <= 0)
+                    m_needItemList.erase(itemid);
+            }
+
+            return;
+        }
+
+            /* uncomment this and your bots will tell you all their outgoing packet opcode names
+               case SMSG_MONSTER_MOVE:
+               case SMSG_UPDATE_WORLD_STATE:
+               case SMSG_COMPRESSED_UPDATE_OBJECT:
+               case MSG_MOVE_SET_FACING:
+               case MSG_MOVE_STOP:
+               case MSG_MOVE_HEARTBEAT:
+               case MSG_MOVE_STOP_STRAFE:
+               case MSG_MOVE_START_STRAFE_LEFT:
+               case SMSG_UPDATE_OBJECT:
+               case MSG_MOVE_START_FORWARD:
+               case MSG_MOVE_START_STRAFE_RIGHT:
+               case SMSG_DESTROY_OBJECT:
+               case MSG_MOVE_START_BACKWARD:
+               case SMSG_AURA_UPDATE_ALL:
+               case MSG_MOVE_FALL_LAND:
+               case MSG_MOVE_JUMP:
+                return;
+
+               default:
+               {
+                const char* oc = LookupOpcodeName(packet.GetOpcode());
+
+                std::ostringstream out;
+                out << "botout: " << oc;
+                //sLog->outError(out.str().c_str());
+
+                //TellMaster(oc);
+               }
+             */
+    }
+}
+
+uint8 PlayerbotAI::GetHealthPercent(const Unit& target) const
+{
+    return (static_cast<float> (target.GetHealth()) / target.GetMaxHealth()) * 100;
+}
+
+uint8 PlayerbotAI::GetHealthPercent() const
+{
+    return GetHealthPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetManaPercent(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+
+uint8 PlayerbotAI::GetManaPercent() const
+{
+    return GetManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent(const Unit& target) const
+{
+    if (target.GetPower(POWER_MANA) >= target.GetCreateMana())
+        return (100);
+    else
+        return (static_cast<float> (target.GetPower(POWER_MANA)) / target.GetCreateMana()) * 100;
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent() const
+{
+    return GetBaseManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRageAmount(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_RAGE)));
+}
+
+uint8 PlayerbotAI::GetRageAmount() const
+{
+    return GetRageAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetEnergyAmount(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_ENERGY)));
+}
+
+uint8 PlayerbotAI::GetEnergyAmount() const
+{
+    return GetEnergyAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRunicPower(const Unit& target) const
+{
+    return (static_cast<float>(target.GetPower(POWER_RUNIC_POWER)));
+}
+
+uint8 PlayerbotAI::GetRunicPower() const
+{
+    return GetRunicPower(*m_bot);
+}
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit& player) const
+{
+    if (spellId <= 0)
+        return false;
+    return player.HasAura(spellId);
+}
+
+bool PlayerbotAI::HasAura(const char* spellName) const
+{
+    return HasAura(spellName, *m_bot);
+}
+
+bool PlayerbotAI::HasAura(const char* spellName, const Unit& player) const
+{
+    uint32 spellId = getSpellId(spellName);
+    return (spellId) ? HasAura(spellId, player) : false;
+}
+
+Item* PlayerbotAI::FindFood() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+            {
+                //TellMaster("Found Consumable %s in backpack, slot %u", !pItemProto->Name1.empty() ? pItemProto->Name1.c_str() : NULL, slot);
+                for (uint8 i = 0; i != 5; ++i)
+                {
+                    if (pItemProto->Spells[i].SpellCategory == SPELL_CATEGORY_FOOD)
+                    {
+                        //TellMaster("It's a food! (spell: %u)", i);
+                        return pItem;
+                    }
+                }
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+                    {
+                        //TellMaster("Found Consumable %s in bag %u, slot %u", !pItemProto->Name1.empty() ? pItemProto->Name1.c_str() : NULL, bag, slot);
+                        for (uint8 i = 0; i != 5; ++i)
+                        {
+                            if (pItemProto->Spells[i].SpellCategory == SPELL_CATEGORY_FOOD)
+                            {
+                                //TellMaster("It's a food! (spell: %u)", i);
+                                return pItem;
+                            }
+                        }
+                    }
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindDrink() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+            {
+                //TellMaster("Found Consumable %s in backpack, slot %u", !pItemProto->Name1.empty() ? pItemProto->Name1.c_str() : NULL, slot);
+                for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    if (pItemProto->Spells[i].SpellCategory == SPELL_CATEGORY_DRINK)
+                    {
+                        //TellMaster("It's a drink! (spell: %u)", i);
+                        return pItem;
+                    }
+                }
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+                    {
+                        //TellMaster("Found Consumable %s in bag %u, slot %u", !pItemProto->Name1.empty() ? pItemProto->Name1.c_str() : NULL, bag, slot);
+                        for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+                        {
+                            if (pItemProto->Spells[i].SpellCategory == SPELL_CATEGORY_DRINK)
+                            {
+                                //TellMaster("It's a drink! (spell: %u)", i);
+                                return pItem;
+                            }
+                        }
+                    }
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindBandage() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+//Find Poison ...Natsukawa
+Item* PlayerbotAI::FindPoison() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_ITEM_ENHANCEMENT)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_ITEM_ENHANCEMENT)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindConsumable(uint32 displayId) const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->DisplayInfoID == displayId)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->DisplayInfoID == displayId)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+void PlayerbotAI::InterruptCurrentCastingSpell()
+{
+    //TellMaster("I'm interrupting my current spell!");
+    WorldPacket* const packet = new WorldPacket(CMSG_CANCEL_CAST, 5);  //changed from thetourist suggestion
+    *packet << m_CurrentlyCastingSpellId;
+    *packet << m_targetGuidCommand;   //changed from thetourist suggestion
+    m_CurrentlyCastingSpellId = 0;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+void PlayerbotAI::Feast()
+{
+    // stand up if we are done feasting
+    if (!(m_bot->GetHealth() < m_bot->GetMaxHealth() || (m_bot->getPowerType() == POWER_MANA && m_bot->GetPower(POWER_MANA) < m_bot->GetMaxPower(POWER_MANA))))
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        return;
+    }
+
+    // wait 3 seconds before checking if we need to drink more or eat more
+    time_t currentTime = time(NULL);
+    m_ignoreAIUpdatesUntilTime = currentTime + 3;
+
+    // should we drink another
+    if (m_bot->getPowerType() == POWER_MANA && currentTime > m_TimeDoneDrinking
+        && ((static_cast<float> (m_bot->GetPower(POWER_MANA)) / m_bot->GetMaxPower(POWER_MANA)) < 0.8))
+    {
+        Item* pItem = FindDrink();
+        if (pItem != NULL)
+        {
+            UseItem(pItem);
+            m_TimeDoneDrinking = currentTime + 30;
+            return;
+        }
+        TellMaster("I need water.");
+    }
+
+    // should we eat another
+    if (currentTime > m_TimeDoneEating && ((static_cast<float> (m_bot->GetHealth()) / m_bot->GetMaxHealth()) < 0.8))
+    {
+        Item* pItem = FindFood();
+        if (pItem != NULL)
+        {
+            //TellMaster("eating now...");
+            UseItem(pItem);
+            m_TimeDoneEating = currentTime + 30;
+            return;
+        }
+        TellMaster("I need food.");
+    }
+
+    // if we are no longer eating or drinking
+    // because we are out of items or we are above 80% in both stats
+    if (currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking)
+    {
+        TellMaster("done feasting!");
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+}
+
+// intelligently sets a reasonable combat order for this bot
+// based on its class / level / etc
+void PlayerbotAI::GetCombatTarget(Unit* forcedTarget)
+{
+    // set combat state, and clear looting, etc...
+    if (m_botState != BOTSTATE_COMBAT)
+    {
+        SetState(BOTSTATE_COMBAT);
+        // m_lootCurrent = ObjectGuid(); This was clearing loot target, causing bots to leave corpses unlooted if interupted by combat. Needs testing.
+        // using this caused bot to remove current loot target, and add this new threat to the loot list.  Now it remembers the loot target and adds a new one.
+        // Bot will still clear the target if the master gets too far away from it.
+        m_targetCombat = 0;
+    }
+
+    // update attacker info now
+    UpdateAttackerInfo();
+
+    // check for attackers on protected unit, and make it a forcedTarget if any
+    if (!forcedTarget && (m_combatOrder & ORDERS_PROTECT) && m_targetProtect != 0)
+    {
+        Unit *newTarget = FindAttacker((ATTACKERINFOTYPE) (AIT_VICTIMNOTSELF | AIT_HIGHESTTHREAT), m_targetProtect);
+        if (newTarget && newTarget != m_targetCombat)
+        {
+            forcedTarget = newTarget;
+            m_targetType = TARGET_THREATEN;
+            if (m_confDebugWhisper)
+                TellMaster("Changing target to %s to protect %s", forcedTarget->GetName().c_str(), m_targetProtect->GetName().c_str());
+        }
+    }
+    else if (forcedTarget)
+    {
+        if (m_confDebugWhisper)
+            TellMaster("Changing target to %s by force!", forcedTarget->GetName().c_str());
+        m_targetType = (m_combatOrder == ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+    }
+
+    // we already have a target and we are not forced to change it
+    if (m_targetCombat && !forcedTarget)
+        return;
+
+    // are we forced on a target?
+    if (forcedTarget)
+    {
+        m_targetCombat = forcedTarget;
+        m_targetChanged = true;
+    }
+    // do we have to assist someone?
+    if (!m_targetCombat && (m_combatOrder & ORDERS_ASSIST) && m_targetAssist != 0)
+    {
+        m_targetCombat = FindAttacker((ATTACKERINFOTYPE) (AIT_VICTIMNOTSELF | AIT_LOWESTTHREAT), m_targetAssist);
+        if (m_confDebugWhisper && m_targetCombat)
+            TellMaster("Attacking %s to assist %s", m_targetCombat->GetName().c_str(), m_targetAssist->GetName().c_str());
+        m_targetType = (m_combatOrder == ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+        m_targetChanged = true;
+    }
+    // are there any other attackers?
+    if (!m_targetCombat)
+    {
+        m_targetCombat = FindAttacker();
+        m_targetType = (m_combatOrder == ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+        m_targetChanged = true;
+    }
+    // no attacker found anyway
+    if (!m_targetCombat || !m_targetCombat->IsVisible() || !m_targetCombat->isTargetableForAttack())
+    {
+        m_targetType = TARGET_NORMAL;
+        m_targetChanged = false;
+        return;
+    }
+
+    // if thing to attack is in a duel, then ignore and don't call updateAI for 6 seconds
+    // this method never gets called when the bot is in a duel and this code
+    // prevents bot from helping
+    if (m_targetCombat->GetTypeId() == TYPEID_PLAYER && m_targetCombat->ToPlayer()->duel)
+    {
+        m_ignoreAIUpdatesUntilTime = time(NULL) + 6;
+        return;
+    }
+
+    m_bot->SetSelection(m_targetCombat->GetGUID());
+    m_ignoreAIUpdatesUntilTime = time(NULL) + 1;
+
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    m_bot->Attack(m_targetCombat, true);
+    //temp
+    if (m_targetCombat->GetMapId() == m_bot->GetMapId())
+    {
+        m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
+        GetClassAI()->DoNextCombatManeuver(m_targetCombat);
+    }
+    m_targetCombatGUID = m_targetCombat->GetGUID();
+
+    // add thingToAttack to loot list
+    if (Creature *cre = m_targetCombat->ToCreature())
+        if (cre->GetCreatureTemplate()->lootid != 0)
+            m_lootTargets.push_back(m_targetCombat->GetGUID());
+
+    return;
+}
+
+void PlayerbotAI::GetDuelTarget(Unit* forcedTarget)
+{
+    // set combat state, and clear looting, etc...
+    if (m_botState != BOTSTATE_COMBAT)
+    {
+        SetState(BOTSTATE_COMBAT);
+        m_targetChanged = true;
+        m_targetCombat = forcedTarget;
+        m_targetType = TARGET_THREATEN;
+        m_combatStyle = COMBAT_MELEE;
+    }
+    m_bot->Attack(m_targetCombat, true);
+}
+
+void PlayerbotAI::DoNextCombatManeuver()
+{
+    if (m_combatOrder == ORDERS_PASSIVE)
+        return;
+
+    // check for new targets
+    if (m_ScenarioType == SCENARIO_DUEL)
+        GetDuelTarget(m_master);
+    else if (Unit *u = m_master->GetVictim())
+        GetCombatTarget(u);
+    else
+        GetCombatTarget();
+
+    // check if we have a target - fixes crash reported by rrtn (kill hunter's pet bug)
+    // if current target for attacks doesn't make sense anymore
+    // clear our orders so we can get orders in next update
+    m_targetCombat = ObjectAccessor::FindConnectedPlayer(m_targetCombatGUID);
+    if (!m_targetCombat ||
+        m_targetCombat->isDead() ||
+        !m_targetCombat->IsInWorld() ||
+        !m_targetCombat->IsVisible() ||
+        !m_targetCombat->isTargetableForAttack() ||
+        //!m_bot->IsHostileTo(m_targetCombat) ||
+        !m_bot->IsInMap(m_targetCombat))
+    {
+        m_bot->AttackStop();
+        m_bot->SetSelection(ObjectGuid::Empty);
+        MovementReset();
+        m_bot->InterruptNonMeleeSpells(true);
+        m_targetCombat = 0;
+        m_targetChanged = false;
+        m_targetType = TARGET_NORMAL;
+        SetQuestNeedCreatures();
+        return;
+    }
+
+    // do opening moves, if we changed target
+    if (m_targetChanged)
+    {
+        if (m_classAI)
+            m_targetChanged = m_classAI->DoFirstCombatManeuver(m_targetCombat);
+        else
+            m_targetChanged = false;
+    }
+
+    // do normal combat movement
+    DoCombatMovement();
+
+    if (m_classAI && !m_targetChanged)
+        m_classAI->DoNextCombatManeuver(m_targetCombat);
+}
+
+void PlayerbotAI::DoCombatMovement()
+{
+    if (!m_targetCombat) return;
+
+    float targetDist = m_classAI->GetCombatDistance(m_targetCombat);
+    //float radius = m_targetCombat->GetFloatValue(UNIT_FIELD_COMBATREACH)/* + m_bot->GetFloatValue(UNIT_FIELD_COMBATREACH)*/;
+    //float dx = m_bot->GetPositionX() - m_targetCombat->GetPositionX();
+    //float dy = m_bot->GetPositionY() - m_targetCombat->GetPositionY();
+    //float dz = m_bot->GetPositionZ() - m_targetCombat->GetPositionZ();
+    //float targetDist = sqrt((dx*dx) + (dy*dy) + (dz*dz)) - radius;
+    targetDist > 0 ? targetDist : 0;
+
+    m_bot->SetFacingTo(m_bot->GetAngle(m_targetCombat));
+
+    if (m_combatStyle == COMBAT_MELEE && !m_bot->HasUnitState(UNIT_STATE_CHASE) && ((m_movementOrder == MOVEMENT_STAY && targetDist < ATTACK_DISTANCE) || (m_movementOrder != MOVEMENT_STAY)))
+        // melee combat - chase target if in range or if we are not forced to stay
+        m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
+    else if (m_combatStyle == COMBAT_RANGED && m_movementOrder != MOVEMENT_STAY)
+    {
+        // ranged combat - just move within spell range
+        // TODO: just follow in spell range! how to determine bots spell range?
+        if (targetDist > 20.0f)
+            m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
+        else
+            MovementClear();
+    }
+}
+
+void PlayerbotAI::SetQuestNeedCreatures()
+{
+    // reset values first
+    m_needCreatureOrGOList.clear();
+
+    // run through accepted quests, get quest info and data
+    for (int qs = 0; qs < MAX_QUEST_LOG_SIZE; ++qs)
+    {
+        uint32 questid = m_bot->GetQuestSlotQuestId(qs);
+        if (questid == 0)
+            continue;
+
+        QuestStatusData &qData = m_bot->getQuestStatusMap()[questid];
+        // only check quest if it is incomplete
+        if (qData.Status != QUEST_STATUS_INCOMPLETE)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+
+        // All creature/GO slain/casted (not required, but otherwise it will display "Creature slain 0/10")
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+        {
+            if (!qInfo->RequiredNpcOrGoCount[i] || (qInfo->RequiredNpcOrGoCount[i] - qData.CreatureOrGOCount[i]) <= 0)
+                continue;
+            m_needCreatureOrGOList[qInfo->RequiredNpcOrGo[i]] = (qInfo->RequiredNpcOrGoCount[i] - qData.CreatureOrGOCount[i]);
+        }
+    }
+}
+
+void PlayerbotAI::SetQuestNeedItems()
+{
+    // reset values first
+    m_needItemList.clear();
+
+    // run through accepted quests, get quest info and data
+    for (int qs = 0; qs < MAX_QUEST_LOG_SIZE; ++qs)
+    {
+        uint32 questid = m_bot->GetQuestSlotQuestId(qs);
+        if (questid == 0)
+            continue;
+
+        QuestStatusData &qData = m_bot->getQuestStatusMap()[questid];
+        // only check quest if it is incomplete
+        if (qData.Status != QUEST_STATUS_INCOMPLETE)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+
+        // check for items we not have enough of
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+        {
+            if (!qInfo->RequiredItemCount[i] || (qInfo->RequiredItemCount[i] - qData.ItemCount[i]) <= 0)
+                continue;
+            m_needItemList[qInfo->RequiredItemId[i]] = (qInfo->RequiredItemCount[i] - qData.ItemCount[i]);
+
+            // collect flags not set to gather quest objects skip remaining section
+            if (!HasCollectFlag(COLLECT_FLAG_NEAROBJECT) && !HasCollectFlag(COLLECT_FLAG_QUEST))
+                continue;
+/* questitem1-6 removed from table.
+            // TODO: find faster way to handle this look up instead of using SQL lookup for each item
+            QueryResult result;
+            // determine if GOs are needed
+            result = WorldDatabase.PQuery("SELECT entry FROM gameobject_template WHERE questItem1='%u' "
+                "OR questItem2='%u' OR questItem3='%u' OR questItem4='%u' OR questItem5='%u' OR questItem6='%u'",
+                qInfo->RequiredItemId[i], qInfo->RequiredItemId[i], qInfo->RequiredItemId[i], qInfo->RequiredItemId[i],
+                qInfo->RequiredItemId[i], qInfo->RequiredItemId[i]);
+
+            if (result)
+            {
+                do
+                {
+                    Field *fields = result->Fetch();
+                    uint32 entry = fields[0].GetUInt32();
+
+                    GameObjectTemplate const * gInfo = sObjectMgr->GetGameObjectTemplate(entry);
+                    if (!gInfo)
+                        continue;
+
+                    // add this GO to our collection list if is chest/ore/herb
+                    if (gInfo->type == GAMEOBJECT_TYPE_CHEST)
+                    {
+                        m_collectObjects.push_back(entry);
+                        m_collectObjects.sort();
+                        m_collectObjects.unique();
+                    }
+                } while (result->NextRow());
+
+                ////delete result;
+            }*/
+        }
+    }
+}
+
+void PlayerbotAI::SetState(BotState state)
+{
+    // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: SetState - %s switch state %d to %d", m_bot->GetName(), m_botState, state );
+    m_botState = state;
+}
+
+uint8 PlayerbotAI::GetFreeBagSpace() const
+{
+    uint8 space = 0;
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+    {
+        Item *pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (!pItem)
+            ++space;
+    }
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        Bag* pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (pBag && pBag->GetTemplate()->BagFamily == BAG_FAMILY_MASK_NONE)
+            space += pBag->GetFreeSlots();
+    }
+    return space;
+}
+
+void PlayerbotAI::DoFlight()
+{
+    //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoFlight - %s : %u", m_bot->GetName(), m_taxiMaster);
+
+    Creature *npc = m_bot->GetNPCIfCanInteractWith(m_taxiMaster, UNIT_NPC_FLAG_FLIGHTMASTER);
+    if (!npc)
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoFlight - %u not found or you can't interact with it.");
+        return;
+    }
+
+    m_bot->ActivateTaxiPathTo(m_taxiNodes, npc);
+}
+
+void PlayerbotAI::DoLoot()
+{
+    // clear BOTSTATE_LOOTING if no more loot targets
+    if (!m_lootCurrent && m_lootTargets.empty())
+    {
+        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoLoot - %s is going back to idle", m_bot->GetName() );
+        SetState(BOTSTATE_NORMAL);
+        m_bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
+        m_inventory_full = false;
+        return;
+    }
+
+    // set first in list to current
+    if (!m_lootCurrent)
+    {
+        m_lootCurrent = m_lootTargets.front();
+        m_lootTargets.pop_front();
+    }
+
+    WorldObject *wo = //ObjectAccessor::GetObjectInMap(m_lootCurrent, m_bot->GetMap(), (WorldObject*)NULL);
+    (WorldObject*)ObjectAccessor::GetObjectByTypeMask(*m_bot, m_lootCurrent, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+
+    // clear invalid object or object that is too far from master
+    if (!wo || m_master->GetDistance(wo) > float(m_confCollectDistanceMax))
+    {
+        m_lootCurrent = ObjectGuid::Empty;
+        return;
+    }
+
+    Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+    GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+
+    // clear creature or object that is not spawned or if not creature or object
+    if ((c && !m_bot->CanSeeOrDetect(c)) || (go && !go->isSpawned()) || (!c && !go))
+    {
+        m_lootCurrent = ObjectGuid::Empty;
+        return;
+    }
+
+    uint32 skillId = 0;
+
+    if (c)
+    {
+        if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+            skillId = c->GetCreatureTemplate()->GetRequiredLootSkill();
+
+        // not a lootable creature, clear it
+        if (!c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) &&
+            (!c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) ||
+             (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && !m_bot->HasSkill(skillId))))
+        {
+            m_lootCurrent = ObjectGuid::Empty;
+            // clear movement target, take next target on next update
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+            return;
+        }
+    }
+
+    if (m_bot->GetDistance(wo) > CONTACT_DISTANCE + wo->GetObjectSize())
+    {
+        float x, y, z;
+        wo->GetContactPoint(m_bot, x, y, z, 0.1f);
+        m_bot->GetMotionMaster()->MovePoint(wo->GetMapId(), x, y, z);
+        // give time to move to point before trying again
+        SetIgnoreUpdateTime(1);
+    }
+
+    if (m_bot->GetDistance(wo) < INTERACTION_DISTANCE)
+    {
+        uint32 reqSkillValue = 0;
+        uint32 SkillValue = 0;
+        bool keyFailed = false;
+        bool skillFailed = false;
+        bool forceFailed = false;
+
+        if (c)  // creature
+        {
+            if (c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
+            {
+                // loot the creature
+                WorldPacket* const packet = new WorldPacket(CMSG_LOOT, 8);
+                *packet << m_lootCurrent;
+                m_bot->GetSession()->QueuePacket(packet);
+                return; // no further processing is needed
+                // m_lootCurrent is reset in SMSG_LOOT_RELEASE_RESPONSE after checking for skinloot
+            }
+            else if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+                // not all creature skins are leather, some are ore or herb
+                if (m_bot->HasSkill(skillId) && ((skillId != SKILL_SKINNING) ||
+                    (HasCollectFlag(COLLECT_FLAG_SKIN) && skillId == SKILL_SKINNING)))
+                {
+                    // calculate skinning skill requirement
+                    uint32 targetLevel = c->getLevel();
+                    reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+                }
+
+            // creatures cannot be unlocked or forced open
+            keyFailed = true;
+            forceFailed = true;
+        }
+
+        if (go) // object
+        {
+            // add this GO to our collection list if active and is chest/ore/herb
+            if (go && HasCollectFlag(COLLECT_FLAG_NEAROBJECT) && go->GetGoType() == GAMEOBJECT_TYPE_CHEST)
+            {
+                m_collectObjects.push_back(go->GetEntry());
+                m_collectObjects.sort();
+                m_collectObjects.unique();
+            }
+
+            uint32 reqItem = 0;
+
+            // check skill or lock on object
+            uint32 lockId = go->GetGOInfo()->GetLockId();
+            LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+            if (lockInfo)
+                for (int i = 0; i < 8; ++i)
+                {
+                    if (lockInfo->Type[i] == LOCK_KEY_ITEM)
+                    {
+                        if (lockInfo->Index[i] > 0)
+                        {
+                            reqItem = lockInfo->Index[i];
+                            if (m_bot->HasItemCount(reqItem, 1))
+                                break;
+                            continue;
+                        }
+                    }
+                    else if (lockInfo->Type[i] == LOCK_KEY_SKILL)
+                    {
+                        switch (LockType(lockInfo->Index[i]))
+                        {
+                            case LOCKTYPE_OPEN:
+                                if (CastSpell(3365))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_CLOSE:
+                                if (CastSpell(6233))    // Closing
+                                    return;
+                                break;
+                            case LOCKTYPE_QUICK_OPEN:
+                                if (CastSpell(6247))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_QUICK_CLOSE:
+                                if (CastSpell(6247))    // Closing
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_TINKERING:
+                                if (CastSpell(6477))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_KNEELING:
+                                if (CastSpell(6478))    // Opening; listed with 17667 and 22810
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_ATTACKING:
+                                if (CastSpell(8386))    // Attacking
+                                    return;
+                                break;
+                            case LOCKTYPE_SLOW_OPEN:
+                                if (CastSpell(21651))   // Opening; also had 26868
+                                    return;
+                                break;
+                            case LOCKTYPE_SLOW_CLOSE:
+                                if (CastSpell(21652))   // Closing
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_FROM_VEHICLE:
+                                if (CastSpell(61437))   // Opening
+                                    return;
+                                break;
+                            default:
+                                if (SkillByLockType(LockType(lockInfo->Index[i])) > 0)
+                                {
+                                    skillId = SkillByLockType(LockType(lockInfo->Index[i]));
+                                    reqSkillValue = lockInfo->Skill[i];
+                                }
+                        }
+                    }
+                }
+
+            // use key on object if available
+            if (reqItem > 0 && m_bot->HasItemCount(reqItem, 1))
+            {
+                UseItem(m_bot->GetItemByEntry(reqItem), TARGET_FLAG_GAMEOBJECT, m_lootCurrent);
+                m_lootCurrent = ObjectGuid::Empty;
+                return;
+            }
+            else
+                keyFailed = true;
+        }
+
+        // determine bot's skill value for object's required skill
+        if (skillId != SKILL_NONE)
+            SkillValue = uint32(m_bot->GetSkillValue(skillId));
+
+        // bot has the specific skill or object requires no skill at all
+        if ((m_bot->HasSkill(skillId) && skillId != SKILL_NONE) || (skillId == SKILL_NONE && go))
+        {
+            if (SkillValue >= reqSkillValue)
+            {
+                switch (skillId)
+                {
+                    case SKILL_MINING:
+                        if (HasTool(TC_MINING_PICK) && CastSpell(MINING))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_HERBALISM:
+                        if (CastSpell(HERB_GATHERING))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_SKINNING:
+                        if (c && HasCollectFlag(COLLECT_FLAG_SKIN) &&
+                            HasTool(TC_SKINNING_KNIFE) && CastSpell(SKINNING, *c))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_LOCKPICKING:
+                        if (CastSpell(PICK_LOCK_1))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_NONE:
+                        if (CastSpell(3365)) //Spell 3365 = Opening?
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    default:
+                        TellMaster("I'm not sure how to get that.");
+                        skillFailed = true;
+                        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]:DoLoot Skill %u is not implemented", skillId);
+                        break;
+                }
+            }
+            else
+            {
+                TellMaster("My skill is not high enough. It requires %u, but mine is %u.",
+                           reqSkillValue, SkillValue);
+                skillFailed = true;
+            }
+        }
+        else
+        {
+            TellMaster("I do not have the required skill.");
+            skillFailed = true;
+        }
+
+        if (go) // only go's can be forced
+        {
+            // if pickable, check if a forcible item is available for the bot
+            if (skillId == SKILL_LOCKPICKING &&
+                (m_bot->HasSkill(SKILL_BLACKSMITHING) || m_bot->HasSkill(SKILL_ENGINEERING)))
+            {
+                // check for skeleton keys appropriate for lock value
+                if (m_bot->HasSkill(SKILL_BLACKSMITHING))
+                {
+                    Item *kItem = FindKeyForLockValue(reqSkillValue);
+                    if (kItem)
+                    {
+                        TellMaster("I have a skeleton key that can open it!");
+                        UseItem(kItem, TARGET_FLAG_GAMEOBJECT, m_lootCurrent);
+                        return;
+                    }
+                    else
+                    {
+                        TellMaster("I have no skeleton keys that can open that lock.");
+                        forceFailed = true;
+                    }
+                }
+
+                // check for a charge that can blast it open
+                if (m_bot->HasSkill(SKILL_ENGINEERING))
+                {
+                    Item *bItem = FindBombForLockValue(reqSkillValue);
+                    if (bItem)
+                    {
+                        TellMaster("I can blast it open!");
+                        UseItem(bItem, TARGET_FLAG_GAMEOBJECT, m_lootCurrent);
+                        return;
+                    }
+                    else
+                    {
+                        TellMaster("I have nothing to blast it open with.");
+                        forceFailed = true;
+                    }
+                }
+            }
+            else
+                forceFailed = true;
+        }
+
+        // if all attempts failed in some way then clear because it won't get SMSG_LOOT_RESPONSE
+        if (keyFailed && skillFailed && forceFailed)
+        {
+            //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoLoot attempts failed on [%s]", go ? go->GetGOInfo()->name : c->GetCreatureTemplate()->Name);
+            m_lootCurrent = ObjectGuid::Empty;
+
+            // remove this GO from our list using the same settings that it was added with earlier
+            if (go && HasCollectFlag(COLLECT_FLAG_NEAROBJECT) && go->GetGoType() == GAMEOBJECT_TYPE_CHEST)
+                m_collectObjects.remove(go->GetEntry());
+
+            // clear movement target, take next target on next update
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+        }
+    }
+}
+
+void PlayerbotAI::AcceptQuest(Quest const *qInfo, Player *pGiver)
+{
+    if (!qInfo || !pGiver)
+        return;
+
+    uint32 quest = qInfo->GetQuestId();
+
+    if (!pGiver->CanShareQuest(qInfo->GetQuestId()))
+    {
+        // giver can't share quest
+        m_bot->SetDivider(ObjectGuid::Empty);
+        return;
+    }
+
+    if (!m_bot->CanTakeQuest(qInfo, false))
+    {
+        // can't take quest
+        m_bot->SetDivider(ObjectGuid::Empty);
+        return;
+    }
+
+    if (m_bot->GetDivider())
+    {
+        // send msg to quest giving player
+        pGiver->SendPushToPartyResponse(m_bot, QUEST_PARTY_MSG_ACCEPT_QUEST);
+        m_bot->SetDivider(ObjectGuid::Empty);
+    }
+
+    if (m_bot->CanAddQuest(qInfo, false))
+    {
+        m_bot->AddQuest(qInfo, pGiver);
+
+        if (m_bot->CanCompleteQuest(quest))
+            m_bot->CompleteQuest(quest);
+
+        // build needed items if quest contains any
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredItemCount[i] > 0)
+            {
+                SetQuestNeedItems();
+                break;
+            }
+
+        // build needed creatures if quest contains any
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredNpcOrGoCount[i] > 0)
+            {
+                SetQuestNeedCreatures();
+                break;
+            }
+
+        // Runsttren: did not add typeid switch from WorldSession::HandleQuestgiverAcceptQuestOpcode!
+        // I think it's not needed, cause typeid should be TYPEID_PLAYER - and this one is not handled
+        // there and there is no default case also.
+
+        if (qInfo->GetSrcSpell() > 0)
+            m_bot->CastSpell(m_bot, qInfo->GetSrcSpell(), true);
+    }
+}
+
+void PlayerbotAI::TurnInQuests(WorldObject *questgiver)
+{
+    ObjectGuid giverGUID = questgiver->GetGUID();
+
+    if (!m_bot->IsInMap(questgiver))
+        TellMaster("hey you are turning in quests without me!");
+    else
+    {
+        m_bot->SetSelection(giverGUID);
+
+        // auto complete every completed quest this NPC has
+        m_bot->PrepareQuestMenu(giverGUID);
+        QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+        for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+        {
+            QuestMenuItem const& qItem = questMenu.GetItem(iI);
+            uint32 questID = qItem.QuestId;
+            Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+
+            std::ostringstream out;
+            std::string questTitle  = pQuest->GetTitle();
+            QuestLocalization(questTitle, questID);
+
+            QuestStatus status = m_bot->GetQuestStatus(questID);
+
+            // if quest is complete, turn it in
+            if (status == QUEST_STATUS_COMPLETE)
+            {
+                // if bot hasn't already turned quest in
+                if (!m_bot->GetQuestRewardStatus(questID))
+                {
+                    // auto reward quest if no choice in reward
+                    if (pQuest->GetRewChoiceItemsCount() == 0)
+                    {
+                        if (m_bot->CanRewardQuest(pQuest, false))
+                        {
+                            m_bot->RewardQuest(pQuest, 0, questgiver, false);
+                            out << "Quest complete: |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                        else
+                            out << "|cffff0000Unable to turn quest in:|r |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                    }
+
+                    // auto reward quest if one item as reward
+                    else if (pQuest->GetRewChoiceItemsCount() == 1)
+                    {
+                        int rewardIdx = 0;
+                        ItemTemplate const *pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                        std::string itemName = pRewardItem->Name1;
+                        ItemLocalization(itemName, pRewardItem->ItemId);
+                        if (m_bot->CanRewardQuest(pQuest, rewardIdx, false))
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, questgiver, true);
+
+                            std::string itemName = pRewardItem->Name1;
+                            ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            out << "Quest complete: "
+                                << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                                << "|h[" << questTitle << "]|h|r reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                        else
+                            out << "|cffff0000Unable to turn quest in:|r "
+                                << "|cff808080|Hquest:" << questID << ':'
+                                << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r"
+                                << " reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                    }
+
+                    // else multiple rewards - let master pick
+                    else
+                    {
+                        out << "What reward should I take for |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                            << "|h[" << questTitle << "]|h|r? ";
+                        for (uint8 i = 0; i < pQuest->GetRewChoiceItemsCount(); ++i)
+                        {
+                            ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[i]);
+                            std::string itemName = pRewardItem->Name1;
+                            ItemLocalization(itemName, pRewardItem->ItemId);
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+                }
+            }
+
+            else if (status == QUEST_STATUS_INCOMPLETE)
+                out << "|cffff0000Quest incomplete:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+            else if (status == QUEST_STATUS_NONE && m_bot->CanTakeQuest(pQuest, false))
+                out << "|cff00ff00Quest available:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+            if (!out.str().empty())
+                TellMaster(out.str());
+        }
+        AutoUpgradeEquipment(*m_bot);
+    }
+}
+
+bool PlayerbotAI::IsInCombat()
+{
+    Pet *pet;
+    bool inCombat = false;
+    inCombat |= m_bot->IsInCombat();
+    pet = m_bot->GetPet();
+    if (pet)
+        inCombat |= pet->IsInCombat();
+    inCombat |= m_master->IsInCombat();
+    if (m_bot->GetGroup())
+    {
+        GroupReference *ref = m_bot->GetGroup()->GetFirstMember();
+        while (ref)
+        {
+            inCombat |= ref->GetSource()->IsInCombat();
+            pet = ref->GetSource()->GetPet();
+            if (pet)
+                inCombat |= pet->IsInCombat();
+            ref = ref->next();
+        }
+    }
+    return inCombat;
+}
+
+void PlayerbotAI::UpdateAttackersForTarget(Unit *victim)
+{
+    HostileReference *ref = victim->getHostileRefManager().getFirst();
+    while (ref)
+    {
+        ThreatManager *target = ref->GetSource();
+        ObjectGuid guid = target->GetOwner()->GetGUID();
+        m_attackerInfo[guid].attacker = target->GetOwner();
+        m_attackerInfo[guid].victim = target->GetOwner()->GetVictim();
+        m_attackerInfo[guid].threat = target->getThreat(victim);
+        m_attackerInfo[guid].count = 1;
+        //m_attackerInfo[guid].source = 1; // source is not used so far.
+        ref = ref->next();
+    }
+}
+
+void PlayerbotAI::UpdateAttackerInfo()
+{
+    // clear old list
+    m_attackerInfo.clear();
+
+    // check own attackers
+    UpdateAttackersForTarget(m_bot);
+    Pet *pet = m_bot->GetPet();
+    if (pet)
+        UpdateAttackersForTarget(pet);
+
+    // check master's attackers
+    UpdateAttackersForTarget(m_master);
+    pet = m_master->GetPet();
+    if (pet)
+        UpdateAttackersForTarget(pet);
+
+    // check all group members now
+    if (m_bot->GetGroup())
+    {
+        GroupReference *gref = m_bot->GetGroup()->GetFirstMember();
+        while (gref)
+        {
+            if (gref->GetSource() == m_bot || gref->GetSource() == m_master)
+            {
+                gref = gref->next();
+                continue;
+            }
+
+            UpdateAttackersForTarget(gref->GetSource());
+            pet = gref->GetSource()->GetPet();
+            if (pet)
+                UpdateAttackersForTarget(pet);
+
+            gref = gref->next();
+        }
+    }
+
+    // get highest threat not caused by bot for every entry in AttackerInfoList...
+    for (AttackerInfoList::iterator itr = m_attackerInfo.begin(); itr != m_attackerInfo.end(); ++itr)
+    {
+        if (!itr->second.attacker)
+            continue;
+        Unit *a = itr->second.attacker;
+        float t = 0.00;
+        std::list<HostileReference*>::const_iterator i = a->getThreatManager().getThreatList().begin();
+        for (; i != a->getThreatManager().getThreatList().end(); ++i)
+        {
+            if ((*i)->getThreat() > t && (*i)->getTarget() != m_bot)
+                t = (*i)->getThreat();
+        }
+        m_attackerInfo[itr->first].threat2 = t;
+    }
+
+    // DEBUG: output attacker info
+    //sLog->outBasic( "[PlayerbotAI]: %s m_attackerInfo = {", m_bot->GetName() );
+    //for( AttackerInfoList::iterator i=m_attackerInfo.begin(); i!=m_attackerInfo.end(); ++i )
+    //    //sLog->outBasic( "[PlayerbotAI]:     [%016I64X] { %08X, %08X, %.2f, %.2f, %d, %d }",
+    //        i->first,
+    //        (i->second.attacker?i->second.attacker->GetGUID().GetCounter():0),
+    //        (i->second.victim?i->second.victim->GetGUID().GetCounter():0),
+    //        i->second.threat,
+    //        i->second.threat2,
+    //        i->second.count,
+    //        i->second.source );
+    //sLog->outBasic( "[PlayerbotAI]: };" );
+}
+
+uint32 PlayerbotAI::EstRepairAll()
+{
+    uint32 TotalCost = 0;
+    // equipped, backpack, bags itself
+    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        TotalCost += EstRepair(((INVENTORY_SLOT_BAG_0 << 8) | i));
+
+    // bank, buyback and keys not repaired
+
+    // items in inventory bags
+    for (int j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; ++j)
+        for (int i = 0; i < MAX_BAG_SIZE; ++i)
+            TotalCost += EstRepair(((j << 8) | i));
+    return TotalCost;
+}
+
+uint32 PlayerbotAI::EstRepair(uint16 pos)
+{
+    Item* item = m_bot->GetItemByPos(pos);
+
+    uint32 TotalCost = 0;
+    if (!item)
+        return TotalCost;
+
+    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    if (!maxDurability)
+        return TotalCost;
+
+    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
+
+    uint32 LostDurability = maxDurability - curDurability;
+    if (LostDurability > 0)
+    {
+        ItemTemplate const *ditemProto = item->GetTemplate();
+
+        DurabilityCostsEntry const *dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
+        if (!dcost)
+        {
+            //sLog->outError("RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
+            return TotalCost;
+        }
+
+        uint32 dQualitymodEntryId = (ditemProto->Quality + 1) * 2;
+        DurabilityQualityEntry const *dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
+        if (!dQualitymodEntry)
+        {
+            //sLog->outError("RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
+            return TotalCost;
+        }
+
+        uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class, ditemProto->SubClass)];
+        uint32 costs = uint32(LostDurability * dmultiplier * double(dQualitymodEntry->quality_mod));
+
+        if (costs == 0)                                 //fix for ITEM_QUALITY_ARTIFACT
+            costs = 1;
+
+        TotalCost = costs;
+    }
+    return TotalCost;
+}
+
+Unit* PlayerbotAI::FindAttacker(ATTACKERINFOTYPE ait, Unit *victim)
+{
+    // list empty? why are we here?
+    if (m_attackerInfo.empty())
+        return 0;
+
+    // not searching something specific - return first in list
+    if (!ait)
+        return (m_attackerInfo.begin())->second.attacker;
+
+    float t = ((ait & AIT_HIGHESTTHREAT) ? 0.00 : 9999.00);
+    Unit *a = 0;
+    AttackerInfoList::iterator itr = m_attackerInfo.begin();
+    for (; itr != m_attackerInfo.end(); ++itr)
+    {
+        if ((ait & AIT_VICTIMSELF) && !(ait & AIT_VICTIMNOTSELF) && itr->second.victim != m_bot)
+            continue;
+
+        if (!(ait & AIT_VICTIMSELF) && (ait & AIT_VICTIMNOTSELF) && itr->second.victim == m_bot)
+            continue;
+
+        if ((ait & AIT_VICTIMNOTSELF) && victim && itr->second.victim != victim)
+            continue;
+
+        if (!(ait & (AIT_LOWESTTHREAT | AIT_HIGHESTTHREAT)))
+        {
+            a = itr->second.attacker;
+            itr = m_attackerInfo.end();
+        }
+        else
+        {
+            if ((ait & AIT_HIGHESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat >= t)
+            {
+                t = itr->second.threat;
+                a = itr->second.attacker;
+            }
+            else if ((ait & AIT_LOWESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat <= t)
+            {
+                t = itr->second.threat;
+                a = itr->second.attacker;
+            }
+        }
+    }
+    return a;
+}
+
+void PlayerbotAI::SetCombatOrderByStr(std::string str, Unit *target)
+{
+    CombatOrderType co;
+    if (str == "tank") co = ORDERS_TANK;
+    else if (str == "assist") co = ORDERS_ASSIST;
+    else if (str == "heal") co = ORDERS_HEAL;
+    else if (str == "protect") co = ORDERS_PROTECT;
+    else if (str == "passive") co = ORDERS_PASSIVE;
+    else if (str == "nodispel") co = ORDERS_NODISPEL;
+    else if (str == "resistfrost") {
+        co = ORDERS_RESIST;
+        m_resistType = SCHOOL_FROST;
+    }
+    else if (str == "resistnature") {
+        co = ORDERS_RESIST;
+        m_resistType = SCHOOL_NATURE;
+    }
+    else if (str == "resistfire") {
+        co = ORDERS_RESIST;
+        m_resistType = SCHOOL_FIRE;
+    }
+    else if (str == "resistshadow") {
+        co = ORDERS_RESIST;
+        m_resistType = SCHOOL_SHADOW;
+    }
+    else
+        co = ORDERS_RESET;
+    SetCombatOrder(co, target);
+    if (FollowAutoGo != 0)
+        FollowAutoGo = 1;
+}
+
+void PlayerbotAI::SetCombatOrder(CombatOrderType co, Unit *target)
+{
+    // reset m_combatOrder after ORDERS_PASSIVE
+    if (m_combatOrder == ORDERS_PASSIVE)
+    {
+        m_combatOrder = ORDERS_NONE;
+        m_targetAssist = 0;
+        m_targetProtect = 0;
+        m_resistType = SCHOOL_NONE;
+    }
+
+    if ((co == ORDERS_ASSIST || co == ORDERS_PROTECT) && !target) {
+        TellMaster("Erf, you forget to target assist/protect characters!");
+        return;
+    }
+    if (co == ORDERS_RESET) {
+        m_combatOrder = ORDERS_NONE;
+        m_targetAssist = 0;
+        m_targetProtect = 0;
+        TellMaster("Orders are cleaned!");
+        return;
+    }
+    if (co == ORDERS_PASSIVE)
+    {
+        m_combatOrder = ORDERS_PASSIVE;
+        SendOrders(*m_master);
+        return;
+    }
+    if (co == ORDERS_PROTECT)
+        m_targetProtect = target;
+    else if (co == ORDERS_ASSIST)
+        m_targetAssist = target;
+    if ((co & ORDERS_PRIMARY))
+        m_combatOrder = (CombatOrderType) (((uint32) m_combatOrder & (uint32) ORDERS_SECONDARY) | (uint32) co);
+    else
+        m_combatOrder = (CombatOrderType) (((uint32) m_combatOrder & (uint32) ORDERS_PRIMARY) | (uint32) co);
+    SendOrders(*m_master);
+}
+
+void PlayerbotAI::SetMovementOrder(MovementOrderType mo, Unit *followTarget)
+{
+    m_movementOrder = mo;
+    m_followTarget = followTarget;
+    MovementReset();
+}
+
+void PlayerbotAI::MovementReset()
+{
+    //TellMaster("Debug: MovementReset()");
+    // stop moving...
+    MovementClear();
+
+    if (m_movementOrder == MOVEMENT_FOLLOW)
+    {
+        // nothing to follow
+        if (!m_followTarget)
+            return;
+        // don't follow while casting
+        if (m_bot->HasUnitState(UNIT_STATE_CASTING))
+            return;
+        // don't follow while in combat
+        if (m_targetCombat)
+            return;
+        // new check bot
+        if (!m_bot->IsAlive() || m_bot->IsBeingTeleported() || m_bot->IsInFlight())
+            return;
+
+        WorldObject* distTarget = m_followTarget;   // target to distance check
+
+        // target is player ?
+        Player const* pTarget = m_followTarget->ToPlayer();
+
+        if (pTarget)
+        {
+            // check player for follow situations
+            if (pTarget->IsBeingTeleported() || pTarget->IsInFlight())
+                return;
+
+            // use player's corpse as distance check target
+            if (pTarget->GetCorpse())
+                distTarget = pTarget->GetCorpse();
+        }
+
+        // is bot too far from the follow target
+        if (m_bot->GetMap() != distTarget->GetMap() || m_bot->GetDistance2d(distTarget) > 50)
+        {
+            //DoTeleport(*m_followTarget);
+            m_ignoreAIUpdatesUntilTime = time(NULL) + 2;
+            PlayerbotChatHandler ch(m_master->GetSession());
+            if (!ch.teleport(*m_bot, *distTarget))
+            {
+                TellMaster("I cannot be teleported...");
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoTeleport - %s failed to teleport", m_bot->GetName() );
+                //return;
+            }
+            m_bot->UpdatePosition(*distTarget, true);
+            return;
+        }
+
+        if (distTarget == m_followTarget)
+        {
+            float angle = frand(0, float(M_PI));
+            float dist = frand(m_confFollowDistance[0], m_confFollowDistance[1]);
+
+            m_bot->GetMotionMaster()->MoveFollow(m_followTarget, dist, angle);
+            //m_ignoreAIUpdatesUntilTime = time(NULL) + 1;
+        }
+        if (FollowAutoGo == 5)
+            FollowAutoGo = 1;
+    }
+}
+
+void PlayerbotAI::MovementClear()
+{
+    //TellMaster("Debug: MovementClear()");
+    // stop...
+    m_bot->GetMotionMaster()->Clear(true);
+    m_bot->ClearUnitState(UNIT_STATE_CHASE);
+    m_bot->ClearUnitState(UNIT_STATE_FOLLOW);
+
+    // stand up...
+    if (!m_bot->IsStandState())
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+}
+
+void PlayerbotAI::BotPlaySound(uint32 soundid)
+{
+    WorldPacket data(SMSG_PLAY_SOUND, 4);
+    data << soundid;
+    m_master->GetSession()->SendPacket(&data);
+}
+
+// BotPlaySound data from SoundEntries.dbc
+void PlayerbotAI::Announce(AnnounceFlags msg)
+{
+    switch (m_bot->getRace())
+    {
+        case RACE_HUMAN:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1908) : BotPlaySound(2032); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1875) : BotPlaySound(1999); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1924) : BotPlaySound(2048); break;
+                default: break;
+            }
+            break;
+        case RACE_ORC:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2319) : BotPlaySound(2374); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2284) : BotPlaySound(2341); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2335) : BotPlaySound(2390); break;
+                default: break;
+            }
+            break;
+        case RACE_DWARF:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1630) : BotPlaySound(1686); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1581) : BotPlaySound(1654); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1636) : BotPlaySound(1702); break;
+                default: break;
+            }
+            break;
+        case RACE_NIGHTELF:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2151) : BotPlaySound(2262); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2118) : BotPlaySound(2229); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2167) : BotPlaySound(2278); break;
+                default: break;
+            }
+            break;
+        case RACE_UNDEAD_PLAYER:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2096) : BotPlaySound(2207); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2054) : BotPlaySound(2173); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2112) : BotPlaySound(2223); break;
+                default: break;
+            }
+            break;
+        case RACE_TAUREN:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2463) : BotPlaySound(2462); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2396) : BotPlaySound(2397); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2495) : BotPlaySound(2494); break;
+                default: break;
+            }
+            break;
+        case RACE_GNOME:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1743) : BotPlaySound(1798); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1708) : BotPlaySound(1709); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1759) : BotPlaySound(1814); break;
+                default: break;
+            }
+            break;
+        case RACE_TROLL:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1853) : BotPlaySound(1963); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1820) : BotPlaySound(1930); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1869) : BotPlaySound(1993); break;
+                default: break;
+            }
+            break;
+        case RACE_BLOODELF:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9583) : BotPlaySound(9584); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9549) : BotPlaySound(9550); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9565) : BotPlaySound(9566); break;
+                default: break;
+            }
+            break;
+        case RACE_DRAENEI:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9498) : BotPlaySound(9499); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9465) : BotPlaySound(9466); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9481) : BotPlaySound(9482); break;
+                default: break;
+            }
+            break;
+        default:
+            break;
+    }
+}
+
+bool PlayerbotAI::IsMoving()
+{
+    //return m_bot->isMoving();
+    return (m_bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE ? false : true);
+}
+
+// some possible things to use in AI
+// GetRandomContactPoint
+// GetPower, GetMaxPower
+// HasSpellCooldown
+// IsAffectedBySpellmod
+// isMoving
+// HasUnitState(FLAG) FLAG like: UNIT_STATE_ROOT, UNIT_STATE_CONFUSED, UNIT_STATE_STUNNED
+// hasAuraType
+
+void PlayerbotAI::UpdateAI(const uint32 /*p_time*/)
+{
+    if (m_bot->IsBeingTeleported() || m_bot->GetTrader())
+        return;
+
+    if (m_changeFaction && !m_master->GetCharmer())
+    {
+        //new
+        uint32 masterteam = m_master->GetTeam();
+        if (m_bot->GetTeam() != masterteam)
+            m_bot->SetBotTeam(Team(masterteam));
+        //new
+        uint32 masterfaction = m_master->getFaction();
+        if (m_bot->getFaction() != masterfaction || !m_bot->IsFriendlyTo(m_master))
+            m_bot->setFaction(masterfaction);
+/* Need to find a solution
+        for (uint8 i = 0; i != m_bot->GetMaxNpcBots(); ++i)
+        {
+            Creature *cre = m_bot->GetBotMap(i)->_Guid() != 0 ? ObjectAccessor::GetObjectInWorld(m_bot->GetBotMap(i)->_Guid(), (Creature*)NULL) : NULL;
+            if (!cre) continue;
+            if (cre->getFaction() != masterfaction || !cre->IsFriendlyTo(m_master))
+                cre->setFaction(masterfaction);
+        }*/
+    }
+/* Need fix tank status
+    if(m_master->GetBotTankGuid() != m_bot->GetBotTankGuid())
+        m_bot->SetBotTank(m_master->GetBotTankGuid());
+*/
+    time_t currentTime = time(NULL);
+    if (currentTime < m_ignoreAIUpdatesUntilTime)
+        return;
+
+    // default updates occur every two seconds
+    m_ignoreAIUpdatesUntilTime = time(NULL) + 1;
+    if (FollowAutoGo == 1)
+    {
+        if (m_combatOrder & ORDERS_TANK)
+            DistOverRide = 1;
+        else if (m_combatOrder & ORDERS_ASSIST)
+            DistOverRide = 3;
+        else
+            DistOverRide = 4;
+        FollowAutoGo = 2;
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+    }
+    if (!m_bot->IsAlive())
+    {
+        if (m_botState != BOTSTATE_DEAD && m_botState != BOTSTATE_DEADRELEASED)
+        {
+            // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - %s died and is not in correct state...", m_bot->GetName() );
+            // clear loot list on death
+            m_lootTargets.clear();
+            m_lootCurrent = ObjectGuid::Empty;
+            // clear combat orders
+            m_bot->SetSelection(ObjectGuid::Empty);
+            m_bot->GetMotionMaster()->Clear(true);
+            // set state to dead
+            SetState(BOTSTATE_DEAD);
+            // wait 30sec
+            m_ignoreAIUpdatesUntilTime = time(NULL) + 30;
+        }
+        else if (m_botState == BOTSTATE_DEAD)
+        {
+            // become ghost
+            if (m_bot->GetCorpse())
+            {
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - %s already has a corpse...", m_bot->GetName() );
+                SetState(BOTSTATE_DEADRELEASED);
+                return;
+            }
+            m_bot->SetBotDeathTimer();
+            m_bot->BuildPlayerRepop();
+            // relocate ghost
+            //Position loc;
+            if (Corpse *corpse = m_bot->GetCorpse())
+            {
+                m_bot->TeleportTo(corpse->GetMapId(), corpse->GetPositionX(), corpse->GetPositionY(), corpse->GetPositionZ(), m_bot->GetOrientation());
+                //m_bot->TeleportTo(*corpse);
+            }
+            // set state to released
+            SetState(BOTSTATE_DEADRELEASED);
+        }
+        else if (m_botState == BOTSTATE_DEADRELEASED)
+        {
+            // get bot's corpse
+            Corpse *corpse = m_bot->GetCorpse();
+            if (!corpse)
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - %s has no corpse!", m_bot->GetName() );
+                return;
+            // teleport ghost from graveyard to corpse
+            // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - Teleport %s to corpse...", m_bot->GetName() );
+            //DoTeleport(*corpse);
+            m_ignoreAIUpdatesUntilTime = time(NULL) + 1;
+            PlayerbotChatHandler ch(m_master->GetSession());
+            if (!ch.teleport(*m_bot, *corpse))
+            {
+                ch.sysmessage(".. could not be teleported ..");
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoTeleport - %s failed to teleport", m_bot->GetName() );
+            }
+            // check if we are allowed to resurrect now
+            if ((corpse->GetGhostTime() + m_bot->GetCorpseReclaimDelay(corpse->GetType() == CORPSE_RESURRECTABLE_PVP)) > time(NULL))
+            {
+                m_ignoreAIUpdatesUntilTime = corpse->GetGhostTime() + m_bot->GetCorpseReclaimDelay(corpse->GetType() == CORPSE_RESURRECTABLE_PVP);
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - %s has to wait for %d seconds to revive...", m_bot->GetName(), m_ignoreAIUpdatesUntilTime-time(NULL) );
+                return;
+            }
+            // resurrect now
+            // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - Reviving %s to corpse...", m_bot->GetName() );
+            m_ignoreAIUpdatesUntilTime = time(NULL) + 6;
+            //PlayerbotChatHandler ch(m_master->GetSession());
+            if (!ch.revive(*m_bot))
+            {
+                ch.sysmessage(".. could not be revived ..");
+                return;
+            }
+            // set back to normal
+            SetState(BOTSTATE_NORMAL);
+        }
+    }
+    else//if bot is alive
+    {
+        if (!m_findNPC.empty())
+            findNearbyCreature();
+
+        // if we are casting a spell then interrupt it
+        // make sure any actions that cast a spell set a proper m_ignoreAIUpdatesUntilTime!
+        //DEBUG
+        Spell* const pSpell = GetCurrentSpell();
+        //if (pSpell && !pSpell->IsChannelActive() && !pSpell->IsAutoRepeat())
+        //{
+        //    TellMaster("UpdateAI(): wrong m_ignoreAIUpdatesUntilTime! Interrupting spell! (%s - %u)", pSpell->GetSpellInfo()->SpellName[0], pSpell->GetSpellInfo()->Id);
+        //    InterruptCurrentCastingSpell();
+        //}
+        //else
+        //DEBUG
+        if (m_botState == BOTSTATE_TAME)
+        {
+            Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
+            if (!pTarget)
+                return;
+
+            m_bot->SetSelection(m_targetGuidCommand);
+
+            if (!IsInRange(pTarget, TAME_BEAST_1))
+                m_bot->ClearUnitState(UNIT_STATE_CHASE);
+
+            if (!m_bot->HasUnitState(UNIT_STATE_CHASE))
+            {
+                m_bot->GetMotionMaster()->MoveChase(pTarget);
+                return;
+            }
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(TAME_BEAST_1);
+            if (!spellInfo)
+                return;
+
+            Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+            if (!spell)
+                return;
+
+            if (m_bot->GetPetGUID() || spell->CheckCast(true) != SPELL_CAST_OK || !pTarget ||
+                pTarget->isDead() || !m_bot->IsInMap(pTarget) ||
+                !(pTarget->ToCreature() && (((Creature *)pTarget)->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_TAMEABLE)))
+            {
+                MovementReset();
+                m_bot->SetSelection(ObjectGuid::Empty);
+                SetState(BOTSTATE_NORMAL);
+                SetIgnoreUpdateTime(0);
+            }
+            else if (!m_bot->HasAura(TAME_BEAST_1, ObjectGuid::Empty, ObjectGuid::Empty, 1))
+            {
+                m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+                SpellCastTargets targets;
+                targets.SetUnitTarget(pTarget);
+                spell->prepare(&targets);
+                SetIgnoreUpdateTime(10);
+            }
+            return;
+        }
+
+        // direct cast command from master
+        else if (m_spellIdCommand != 0)
+        {
+            Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
+            if (pTarget)
+                CastSpell(m_spellIdCommand, *pTarget);
+            m_spellIdCommand = 0;
+            m_targetGuidCommand = ObjectGuid::Empty;
+        }
+
+        else if (m_botState == BOTSTATE_ENCHANT)
+        {
+            SetState(BOTSTATE_NORMAL);
+            InspectUpdate();
+        }
+
+        else if (m_botState == BOTSTATE_CRAFT)
+        {
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(m_CurrentlyCastingSpellId);
+            if (!spellInfo)
+                return;
+
+            Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+            if (!spell)
+                return;
+
+            if (GetSpellCharges(m_CurrentlyCastingSpellId) == 0 || spell->CheckCast(true) != SPELL_CAST_OK)
+            {
+                SetState(BOTSTATE_NORMAL);
+                SetIgnoreUpdateTime(0);
+            }
+            else
+            {
+                SpellCastTargets targets;
+                spell->prepare(&targets);
+                SetIgnoreUpdateTime(3);
+            }
+        }
+
+        else if (m_master->IsMounted() && !m_bot->IsMounted() && !m_bot->HasUnitState(UNIT_STATE_CASTING))
+        {
+            //Player Part
+            Unit::AuraEffectList const& AuraList = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+            if (!AuraList.empty())
+            {
+                SpellInfo const *pSpellInfo = AuraList.front()->GetSpellInfo();
+
+                //Bot Part
+                uint32 spellMount = 0;
+                //cheap check if we know this spell
+                for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+                {
+                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
+                        continue;
+                    uint32 spellId = itr->first;
+                    if (pSpellInfo->Id == spellId)
+                    {
+                        spellMount = spellId;
+                        break;
+                    }
+                }
+                if (!spellMount)
+                {
+                    //analyze and find proper mount spell
+                    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+                    {
+                        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
+                            continue;
+                        uint32 spellId = itr->first;
+                        SpellInfo const *bSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+                        if (!bSpellInfo || bSpellInfo->IsPassive())
+                            continue;
+
+                        for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                        {
+                            if (bSpellInfo->Effects[i].ApplyAuraName == SPELL_AURA_MOUNTED)
+                            {
+                                //arrange values
+                                int8 j = i-1, k = i+1;
+                                if (j < 0)// i == 0
+                                    j = k+1;//2
+                                else if (k >= MAX_SPELL_EFFECTS)// i == 2
+                                    k = j-1;//0
+
+                                if (bSpellInfo->Effects[j].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED)
+                                {
+                                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                                    {
+                                        if (pSpellInfo->Effects[i].BasePoints == bSpellInfo->Effects[j].BasePoints)
+                                        {
+                                            spellMount = spellId;
+                                            break;
+                                        }
+                                    }
+                                    if (spellMount)
+                                        break;
+                                }
+                                else if (bSpellInfo->Effects[k].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED)
+                                {
+                                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                                    {
+                                        if (pSpellInfo->Effects[i].BasePoints == bSpellInfo->Effects[k].BasePoints)
+                                        {
+                                            spellMount = spellId;
+                                            break;
+                                        }
+                                    }
+                                    if (spellMount)
+                                        break;
+                                }
+                                else if (bSpellInfo->Effects[j].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                                {
+                                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                                    {
+                                        if (pSpellInfo->Effects[i].BasePoints == bSpellInfo->Effects[j].BasePoints)
+                                        {
+                                            spellMount = spellId;
+                                            break;
+                                        }
+                                    }
+                                    if (spellMount)
+                                        break;
+                                }
+                                else if (bSpellInfo->Effects[k].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                                {
+                                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                                    {
+                                        if (pSpellInfo->Effects[i].BasePoints == bSpellInfo->Effects[k].BasePoints)
+                                        {
+                                            spellMount = spellId;
+                                            break;
+                                        }
+                                    }
+                                    if (spellMount)
+                                        break;
+                                }
+                            }
+                        }
+                        if (spellMount)
+                            break;
+                    }
+                }
+                if (spellMount)
+                    CastSpell(spellMount);
+                else
+                    SendWhisper("Cannot find approriate mount!", *m_master);
+            }
+        }
+
+        //if master is unmounted, unmount the bot
+        else if (!m_master->IsMounted() && m_bot->IsMounted())
+        {
+            WorldPacket emptyPacket;
+            m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);  //updated code
+        }
+
+        // handle combat (either self/master/group in combat, or combat state and valid target)
+        else if (IsInCombat() || (m_botState == BOTSTATE_COMBAT && m_targetCombat) ||  m_ScenarioType == SCENARIO_DUEL)
+        {
+            //check if the bot is Mounted
+            if (!m_bot->IsMounted())
+            {
+                if (!pSpell || !pSpell->IsChannelActive())
+                    DoNextCombatManeuver();
+                else
+                    SetIgnoreUpdateTime(1);  // It's better to update AI more frequently during combat
+            }
+        }
+        // bot was in combat recently - loot now
+        else if (m_botState == BOTSTATE_COMBAT)
+        {
+            SetState(BOTSTATE_LOOTING);
+            m_attackerInfo.clear();
+            if (HasCollectFlag(COLLECT_FLAG_COMBAT))
+                m_lootTargets.unique();
+            else
+                m_lootTargets.clear();
+            SetIgnoreUpdateTime(0);
+        }
+        else if (m_botState == BOTSTATE_LOOTING)
+        {
+            DoLoot();
+        }
+        else if (m_botState == BOTSTATE_FLYING)
+        {
+            /* std::ostringstream out;
+               out << "Taxi: " << m_bot->GetName() << m_ignoreAIUpdatesUntilTime;
+               TellMaster(out.str().c_str()); */
+            DoFlight();
+            SetState(BOTSTATE_NORMAL);
+            SetIgnoreUpdateTime(0);
+        }
+        // if commanded to follow master and not already following master then follow master
+        else if (!m_bot->IsInCombat() && !IsMoving())
+        {
+            //TellMaster("UpdateAI():I am not in combat and not moving - reset movement");
+            MovementReset();
+        }
+
+        // do class specific non combat actions
+        else if (m_classAI && !m_bot->IsMounted())
+        {
+            (m_classAI)->DoNonCombatActions();
+
+            // have we been told to collect GOs
+            if (HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+            {
+                findNearbyGO();
+                // start looting if have targets
+                if (!m_lootTargets.empty())
+                    SetState(BOTSTATE_LOOTING);
+            }
+        }
+        //debug
+        if (!m_bot->HasUnitState(UNIT_STATE_CASTING))
+            m_bot->RemoveAura(SPELL_ROOT);
+        //end debug
+        // debug
+        if (m_botState == BOTSTATE_NORMAL)
+        {
+            if (m_master->getStandState() == UNIT_STAND_STATE_SIT)
+                m_bot->SetStandState(UNIT_STAND_STATE_SIT);
+            else if (m_bot->getStandState() == UNIT_STAND_STATE_SIT && m_TimeDoneDrinking < time(0) && m_TimeDoneEating < time(0)) //Do no interrupt if bot is eating/drinking
+                m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+            m_bot->SendUpdateToPlayer(m_master);
+        }
+        // end debug
+    }//end is alive
+}
+
+Spell* PlayerbotAI::GetCurrentSpell() const
+{
+    if (m_CurrentlyCastingSpellId == 0)
+        return NULL;
+
+    return m_bot->FindCurrentSpellBySpellId(m_CurrentlyCastingSpellId);
+}
+
+void PlayerbotAI::TellMaster(std::string const& text) const
+{
+    SendWhisper(text, *m_master);
+}
+
+void PlayerbotAI::TellMaster(const char *fmt, ...) const
+{
+    char temp_buf[2048];
+    va_list ap;
+    va_start(ap, fmt);
+    vsnprintf(temp_buf, 2048, fmt, ap);
+    va_end(ap);
+    std::string str = temp_buf;
+    TellMaster(str);
+}
+
+void PlayerbotAI::SendWhisper(std::string const& text, Player& player) const
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    ChatHandler::BuildChatPacket(data, CHAT_MSG_WHISPER, LANG_UNIVERSAL, m_bot, m_master, text);
+    //sScriptMgr->OnPlayerChat(&data, CHAT_MSG_WHISPER, LANG_UNIVERSAL, text, m_master);
+    player.GetSession()->SendPacket(&data);
+}
+
+bool PlayerbotAI::canObeyCommandFrom(const Player& player) const
+{
+    return player.GetSession()->GetAccountId() == m_master->GetSession()->GetAccountId();
+}
+
+bool PlayerbotAI::IsInRange(Unit* Target, uint32 spellId)
+{
+    const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+        return false;
+
+    bool positive = (Target->ToPlayer() && Target->ToPlayer()->GetGroup() == m_bot->GetGroup()) || Target->IsFriendlyTo(m_bot);
+    return m_bot->IsInRange(Target, pSpellInfo->GetMinRange(positive), pSpellInfo->GetMaxRange(positive));
+
+    //SpellRangeEntry const* TempRange = GetSpellRangeStore()->LookupEntry(pSpellInfo->rangeIndex);
+
+    ////Spell has invalid range store so we can't use it
+    //if (!TempRange)
+    //    return false;
+
+    //if ((TempRange->minRange == 0.0f) && (TempRange->maxRange == 0.0f))
+    //    return true;
+
+    ////Unit is out of range for this spell
+    //if (!m_bot->IsInRange(Target, TempRange->minRange, TempRange->maxRange))
+    //    return false;
+
+    //return true;
+}
+
+bool PlayerbotAI::CastSpell(const char* args)
+{
+    uint32 spellId = getSpellId(args);
+    return (spellId) ? CastSpell(spellId) : false;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit& target)
+{
+    ObjectGuid oldSel = m_bot->GetTarget();
+    m_bot->SetSelection(target.GetGUID());
+    bool rv = CastSpell(spellId);
+    m_bot->SetSelection(oldSel);
+    return rv;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId)
+{
+    // some AIs don't check if the bot doesn't have spell before using it
+    // so just return false when this happens
+    if (spellId == 0)
+        return false;
+    //debug
+    //prevent interrupting
+    if (m_bot->IsNonMeleeSpellCast(false))
+        return false;
+    //debug
+
+    // see Creature.cpp 1738 for reference
+    // don't allow bot to cast damage spells on friends
+    SpellInfo const *pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+    {
+        TellMaster("Missing spell entry in CastSpell for spellid %u.", spellId);
+        return false;
+    }
+
+    // set target
+    Unit* pTarget = m_bot->GetTarget() ? ObjectAccessor::GetUnit(*m_bot, m_bot->GetTarget()) : m_bot;
+
+    if (!pTarget)
+        pTarget = m_bot;
+
+    if (pSpellInfo->IsPositive())
+    {
+        if (pTarget && !m_bot->IsFriendlyTo(pTarget))
+            pTarget = m_bot;
+    }
+    else
+    {
+        if (pTarget && m_bot->IsFriendlyTo(pTarget))
+            return false;
+
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+    }
+
+    float CastTime = 0.0f;
+
+    // stop movement to prevent cancel spell casting
+    SpellCastTimesEntry const * castTimeEntry = pSpellInfo->CastTimeEntry;
+    if (castTimeEntry && castTimeEntry->CastTime)
+    {
+        CastTime = (castTimeEntry->CastTime / 1000);
+        //TellMaster("CastSpell - movement reset for casting %s (%u, cast time: %f)", pSpellInfo->SpellName[0], spellId, CastTime);
+        m_bot->StopMoving();
+        //debug See also UpdateAI
+        m_bot->AddAura(SPELL_ROOT, m_bot);
+        //TellMaster("CastSpell - Applying root (%s - %u, cast time: %f)", pSpellInfo->SpellName[0], spellId, CastTime);
+        //end debug
+    }
+
+    uint32 target_type = TARGET_FLAG_UNIT;
+
+    if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_OPEN_LOCK)
+        target_type = TARGET_FLAG_GAMEOBJECT;
+
+    m_CurrentlyCastingSpellId = spellId;
+
+    if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_OPEN_LOCK ||
+        pSpellInfo->Effects[0].Effect == SPELL_EFFECT_SKINNING)
+    {
+        if (m_lootCurrent)
+        {
+            WorldPacket* const packet = new WorldPacket(CMSG_CAST_SPELL, 1 + 4 + 1 + 4 + 8);
+            *packet << uint8(0);                            // spells cast count;
+            *packet << spellId;
+            *packet << uint8(0);                            // unk_flags
+            *packet << uint32(target_type);
+            *packet << m_lootCurrent;//.WriteAsPacked();
+            m_bot->GetSession()->QueuePacket(packet);       // queue the packet to get around race condition
+
+            if (target_type == TARGET_FLAG_GAMEOBJECT)
+            {
+                WorldPacket* const packetgouse = new WorldPacket(CMSG_GAMEOBJ_REPORT_USE, 8);
+                *packetgouse << m_lootCurrent;
+                m_bot->GetSession()->QueuePacket(packetgouse);  // queue the packet to get around race condition
+
+                GameObject *obj = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+                if (!obj)
+                    return false;
+
+                // add other go types here, i.e.:
+                // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+                if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+                {
+                    TurnInQuests(obj);
+
+                    // auto accept every available quest this NPC has
+                    m_bot->PrepareQuestMenu(m_lootCurrent);
+                    QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+                    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+                    {
+                        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+                        uint32 questID = qItem.QuestId;
+                        if (!AddQuest(questID, obj))
+                            TellMaster("Couldn't take quest");
+                    }
+                    m_lootCurrent = ObjectGuid::Empty;
+                    m_bot->GetMotionMaster()->Clear();
+                    m_bot->GetMotionMaster()->MoveIdle();
+                }
+            }
+        }
+        else
+            return false;
+    }
+    else
+    {
+        // Check spell range
+        if (!pTarget || !IsInRange(pTarget, spellId))
+        {
+            //TellMaster("CastSpell - i'm not in range! (spell: %s, target: %s)", pSpellInfo->SpellName[0], pTarget->GetName());
+            return false;
+        }
+
+        // Check line of sight
+        if (!pTarget || !m_bot->IsWithinLOSInMap(pTarget))
+        {
+            //TellMaster("CastSpell - i'm not wothin LOS! (spell: %s, target: %s)", pSpellInfo->SpellName[0], pTarget->GetName());
+            return false;
+        }
+
+        ////temp
+        //Spell *spell = new Spell(m_bot, pSpellInfo, TRIGGERED_NONE);
+        //if (!spell->CheckCast(true))
+        //    TellMaster("CastSpell:CheckCast() cannot cast spell %u (%s), target: %s)", pSpellInfo->Id, pSpellInfo->SpellName[0], pTarget->GetName());
+
+        m_bot->CastSpell(pTarget, pSpellInfo, false/*true*/);       // actually cast spell
+        //TellMaster("CastSpell - processing spell %u (%s), target: %s)", pSpellInfo->Id, pSpellInfo->SpellName[0], pTarget->GetName());
+    }
+
+    //DEBUG
+    //if (pSpellInfo->IsChanneled())
+    //    m_ignoreAIUpdatesUntilTime = time(NULL) + CastTime + 0.1f;
+    //else
+    //    m_ignoreAIUpdatesUntilTime = time(NULL) + 2;
+    //DEBUG
+
+    //m_CurrentlyCastingSpellId = 0;
+    m_CurrentlyCastingSpellId = pSpellInfo->Id;
+
+    // if this caused the caster to move (blink) update the position
+    // I think this is normally done on the client
+    // this should be done on spell success
+    /*
+       if (name == "Blink") {
+       float x,y,z;
+       m_bot->GetPosition(x,y,z);
+       m_bot->GetNearPoint(m_bot, x, y, z, 1, 5, 0);
+       m_bot->Relocate(x,y,z);
+       m_bot->SendHeartBeat();
+
+       }
+     */
+
+    return true;
+}
+
+bool PlayerbotAI::CastPetSpell(uint32 spellId, Unit* target)
+{
+    if (spellId == 0)
+        return false;
+
+    Pet* pet = m_bot->GetPet();
+    if (!pet)
+        return false;
+
+    const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+    {
+        TellMaster("Missing spell entry in CastPetSpell()");
+        return false;
+    }
+
+    // set target
+    Unit* pTarget;
+    if (!target)
+    {
+        ObjectGuid targetGUID = m_bot->GetTarget();
+        pTarget = ObjectAccessor::GetUnit(*m_bot, targetGUID);
+    }
+    else
+        pTarget = target;
+
+    if (sSpellMgr->GetSpellInfo(spellId)->IsPositive())
+    {
+        if (pTarget && !m_bot->IsFriendlyTo(pTarget))
+            pTarget = m_bot;
+    }
+    else
+    {
+        if (pTarget && m_bot->IsFriendlyTo(pTarget))
+            return false;
+
+        if (!pet->isInFrontInMap(pTarget, 10)) // distance probably should be calculated
+            pet->SetFacingTo(pet->GetAngle(pTarget));
+    }
+
+    pet->CastSpell(pTarget, pSpellInfo, false);
+
+    Spell* const pSpell = pet->FindCurrentSpellBySpellId(spellId);
+    if (!pSpell)
+        return false;
+
+    return true;
+}
+
+// Perform sanity checks and cast spell
+bool PlayerbotAI::Buff(uint32 spellId, Unit* target, void (*beforeCast)(Player *))
+{
+    if (spellId == 0)
+        return false;
+
+    SpellInfo const * spellProto = sSpellMgr->GetSpellInfo(spellId);
+
+    if (!spellProto)
+        return false;
+
+    if (!target)
+        return false;
+
+    // Select appropriate spell rank for target's level
+    spellProto = spellProto->GetAuraRankForLevel(target->getLevel());
+    if (!spellProto)
+        return false;
+
+    // Check if spell will boost one of already existent auras
+    bool willBenefitFromSpell = false;
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (spellProto->Effects[i].ApplyAuraName == SPELL_AURA_NONE)
+            break;
+
+        bool sameOrBetterAuraFound = false;
+        int32 bonus = m_bot->CalculateSpellDamage(target, spellProto, i);
+        Unit::AuraEffectList const& auras = target->GetAuraEffectsByType(AuraType(spellProto->Effects[i].ApplyAuraName));
+        for (Unit::AuraEffectList::const_iterator it = auras.begin(); it != auras.end(); ++it)
+        {
+            if ((*it)->GetMiscValue() == spellProto->Effects[i].MiscValue && (*it)->GetAmount() >= bonus)
+            {
+                sameOrBetterAuraFound = true;
+                break;
+            }
+        }
+        willBenefitFromSpell = willBenefitFromSpell || !sameOrBetterAuraFound;
+    }
+
+    if (!willBenefitFromSpell)
+        return false;
+
+    // Druids may need to shapeshift before casting
+    if (beforeCast)
+        (*beforeCast)(m_bot);
+
+    return CastSpell(spellProto->Id, *target);
+}
+
+// Can be used for personal buffs like Mage Armor and Inner Fire
+bool PlayerbotAI::SelfBuff(uint32 spellId)
+{
+    if (spellId == 0)
+        return false;
+
+    if (m_bot->HasAura(spellId))
+        return false;
+
+    return CastSpell(spellId, *m_bot);
+}
+
+// Checks if spell is single per target per caster and will make any effect on target
+bool PlayerbotAI::CanReceiveSpecificSpell(uint8 spec, Unit* target) const
+{
+    if (IsSingleFromSpellSpecificPerTargetPerCaster(SpellSpecific(spec), SpellSpecific(spec)))
+    {
+        Unit::AuraMap const &holders = target->GetOwnedAuras();
+        Unit::AuraMap::const_iterator it;
+        for (it = holders.begin(); it != holders.end(); ++it)
+            if ((*it).second->GetCasterGUID() == m_bot->GetGUID() && (*it).second->GetSpellInfo()->GetSpellSpecific() == SpellSpecificType(spec))
+                return false;
+    }
+    return true;
+}
+
+bool PlayerbotAI::IsSingleFromSpellSpecificPerTargetPerCaster(SpellSpecific spellSpec1, SpellSpecific spellSpec2) const
+{
+    switch (spellSpec1)
+    {
+        case SPELL_BLESSING:
+        case SPELL_AURA:
+        case SPELL_STING:
+        case SPELL_CURSE:
+        case SPELL_ASPECT:
+        case SPELL_POSITIVE_SHOUT:
+        case SPELL_JUDGEMENT:
+        case SPELL_HAND:
+        case SPELL_UA_IMMOLATE:
+            return spellSpec1==spellSpec2;
+        default:
+            return false;
+    }
+}
+
+uint8 PlayerbotAI::_findItemSlot(Item* target)
+{
+    // list out items equipped & in main backpack
+    //INVENTORY_SLOT_ITEM_START = 23
+    //INVENTORY_SLOT_ITEM_END = 39
+
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: FindItem - [%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);  // 255, 23 to 38
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == target->GetTemplate()->ItemId)   // have required item
+                return slot;
+        }
+    }
+    // list out items in other removable backpacks
+    //INVENTORY_SLOT_BAG_START = 19
+    //INVENTORY_SLOT_BAG_END = 23
+
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)  // 20 to 23 = 4
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);   // 255, 20 to 23
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: FindItem - [%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);  // 1 to bagsize = ?
+                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == target->GetTemplate()->ItemId)        // have required item
+                        return slot;
+                }
+            }
+    }
+    return 0;
+}
+
+Item* PlayerbotAI::FindItem(uint32 ItemId)
+{
+    // list out items equipped & in main backpack
+    //INVENTORY_SLOT_ITEM_START = 23
+    //INVENTORY_SLOT_ITEM_END = 39
+
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: FindItem - [%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);  // 255, 23 to 38
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    //INVENTORY_SLOT_BAG_START = 19
+    //INVENTORY_SLOT_BAG_END = 23
+
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)  // 20 to 23 = 4
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);   // 255, 20 to 23
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: FindItem - [%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);  // 1 to bagsize = ?
+                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == ItemId)        // have required item
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindItemInBank(uint32 ItemId)
+{
+    // list out items in bank item slots
+
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug("[%s's]backpack slot = %u",m_bot->GetName(),slot);
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+    // list out items in bank bag slots
+
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                // sLog->outDebug("[%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == ItemId)        // have required item
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindKeyForLockValue(uint32 reqSkillValue)
+{
+    if (reqSkillValue <= 25 && m_bot->HasItemCount(SILVER_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(SILVER_SKELETON_KEY);
+    if (reqSkillValue <= 125 && m_bot->HasItemCount(GOLDEN_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(GOLDEN_SKELETON_KEY);
+    if (reqSkillValue <= 200 && m_bot->HasItemCount(TRUESILVER_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(TRUESILVER_SKELETON_KEY);
+    if (reqSkillValue <= 300 && m_bot->HasItemCount(ARCANITE_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(ARCANITE_SKELETON_KEY);
+    if (reqSkillValue <= 375 && m_bot->HasItemCount(TITANIUM_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(TITANIUM_SKELETON_KEY);
+    if (reqSkillValue <= 400 && m_bot->HasItemCount(COBALT_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(COBALT_SKELETON_KEY);
+
+    return NULL;
+}
+
+Item* PlayerbotAI::FindBombForLockValue(uint32 reqSkillValue)
+{
+    if (reqSkillValue <= 150 && m_bot->HasItemCount(SMALL_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(SMALL_SEAFORIUM_CHARGE);
+    if (reqSkillValue <= 250 && m_bot->HasItemCount(LARGE_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(LARGE_SEAFORIUM_CHARGE);
+    if (reqSkillValue <= 300 && m_bot->HasItemCount(POWERFUL_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(POWERFUL_SEAFORIUM_CHARGE);
+    if (reqSkillValue <= 350 && m_bot->HasItemCount(ELEMENTAL_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(ELEMENTAL_SEAFORIUM_CHARGE);
+
+    return NULL;
+}
+
+bool PlayerbotAI::HasTool(uint32 TC)
+{
+    std::ostringstream out;
+
+    switch (TC)
+    {
+        case TC_MINING_PICK:                //  = 165
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a MINING PICK!";
+            break;
+
+        case TC_ARCLIGHT_SPANNER:          //  = 14
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have an ARCLIGHT SPANNER!";
+            break;
+
+        case TC_BLACKSMITH_HAMMER:         //  = 162
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a BLACKSMITH's HAMMER!";
+            break;
+
+        case TC_SKINNING_KNIFE:            //  = 166
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a SKINNING KNIFE!";
+            break;
+
+        case TC_COPPER_ROD:                //  = 6,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED COPPER ROD!";
+            break;
+
+        case TC_SILVER_ROD:                //  = 7,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED SILVER ROD!";
+            break;
+
+        case TC_GOLDEN_ROD:                //  = 8,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED GOLDEN ROD!";
+            break;
+
+        case TC_TRUESILVER_ROD:            //  = 9,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED TRUESILVER ROD!";
+            break;
+
+        case TC_ARCANITE_ROD:              //  = 10,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED ARCANITE ROD!";
+            break;
+
+        case TC_FEL_IRON_ROD:              //  = 41,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED FEL IRON ROD!";
+            break;
+
+        case TC_ADAMANTITE_ROD:            //  = 62,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED ADAMANTITE ROD!";
+            break;
+
+        case TC_ETERNIUM_ROD:              //  = 63,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED ETERNIUM ROD!";
+            break;
+
+        case TC_RUNED_AZURITE_ROD:         //  = 101,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED AZURITE ROD!";
+            break;
+
+        case TC_VIRTUOSO_INKING_SET:       //  = 121,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a VIRTUOSO INKING SET!";
+            break;
+
+        case TC_RUNED_COBALT_ROD:          //  = 189,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED COBALT ROD!";
+            break;
+
+        case TC_RUNED_TITANIUM_ROD:        //  = 190,
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED TITANIUM ROD!";
+            break;
+        default:
+            out << "|cffffffffI do not know what tool that needs! TC (" << TC << ")";
+    }
+    TellMaster(out.str().c_str());
+    return false;
+}
+
+bool PlayerbotAI::HasSpellReagents(uint32 spellId)
+{
+    const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+        return false;
+
+    if (m_bot->CanNoReagentCast(pSpellInfo))
+        return true;
+
+    for (uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
+    {
+        if (pSpellInfo->Reagent[i] <= 0)
+            continue;
+
+        uint32 itemid = pSpellInfo->Reagent[i];
+        uint32 count = pSpellInfo->ReagentCount[i];
+
+        if (!m_bot->HasItemCount(itemid, count))
+            return false;
+    }
+
+    return true;
+}
+
+uint32 PlayerbotAI::GetSpellCharges(uint32 spellId)
+{
+    const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+        return 0;
+
+    if (m_bot->CanNoReagentCast(pSpellInfo))
+        return 0;
+
+    uint32 charges = 0;
+    std::list<uint32> chargeList;
+    for (uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
+    {
+        if (pSpellInfo->Reagent[i] <= 0)
+            continue;
+
+        uint32 totalcount = 0;
+        uint32 itemid = pSpellInfo->Reagent[i];
+        uint32 count = pSpellInfo->ReagentCount[i];
+        ItemCountInInv(itemid, totalcount);
+        chargeList.push_back((totalcount / count));
+    }
+
+    for (uint32 i = 0; i < 3; ++i)
+    {
+        if (pSpellInfo->TotemCategory[i] == 0)
+            continue;
+
+        if (!m_bot->HasItemTotemCategory(pSpellInfo->TotemCategory[i]))
+        {
+            m_noToolList.push_back(pSpellInfo->TotemCategory[i]);
+            return 0;
+        }
+    }
+
+    if (!chargeList.empty())
+    {
+        charges = chargeList.front();
+        chargeList.pop_front();
+        for (std::list<uint32>::iterator it = chargeList.begin(); it != chargeList.end(); ++it)
+            if (*it < charges)
+                charges = *it;
+    }
+    return charges;
+}
+
+void PlayerbotAI::ItemCountInInv(uint32 itemid, uint32 &count)
+{
+    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+    {
+        Item *pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (pItem && pItem->GetEntry() == itemid && !pItem->IsInTrade())
+            count += pItem->GetCount();
+    }
+
+    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if (Bag * pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+            {
+                Item* pItem = m_bot->GetItemByPos(i, j);
+                if (pItem && pItem->GetEntry() == itemid && !pItem->IsInTrade())
+                    count += pItem->GetCount();
+            }
+    }
+}
+
+// extracts all item ids in format below
+// I decided to roll my own extractor rather then use the one in ChatHandler
+// because this one works on a const string, and it handles multiple links
+// |color|linkType:key:something1:...:somethingN|h[name]|h|r
+void PlayerbotAI::extractItemIds(const std::string& text, std::list<uint32>& itemIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hitem:", pos);
+        if (i == -1)
+            break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            itemIds.push_back(id);
+    }
+}
+
+void PlayerbotAI::extractMailIds(const std::string& text, std::list<uint32>& mailIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hmail:", pos);
+        if (i == -1)
+            break;
+        pos = i + 6;
+        int endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            mailIds.push_back(id);
+    }
+}
+
+/**
+ * Checks whether the TalentSpec database contains any obvious errors
+ *
+ * return 0  -> all ok
+ * return x  -> return the talentspec_id of the first talentspec that errors out
+ */
+
+// TODO: the way this is built is just begging for a memory leak (by adding a return case and forgetting to delete result)
+uint32 PlayerbotAI::TalentSpecDBContainsError()
+{
+    //QueryResult result = CharacterDatabase.PQuery("SELECT * FROM playerbot_talentspec ORDER BY class ASC");
+
+    //if (!result)
+    //{
+    //    // Do you really need a progress bar? No, but all the other kids jumped off the bridge too...
+    //    //BarGoLink bar(1);
+
+    //    //bar.step();
+
+    //    //sLog->outString();
+    //    //sLog->outString(">> Loaded `playerbot_talentspec`, table is empty.");
+
+    //    return 0;   // Because, well, no specs means none contain errors...
+    //}
+
+    ////BarGoLink bar(result->GetRowCount());
+
+    //do
+    //{
+    //    //bar.step();
+
+    //    /* 0            talentspec_id
+    //       1            name
+    //       2            class
+    //       3            purpose
+    //       4 to 74        talent_10 to 71
+    //       75 to 80        major_glyph_15, 30, 80, minor_glyph_15, 50, 70
+    //     */
+    //    Field* fields = result->Fetch();
+
+    //    uint32 ts_id = fields[0].GetUInt32();
+    //    if (!ts_id)    // Nice bit of paranoia: ts_id is a non-zero NOT NULL AUTO_INCREMENT value
+    //        continue;  // Of course, if the impossible ever does happen, we can't very well identify a TalentSpec without an ID...
+
+    //    std::string ts_name = fields[1].GetCString();
+    //    /*    Commented out? Because it's only required if you assume only players (not the server) pick talentspecs
+    //       if (0 == ts_name.size())
+    //       {
+    //       TellMaster("TalentSpec ID: %u does not have a name.", ts_id);
+
+    //       //delete result;
+    //       return ts_id;
+    //       }
+    //     */
+
+    //    long ts_class = fields[2].GetInt32();
+    //    if (ts_class != CLASS_DEATH_KNIGHT && ts_class != CLASS_DRUID && ts_class != CLASS_HUNTER && ts_class != CLASS_MAGE && ts_class != CLASS_PALADIN && ts_class != CLASS_PRIEST && ts_class != CLASS_ROGUE && ts_class != CLASS_SHAMAN && ts_class != CLASS_WARLOCK && ts_class != CLASS_WARRIOR &&
+    //        ts_class != CLASS_PET_CUNNING && ts_class != CLASS_PET_FEROCITY && ts_class != CLASS_PET_TENACITY)
+    //    {
+    //        TellMaster("TalentSpec: %u. \"%s\" contains an invalid class: %i.", ts_id, ts_name.c_str(), ts_class);
+
+    //        ////delete result;
+    //        return ts_id;    // invalid class
+    //    }
+
+    //    // Can't really be error checked, can it?
+    //    // uint32 ts_purpose = fields[3].GetUInt32();
+
+    //    // check all talents
+    //    for (uint8 i = 0; i < 71; i++)
+    //    {
+    //        uint8 fieldLoc = i + 4;
+    //        if (fields[fieldLoc].GetUInt16() == 0)
+    //        {
+    //            for (uint8 j = (i + 1); j < 71; j++)
+    //            {
+    //                fieldLoc = j + 4;
+    //                if (fields[fieldLoc].GetUInt16() != 0)
+    //                {
+    //                    TellMaster("TalentSpec: %u. \"%s\" contains an empty talent for level: %u while a talent for level: %u exists.", ts_id, ts_name.c_str(), (i + 10), (j + 10));
+
+    //                    ////delete result;
+    //                    return ts_id;
+    //                }
+    //            }
+    //            break;
+    //        }
+    //        else if (!ValidateTalent(fields[fieldLoc].GetUInt16(), ts_class))
+    //        {
+    //            TellMaster("TalentSpec: %u. \"%s\" (class: %i) contains an invalid talent for level %u: %u", ts_id, ts_name.c_str(), ts_class, (i + 10), fields[fieldLoc].GetUInt16());
+
+    //            ////delete result;
+    //            return ts_id;    // invalid talent
+    //        }
+    //    }
+
+    //    for (uint8 i = 75; i < 78; i++)  // as in, the 3 major glyphs
+    //    {
+    //        if (fields[i].GetUInt16() != 0 && !ValidateMajorGlyph(fields[i].GetUInt16(), ts_class))
+    //        {
+    //            TellMaster("TalentSpec: %u. \"%s\" contains an invalid Major glyph %u: %u", ts_id, ts_name.c_str(), (i - 74), fields[i].GetUInt16());
+    //            if (!ValidateGlyph(fields[i].GetUInt16(), ts_class))
+    //                TellMaster("In fact, according to our records, it's no glyph at all");
+
+    //            ////delete result;
+    //            return ts_id;
+    //        }
+    //    }
+    //    for (uint8 i = 78; i < 81; i++)  // as in, the 3 minor glyphs
+    //    {
+    //        if (fields[i].GetUInt16() != 0 && !ValidateMinorGlyph(fields[i].GetUInt16(), ts_class))
+    //        {
+    //            TellMaster("TalentSpec: %u. \"%s\" contains an invalid Minor glyph %u: %u", ts_id, ts_name.c_str(), (i - 77), fields[i].GetUInt16());
+    //            if (!ValidateGlyph(fields[i].GetUInt16(), ts_class))
+    //                TellMaster("In fact, according to our records, it's no glyph at all");
+
+    //            ////delete result;
+    //            return ts_id;
+    //        }
+    //    }
+    //} while (result->NextRow());
+
+    ////delete result;
+    return 0;
+}
+
+uint32 PlayerbotAI::GetTalentSpecsAmount()
+{
+    //QueryResult result = CharacterDatabase.PQuery("SELECT COUNT(*) FROM playerbot_talentspec");
+
+    //if (!result)
+    //{
+    //    //sLog->outString();
+    //    //sLog->outString(">> Loaded `playerbot_talentspec`, table is empty.");
+
+        return 0;
+    //}
+
+    //Field* fields = result->Fetch();
+
+    //uint32 count = fields[0].GetUInt32();
+
+    ////delete result;
+    //return count;
+}
+
+uint32 PlayerbotAI::GetTalentSpecsAmount(long /*specClass*/)
+{
+    //QueryResult result = CharacterDatabase.PQuery("SELECT COUNT(*) FROM playerbot_talentspec WHERE class = '%li'", specClass);
+
+    //if (!result)
+    //{
+    //    //sLog->outString();
+    //    //sLog->outString(">> Loaded `playerbot_talentspec`, found no talentspecs for class %li.", specClass);
+
+        return 0;
+    //}
+
+    //Field* fields = result->Fetch();
+
+    //uint32 count = fields[0].GetUInt32();
+
+    ////delete result;
+    //return count;
+}
+
+/**
+ * GetTalentSpecs queries DB for the talentspecs (for a class), returning them in a list of TS structures
+ *
+ * *** for the most part, GetTalentSpecs assumes ALL SPECS ARE VALID ***
+ */
+std::list<TalentSpec> PlayerbotAI::GetTalentSpecs(long /*specClass*/)
+{
+    TalentSpec ts;
+    std::list<TalentSpec> tsList;
+    tsList.clear();
+    return tsList;
+
+    //QueryResult result = CharacterDatabase.PQuery("SELECT * FROM playerbot_talentspec WHERE class = %li ORDER BY talentspec_id ASC", specClass);
+
+    //if (!result)
+    //{
+    //    //sLog->outString();
+    //    //sLog->outString(">> Loaded `playerbot_talentspec`, found no talentspecs for class %li.", specClass);
+
+    //    return tsList; // empty
+    //}
+
+    //do
+    //{
+    //    /* 0            talentspec_id
+    //       1            name
+    //       2            class
+    //       3            purpose
+    //       4 to 74        talent_10 to 71
+    //       75 to 80        major_glyph_15, 30, 80, minor_glyph_15, 50, 70
+    //     */
+    //    Field* fields = result->Fetch();
+
+    //    /* ts_id = fields[0].GetUInt32(); // not used
+    //       if (!ts_id)    // Nice bit of paranoia: ts_id is an AUTO_INCREMENT value
+    //       continue;  // Of course, if the impossible ever does happen, we can't very well identify a TalentSpec without an ID...
+    //     */
+
+    //    ts.specName = fields[1].GetCString();
+    //    ts.specClass = fields[2].GetInt16();
+    //    if (ts.specClass != CLASS_DEATH_KNIGHT && ts.specClass != CLASS_DRUID && ts.specClass != CLASS_HUNTER && ts.specClass != CLASS_MAGE && ts.specClass != CLASS_PALADIN && ts.specClass != CLASS_PRIEST && ts.specClass != CLASS_ROGUE && ts.specClass != CLASS_SHAMAN && ts.specClass != CLASS_WARLOCK && ts.specClass != CLASS_WARRIOR &&
+    //        ts.specClass != CLASS_PET_CUNNING && ts.specClass != CLASS_PET_FEROCITY && ts.specClass != CLASS_PET_TENACITY)
+    //    {
+    //        TellMaster("TalentSpec: %u. \"%s\" contains an invalid class.", fields[0].GetUInt32(), ts.specName.c_str());
+
+    //        continue;    // this spec is clearly broken, the next may or may not be
+    //    }
+
+    //    ts.specPurpose = (TalentSpecPurpose) fields[3].GetUInt32();
+
+    //    // check all talents
+    //    for (uint8 i = 0; i < 71; i++)
+    //    {
+    //        ts.talentId[i] = fields[i + 4].GetUInt16();
+    //    }
+
+    //    for (uint8 i = 0; i < 3; i++)  // as in, the 3 major glyphs
+    //    {
+    //        ts.glyphIdMajor[i] = fields[i + 75].GetUInt16();
+    //    }
+    //    for (uint8 i = 0; i < 3; i++)  // as in, the 3 minor glyphs
+    //    {
+    //        ts.glyphIdMajor[i] = fields[i + 78].GetUInt16();
+    //    }
+
+    //    tsList.push_back(ts);
+    //} while (result->NextRow());
+
+    ////delete result;
+    //return tsList;
+}
+
+/**
+ * GetTalentSpec queries DB for a talentspec given a class and a choice.
+ * The choice applies to the results for that class only, and is volatile.
+ *
+ * *** for the most part, GetTalentSpec assumes ALL SPECS ARE VALID ***
+ */
+TalentSpec PlayerbotAI::GetTalentSpec(long /*specClass*/, long /*choice*/)
+{
+    TalentSpec ts;
+    // Let's zero it out to be safe
+    ts.specName = "";
+    ts.specClass = 0;
+    ts.specPurpose = TSP_NONE;
+    for (int i = 0; i < 71; i++) ts.talentId[i] = 0;
+    for (int i = 0; i < 3; i++) ts.glyphIdMajor[i] = 0;
+    for (int i = 0; i < 3; i++) ts.glyphIdMinor[i] = 0;
+    return ts;
+
+    //// Weed out invalid choice - ts has been zero'd out anyway
+    //if (0 >= choice || (long) GetTalentSpecsAmount(specClass) < choice) return ts;
+
+    //QueryResult result = CharacterDatabase.PQuery("SELECT * FROM playerbot_talentspec WHERE class = %li ORDER BY talentspec_id ASC", specClass);
+
+    //if (!result)
+    //{
+    //    //sLog->outString();
+    //    //sLog->outString(">> Loaded `playerbot_talentspec`, found no talentspecs for class %li.", specClass);
+
+    //    //delete result;
+    //    return ts; // empty
+    //}
+
+    //for (int i = 1; i <= (int) GetTalentSpecsAmount(specClass); i++)
+    //{
+
+    //    if (i == choice)
+    //    {
+    //        /*
+    //           0            talentspec_id
+    //           1            name
+    //           2            class
+    //           3            purpose
+    //           4 to 74    talent_10 to 71
+    //           75 to 80    major_glyph_15, 30, 80, minor_glyph_15, 50, 70
+    //         */
+    //        Field* fields = result->Fetch();
+
+    //        /* ts_id = fields[0].GetUInt32(); // not used
+    //           if (!ts_id)    // Nice bit of paranoia: ts_id is an AUTO_INCREMENT value
+    //           continue;  // Of course, if the impossible ever does happen, we can't very well identify a TalentSpec without an ID...
+    //         */
+
+    //        ts.specName = fields[1].GetCString();
+    //        ts.specClass = fields[2].GetInt16();
+    //        if (ts.specClass != CLASS_DEATH_KNIGHT && ts.specClass != CLASS_DRUID && ts.specClass != CLASS_HUNTER && ts.specClass != CLASS_MAGE && ts.specClass != CLASS_PALADIN && ts.specClass != CLASS_PRIEST && ts.specClass != CLASS_ROGUE && ts.specClass != CLASS_SHAMAN && ts.specClass != CLASS_WARLOCK && ts.specClass != CLASS_WARRIOR &&
+    //            ts.specClass != CLASS_PET_CUNNING && ts.specClass != CLASS_PET_FEROCITY && ts.specClass != CLASS_PET_TENACITY)
+    //        {
+    //            TellMaster("TalentSpec: %u. \"%s\" contains an invalid class.", fields[0].GetUInt32(), ts.specName.c_str());
+
+    //            ts.specName = "";
+    //            ts.specClass = 0;
+    //            //delete result;
+    //            return ts;
+    //        }
+
+    //        ts.specPurpose = (TalentSpecPurpose) fields[3].GetUInt32();
+
+    //        // check all talents
+    //        for (uint8 i = 0; i < 71; i++)
+    //        {
+    //            ts.talentId[i] = fields[i + 4].GetUInt16();
+    //        }
+
+    //        for (uint8 i = 0; i < 3; i++)  // as in, the 3 major glyphs
+    //        {
+    //            ts.glyphIdMajor[i] = fields[i + 75].GetUInt16();
+    //        }
+    //        for (uint8 i = 0; i < 3; i++)  // as in, the 3 minor glyphs
+    //        {
+    //            ts.glyphIdMajor[i] = fields[i + 78].GetUInt16();
+    //        }
+
+    //        //delete result;
+    //        return ts;
+    //    }
+
+    //    // TODO: okay, this won't bog down the system, but it's still a waste. Figure out a better way.
+    //    result->NextRow();
+    //}
+
+    ////delete result;
+    //return ts;
+}
+
+/**
+ * ApplyActiveTalentSpec takes the active talent spec and attempts to apply it
+ *
+ * return true  -> ok, talentspec applied as fully as possible
+ * return false -> talentspec was not or only partially applied
+ */
+bool PlayerbotAI::ApplyActiveTalentSpec()
+{
+    //DISABLED
+    //// empty talent spec -> nothing to apply -> fully applied
+    //if (m_activeTalentSpec.specClass == 0 || m_activeTalentSpec.specPurpose == TSP_NONE)
+    //    return true;
+
+    //// Some basic error checking just in case
+    //if (m_activeTalentSpec.specClass != m_bot->getClass())
+    //    return false;
+
+    //std::vector<uint16> talentsToLearn;
+    //talentsToLearn.reserve(71);
+    //for (int i = 0; i < 71; i++)
+    //{
+    //    if (m_activeTalentSpec.talentId[i] != 0)
+    //        talentsToLearn.push_back(m_activeTalentSpec.talentId[i]);
+    //}
+
+    //PlayerTalentMap *ptm = m_bot->GetTalents(m_bot->GetActiveSpec());
+    //// First do a check as to whether all known talents are in the talent spec
+    //for (PlayerTalentMap::iterator iter = ptm->begin(); iter != ptm->end(); iter++)
+    //{
+    //    PlayerTalent* talent = (*iter).second;
+
+    //    // WARNING: There may be more than 71 'talents' in the PTM - unlearned talents are simply set as disabled - not removed
+    //    if (talent.state == PLAYERSPELL_REMOVED)
+    //        continue;
+
+    //    // currentRank = 0 to (MAX_RANK-1) not 1 to MAX_RANK
+    //    for (int i = 0; i <= (int) talent.currentRank; i++)
+    //    {
+    //        int j = 0; // why 0 and not -1? Because if talentsToCheck (no TalentSpec) is empty and talents have been learned -> NOK
+    //        for (std::vector<uint16>::iterator it = talentsToLearn.begin(); it != talentsToLearn.end(); it++)
+    //        {
+    //            if (talentsToLearn.at(j) == talent.talentEntry->TalentID)
+    //            {
+    //                talentsToLearn.erase(it);
+    //                j = -1; // So j = -1 -> learned talent found in talentspec
+    //                break;
+    //            }
+    //            j++;
+    //        }
+
+    //        // j == -1 signifies talent has been found in talent spec
+    //        if (-1 != j)
+    //        {
+    //            TellMaster("I've learned talents that are not in my talent spec. If you want me to learn the talent spec anyway you should have me reset my talents.");
+    //            return false;
+    //        }
+    //    }
+    //}
+
+    //int x = 0;
+    //for (std::vector<uint16>::iterator iter = talentsToLearn.begin(); iter != talentsToLearn.end(); iter++)
+    //{
+    //    // find current talent rank
+    //    uint32 learnTalentRank = 0;
+    //    if (PlayerTalent const* talent = m_bot->GetKnownTalentById(talentsToLearn.at(x)))
+    //        learnTalentRank = talent->currentRank + 1;
+    //    // else -> not known -> to learn = 0
+
+    //    // check if we have enough talent points
+    //    uint32 freeTalentPointsBefore = m_bot->GetFreeTalentPoints();
+    //    if (0 == freeTalentPointsBefore)
+    //        return true;
+
+    //    m_bot->LearnTalent(talentsToLearn.at(x), learnTalentRank);
+    //    if (freeTalentPointsBefore == m_bot->GetFreeTalentPoints())
+    //    {
+    //        // Do not tell master - error is logged server side, master gets generic failure warning from calling function.
+    //        //TellMaster("Failed to learn talent - Class: %i; TalentId: %i; TalentRank: %i. This error has been logged.", m_bot->getClass(), talentsToLearn.at(x), learnTalentRank);
+    //        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: ApplyActiveTalentSpec failure - Class: %i; TalentId: %i; TalentRank: %i.", m_bot->getClass(), talentsToLearn.at(x), learnTalentRank);
+    //        return false;
+    //    }
+
+    //    x++;
+    //}
+
+    return true;
+}
+
+/**
+ * ValidateTalent tests a talent against class to see if it belongs to that class
+ *
+ * uint16 talent:        talent ID
+ * long charClass:    member of the Classes enum or ClassesCombatPets enum
+ *
+ * return true  -> ok
+ * return false -> not a valid talent for that class
+ */
+bool PlayerbotAI::ValidateTalent(uint16 talent, long charClass)
+{
+    if (charClass == CLASS_DEATH_KNIGHT)
+    {
+        // this looong 'if' is to see if any talent is not a Death Knight talent when the class clearly is
+        if (DEATHKNIGHT_BUTCHERY != talent && DEATHKNIGHT_SUBVERSION != talent && DEATHKNIGHT_BLADE_BARRIER != talent && DEATHKNIGHT_BLADED_ARMOR != talent && DEATHKNIGHT_SCENT_OF_BLOOD != talent && DEATHKNIGHT_TWOHANDED_WEAPON_SPECIALIZATION != talent && DEATHKNIGHT_RUNE_TAP != talent && DEATHKNIGHT_DARK_CONVICTION != talent && DEATHKNIGHT_DEATH_RUNE_MASTERY != talent && DEATHKNIGHT_IMPROVED_RUNE_TAP != talent && DEATHKNIGHT_SPELL_DEFLECTION != talent && DEATHKNIGHT_VENDETTA != talent && DEATHKNIGHT_BLOODY_STRIKES != talent && DEATHKNIGHT_VETERAN_OF_THE_THIRD_WAR != talent && DEATHKNIGHT_MARK_OF_BLOOD != talent && DEATHKNIGHT_BLOODY_VENGEANCE != talent && DEATHKNIGHT_ABOMINATIONS_MIGHT != talent && DEATHKNIGHT_BLOOD_WORMS != talent && DEATHKNIGHT_HYSTERIA != talent && DEATHKNIGHT_IMPROVED_BLOOD_PRESENCE != talent && DEATHKNIGHT_IMPROVED_DEATH_STRIKE != talent && DEATHKNIGHT_SUDDEN_DOOM != talent && DEATHKNIGHT_VAMPIRIC_BLOOD != talent && DEATHKNIGHT_WILL_OF_THE_NECROPOLIS != talent && DEATHKNIGHT_HEART_STRIKE != talent && DEATHKNIGHT_MIGHT_OF_MOGRAINE != talent && DEATHKNIGHT_BLOOD_GORGED != talent && DEATHKNIGHT_DANCING_RUNE_WEAPON != talent && DEATHKNIGHT_IMPROVED_ICY_TOUCH != talent && DEATHKNIGHT_RUNIC_POWER_MASTERY != talent && DEATHKNIGHT_TOUGHNESS != talent && DEATHKNIGHT_ICY_REACH != talent && DEATHKNIGHT_BLACK_ICE != talent && DEATHKNIGHT_NERVES_OF_COLD_STEEL != talent && DEATHKNIGHT_ICY_TALONS != talent && DEATHKNIGHT_LICHBORNE != talent && DEATHKNIGHT_ANNIHILATION != talent && DEATHKNIGHT_KILLING_MACHINE != talent && DEATHKNIGHT_CHILL_OF_THE_GRAVE != talent && DEATHKNIGHT_ENDLESS_WINTER != talent && DEATHKNIGHT_FRIGID_DREADPLATE != talent && DEATHKNIGHT_GLACIER_ROT != talent && DEATHKNIGHT_DEATHCHILL != talent && DEATHKNIGHT_IMPROVED_ICY_TALONS != talent && DEATHKNIGHT_MERCILESS_COMBAT != talent && DEATHKNIGHT_RIME != talent && DEATHKNIGHT_CHILLBLAINS != talent && DEATHKNIGHT_HUNGERING_COLD != talent && DEATHKNIGHT_IMPROVED_FROST_PRESENCE != talent && DEATHKNIGHT_THREAT_OF_THASSARIAN != talent && DEATHKNIGHT_BLOOD_OF_THE_NORTH != talent && DEATHKNIGHT_UNBREAKABLE_ARMOR != talent && DEATHKNIGHT_ACCLIMATION != talent && DEATHKNIGHT_FROST_STRIKE != talent && DEATHKNIGHT_GUILE_OF_GOREFIEND != talent && DEATHKNIGHT_TUNDRA_STALKER != talent && DEATHKNIGHT_HOWLING_BLAST != talent && DEATHKNIGHT_VICIOUS_STRIKES != talent && DEATHKNIGHT_VIRULENCE != talent && DEATHKNIGHT_ANTICIPATION != talent && DEATHKNIGHT_EPIDEMIC != talent && DEATHKNIGHT_MORBIDITY != talent && DEATHKNIGHT_UNHOLY_COMMAND != talent && DEATHKNIGHT_RAVENOUS_DEAD != talent && DEATHKNIGHT_OUTBREAK != talent && DEATHKNIGHT_NECROSIS != talent && DEATHKNIGHT_CORPSE_EXPLOSION != talent && DEATHKNIGHT_ON_A_PALE_HORSE != talent && DEATHKNIGHT_BLOODCAKED_BLADE != talent && DEATHKNIGHT_NIGHT_OF_THE_DEAD != talent && DEATHKNIGHT_UNHOLY_BLIGHT != talent && DEATHKNIGHT_IMPURITY != talent && DEATHKNIGHT_DIRGE != talent && DEATHKNIGHT_DESECRATION != talent && DEATHKNIGHT_MAGIC_SUPPRESSION != talent && DEATHKNIGHT_REAPING != talent && DEATHKNIGHT_MASTER_OF_GHOULS != talent && DEATHKNIGHT_DESOLATION != talent && DEATHKNIGHT_ANTIMAGIC_ZONE != talent && DEATHKNIGHT_IMPROVED_UNHOLY_PRESENCE != talent && DEATHKNIGHT_GHOUL_FRENZY != talent && DEATHKNIGHT_CRYPT_FEVER != talent && DEATHKNIGHT_BONE_SHIELD != talent && DEATHKNIGHT_WANDERING_PLAGUE != talent && DEATHKNIGHT_EBON_PLAGUEBRINGER != talent && DEATHKNIGHT_SCOURGE_STRIKE != talent && DEATHKNIGHT_RAGE_OF_RIVENDARE != talent && DEATHKNIGHT_SUMMON_GARGOYLE != talent)
+            return false;
+    }
+    else if (charClass == CLASS_DRUID)
+    {
+        if (DRUID_FEROCITY != talent && DRUID_FERAL_AGGRESSION != talent && DRUID_FERAL_INSTINCT != talent && DRUID_SAVAGE_FURY != talent && DRUID_THICK_HIDE != talent && DRUID_FERAL_SWIFTNESS != talent && DRUID_SURVIVAL_INSTINCTS != talent && DRUID_SHARPENED_CLAWS != talent && DRUID_SHREDDING_ATTACKS != talent && DRUID_PREDATORY_STRIKES != talent && DRUID_PRIMAL_FURY != talent && DRUID_PRIMAL_PRECISION != talent && DRUID_BRUTAL_IMPACT != talent && DRUID_FERAL_CHARGE != talent && DRUID_NURTURING_INSTINCT != talent && DRUID_NATURAL_REACTION != talent && DRUID_HEART_OF_THE_WILD != talent && DRUID_SURVIVAL_OF_THE_FITTEST != talent && DRUID_LEADER_OF_THE_PACK != talent && DRUID_IMPROVED_LEADER_OF_THE_PACK != talent && DRUID_PRIMAL_TENACITY != talent && DRUID_PROTECTOR_OF_THE_PACK != talent && DRUID_PREDATORY_INSTINCTS != talent && DRUID_INFECTED_WOUNDS != talent && DRUID_KING_OF_THE_JUNGLE != talent && DRUID_MANGLE != talent && DRUID_IMPROVED_MANGLE != talent && DRUID_REND_AND_TEAR != talent && DRUID_PRIMAL_GORE != talent && DRUID_BERSERK != talent && DRUID_IMPROVED_MARK_OF_THE_WILD != talent && DRUID_NATURES_FOCUS != talent && DRUID_FUROR != talent && DRUID_NATURALIST != talent && DRUID_SUBTLETY != talent && DRUID_NATURAL_SHAPESHIFTER != talent && DRUID_INTENSITY != talent && DRUID_OMEN_OF_CLARITY != talent && DRUID_MASTER_SHAPESHIFTER != talent && DRUID_TRANQUIL_SPIRIT != talent && DRUID_IMPROVED_REJUVENATION != talent && DRUID_NATURES_SWIFTNESS != talent && DRUID_GIFT_OF_NATURE != talent && DRUID_IMPROVED_TRANQUILITY != talent && DRUID_EMPOWERED_TOUCH != talent && DRUID_NATURES_BOUNTY != talent && DRUID_LIVING_SPIRIT != talent && DRUID_SWIFTMEND != talent && DRUID_NATURAL_PERFECTION != talent && DRUID_EMPOWERED_REJUVENATION != talent && DRUID_LIVING_SEED != talent && DRUID_REVITALIZE != talent && DRUID_TREE_OF_LIFE != talent && DRUID_IMPROVED_TREE_OF_LIFE != talent && DRUID_IMPROVED_BARKSKIN != talent && DRUID_GIFT_OF_THE_EARTHMOTHER != talent && DRUID_WILD_GROWTH != talent && DRUID_STARLIGHT_WRATH != talent && DRUID_GENESIS != talent && DRUID_MOONGLOW != talent && DRUID_NATURES_MAJESTY != talent && DRUID_IMPROVED_MOONFIRE != talent && DRUID_BRAMBLES != talent && DRUID_NATURES_GRACE != talent && DRUID_NATURES_SPLENDOR_A != talent && DRUID_NATURES_REACH != talent && DRUID_VENGEANCE != talent && DRUID_CELESTIAL_FOCUS != talent && DRUID_LUNAR_GUIDANCE != talent && DRUID_INSECT_SWARM != talent && DRUID_IMPROVED_INSECT_SWARM != talent && DRUID_DREAMSTATE != talent && DRUID_MOONFURY != talent && DRUID_BALANCE_OF_POWER != talent && DRUID_IMPROVED_MOONKIN_FORM != talent && DRUID_IMPROVED_FAERIE_FIRE != talent && DRUID_OWLKIN_FRENZY != talent && DRUID_WRATH_OF_CENARIUS != talent && DRUID_ECLIPSE != talent && DRUID_TYPHOON != talent && DRUID_FORCE_OF_NATURE != talent && DRUID_GALE_WINDS != talent && DRUID_EARTH_AND_MOON != talent && DRUID_STARFALL != talent)
+            return false;
+    }
+    else if (charClass == CLASS_HUNTER)
+    {
+        if (HUNTER_IMPROVED_ASPECT_OF_THE_HAWK != talent && HUNTER_ENDURANCE_TRAINING != talent && HUNTER_FOCUSED_FIRE != talent && HUNTER_IMPROVED_ASPECT_OF_THE_MONKEY != talent && HUNTER_THICK_HIDE != talent && HUNTER_IMPROVED_REVIVE_PET != talent && HUNTER_PATHFINDING != talent && HUNTER_ASPECT_MASTERY != talent && HUNTER_UNLEASHED_FURY != talent && HUNTER_IMPROVED_MEND_PET != talent && HUNTER_FEROCITY != talent && HUNTER_SPIRIT_BOND != talent && HUNTER_INTIMIDATION != talent && HUNTER_BESTIAL_DISCIPLINE != talent && HUNTER_ANIMAL_HANDLER != talent && HUNTER_FRENZY != talent && HUNTER_FEROCIOUS_INSPIRATION != talent && HUNTER_BESTIAL_WRATH != talent && HUNTER_CATLIKE_REFLEXES != talent && HUNTER_INVIGORATION != talent && HUNTER_SERPENTS_SWIFTNESS != talent && HUNTER_LONGEVITY != talent && HUNTER_THE_BEAST_WITHIN != talent && HUNTER_COBRA_STRIKES != talent && HUNTER_KINDRED_SPIRITS != talent && HUNTER_BEAST_MASTERY != talent && HUNTER_IMPROVED_TRACKING != talent && HUNTER_HAWK_EYE != talent && HUNTER_SAVAGE_STRIKES != talent && HUNTER_SUREFOOTED != talent && HUNTER_ENTRAPMENT != talent && HUNTER_TRAP_MASTERY != talent && HUNTER_SURVIVAL_INSTINCTS != talent && HUNTER_SURVIVALIST != talent && HUNTER_SCATTER_SHOT != talent && HUNTER_DEFLECTION != talent && HUNTER_SURVIVAL_TACTICS != talent && HUNTER_TNT != talent && HUNTER_LOCK_AND_LOAD != talent && HUNTER_HUNTER_VS_WILD != talent && HUNTER_KILLER_INSTINCT != talent && HUNTER_COUNTERATTACK != talent && HUNTER_LIGHTNING_REFLEXES != talent && HUNTER_RESOURCEFULNESS != talent && HUNTER_EXPOSE_WEAKNESS != talent && HUNTER_WYVERN_STING != talent && HUNTER_THRILL_OF_THE_HUNT != talent && HUNTER_MASTER_TACTICIAN != talent && HUNTER_NOXIOUS_STINGS != talent && HUNTER_POINT_OF_NO_ESCAPE != talent && HUNTER_BLACK_ARROW != talent && HUNTER_SNIPER_TRAINING != talent && HUNTER_HUNTING_PARTY != talent && HUNTER_EXPLOSIVE_SHOT != talent && HUNTER_IMPROVED_CONCUSSIVE_SHOT != talent && HUNTER_FOCUSED_AIM != talent && HUNTER_LETHAL_SHOTS != talent && HUNTER_CAREFUL_AIM != talent && HUNTER_IMPROVED_HUNTERS_MARK != talent && HUNTER_MORTAL_SHOTS != talent && HUNTER_GO_FOR_THE_THROAT != talent && HUNTER_IMPROVED_ARCANE_SHOT != talent && HUNTER_AIMED_SHOT != talent && HUNTER_RAPID_KILLING != talent && HUNTER_IMPROVED_STINGS != talent && HUNTER_EFFICIENCY != talent && HUNTER_CONCUSSIVE_BARRAGE != talent && HUNTER_READINESS != talent && HUNTER_BARRAGE != talent && HUNTER_COMBAT_EXPERIENCE != talent && HUNTER_RANGED_WEAPON_SPECIALIZATION != talent && HUNTER_PIERCING_SHOTS != talent && HUNTER_TRUESHOT_AURA != talent && HUNTER_IMPROVED_BARRAGE != talent && HUNTER_MASTER_MARKSMAN != talent && HUNTER_RAPID_RECUPERATION != talent && HUNTER_WILD_QUIVER != talent && HUNTER_SILENCING_SHOT != talent && HUNTER_IMPROVED_STEADY_SHOT != talent && HUNTER_MARKED_FOR_DEATH != talent && HUNTER_CHIMERA_SHOT != talent)
+            return false;
+    }
+    else if (charClass == CLASS_MAGE)
+    {
+        if (MAGE_IMPROVED_FIRE_BLAST != talent && MAGE_INCINERATION != talent && MAGE_IMPROVED_FIREBALL != talent && MAGE_IGNITE != talent && MAGE_BURNING_DETERMINATION != talent && MAGE_WORLD_IN_FLAMES != talent && MAGE_FLAME_THROWING != talent && MAGE_IMPACT != talent && MAGE_PYROBLAST != talent && MAGE_BURNING_SOUL != talent && MAGE_IMPROVED_SCORCH != talent && MAGE_MOLTEN_SHIELDS != talent && MAGE_MASTER_OF_ELEMENTS != talent && MAGE_PLAYING_WITH_FIRE != talent && MAGE_CRITICAL_MASS != talent && MAGE_BLAST_WAVE != talent && MAGE_BLAZING_SPEED != talent && MAGE_FIRE_POWER != talent && MAGE_PYROMANIAC != talent && MAGE_COMBUSTION != talent && MAGE_MOLTEN_FURY != talent && MAGE_FIERY_PAYBACK != talent && MAGE_EMPOWERED_FIRE != talent && MAGE_FIRESTARTER != talent && MAGE_DRAGONS_BREATH != talent && MAGE_HOT_STREAK != talent && MAGE_BURNOUT != talent && MAGE_LIVING_BOMB != talent && MAGE_FROSTBITE != talent && MAGE_IMPROVED_FROSTBOLT != talent && MAGE_ICE_FLOES != talent && MAGE_ICE_SHARDS != talent && MAGE_FROST_WARDING != talent && MAGE_PRECISION != talent && MAGE_PERMAFROST != talent && MAGE_PIERCING_ICE != talent && MAGE_ICY_VEINS != talent && MAGE_IMPROVED_BLIZZARD != talent && MAGE_ARCTIC_REACH != talent && MAGE_FROST_CHANNELING != talent && MAGE_SHATTER != talent && MAGE_COLD_SNAP != talent && MAGE_IMPROVED_CONE_OF_COLD != talent && MAGE_FROZEN_CORE != talent && MAGE_COLD_AS_ICE != talent && MAGE_WINTERS_CHILL != talent && MAGE_SHATTERED_BARRIER != talent && MAGE_ICE_BARRIER != talent && MAGE_ARCTIC_WINDS != talent && MAGE_EMPOWERED_FROSTBOLT != talent && MAGE_FINGERS_OF_FROST != talent && MAGE_BRAIN_FREEZE != talent && MAGE_SUMMON_WATER_ELEMENTAL != talent && MAGE_ENDURING_WINTER != talent && MAGE_CHILLD_TO_THE_BONE != talent && MAGE_DEEP_FREEZE != talent && MAGE_ARCANE_SUBTLETY != talent && MAGE_ARCANE_FOCUS != talent && MAGE_ARCANE_STABILITY != talent && MAGE_ARCANE_FORTITUDE != talent && MAGE_MAGIC_ABSORPTION != talent && MAGE_ARCANE_CONCENTRATION != talent && MAGE_MAGIC_ATTUNEMENT != talent && MAGE_SPELL_IMPACT != talent && MAGE_STUDENT_OF_THE_MIND != talent && MAGE_FOCUS_MAGIC != talent && MAGE_ARCANE_SHIELDING != talent && MAGE_IMPROVED_COUNTERSPELL != talent && MAGE_ARCANE_MEDITATION != talent && MAGE_TORMENT_THE_WEAK != talent && MAGE_IMPROVED_BLINK != talent && MAGE_PRESENCE_OF_MIND != talent && MAGE_ARCANE_MIND != talent && MAGE_PRISMATIC_CLOAK != talent && MAGE_ARCANE_INSTABILITY != talent && MAGE_ARCANE_POTENCY != talent && MAGE_ARCANE_EMPOWERMENT != talent && MAGE_ARCANE_POWER != talent && MAGE_INCANTERS_ABSORPTION != talent && MAGE_ARCANE_FLOWS != talent && MAGE_MIND_MASTERY != talent && MAGE_SLOW != talent && MAGE_MISSILE_BARRAGE != talent && MAGE_NETHERWIND_PRESENCE != talent && MAGE_SPELL_POWER != talent && MAGE_ARCANE_BARRAGE != talent)
+            return false;
+    }
+    else if (charClass == CLASS_PALADIN)
+    {
+        if (PALADIN_DEFLECTION != talent && PALADIN_BENEDICTION != talent && PALADIN_IMPROVED_JUDGEMENTS != talent && PALADIN_HEART_OF_THE_CRUSADER != talent && PALADIN_IMPROVED_BLESSING_OF_MIGHT != talent && PALADIN_VINDICATION != talent && PALADIN_CONVICTION != talent && PALADIN_SEAL_OF_COMMAND != talent && PALADIN_PURSUIT_OF_JUSTICE != talent && PALADIN_EYE_FOR_AN_EYE != talent && PALADIN_SANCTITY_OF_BATTLE != talent && PALADIN_CRUSADE != talent && PALADIN_TWOHANDED_WEAPON_SPECIALIZATION != talent && PALADIN_SANCTIFIED_RETRIBUTION != talent && PALADIN_VENGEANCE != talent && PALADIN_DIVINE_PURPOSE != talent && PALADIN_THE_ART_OF_WAR != talent && PALADIN_REPENTANCE != talent && PALADIN_JUDGEMENTS_OF_THE_WISE != talent && PALADIN_FANATICISM != talent && PALADIN_SANCTIFIED_WRATH != talent && PALADIN_SWIFT_RETRIBUTION != talent && PALADIN_CRUSADER_STRIKE != talent && PALADIN_SHEATH_OF_LIGHT != talent && PALADIN_RIGHTEOUS_VENGEANCE != talent && PALADIN_DIVINE_STORM != talent && PALADIN_SPIRITUAL_FOCUS != talent && PALADIN_SEALS_OF_THE_PURE != talent && PALADIN_HEALING_LIGHT != talent && PALADIN_DIVINE_INTELLECT != talent && PALADIN_UNYIELDING_FAITH != talent && PALADIN_AURA_MASTERY != talent && PALADIN_ILLUMINATION != talent && PALADIN_IMPROVED_LAY_ON_HANDS != talent && PALADIN_IMPROVED_CONCENTRATION_AURA != talent && PALADIN_IMPROVED_BLESSING_OF_WISDOM != talent && PALADIN_BLESSED_HANDS != talent && PALADIN_PURE_OF_HEART != talent && PALADIN_DIVINE_FAVOR != talent && PALADIN_SANCTIFIED_LIGHT != talent && PALADIN_PURIFYING_POWER != talent && PALADIN_HOLY_POWER != talent && PALADIN_LIGHTS_GRACE != talent && PALADIN_HOLY_SHOCK != talent && PALADIN_BLESSED_LIFE != talent && PALADIN_SACRED_CLEANSING != talent && PALADIN_HOLY_GUIDANCE != talent && PALADIN_DIVINE_ILLUMINATION != talent && PALADIN_JUDGEMENTS_OF_THE_PURE != talent && PALADIN_INFUSION_OF_LIGHT != talent && PALADIN_ENLIGHTENED_JUDGEMENTS != talent && PALADIN_BEACON_OF_LIGHT != talent && PALADIN_DIVINITY != talent && PALADIN_DIVINE_STRENGTH != talent && PALADIN_STOICISM != talent && PALADIN_GUARDIANS_FAVOR != talent && PALADIN_ANTICIPATION != talent && PALADIN_DIVINE_SACRIFICE != talent && PALADIN_IMPROVED_RIGHTEOUS_FURY != talent && PALADIN_TOUGHNESS != talent && PALADIN_DIVINE_GUARDIAN != talent && PALADIN_IMPROVED_HAMMER_OF_JUSTICE != talent && PALADIN_IMPROVED_DEVOTION_AURA != talent && PALADIN_BLESSING_OF_SANCTUARY != talent && PALADIN_RECKONING != talent && PALADIN_SACRED_DUTY != talent && PALADIN_ONEHANDED_WEAPON_SPECIALIZATION != talent && PALADIN_SPIRITUAL_ATTUNEMENT != talent && PALADIN_HOLY_SHIELD != talent && PALADIN_ARDENT_DEFENDER != talent && PALADIN_REDOUBT != talent && PALADIN_COMBAT_EXPERTISE != talent && PALADIN_TOUCHER_BY_THE_LIGHT != talent && PALADIN_AVENGERS_SHIELD != talent && PALADIN_GUARDED_BY_THE_LIGHT != talent && PALADIN_SHIELD_OF_THE_TEMPLAR != talent && PALADIN_JUDGEMENT_OF_THE_JUST != talent && PALADIN_HAMMER_OF_THE_RIGHTEOUS != talent)
+            return false;
+    }
+    else if (charClass == CLASS_PRIEST)
+    {
+        if (PRIEST_UNBREAKABLE_WILL != talent && PRIEST_TWIN_DISCIPLINES != talent && PRIEST_SILENT_RESOLVE != talent && PRIEST_IMPROVED_INNER_FIRE != talent && PRIEST_IMPROVED_POWER_WORD_FORTITUDE != talent && PRIEST_MARTYRDOM != talent && PRIEST_MEDITATION != talent && PRIEST_INNER_FOCUS != talent && PRIEST_IMPROVED_POWER_WORD_SHIELD != talent && PRIEST_ABSOLUTION != talent && PRIEST_MENTAL_AGILITY != talent && PRIEST_IMPROVED_MANA_BURN != talent && PRIEST_REFLECTIVE_SHIELD != talent && PRIEST_MENTAL_STRENGTH != talent && PRIEST_SOUL_WARDING != talent && PRIEST_FOCUSED_POWER != talent && PRIEST_ENLIGHTENMENT != talent && PRIEST_FOCUSED_WILL != talent && PRIEST_POWER_INFUSION != talent && PRIEST_IMPROVED_FLASH_HEAL != talent && PRIEST_RENEWED_HOPE != talent && PRIEST_RAPTURE != talent && PRIEST_ASPIRATION != talent && PRIEST_DIVINE_AEGIS != talent && PRIEST_PAIN_SUPPRESSION != talent && PRIEST_GRACE != talent && PRIEST_BORROWED_TIME != talent && PRIEST_PENANCE != talent && PRIEST_HEALING_FOCUS != talent && PRIEST_IMPROVED_RENEW != talent && PRIEST_HOLY_SPECIALIZATION != talent && PRIEST_SPELL_WARDING != talent && PRIEST_DIVINE_FURY != talent && PRIEST_DESPERATE_PRAYER != talent && PRIEST_BLESSED_RECOVERY != talent && PRIEST_INSPIRATION != talent && PRIEST_HOLY_REACH != talent && PRIEST_IMPROVED_HEALIN != talent && PRIEST_SEARING_LIGHT != talent && PRIEST_HEALING_PRAYERS != talent && PRIEST_SPIRIT_OF_REDEMPTION != talent && PRIEST_SPIRITUAL_GUIDANCE != talent && PRIEST_SURGE_OF_LIGHT != talent && PRIEST_SPIRITUAL_HEALING != talent && PRIEST_HOLY_CONCENTRATION != talent && PRIEST_LIGHTWELL != talent && PRIEST_BLESSED_RESILIENCE != talent && PRIEST_BODY_AND_SOUL != talent && PRIEST_EMPOWERED_HEALING != talent && PRIEST_SERENDIPITY != talent && PRIEST_EMPOWERED_RENEW != talent && PRIEST_CIRCLE_OF_HEALING != talent && PRIEST_TEST_OF_FAITH != talent && PRIEST_DIVINE_PROVIDENCE != talent && PRIEST_GUARDIAN_SPIRIT != talent && PRIEST_SPIRIT_TAP != talent && PRIEST_IMPROVED_SPIRIT_TAP != talent && PRIEST_DARKNESS != talent && PRIEST_SHADOW_AFFINITY != talent && PRIEST_IMPROVED_SHADOW_WORD_PAIN != talent && PRIEST_SHADOW_FOCUS != talent && PRIEST_IMPROVED_PSYCHIC_SCREAM != talent && PRIEST_IMPROVED_MIND_BLAST != talent && PRIEST_MIND_FLAY != talent && PRIEST_VEILED_SHADOWS != talent && PRIEST_SHADOW_REACH != talent && PRIEST_SHADOW_WEAVING != talent && PRIEST_SILENCE != talent && PRIEST_VAMPIRIC_EMBRACE != talent && PRIEST_IMPROVED_VAMPIRIC_EMBRACE != talent && PRIEST_FOCUSED_MIND != talent && PRIEST_MIND_MELT != talent && PRIEST_IMPROVED_DEVOURING_PLAGUE != talent && PRIEST_SHADOWFORM != talent && PRIEST_SHADOW_POWER != talent && PRIEST_IMPROVED_SHADOWFORM != talent && PRIEST_MISERY != talent && PRIEST_PSYCHIC_HORROR != talent && PRIEST_VAMPIRIC_TOUCH != talent && PRIEST_PAIN_AND_SUFFERING != talent && PRIEST_TWISTED_FAITH != talent && PRIEST_DISPERSION != talent)
+            return false;
+    }
+    else if (charClass == CLASS_ROGUE)
+    {
+        if (ROGUE_IMPROVED_GOUGE != talent && ROGUE_IMPROVED_SINISTER_STRIKE != talent && ROGUE_DUAL_WIELD_SPECIALIZATION != talent && ROGUE_IMPROVED_SLICE_AND_DICE != talent && ROGUE_DEFLECTION != talent && ROGUE_PRECISION != talent && ROGUE_ENDURANCE != talent && ROGUE_RIPOSTE != talent && ROGUE_CLOSE_QUARTERS_COMBAT != talent && ROGUE_IMPROVED_KICK != talent && ROGUE_IMPROVED_SPRINT != talent && ROGUE_LIGHTNING_REFLEXES != talent && ROGUE_AGGRESSION != talent && ROGUE_MACE_SPECIALIZATION != talent && ROGUE_BLADE_FLURRY != talent && ROGUE_HACK_AND_SLASH != talent && ROGUE_WEAPON_EXPERTISE != talent && ROGUE_BLADE_TWISTING != talent && ROGUE_VITALITY != talent && ROGUE_ADRENALINE_RUSH != talent && ROGUE_NERVES_OF_STEEL != talent && ROGUE_THROWING_SPECIALIZATION != talent && ROGUE_COMBAT_POTENCY != talent && ROGUE_UNFAIR_ADVANTAGE != talent && ROGUE_SURPRISE_ATTACKS != talent && ROGUE_SAVAGE_COMBAT != talent && ROGUE_PREY_ON_THE_WEAK != talent && ROGUE_KILLING_SPREE != talent && ROGUE_IMPROVED_EVISCERATE != talent && ROGUE_REMORSELESS_ATTACKS != talent && ROGUE_MALICE != talent && ROGUE_RUTHLESSNESS != talent && ROGUE_BLOOD_SPATTER != talent && ROGUE_PUNCTURING_WOUNDS != talent && ROGUE_VIGOR != talent && ROGUE_IMPROVED_EXPOSE_ARMOR != talent && ROGUE_LETHALITY != talent && ROGUE_VILE_POISONS != talent && ROGUE_IMPROVED_POISONS != talent && ROGUE_FLEET_FOOTED != talent && ROGUE_COLD_BLOOD != talent && ROGUE_IMPROVED_KIDNEY_SHOT != talent && ROGUE_QUICK_RECOVERY != talent && ROGUE_SEAL_FATE != talent && ROGUE_MURDER != talent && ROGUE_DEADLY_BREW != talent && ROGUE_OVERKILL != talent && ROGUE_DEADENED_NERVES != talent && ROGUE_FOCUSED_ATTACKS != talent && ROGUE_FIND_WEAKNESS != talent && ROGUE_MASTER_POISONER != talent && ROGUE_MUTILATE != talent && ROGUE_TURN_THE_TABLES != talent && ROGUE_CUT_TO_THE_CHASE != talent && ROGUE_HUNGER_FOR_BLOOD != talent && ROGUE_RELENTLESS_STRIKES != talent && ROGUE_MASTER_OF_DECEPTION != talent && ROGUE_OPPORTUNITY != talent && ROGUE_SLEIGHT_OF_HAND != talent && ROGUE_DIRTY_TRICKS != talent && ROGUE_CAMOUFLAGE != talent && ROGUE_ELUSIVENESS != talent && ROGUE_GHOSTLY_STRIKE != talent && ROGUE_SERRATED_BLADES != talent && ROGUE_SETUP != talent && ROGUE_INITIATIVE != talent && ROGUE_IMPROVED_AMBUSH != talent && ROGUE_HEIGHTENED_SENSES != talent && ROGUE_PREPARATION != talent && ROGUE_DIRTY_DEEDS != talent && ROGUE_HEMORRHAGE != talent && ROGUE_MASTER_OF_SUBTLETY != talent && ROGUE_DEADLINESS != talent && ROGUE_ENVELOPING_SHADOWS != talent && ROGUE_PREMEDITATION != talent && ROGUE_CHEAT_DEATH != talent && ROGUE_SINISTER_CALLING != talent && ROGUE_WAYLAY != talent && ROGUE_HONOR_AMONG_THIEVES != talent && ROGUE_SHADOWSTEP != talent && ROGUE_FILTHY_TRICKS != talent && ROGUE_SLAUGHTER_FROM_THE_SHADOWS != talent && ROGUE_SHADOW_DANCE != talent)
+            return false;
+    }
+    else if (charClass == CLASS_SHAMAN)
+    {
+        if (SHAMAN_CONVECTION != talent && SHAMAN_CONCUSSION != talent && SHAMAN_CALL_OF_FLAME != talent && SHAMAN_ELEMENTAL_WARDING != talent && SHAMAN_ELEMENTAL_DEVASTATION != talent && SHAMAN_REVERBERATION != talent && SHAMAN_ELEMENTAL_FOCUS != talent && SHAMAN_ELEMENTAL_FURY != talent && SHAMAN_IMPROVED_FIRE_NOVA != talent && SHAMAN_EYE_OF_THE_STORM != talent && SHAMAN_ELEMENTAL_REACH != talent && SHAMAN_CALL_OF_THUNDER != talent && SHAMAN_UNRELENTING_STORM != talent && SHAMAN_ELEMENTAL_PRECISION != talent && SHAMAN_LIGHTNING_MASTERY != talent && SHAMAN_ELEMENTAL_MASTERY != talent && SHAMAN_STORM_EARTH_AND_FIRE != talent && SHAMAN_BOOMING_ECHOES != talent && SHAMAN_ELEMENTAL_OATH != talent && SHAMAN_LIGHTNING_OVERLOAD != talent && SHAMAN_ASTRAL_SHIFT != talent && SHAMAN_TOTEM_OF_WRATH != talent && SHAMAN_LAVA_FLOWS != talent && SHAMAN_SHAMANISM != talent && SHAMAN_THUNDERSTORM != talent && SHAMAN_IMPROVED_HEALING_WAVE != talent && SHAMAN_TOTEMIC_FOCUS != talent && SHAMAN_IMPROVED_REINCARNATION != talent && SHAMAN_HEALING_GRACE != talent && SHAMAN_TIDAL_FOCUS != talent && SHAMAN_IMPROVED_WATER_SHIELD != talent && SHAMAN_HEALING_FOCUS != talent && SHAMAN_TIDAL_FORCE != talent && SHAMAN_ANCESTRAL_HEALING != talent && SHAMAN_RESTORATIVE_TOTEMS != talent && SHAMAN_TIDAL_MASTERY != talent && SHAMAN_HEALING_WAY != talent && SHAMAN_NATURES_SWIFTNESS != talent && SHAMAN_FOCUSED_MIND != talent && SHAMAN_PURIFICATION != talent && SHAMAN_NATURES_GUARDIAN != talent && SHAMAN_MANA_TIDE_TOTEM != talent && SHAMAN_CLEANSE_SPIRIT != talent && SHAMAN_BLESSING_OF_THE_ETERNALS != talent && SHAMAN_IMPROVED_CHAIN_HEAL != talent && SHAMAN_NATURES_BLESSING != talent && SHAMAN_ANCESTRAL_AWAKENING != talent && SHAMAN_EARTH_SHIELD != talent && SHAMAN_IMPROVED_EARTH_SHIELD != talent && SHAMAN_TIDAL_WAVES != talent && SHAMAN_RIPTIDE != talent && SHAMAN_ENHANCING_TOTEMS != talent && SHAMAN_EARTHS_GRASP != talent && SHAMAN_ANCESTRAL_KNOWLEDGE != talent && SHAMAN_GUARDIAN_TOTEMS != talent && SHAMAN_THUNDERING_STRIKES != talent && SHAMAN_IMPROVED_GHOST_WOLF != talent && SHAMAN_IMPROVED_SHIELDS != talent && SHAMAN_ELEMENTAL_WEAPONS != talent && SHAMAN_SHAMANISTIC_FOCUS != talent && SHAMAN_ANTICIPATION != talent && SHAMAN_FLURRY != talent && SHAMAN_TOUGHNESS != talent && SHAMAN_IMPROVED_WINDFURY_TOTEM != talent && SHAMAN_SPIRIT_WEAPONS != talent && SHAMAN_MENTAL_DEXTERITY != talent && SHAMAN_UNLEASHED_RAGE != talent && SHAMAN_WEAPON_MASTERY != talent && SHAMAN_FROZEN_POWER != talent && SHAMAN_DUAL_WIELD_SPECIALIZATION != talent && SHAMAN_DUAL_WIELD != talent && SHAMAN_STORMSTRIKE != talent && SHAMAN_STATIC_SHOCK != talent && SHAMAN_LAVA_LASH != talent && SHAMAN_IMPROVED_STORMSTRIKE != talent && SHAMAN_MENTAL_QUICKNESS != talent && SHAMAN_SHAMANISTIC_RAGE != talent && SHAMAN_EARTHEN_POWER != talent && SHAMAN_MAELSTROM_WEAPON != talent && SHAMAN_FERAL_SPIRIT != talent)
+            return false;
+    }
+    else if (charClass == CLASS_WARLOCK)
+    {
+        if (WARLOCK_IMPROVED_SHADOW_BOLT != talent && WARLOCK_BANE != talent && WARLOCK_AFTERMATH != talent && WARLOCK_MOLTEN_SKIN != talent && WARLOCK_CATACLYSM != talent && WARLOCK_DEMONIC_POWER != talent && WARLOCK_SHADOWBURN != talent && WARLOCK_RUIN != talent && WARLOCK_INTENSITY != talent && WARLOCK_DESTRUCTIVE_REACH != talent && WARLOCK_IMPROVED_SEARING_PAIN != talent && WARLOCK_BACKLASH != talent && WARLOCK_IMPROVED_IMMOLATE != talent && WARLOCK_DEVASTATION != talent && WARLOCK_NETHER_PROTECTION != talent && WARLOCK_EMBERSTORM != talent && WARLOCK_CONFLAGRATE != talent && WARLOCK_SOUL_LEECH != talent && WARLOCK_PYROCLASM != talent && WARLOCK_SHADOW_AND_FLAME != talent && WARLOCK_IMPROVED_SOUL_LEECH != talent && WARLOCK_BACKDRAFT != talent && WARLOCK_SHADOWFURY != talent && WARLOCK_EMPOWERED_IMP != talent && WARLOCK_FIRE_AND_BRIMSTONE != talent && WARLOCK_CHAOS_BOLT != talent && WARLOCK_IMPROVED_CURSE_OF_AGONY != talent && WARLOCK_SUPPRESSION != talent && WARLOCK_IMPROVED_CORRUPTION != talent && WARLOCK_IMPROVED_CURSE_OF_WEAKNESS != talent && WARLOCK_IMPROVED_DRAIN_SOUL != talent && WARLOCK_IMPROVED_LIFE_TAP != talent && WARLOCK_SOUL_SIPHON != talent && WARLOCK_IMPROVED_FEAR != talent && WARLOCK_FEL_CONCENTRATION != talent && WARLOCK_AMPLIFY_CURSE != talent && WARLOCK_GRIM_REACH != talent && WARLOCK_NIGHTFALL != talent && WARLOCK_EMPOWERED_CORRUPTION != talent && WARLOCK_SHADOW_EMBRACE != talent && WARLOCK_SIPHON_LIFE != talent && WARLOCK_CURSE_OF_EXHAUSTION != talent && WARLOCK_IMPROVED_FELHUNTER != talent && WARLOCK_SHADOW_MASTERY != talent && WARLOCK_ERADICATION != talent && WARLOCK_CONTAGION != talent && WARLOCK_DARK_PACT != talent && WARLOCK_IMPROVED_HOWL_OF_TERROR != talent && WARLOCK_MALEDICTION != talent && WARLOCK_DEATHS_EMBRACE != talent && WARLOCK_UNSTABLE_AFFLICTION != talent && WARLOCK_PANDEMIC != talent && WARLOCK_EVERLASTING_AFFLICTION != talent && WARLOCK_HAUNT != talent && WARLOCK_IMPROVED_HEALTHSTONE != talent && WARLOCK_IMPROVED_IMP != talent && WARLOCK_DEMONIC_EMBRACE != talent && WARLOCK_FEL_SYNERGY != talent && WARLOCK_IMPROVED_HEALTH_FUNNEL != talent && WARLOCK_DEMONIC_BRUTALITY != talent && WARLOCK_FEL_VITALITY != talent && WARLOCK_IMPROVED_SUCCUBUS != talent && WARLOCK_SOUL_LINK != talent && WARLOCK_FEL_DOMINATION != talent && WARLOCK_DEMONIC_AEGIS != talent && WARLOCK_UNHOLY_POWER != talent && WARLOCK_MASTER_SUMMONER != talent && WARLOCK_MANA_FEED != talent && WARLOCK_MASTER_CONJURER != talent && WARLOCK_MASTER_DEMONOLOGIST != talent && WARLOCK_MOLTEN_CORE != talent && WARLOCK_DEMONIC_RESILIENCE != talent && WARLOCK_DEMONIC_EMPOWERMENT != talent && WARLOCK_DEMONIC_KNOWLEDGE != talent && WARLOCK_DEMONIC_TACTICS != talent && WARLOCK_DECIMATION != talent && WARLOCK_IMPROVED_DEMONIC_TACTICS != talent && WARLOCK_SUMMON_FELGUARD != talent && WARLOCK_NEMESIS != talent && WARLOCK_DEMONIC_PACT != talent && WARLOCK_METAMORPHOSIS != talent)
+            return false;
+    }
+    else if (charClass == CLASS_WARRIOR)
+    {
+        if (WARRIOR_IMPROVED_HEROIC_STRIKE != talent && WARRIOR_DEFLECTION != talent && WARRIOR_IMPROVED_REND != talent && WARRIOR_IMPROVED_CHARGE != talent && WARRIOR_IRON_WILL != talent && WARRIOR_TACTICAL_MASTERY != talent && WARRIOR_IMPROVED_OVERPOWER != talent && WARRIOR_ANGER_MANAGEMENT != talent && WARRIOR_IMPALE != talent && WARRIOR_DEEP_WOUNDS != talent && WARRIOR_TWOHANDED_WEAPON_SPECIALIZATION != talent && WARRIOR_TASTE_FOR_BLOOD != talent && WARRIOR_POLEAXE_SPECIALIZATION != talent && WARRIOR_SWEEPING_STRIKES != talent && WARRIOR_MACE_SPECIALIZATION != talent && WARRIOR_SWORD_SPECIALIZATION != talent && WARRIOR_WEAPON_MASTERY != talent && WARRIOR_IMPROVED_HAMSTRING != talent && WARRIOR_TRAUMA != talent && WARRIOR_SECOND_WIND != talent && WARRIOR_MORTAL_STRIKE != talent && WARRIOR_STRENGTH_OF_ARMS != talent && WARRIOR_IMPROVED_SLAM != talent && WARRIOR_JUGGERNAUT != talent && WARRIOR_IMPROVED_MORTAL_STRIKE != talent && WARRIOR_UNRELENTING_ASSAULT != talent && WARRIOR_SUDDEN_DEATH != talent && WARRIOR_ENDLESS_RAGE != talent && WARRIOR_BLOOD_FRENZY != talent && WARRIOR_WRECKING_CREW != talent && WARRIOR_BLADESTORM != talent && WARRIOR_IMPROVED_BLOODRAGE != talent && WARRIOR_SHIELD_SPECIALIZATION != talent && WARRIOR_IMPROVED_THUNDER_CLAP != talent && WARRIOR_INCITE != talent && WARRIOR_ANTICIPATION != talent && WARRIOR_LAST_STAND != talent && WARRIOR_IMPROVED_REVENGE != talent && WARRIOR_SHIELD_MASTERY != talent && WARRIOR_TOUGHNESS != talent && WARRIOR_IMPROVED_SPELL_REFLECTION != talent && WARRIOR_IMPROVED_DISARM != talent && WARRIOR_PUNCTURE != talent && WARRIOR_IMPROVED_DISCIPLINES != talent && WARRIOR_CONCUSSION_BLOW != talent && WARRIOR_GAG_ORDER != talent && WARRIOR_ONEHANDED_WEAPON_SPECIALIZATION != talent && WARRIOR_IMPROVED_DEFENSIVE_STANCE != talent && WARRIOR_VIGILANCE != talent && WARRIOR_FOCUSED_RAGE != talent && WARRIOR_VITALITY != talent && WARRIOR_SAFEGUARD != talent && WARRIOR_WARBRINGER != talent && WARRIOR_DEVASTATE != talent && WARRIOR_CRITICAL_BLOCK != talent && WARRIOR_SWORD_AND_BOARD != talent && WARRIOR_DAMAGE_SHIELD != talent && WARRIOR_SHOCKWAVE != talent && WARRIOR_ARMORED_TO_THE_TEETH != talent && WARRIOR_BOOMING_VOICE != talent && WARRIOR_CRUELTY != talent && WARRIOR_IMPROVED_DEMORALIZING_SHOUT != talent && WARRIOR_UNBRIDLED_WRATH != talent && WARRIOR_IMPROVED_CLEAVE != talent && WARRIOR_PIERCING_HOWL != talent && WARRIOR_BLOOD_CRAZE != talent && WARRIOR_COMMANDING_PRESENCE != talent && WARRIOR_DUAL_WIELD_SPECIALIZATION != talent && WARRIOR_IMPROVED_EXECUTE != talent && WARRIOR_ENRAGE != talent && WARRIOR_PRECISION != talent && WARRIOR_DEATH_WISH != talent && WARRIOR_IMPROVED_INTERCEPT != talent && WARRIOR_IMPROVED_BERSERKER_RAGE != talent && WARRIOR_FLURRY != talent && WARRIOR_INTENSIFY_RAGE != talent && WARRIOR_BLOODTHIRST != talent && WARRIOR_IMPROVED_WHIRLWIND != talent && WARRIOR_FURIOUS_ATTACKS != talent && WARRIOR_IMPROVED_BERSERKER_STANCE != talent && WARRIOR_HEROIC_FURY != talent && WARRIOR_RAMPAGE != talent && WARRIOR_BLOODSURGE != talent && WARRIOR_UNENDING_FURY != talent && WARRIOR_TITANS_GRIP != talent)
+            return false;
+    }
+    else if (charClass == CLASS_PET_CUNNING)
+    {
+        if (PET_CUNNING_COBRA_REFLEXES != talent && PET_CUNNING_DASHDIVE1 != talent && PET_CUNNING_DASHDIVE2 != talent && PET_CUNNING_GREAT_STAMINA != talent && PET_CUNNING_NATURAL_ARMOR != talent && PET_CUNNING_BOARS_SPEED != talent && PET_CUNNING_MOBILITY1 != talent && PET_CUNNING_MOBILITY2 != talent && PET_CUNNING_OWLS_FOCUS != talent && PET_CUNNING_SPIKED_COLLAR != talent && PET_CUNNING_CULLING_THE_HERD != talent && PET_CUNNING_LIONHEARTED != talent && PET_CUNNING_CARRION_FEEDER != talent && PET_CUNNING_GREAT_RESISTANCE != talent && PET_CUNNING_CORNERED != talent && PET_CUNNING_FEEDING_FRENZY != talent && PET_CUNNING_WOLVERINE_BITE != talent && PET_CUNNING_ROAR_OF_RECOVERY != talent && PET_CUNNING_BULLHEADED != talent && PET_CUNNING_GRACE_OF_THE_MANTIS != talent && PET_CUNNING_WILD_HUNT != talent && PET_CUNNING_ROAR_OF_SACRIFICE != talent)
+            return false;
+    }
+    else if (charClass == CLASS_PET_FEROCITY)
+    {
+        if (PET_FEROCITY_COBRA_REFLEXES != talent && PET_FEROCITY_DASHDIVE1 != talent && PET_FEROCITY_DASHDIVE2 != talent && PET_FEROCITY_GREAT_STAMINA != talent && PET_FEROCITY_NATURAL_ARMOR != talent && PET_FEROCITY_IMPROVED_COWER != talent && PET_FEROCITY_BLOODTHIRSTY != talent && PET_FEROCITY_SPIKED_COLLAR != talent && PET_FEROCITY_BOARS_SPEED != talent && PET_FEROCITY_CULLING_THE_HERD != talent && PET_FEROCITY_LIONHEARTED != talent && PET_FEROCITY_CHARGESWOOP1 != talent && PET_FEROCITY_CHARGESWOOP2 != talent && PET_FEROCITY_HEART_OF_THE_PHOENIX != talent && PET_FEROCITY_SPIDERS_BITE != talent && PET_FEROCITY_GREAT_RESISTANCE != talent && PET_FEROCITY_RABID != talent && PET_FEROCITY_LICK_YOUR_WOUNDS != talent && PET_FEROCITY_CALL_OF_THE_WILD != talent && PET_FEROCITY_SHARK_ATTACK != talent && PET_FEROCITY_WILD_HUNT != talent)
+            return false;
+    }
+    else if (charClass == CLASS_PET_TENACITY)
+    {
+        if (PET_TENACITY_COBRA_REFLEXES != talent && PET_TENACITY_CHARGE != talent && PET_TENACITY_GREAT_STAMINA != talent && PET_TENACITY_NATURAL_ARMOR != talent && PET_TENACITY_SPIKED_COLLAR != talent && PET_TENACITY_BOARS_SPEED != talent && PET_TENACITY_BLOOD_OF_THE_RHINO != talent && PET_TENACITY_PET_BARDING != talent && PET_TENACITY_CULLING_THE_HERD != talent && PET_TENACITY_GUARD_DOG != talent && PET_TENACITY_LIONHEARTED != talent && PET_TENACITY_THUNDERSTOMP != talent && PET_TENACITY_GRACE_OF_THE_MANTIS != talent && PET_TENACITY_GREAT_RESISTANCE != talent && PET_TENACITY_LAST_STAND != talent && PET_TENACITY_TAUNT != talent && PET_TENACITY_ROAR_OF_SACRIFICE != talent && PET_TENACITY_INTERVENE != talent && PET_TENACITY_SILVERBACK != talent && PET_TENACITY_WILD_HUNT != talent)
+            return false;
+    }
+    else // charClass unknown
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Someone was naughty and supplied an invalid class to ValidateTalent: %u", (uint32) charClass);
+        return false;
+    }
+
+    return true;
+}
+
+/**
+ * ValidateGlyph tests a glyph against class to see if it belongs to that class - accepts both Major and Minor glyphs
+ *
+ * uint16 glyph:        glyph ID
+ * long charClass:    member of the Classes enum or ClassesCombatPets enum
+ *
+ * return true  -> ok
+ * return false -> not a valid glyph for that class
+ */
+bool PlayerbotAI::ValidateGlyph(uint16 glyph, long charClass)
+{
+    // XOR the two helper functions. Both true (supposedly impossible) or both false -> false
+    return ValidateMajorGlyph(glyph, charClass) ^ ValidateMinorGlyph(glyph, charClass);
+}
+
+/**
+ * ValidateMajorGlyph tests a glyph against class to see if it belongs to that class - only accepts Major glyphs
+ *
+ * uint16 glyph:        glyph ID
+ * long charClass:    member of the Classes enum or ClassesCombatPets enum
+ *
+ * return true  -> ok
+ * return false -> not a valid major glyph for that class
+ */
+bool PlayerbotAI::ValidateMajorGlyph(uint16 glyph, long charClass)
+{
+    if (charClass == CLASS_DEATH_KNIGHT)
+    {
+        // this looong 'if' is to see if any glyph is not a Death Knight glyph when the class clearly is
+        if (DEATH_KNIGHT_MAJOR_GLYPH_OF_DARK_COMMAND != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_ANTIMAGIC_SHELL != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_HEART_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_BONE_SHIELD != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_CHAINS_OF_ICE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_GRIP != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_AND_DECAY != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_FROST_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_ICEBOUND_FORTITUDE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_ICY_TOUCH != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_OBLITERATE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_PLAGUE_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_THE_GHOUL != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_RUNE_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_SCOURGE_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_STRANGULATE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_UNBREAKABLE_ARMOR != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_VAMPIRIC_BLOOD != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_RUNE_TAP != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_BLOOD_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DANCING_RUNE_WEAPON != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_HUNGERING_COLD != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_UNHOLY_BLIGHT != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DARK_DEATH != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DISEASE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_HOWLING_BLAST != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_DRUID)
+    {
+        if (DRUID_MAJOR_GLYPH_OF_FRENZIED_REGENERATION != glyph && DRUID_MAJOR_GLYPH_OF_MAUL != glyph && DRUID_MAJOR_GLYPH_OF_MANGLE != glyph && DRUID_MAJOR_GLYPH_OF_SHRED != glyph && DRUID_MAJOR_GLYPH_OF_RIP != glyph && DRUID_MAJOR_GLYPH_OF_RAKE != glyph && DRUID_MAJOR_GLYPH_OF_SWIFTMEND != glyph && DRUID_MAJOR_GLYPH_OF_INNERVATE != glyph && DRUID_MAJOR_GLYPH_OF_REBIRTH != glyph && DRUID_MAJOR_GLYPH_OF_REGROWTH != glyph && DRUID_MAJOR_GLYPH_OF_REJUVENATION != glyph && DRUID_MAJOR_GLYPH_OF_HEALING_TOUCH != glyph && DRUID_MAJOR_GLYPH_OF_LIFEBLOOM != glyph && DRUID_MAJOR_GLYPH_OF_STARFIRE != glyph && DRUID_MAJOR_GLYPH_OF_INSECT_SWARM != glyph && DRUID_MAJOR_GLYPH_OF_HURRICANE != glyph && DRUID_MAJOR_GLYPH_OF_STARFALL != glyph && DRUID_MAJOR_GLYPH_OF_WRATH != glyph && DRUID_MAJOR_GLYPH_OF_MOONFIRE != glyph && DRUID_MAJOR_GLYPH_OF_ENTANGLING_ROOTS != glyph && DRUID_MAJOR_GLYPH_OF_FOCUS != glyph && DRUID_MAJOR_GLYPH_OF_BERSERK != glyph && DRUID_MAJOR_GLYPH_OF_WILD_GROWTH != glyph && DRUID_MAJOR_GLYPH_OF_NOURISH != glyph && DRUID_MAJOR_GLYPH_OF_SAVAGE_ROAR != glyph && DRUID_MAJOR_GLYPH_OF_MONSOON != glyph && DRUID_MAJOR_GLYPH_OF_BARKSKIN != glyph && DRUID_MAJOR_GLYPH_OF_SURVIVAL_INSTINCTS != glyph && DRUID_MAJOR_GLYPH_OF_CLAW != glyph && DRUID_MAJOR_GLYPH_OF_RAPID_REJUVENATION != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_HUNTER)
+    {
+        if (HUNTER_MAJOR_GLYPH_OF_AIMED_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_ARCANE_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_THE_BEAST != glyph && HUNTER_MAJOR_GLYPH_OF_MENDING != glyph && HUNTER_MAJOR_GLYPH_OF_ASPECT_OF_THE_VIPER != glyph && HUNTER_MAJOR_GLYPH_OF_BESTIAL_WRATH != glyph && HUNTER_MAJOR_GLYPH_OF_DETERRENCE != glyph && HUNTER_MAJOR_GLYPH_OF_DISENGAGE != glyph && HUNTER_MAJOR_GLYPH_OF_FREEZING_TRAP != glyph && HUNTER_MAJOR_GLYPH_OF_FROST_TRAP != glyph && HUNTER_MAJOR_GLYPH_OF_HUNTERS_MARK != glyph && HUNTER_MAJOR_GLYPH_OF_IMMOLATION_TRAP != glyph && HUNTER_MAJOR_GLYPH_OF_MULTISHOT != glyph && HUNTER_MAJOR_GLYPH_OF_RAPID_FIRE != glyph && HUNTER_MAJOR_GLYPH_OF_SERPENT_STING != glyph && HUNTER_MAJOR_GLYPH_OF_SNAKE_TRAP != glyph && HUNTER_MAJOR_GLYPH_OF_STEADY_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_TRUESHOT_AURA != glyph && HUNTER_MAJOR_GLYPH_OF_VOLLEY != glyph && HUNTER_MAJOR_GLYPH_OF_WYVERN_STING != glyph && HUNTER_MAJOR_GLYPH_OF_CHIMERA_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_EXPLOSIVE_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_KILL_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_EXPLOSIVE_TRAP != glyph && HUNTER_MAJOR_GLYPH_OF_SCATTER_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_RAPTOR_STRIKE != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_MAGE)
+    {
+        if (MAGE_MAJOR_GLYPH_OF_ARCANE_EXPLOSION != glyph && MAGE_MAJOR_GLYPH_OF_ARCANE_MISSILES != glyph && MAGE_MAJOR_GLYPH_OF_ARCANE_POWER != glyph && MAGE_MAJOR_GLYPH_OF_BLINK != glyph && MAGE_MAJOR_GLYPH_OF_EVOCATION != glyph && MAGE_MAJOR_GLYPH_OF_FIREBALL != glyph && MAGE_MAJOR_GLYPH_OF_FIRE_BLAST != glyph && MAGE_MAJOR_GLYPH_OF_FROST_NOVA != glyph && MAGE_MAJOR_GLYPH_OF_FROSTBOLT != glyph && MAGE_MAJOR_GLYPH_OF_ICE_ARMOR != glyph && MAGE_MAJOR_GLYPH_OF_ICE_BLOCK != glyph && MAGE_MAJOR_GLYPH_OF_ICE_LANCE != glyph && MAGE_MAJOR_GLYPH_OF_ICY_VEINS != glyph && MAGE_MAJOR_GLYPH_OF_SCORCH != glyph && MAGE_MAJOR_GLYPH_OF_INVISIBILITY != glyph && MAGE_MAJOR_GLYPH_OF_MAGE_ARMOR != glyph && MAGE_MAJOR_GLYPH_OF_MANA_GEM != glyph && MAGE_MAJOR_GLYPH_OF_MOLTEN_ARMOR != glyph && MAGE_MAJOR_GLYPH_OF_POLYMORPH != glyph && MAGE_MAJOR_GLYPH_OF_REMOVE_CURSE != glyph && MAGE_MAJOR_GLYPH_OF_WATER_ELEMENTAL != glyph && MAGE_MAJOR_GLYPH_OF_FROSTFIRE != glyph && MAGE_MAJOR_GLYPH_OF_ARCANE_BLAST != glyph && MAGE_MAJOR_GLYPH_OF_DEEP_FREEZE != glyph && MAGE_MAJOR_GLYPH_OF_LIVING_BOMB != glyph && MAGE_MAJOR_GLYPH_OF_ARCANE_BARRAGE != glyph && MAGE_MAJOR_GLYPH_OF_MIRROR_IMAGE != glyph && MAGE_MAJOR_GLYPH_OF_ICE_BARRIER != glyph && MAGE_MAJOR_GLYPH_OF_ETERNAL_WATER != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_PALADIN)
+    {
+        if (PALADIN_MAJOR_GLYPH_OF_JUDGEMENT != glyph && PALADIN_MAJOR_GLYPH_OF_SEAL_OF_COMMAND != glyph && PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_JUSTICE != glyph && PALADIN_MAJOR_GLYPH_OF_SPIRITUAL_ATTUNEMENT != glyph && PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_WRATH != glyph && PALADIN_MAJOR_GLYPH_OF_CRUSADER_STRIKE != glyph && PALADIN_MAJOR_GLYPH_OF_CONSECRATION != glyph && PALADIN_MAJOR_GLYPH_OF_RIGHTEOUS_DEFENSE != glyph && PALADIN_MAJOR_GLYPH_OF_AVENGERS_SHIELD != glyph && PALADIN_MAJOR_GLYPH_OF_TURN_EVIL != glyph && PALADIN_MAJOR_GLYPH_OF_EXORCISM != glyph && PALADIN_MAJOR_GLYPH_OF_CLEANSING != glyph && PALADIN_MAJOR_GLYPH_OF_FLASH_OF_LIGHT != glyph && PALADIN_MAJOR_GLYPH_OF_HOLY_LIGHT != glyph && PALADIN_MAJOR_GLYPH_OF_AVENGING_WRATH != glyph && PALADIN_MAJOR_GLYPH_OF_DIVINITY != glyph && PALADIN_MAJOR_GLYPH_OF_SEAL_OF_WISDOM != glyph && PALADIN_MAJOR_GLYPH_OF_SEAL_OF_LIGHT != glyph && PALADIN_MAJOR_GLYPH_OF_HOLY_WRATH != glyph && PALADIN_MAJOR_GLYPH_OF_SEAL_OF_RIGHTEOUSNESS != glyph && PALADIN_MAJOR_GLYPH_OF_SEAL_OF_VENGEANCE != glyph && PALADIN_MAJOR_GLYPH_OF_BEACON_OF_LIGHT != glyph && PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_THE_RIGHTEOUS != glyph && PALADIN_MAJOR_GLYPH_OF_DIVINE_STORM != glyph && PALADIN_MAJOR_GLYPH_OF_SHIELD_OF_RIGHTEOUSNESS != glyph && PALADIN_MAJOR_GLYPH_OF_DIVINE_PLEA != glyph && PALADIN_MAJOR_GLYPH_OF_HOLY_SHOCK != glyph && PALADIN_MAJOR_GLYPH_OF_SALVATION != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_PRIEST)
+    {
+        if (PRIEST_MAJOR_GLYPH_OF_CIRCLE_OF_HEALING != glyph && PRIEST_MAJOR_GLYPH_OF_DISPEL_MAGIC != glyph && PRIEST_MAJOR_GLYPH_OF_FADE != glyph && PRIEST_MAJOR_GLYPH_OF_FEAR_WARD != glyph && PRIEST_MAJOR_GLYPH_OF_FLASH_HEAL != glyph && PRIEST_MAJOR_GLYPH_OF_HOLY_NOVA != glyph && PRIEST_MAJOR_GLYPH_OF_INNER_FIRE != glyph && PRIEST_MAJOR_GLYPH_OF_LIGHTWELL != glyph && PRIEST_MAJOR_GLYPH_OF_MASS_DISPEL != glyph && PRIEST_MAJOR_GLYPH_OF_MIND_CONTROL != glyph && PRIEST_MAJOR_GLYPH_OF_SHADOW_WORD_PAIN != glyph && PRIEST_MAJOR_GLYPH_OF_SHADOW != glyph && PRIEST_MAJOR_GLYPH_OF_POWER_WORD_SHIELD != glyph && PRIEST_MAJOR_GLYPH_OF_PRAYER_OF_HEALING != glyph && PRIEST_MAJOR_GLYPH_OF_PSYCHIC_SCREAM != glyph && PRIEST_MAJOR_GLYPH_OF_RENEW != glyph && PRIEST_MAJOR_GLYPH_OF_SCOURGE_IMPRISONMENT != glyph && PRIEST_MAJOR_GLYPH_OF_SHADOW_WORD_DEATH != glyph && PRIEST_MAJOR_GLYPH_OF_MIND_FLAY != glyph && PRIEST_MAJOR_GLYPH_OF_SMITE != glyph && PRIEST_MAJOR_GLYPH_OF_SPIRIT_OF_REDEMPTION != glyph && PRIEST_MAJOR_GLYPH_OF_DISPERSION != glyph && PRIEST_MAJOR_GLYPH_OF_GUARDIAN_SPIRIT != glyph && PRIEST_MAJOR_GLYPH_OF_PENANCE != glyph && PRIEST_MAJOR_GLYPH_OF_MIND_SEAR != glyph && PRIEST_MAJOR_GLYPH_OF_HYMN_OF_HOPE != glyph && PRIEST_MAJOR_GLYPH_OF_PAIN_SUPPRESSION != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_ROGUE)
+    {
+        if (ROGUE_MAJOR_GLYPH_OF_ADRENALINE_RUSH != glyph && ROGUE_MAJOR_GLYPH_OF_AMBUSH != glyph && ROGUE_MAJOR_GLYPH_OF_BACKSTAB != glyph && ROGUE_MAJOR_GLYPH_OF_BLADE_FLURRY != glyph && ROGUE_MAJOR_GLYPH_OF_CRIPPLING_POISON != glyph && ROGUE_MAJOR_GLYPH_OF_DEADLY_THROW != glyph && ROGUE_MAJOR_GLYPH_OF_EVASION != glyph && ROGUE_MAJOR_GLYPH_OF_EVISCERATE != glyph && ROGUE_MAJOR_GLYPH_OF_EXPOSE_ARMOR != glyph && ROGUE_MAJOR_GLYPH_OF_FEINT != glyph && ROGUE_MAJOR_GLYPH_OF_GARROTE != glyph && ROGUE_MAJOR_GLYPH_OF_GHOSTLY_STRIKE != glyph && ROGUE_MAJOR_GLYPH_OF_GOUGE != glyph && ROGUE_MAJOR_GLYPH_OF_HEMORRHAGE != glyph && ROGUE_MAJOR_GLYPH_OF_PREPARATION != glyph && ROGUE_MAJOR_GLYPH_OF_RUPTURE != glyph && ROGUE_MAJOR_GLYPH_OF_SAP != glyph && ROGUE_MAJOR_GLYPH_OF_VIGOR != glyph && ROGUE_MAJOR_GLYPH_OF_SINISTER_STRIKE != glyph && ROGUE_MAJOR_GLYPH_OF_SLICE_AND_DICE != glyph && ROGUE_MAJOR_GLYPH_OF_SPRINT != glyph && ROGUE_MAJOR_GLYPH_OF_HUNGER_FOR_BLOOD != glyph && ROGUE_MAJOR_GLYPH_OF_KILLING_SPREE != glyph && ROGUE_MAJOR_GLYPH_OF_SHADOW_DANCE != glyph && ROGUE_MAJOR_GLYPH_OF_FAN_OF_KNIVES != glyph && ROGUE_MAJOR_GLYPH_OF_TRICKS_OF_THE_TRADE != glyph && ROGUE_MAJOR_GLYPH_OF_MUTILATE != glyph && ROGUE_MAJOR_GLYPH_OF_CLOAK_OF_SHADOWS != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_SHAMAN)
+    {
+        if (SHAMAN_MAJOR_GLYPH_OF_WATER_MASTERY != glyph && SHAMAN_MAJOR_GLYPH_OF_CHAIN_HEAL != glyph && SHAMAN_MAJOR_GLYPH_OF_CHAIN_LIGHTNING != glyph && SHAMAN_MAJOR_GLYPH_OF_LAVA != glyph && SHAMAN_MAJOR_GLYPH_OF_SHOCKING != glyph && SHAMAN_MAJOR_GLYPH_OF_EARTHLIVING_WEAPON != glyph && SHAMAN_MAJOR_GLYPH_OF_FIRE_ELEMENTAL_TOTEM != glyph && SHAMAN_MAJOR_GLYPH_OF_FIRE_NOVA != glyph && SHAMAN_MAJOR_GLYPH_OF_FLAME_SHOCK != glyph && SHAMAN_MAJOR_GLYPH_OF_FLAMETONGUE_WEAPON != glyph && SHAMAN_MAJOR_GLYPH_OF_FROST_SHOCK != glyph && SHAMAN_MAJOR_GLYPH_OF_HEALING_STREAM_TOTEM != glyph && SHAMAN_MAJOR_GLYPH_OF_HEALING_WAVE != glyph && SHAMAN_MAJOR_GLYPH_OF_LESSER_HEALING_WAVE != glyph && SHAMAN_MAJOR_GLYPH_OF_LIGHTNING_SHIELD != glyph && SHAMAN_MAJOR_GLYPH_OF_LIGHTNING_BOLT != glyph && SHAMAN_MAJOR_GLYPH_OF_STORMSTRIKE != glyph && SHAMAN_MAJOR_GLYPH_OF_LAVA_LASH != glyph && SHAMAN_MAJOR_GLYPH_OF_ELEMENTAL_MASTERY != glyph && SHAMAN_MAJOR_GLYPH_OF_WINDFURY_WEAPON != glyph && SHAMAN_MAJOR_GLYPH_OF_THUNDER != glyph && SHAMAN_MAJOR_GLYPH_OF_FERAL_SPIRIT != glyph && SHAMAN_MAJOR_GLYPH_OF_RIPTIDE != glyph && SHAMAN_MAJOR_GLYPH_OF_EARTH_SHIELD != glyph && SHAMAN_MAJOR_GLYPH_OF_TOTEM_OF_WRATH != glyph && SHAMAN_MAJOR_GLYPH_OF_HEX != glyph && SHAMAN_MAJOR_GLYPH_OF_STONECLAW_TOTEM != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_WARLOCK)
+    {
+        if (WARLOCK_MAJOR_GLYPH_OF_INCINERATE != glyph && WARLOCK_MAJOR_GLYPH_OF_CONFLAGRATE != glyph && WARLOCK_MAJOR_GLYPH_OF_CORRUPTION != glyph && WARLOCK_MAJOR_GLYPH_OF_CURSE_OF_AGONY != glyph && WARLOCK_MAJOR_GLYPH_OF_DEATH_COIL != glyph && WARLOCK_MAJOR_GLYPH_OF_FEAR != glyph && WARLOCK_MAJOR_GLYPH_OF_FELGUARD != glyph && WARLOCK_MAJOR_GLYPH_OF_FELHUNTER != glyph && WARLOCK_MAJOR_GLYPH_OF_HEALTH_FUNNEL != glyph && WARLOCK_MAJOR_GLYPH_OF_HEALTHSTONE != glyph && WARLOCK_MAJOR_GLYPH_OF_HOWL_OF_TERROR != glyph && WARLOCK_MAJOR_GLYPH_OF_IMMOLATE != glyph && WARLOCK_MAJOR_GLYPH_OF_IMP != glyph && WARLOCK_MAJOR_GLYPH_OF_SEARING_PAIN != glyph && WARLOCK_MAJOR_GLYPH_OF_SHADOW_BOLT != glyph && WARLOCK_MAJOR_GLYPH_OF_SHADOWBURN != glyph && WARLOCK_MAJOR_GLYPH_OF_SIPHON_LIFE != glyph && WARLOCK_MAJOR_GLYPH_OF_SOULSTONE != glyph && WARLOCK_MAJOR_GLYPH_OF_SUCCUBUS != glyph && WARLOCK_MAJOR_GLYPH_OF_UNSTABLE_AFFLICTION != glyph && WARLOCK_MAJOR_GLYPH_OF_VOIDWALKER != glyph && WARLOCK_MAJOR_GLYPH_OF_HAUNT != glyph && WARLOCK_MAJOR_GLYPH_OF_METAMORPHOSIS != glyph && WARLOCK_MAJOR_GLYPH_OF_CHAOS_BOLT != glyph && WARLOCK_MAJOR_GLYPH_OF_DEMONIC_CIRCLE != glyph && WARLOCK_MAJOR_GLYPH_OF_SHADOWFLAME != glyph && WARLOCK_MAJOR_GLYPH_OF_LIFE_TAP != glyph && WARLOCK_MAJOR_GLYPH_OF_SOUL_LINK != glyph && WARLOCK_MAJOR_GLYPH_OF_QUICK_DECAY != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_WARRIOR)
+    {
+        if (WARRIOR_MAJOR_GLYPH_OF_MORTAL_STRIKE != glyph && WARRIOR_MAJOR_GLYPH_OF_BLOODTHIRST != glyph && WARRIOR_MAJOR_GLYPH_OF_RAPID_CHARGE != glyph && WARRIOR_MAJOR_GLYPH_OF_CLEAVING != glyph && WARRIOR_MAJOR_GLYPH_OF_DEVASTATE != glyph && WARRIOR_MAJOR_GLYPH_OF_EXECUTION != glyph && WARRIOR_MAJOR_GLYPH_OF_HAMSTRING != glyph && WARRIOR_MAJOR_GLYPH_OF_HEROIC_STRIKE != glyph && WARRIOR_MAJOR_GLYPH_OF_INTERVENE != glyph && WARRIOR_MAJOR_GLYPH_OF_BARBARIC_INSULTS != glyph && WARRIOR_MAJOR_GLYPH_OF_OVERPOWER != glyph && WARRIOR_MAJOR_GLYPH_OF_RENDING != glyph && WARRIOR_MAJOR_GLYPH_OF_REVENGE != glyph && WARRIOR_MAJOR_GLYPH_OF_BLOCKING != glyph && WARRIOR_MAJOR_GLYPH_OF_LAST_STAND != glyph && WARRIOR_MAJOR_GLYPH_OF_SUNDER_ARMOR != glyph && WARRIOR_MAJOR_GLYPH_OF_SWEEPING_STRIKES != glyph && WARRIOR_MAJOR_GLYPH_OF_TAUNT != glyph && WARRIOR_MAJOR_GLYPH_OF_RESONATING_POWER != glyph && WARRIOR_MAJOR_GLYPH_OF_VICTORY_RUSH != glyph && WARRIOR_MAJOR_GLYPH_OF_WHIRLWIND != glyph && WARRIOR_MAJOR_GLYPH_OF_BLADESTORM != glyph && WARRIOR_MAJOR_GLYPH_OF_SHOCKWAVE != glyph && WARRIOR_MAJOR_GLYPH_OF_VIGILANCE != glyph && WARRIOR_MAJOR_GLYPH_OF_ENRAGED_REGENERATION != glyph && WARRIOR_MAJOR_GLYPH_OF_SPELL_REFLECTION != glyph && WARRIOR_MAJOR_GLYPH_OF_SHIELD_WALL != glyph)
+            return false;
+    }
+    // pets don't have glyphs... yet
+    else if (charClass == CLASS_PET_CUNNING || charClass == CLASS_PET_FEROCITY || charClass == CLASS_PET_TENACITY)
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Someone tried to validate a glyph for a pet... ValidateMajorGlyph: %u", (uint32) charClass);
+        return false;
+    }
+    else // charClass unknown
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Someone was naughty and supplied an invalid class to ValidateMajorGlyph: %u", (uint32) charClass);
+        return false;
+    }
+
+    return true;
+}
+
+/**
+ * ValidateMinorGlyph tests a glyph against class to see if it belongs to that class - only accepts Minor glyphs
+ *
+ * uint16 glyph:        glyph ID
+ * long charClass:    member of the Classes enum or ClassesCombatPets enum
+ *
+ * return true  -> ok
+ * return false -> not a valid minor glyph for that class
+ */
+bool PlayerbotAI::ValidateMinorGlyph(uint16 glyph, long charClass)
+{
+    if (charClass == CLASS_DEATH_KNIGHT)
+    {
+        // this looong 'if' is to see if any glyph is not a Death Knight glyph when the class clearly is
+        if (DEATH_KNIGHT_MINOR_GLYPH_OF_BLOOD_TAP != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_DEATHS_EMBRACE != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_HORN_OF_WINTER != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_PESTILENCE != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_CORPSE_EXPLOSION != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_RAISE_DEAD != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_RAISE_DEAD2 != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_DRUID)
+    {
+        if (DRUID_MINOR_GLYPH_OF_AQUATIC_FORM != glyph && DRUID_MINOR_GLYPH_OF_CHALLENGING_ROAR != glyph && DRUID_MINOR_GLYPH_OF_THE_WILD != glyph && DRUID_MINOR_GLYPH_OF_UNBURDENED_REBIRTH != glyph && DRUID_MINOR_GLYPH_OF_THORNS != glyph && DRUID_MINOR_GLYPH_OF_DASH != glyph && DRUID_MINOR_GLYPH_OF_TYPHOON != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_HUNTER)
+    {
+        if (HUNTER_MINOR_GLYPH_OF_REVIVE_PET != glyph && HUNTER_MINOR_GLYPH_OF_MEND_PET != glyph && HUNTER_MINOR_GLYPH_OF_FEIGN_DEATH != glyph && HUNTER_MINOR_GLYPH_OF_SCARE_BEAST != glyph && HUNTER_MINOR_GLYPH_OF_THE_PACK != glyph && HUNTER_MINOR_GLYPH_OF_POSSESSED_STRENGTH != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_MAGE)
+    {
+        if (MAGE_MINOR_GLYPH_OF_ARCANE_INTELLECT != glyph && MAGE_MINOR_GLYPH_OF_BLAST_WAVE != glyph && MAGE_MINOR_GLYPH_OF_FIRE_WARD != glyph && MAGE_MINOR_GLYPH_OF_FROST_WARD != glyph && MAGE_MINOR_GLYPH_OF_FROST_ARMOR != glyph && MAGE_MINOR_GLYPH_OF_THE_PENGUIN != glyph && MAGE_MINOR_GLYPH_OF_SLOW_FALL != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_PALADIN)
+    {
+        if (PALADIN_MINOR_GLYPH_OF_BLESSING_OF_KINGS != glyph && PALADIN_MINOR_GLYPH_OF_BLESSING_OF_MIGHT != glyph && PALADIN_MINOR_GLYPH_OF_BLESSING_OF_WISDOM != glyph && PALADIN_MINOR_GLYPH_OF_LAY_ON_HANDS != glyph && PALADIN_MINOR_GLYPH_OF_SENSE_UNDEAD != glyph && PALADIN_MINOR_GLYPH_OF_THE_WISE != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_PRIEST)
+    {
+        if (PRIEST_MINOR_GLYPH_OF_FADING != glyph && PRIEST_MINOR_GLYPH_OF_LEVITATE != glyph && PRIEST_MINOR_GLYPH_OF_FORTITUDE != glyph && PRIEST_MINOR_GLYPH_OF_SHACKLE_UNDEAD != glyph && PRIEST_MINOR_GLYPH_OF_SHADOW_PROTECTION != glyph && PRIEST_MINOR_GLYPH_OF_SHADOWFIEND != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_ROGUE)
+    {
+        if (ROGUE_MINOR_GLYPH_OF_DISTRACT != glyph && ROGUE_MINOR_GLYPH_OF_PICK_LOCK != glyph && ROGUE_MINOR_GLYPH_OF_PICK_POCKET != glyph && ROGUE_MINOR_GLYPH_OF_SAFE_FALL != glyph && ROGUE_MINOR_GLYPH_OF_BLURRED_SPEED != glyph && ROGUE_MINOR_GLYPH_OF_VANISH != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_SHAMAN)
+    {
+        if (SHAMAN_MINOR_GLYPH_OF_ASTRAL_RECALL != glyph && SHAMAN_MINOR_GLYPH_OF_RENEWED_LIFE != glyph && SHAMAN_MINOR_GLYPH_OF_WATER_BREATHING != glyph && SHAMAN_MINOR_GLYPH_OF_WATER_SHIELD != glyph && SHAMAN_MINOR_GLYPH_OF_WATER_WALKING != glyph && SHAMAN_MINOR_GLYPH_OF_GHOST_WOLF != glyph && SHAMAN_MINOR_GLYPH_OF_THUNDERSTORM != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_WARLOCK)
+    {
+        if (WARLOCK_MINOR_GLYPH_OF_UNENDING_BREATH != glyph && WARLOCK_MINOR_GLYPH_OF_DRAIN_SOUL != glyph && WARLOCK_MINOR_GLYPH_OF_KILROGG != glyph && WARLOCK_MINOR_GLYPH_OF_ENSLAVE_DEMON != glyph && WARLOCK_MINOR_GLYPH_OF_SOULS != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_WARRIOR)
+    {
+        if (WARRIOR_MINOR_GLYPH_OF_BATTLE != glyph && WARRIOR_MINOR_GLYPH_OF_BLOODRAGE != glyph && WARRIOR_MINOR_GLYPH_OF_CHARGE != glyph && WARRIOR_MINOR_GLYPH_OF_MOCKING_BLOW != glyph && WARRIOR_MINOR_GLYPH_OF_THUNDER_CLAP != glyph && WARRIOR_MINOR_GLYPH_OF_ENDURING_VICTORY != glyph && WARRIOR_MINOR_GLYPH_OF_COMMAND != glyph)
+            return false;
+    }
+    // pets don't have glyphs... yet
+    else if (charClass == CLASS_PET_CUNNING || charClass == CLASS_PET_FEROCITY || charClass == CLASS_PET_TENACITY)
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Someone tried to validate a glyph for a pet... ValidateMinorGlyph: %u", (uint32) charClass);
+        return false;
+    }
+    else // charClass unknown
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Someone was naughty and supplied an invalid class to ValidateMinorGlyph: %u", (uint32) charClass);
+        return false;
+    }
+
+    return true;
+}
+
+void PlayerbotAI::extractQuestIds(const std::string& text, std::list<uint32>& questIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hquest:", pos);
+        if (i == -1)
+            break;
+        pos = i + 7;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            questIds.push_back(id);
+    }
+}
+
+// Build an hlink for Weapon skills in Aqua
+void PlayerbotAI::MakeWeaponSkillLink(const SpellEntry *sInfo, std::ostringstream &out, uint32 skillid)
+{
+    int loc = m_master->GetSession()->GetSessionDbcLocale();
+    out << "|cff00ffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[loc] << " : " << m_bot->GetSkillValue(skillid) << " /" << m_bot->GetMaxSkillValue(skillid) << "]|h|r";
+}
+
+// Build an hlink for spells in White
+void PlayerbotAI::MakeSpellLink(const SpellEntry *sInfo, std::ostringstream &out)
+{
+    int loc = m_master->GetSession()->GetSessionDbcLocale();
+    out << "|cffffffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[loc] << "]|h|r";
+}
+
+// Builds a hlink for an item, but since its
+// only a ItemTemplate, we cant fill in everything
+void PlayerbotAI::MakeItemLink(const ItemTemplate *item, std::ostringstream &out)
+{
+    // Color
+    out << "|c";
+    switch (item->Quality)
+    {
+        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    out << "ffff0000"; break;  //Don't know color, so red?
+    }
+    out << "|Hitem:";
+
+    // Item Id
+    out << item->ItemId << ":";
+
+    // Permanent enchantment, gems, 4 unknowns, and reporter_level
+    // ->new items wont have enchantments or gems so..
+    out << "0:0:0:0:0:0:0:0:0";
+
+    // Name
+    std::string name = item->Name1;
+    ItemLocalization(name, item->ItemId);
+    out << "|h[" << name << "]|h|r";
+
+    // Stacked items
+    if (item->BuyCount > 1)
+        out << "|cff009900x" << item->BuyCount << ".|r";
+    else
+        out << "|cff009900.|r";
+}
+
+// Builds a hlink for an item, includes everything
+// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:0:0:0:reporter_level|h[name]|h|r
+void PlayerbotAI::MakeItemLink(const Item *item, std::ostringstream &out, bool IncludeQuantity /*= true*/)
+{
+    const ItemTemplate *proto = item->GetTemplate();
+    // Color
+    out << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    out << "ffff0000"; break;  //Don't know color, so red?
+    }
+    out << "|Hitem:";
+
+    // Item Id
+    out << proto->ItemId << ":";
+
+    // Permanent enchantment
+    out << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":";
+
+    // Gems
+    uint32 g1 = 0, g2 = 0, g3 = 0;
+    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++slot)
+    {
+        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
+        if (!eId) continue;
+
+        SpellItemEnchantmentEntry const* entry = sSpellItemEnchantmentStore.LookupEntry(eId);
+        if (!entry) continue;
+
+        switch (slot - SOCK_ENCHANTMENT_SLOT)
+        {
+            case 1: g1 = entry->GemID; break;
+            case 2: g2 = entry->GemID; break;
+            case 3: g3 = entry->GemID; break;
+        }
+    }
+    out << g1 << ":" << g2 << ":" << g3 << ":";
+
+    // Temp enchantment, Bonus Enchantment, Prismatic Enchantment?
+    // Other stuff, don't know what it is
+    out << "0:0:0:0:";
+
+    // Reporter Level
+    out << "0";
+
+    // Name
+    std::string name = proto->Name1;
+    ItemLocalization(name, proto->ItemId);
+    out << "|h[" << name << "]|h|r";
+
+    // Stacked items
+    if (item->GetCount() > 1 && IncludeQuantity)
+        out << "x" << item->GetCount() << ' ';
+}
+
+// Builds a string for an item   |color[name]|r
+void PlayerbotAI::MakeItemText(const Item *item, std::ostringstream &out, bool IncludeQuantity /*= true*/)
+{
+    const ItemTemplate *proto = item->GetTemplate();
+    // Color
+    out << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    out << "ffff0000"; break;  //Don't know color, so red?
+    }
+
+    // Name
+    std::string name = proto->Name1;
+    ItemLocalization(name, proto->ItemId);
+    out << "[" << name << "]|r";
+
+    // Stacked items
+    if (item->GetCount() > 1 && IncludeQuantity)
+        out << "x" << item->GetCount() << ' ';
+}
+
+void PlayerbotAI::extractAuctionIds(const std::string& text, std::list<uint32>& auctionIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Htitle:", pos);
+        if (i == -1)
+            break;
+        pos = i + 7;
+        int endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            auctionIds.push_back(id);
+    }
+}
+
+void PlayerbotAI::extractSpellId(const std::string& text, uint32 &spellId) const
+{
+
+    //   Link format
+    //   |cffffffff|Hspell:" << spellId << ":" << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+    //   cast |cff71d5ff|Hspell:686|h[Shadow Bolt]|h|r";
+    //   012345678901234567890123456
+    //        base = 16 >|  +7 >|
+
+    uint8 pos = 0;
+
+    int i = text.find("Hspell:", pos);
+    if (i == -1)
+        return;
+
+    // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: extractSpellId - first pos %u i %u",pos,i);
+    pos = i + 7;     // start of window in text 16 + 7 = 23
+    int endPos = text.find('|', pos);
+    if (endPos == -1)
+        return;
+
+    // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: extractSpellId - second endpos : %u pos : %u",endPos,pos);
+    std::string idC = text.substr(pos, endPos - pos);     // 26 - 23
+    spellId = atol(idC.c_str());
+    pos = endPos;     // end
+}
+
+void PlayerbotAI::extractSpellIdList(const std::string& text, BotEntryList& m_spellsToLearn) const
+{
+
+    //   Link format
+    //   |cffffffff|Hspell:" << spellId << ":" << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+    //   cast |cff71d5ff|Hspell:686|h[Shadow Bolt]|h|r";
+    //   012345678901234567890123456
+    //        base = 16 >|  +7 >|
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hspell:", pos);
+        if (i == -1)
+            break;
+
+        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: extractSpellIdList - first pos %u i %u",pos,i);
+        pos = i + 7;     // start of window in text 16 + 7 = 23
+        int endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+
+        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: extractSpellIdList - second endpos : %u pos : %u",endPos,pos);
+        std::string idC = text.substr(pos, endPos - pos);     // 26 - 23
+        uint32 spellId = atol(idC.c_str());
+        pos = endPos;     // end
+
+        if (spellId)
+            m_spellsToLearn.push_back(spellId);
+    }
+}
+
+void PlayerbotAI::extractTalentIds(const std::string &text, std::list<talentPair> &talentIds) const
+{
+    // Link format:
+    // |color|Htalent:talent_id:rank|h[name]|h|r
+    // |cff4e96f7|Htalent:1396:4|h[Unleashed Fury]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Htalent:", pos);
+        if (i == -1)
+            break;
+        pos = i + 8;
+        // sLog->outDebug(LOG_FILTER_NONE, "extractTalentIds first pos %u i %u",pos,i);
+        // extract talent_id
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        // sLog->outDebug(LOG_FILTER_NONE, "extractTalentId second endpos : %u pos : %u",endPos,pos);
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos + 1;
+        // extract rank
+        endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+        // sLog->outDebug(LOG_FILTER_NONE, "extractTalentId third endpos : %u pos : %u",endPos,pos);
+        std::string rankC = text.substr(pos, endPos - pos);
+        uint32 rank = atol(rankC.c_str());
+        pos = endPos + 1;
+
+        // sLog->outDebug(LOG_FILTER_NONE, "extractTalentId second id : %u  rank : %u",id,rank);
+
+        if (id)
+            talentIds.push_back(std::pair<uint32, uint32>(id, rank));
+    }
+}
+
+void PlayerbotAI::extractGOinfo(const std::string& text, BotObjectList& m_lootTargets) const
+{
+
+    //    Link format
+    //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':'  <<  "|h[" << gInfo->name << "]|h|r";
+    //    |cFFFFFF00|Hfound:9582:1731|h[Copper Vein]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        // extract GO guid
+        int i = text.find("Hfound:", pos);     // base H = 11
+        if (i == -1)     // break if error
+            break;
+
+        pos = i + 7;     //start of window in text 11 + 7 = 18
+        int endPos = text.find(':', pos);     // end of window in text 22
+        if (endPos == -1)     //break if error
+            break;
+        std::string guidC = text.substr(pos, endPos - pos);     // get string within window i.e guid 22 - 18 =  4
+        uint32 guid = atol(guidC.c_str());     // convert ascii to long int
+
+        // extract GO entry
+        pos = endPos + 1;
+        endPos = text.find(':', pos);     // end of window in text
+        if (endPos == -1)     //break if error
+            break;
+
+        std::string entryC = text.substr(pos, endPos - pos);     // get string within window i.e entry
+        //uint32 entry = atol(entryC.c_str());     // convert ascii to float
+
+        //ObjectGuid lootCurrent = ObjectGuid(HighGuid::GameObject, entry, guid);
+        ObjectGuid lootCurrent = ObjectGuid(HighGuid::GameObject, guid);
+
+        if (guid)
+            m_lootTargets.push_back(lootCurrent);
+    }
+}
+
+// extracts currency in #g#s#c format
+uint32 PlayerbotAI::extractMoney(const std::string& text) const
+{
+    // if user specified money in ##g##s##c format
+    std::string acum = "";
+    uint32 copper = 0;
+    for (uint8 i = 0; i < text.length(); i++)
+    {
+        if (text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if (text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if (text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if (text[i] == ' ')
+            break;
+        else if (text[i] >= 48 && text[i] <= 57)
+            acum += text[i];
+        else
+        {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+// finds items in equipment and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+    for (uint8 slot = EQUIPMENT_SLOT_START; itemIdSearchList.size() > 0 && slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetTemplate()->ItemId != *it)
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+}
+
+// finds items in inventory and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+
+    // look for items in main bag
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; itemIdSearchList.size() > 0 && slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetTemplate()->ItemId != *it)
+                continue;
+
+            if (m_bot->GetTrader() && m_bot->GetTradeData()->HasItem(pItem->GetGUID()))
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+
+    // for all for items in other bags
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; itemIdSearchList.size() > 0 && bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (!pBag)
+            continue;
+
+        for (uint8 slot = 0; itemIdSearchList.size() > 0 && slot < pBag->GetBagSize(); ++slot)
+        {
+            Item* const pItem = m_bot->GetItemByPos(bag, slot);
+            if (!pItem)
+                continue;
+
+            for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+            {
+                if (pItem->GetTemplate()->ItemId != *it)
+                    continue;
+
+                if (m_bot->GetTrader() && m_bot->GetTradeData()->HasItem(pItem->GetGUID()))
+                    continue;
+
+                foundItemList.push_back(pItem);
+                itemIdSearchList.erase(it);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::findNearbyGO()
+{
+    if (m_collectObjects.empty())
+        return;
+
+    std::list<GameObject*> tempTargetGOList;
+
+    for (BotEntryList::iterator itr = m_collectObjects.begin(); itr != m_collectObjects.end(); itr++)
+    {
+        uint32 entry = *(itr);
+        GameObjectTemplate const * gInfo = sObjectMgr->GetGameObjectTemplate(entry);
+        bool questGO = false;
+        uint8 needCount = 0;
+
+        if (questGO && needCount == 0)
+        {
+            m_collectObjects.remove(entry); // remove gameobject from collect list
+            return;
+        }
+
+        // search for GOs with entry, within range of m_bot
+        Trinity::GameObjectInRangeCheck go_check(m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), float(m_confCollectDistance), entry);
+        Trinity::GameObjectListSearcher<Trinity::GameObjectInRangeCheck> checker(m_bot, tempTargetGOList, go_check);
+        m_bot->VisitNearbyWorldObject(m_confCollectDistance, checker);
+        //VisitGridObjects(m_bot, checker, float(m_collectDist));
+
+        // no objects found, continue to next entry
+        if (tempTargetGOList.empty())
+            continue;
+
+        // add any objects found to our lootTargets
+        for (std::list<GameObject*>::iterator iter = tempTargetGOList.begin(); iter != tempTargetGOList.end(); iter++)
+        {
+            GameObject* go = (*iter);
+            if (go->isSpawned())
+                m_lootTargets.push_back(go->GetGUID());
+        }
+    }
+}
+
+void PlayerbotAI::findNearbyCreature()
+{
+    std::list<Creature*> creatureList;
+    float radius = INTERACTION_DISTANCE;
+
+    CellCoord pair(Trinity::ComputeCellCoord(m_bot->GetPositionX(), m_bot->GetPositionY()));
+    Cell cell(pair);
+
+    Trinity::AnyUnitInObjectRangeCheck go_check(m_bot, radius);
+    Trinity::CreatureListSearcher<Trinity::AnyUnitInObjectRangeCheck> go_search(m_bot, creatureList, go_check);
+    TypeContainerVisitor<Trinity::CreatureListSearcher<Trinity::AnyUnitInObjectRangeCheck>, GridTypeMapContainer> go_visit(go_search);
+
+    // Get Creatures
+    cell.Visit(pair, go_visit, *(m_bot->GetMap()), *(m_bot), radius);
+
+    // if (!creatureList.empty())
+    //    TellMaster("Found %i Creatures.", creatureList.size());
+
+    for (std::list<Creature*>::iterator iter = creatureList.begin(); iter != creatureList.end(); iter++)
+    {
+        Creature* currCreature = *iter;
+
+        for (std::list<enum NPCFlags>::iterator itr = m_findNPC.begin(); itr != m_findNPC.end(); itr = m_findNPC.erase(itr))
+        {
+            uint32 npcflags = currCreature->GetUInt32Value(UNIT_NPC_FLAGS);
+
+            if (!(*itr & npcflags))
+                continue;
+
+            if ((*itr == UNIT_NPC_FLAG_TRAINER_CLASS) && !currCreature->isCanTrainingAndResetTalentsOf(m_bot))
+                continue;
+
+            //WorldObject *wo = ObjectAccessor::GetObjectInMap(currCreature->GetGUID(), m_bot->GetMap(), (WorldObject*)NULL);
+            Creature *wo = ObjectAccessor::GetCreature(*m_bot, currCreature->GetGUID());
+            if (!wo) continue;
+            if (m_bot->GetDistance(wo) > CONTACT_DISTANCE + wo->GetObjectSize())
+            {
+                float x, y, z;
+                wo->GetContactPoint(m_bot, x, y, z, 1.0f);
+                m_bot->GetMotionMaster()->MovePoint(wo->GetMapId(), x, y, z);
+                // give time to move to point before trying again
+                SetIgnoreUpdateTime(1);
+            }
+
+            if (m_bot->GetDistance(wo) < INTERACTION_DISTANCE)
+            {
+
+                // sLog->outDebug(LOG_FILTER_NONE, "%s is interacting with (%s)",m_bot->GetName(),currCreature->GetCreatureTemplate()->Name);
+                GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(currCreature->GetCreatureTemplate()->GossipMenuId);
+
+                // prepares quest menu when true
+                bool canSeeQuests = currCreature->GetCreatureTemplate()->GossipMenuId == m_bot->GetDefaultGossipMenuForSource(wo);
+
+                // if canSeeQuests (the default, top level menu) and no menu options exist for this, use options from default options
+                if (pMenuItemBounds.first == pMenuItemBounds.second && canSeeQuests)
+                    pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(0);
+
+                for (GossipMenuItemsContainer::const_iterator it = pMenuItemBounds.first; it != pMenuItemBounds.second; it++)
+                {
+                    if (!(it->second.OptionNpcflag & npcflags))
+                        continue;
+
+                    switch (it->second.OptionType)
+                    {
+                        case GOSSIP_OPTION_BANKER:
+                        {
+                            // Manage banking actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); ait = m_tasks.erase(ait))
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // withdraw items
+                                        case BANK_WITHDRAW:
+                                        {
+                                            // TellMaster("Withdraw items");
+                                            if (!Withdraw(ait->second))
+                                                //sLog->outDebug(LOG_FILTER_NONE, "Withdraw: Couldn't withdraw (%u)", ait->second);
+                                            break;
+                                        }
+                                        // deposit items
+                                        case BANK_DEPOSIT:
+                                        {
+                                            // TellMaster("Deposit items");
+                                            if (!Deposit(ait->second))
+                                                //sLog->outDebug(LOG_FILTER_NONE, "Deposit: Couldn't deposit (%u)", ait->second);
+                                            break;
+                                        }
+                                        default:
+                                            break;
+                                    }
+                                }
+                            BankBalance();
+                            break;
+                        }
+                        case GOSSIP_OPTION_TAXIVENDOR:
+                        case GOSSIP_OPTION_GOSSIP:
+                        case GOSSIP_OPTION_INNKEEPER:
+                        case GOSSIP_OPTION_TRAINER:
+                        case GOSSIP_OPTION_QUESTGIVER:
+                        case GOSSIP_OPTION_VENDOR:
+                        case GOSSIP_OPTION_UNLEARNTALENTS:
+                        {
+                            // Manage questgiver, trainer, innkeeper & vendor actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); ait = m_tasks.erase(ait))
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // reset talents
+                                        case RESET_TALENTS:
+                                        {
+                                            // TellMaster("Reset all talents");
+                                            if (Talent(currCreature))
+                                                InspectUpdate();
+                                            break;
+                                        }
+                                        // take new quests
+                                        case TAKE_QUEST:
+                                        {
+                                            // TellMaster("Accepting quest");
+                                            if (!AddQuest(ait->second, wo))
+                                                //sLog->outDebug(LOG_FILTER_NONE, "AddQuest: Couldn't add quest (%u)", ait->second);
+                                            break;
+                                        }
+                                        // list npc quests
+                                        case LIST_QUEST:
+                                        {
+                                            // TellMaster("Show available npc quests");
+                                            ListQuests(wo);
+                                            break;
+                                        }
+                                        // end quests
+                                        case END_QUEST:
+                                        {
+                                            // TellMaster("Turn in available quests");
+                                            TurnInQuests(wo);
+                                            break;
+                                        }
+                                        // sell items
+                                        case SELL_ITEMS:
+                                        {
+                                            // TellMaster("Selling items");
+                                            Sell(ait->second);
+                                            break;
+                                        }
+                                        // repair items
+                                        //case REPAIR_ITEMS:
+                                        //{
+                                            // TellMaster("Repairing items");
+                                            //Repair(ait->second, currCreature);
+                                            //break;
+                                        //}
+                                        default:
+                                            break;
+                                    }
+                                }
+                            break;
+                        }
+                        case GOSSIP_OPTION_AUCTIONEER:
+                        {
+                            // Manage auctioneer actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); ait = m_tasks.erase(ait))
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // add new auction item
+                                        case ADD_AUCTION:
+                                        {
+                                            // TellMaster("Creating auction");
+                                            AddAuction(ait->second, currCreature);
+                                            break;
+                                        }
+                                        // cancel active auction
+                                        case REMOVE_AUCTION:
+                                        {
+                                            // TellMaster("Cancelling auction");
+                                            if (!RemoveAuction(ait->second))
+                                                //sLog->outDebug(LOG_FILTER_NONE, "RemoveAuction: Couldn't remove auction (%u)", ait->second);
+                                            break;
+                                        }
+                                        default:
+                                            break;
+                                    }
+                                }
+                            ListAuctions();
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                    m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+                }
+            }
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+        }
+    }
+}
+
+/**
+ * GiveLevel sets the bot's level to 'level'
+ * Not the clearest of function names, we're just mirroring Player.cpp's function name
+ */
+void PlayerbotAI::GiveLevel(uint32 /*level*/)
+{
+    // Talent function in Player::GetLevel take care of resetting talents in case level < getLevel()
+    ApplyActiveTalentSpec();
+}
+
+bool PlayerbotAI::CanStore()
+{
+    uint32 totalused = 0;
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+            totalused++;
+    }
+    uint32 totalfree = 16 - totalused;
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+                totalfree =  totalfree + pBag->GetFreeSlots();
+        }
+    }
+    return totalfree;
+}
+
+// use item on self
+void PlayerbotAI::UseItem(Item *item)
+{
+    UseItem(item, TARGET_FLAG_NONE, ObjectGuid::Empty);
+}
+
+// use item on equipped item
+void PlayerbotAI::UseItem(Item *item, uint8 targetInventorySlot)
+{
+    if (targetInventorySlot >= EQUIPMENT_SLOT_END)
+        return;
+
+    Item* const targetItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, targetInventorySlot);
+    if (!targetItem)
+        return;
+
+    UseItem(item, TARGET_FLAG_ITEM, targetItem->GetGUID());
+}
+
+// use item on unit
+void PlayerbotAI::UseItem(Item *item, Unit *target)
+{
+    if (!target)
+        return;
+
+    UseItem(item, TARGET_FLAG_UNIT, target->GetGUID());
+}
+
+// generic item use method
+void PlayerbotAI::UseItem(Item *item, uint32 targetFlag, ObjectGuid targetGUID)
+{
+    if (!item)
+        return;
+
+    uint8 bagIndex = item->GetBagSlot();
+    uint8 slot = item->GetSlot();
+    uint8 cast_count = 1;
+    ObjectGuid item_guid = item->GetGUID();
+    uint32 glyphIndex = 0;
+    uint8 unk_flags = 0;
+
+    if (uint32 questid = item->GetTemplate()->StartQuest)
+    {
+        std::ostringstream report;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (qInfo)
+        {
+            m_bot->GetMotionMaster()->Clear(true);
+            WorldPacket* const packet = new WorldPacket(CMSG_QUESTGIVER_ACCEPT_QUEST, 8 + 4 + 4);
+            *packet << item_guid;
+            *packet << questid;
+            *packet << uint32(0);
+            m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+            report << "|cffffff00Quest taken |r" << qInfo->GetTitle();
+            TellMaster(report.str());
+        }
+        return;
+    }
+
+    uint32 spellId = 0;
+    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        if (item->GetTemplate()->Spells[i].SpellId > 0)
+        {
+            spellId = item->GetTemplate()->Spells[i].SpellId;
+            break;
+        }
+    }
+
+    if (item->GetTemplate()->Flags & ITEM_FLAG_UNLOCKED && spellId == 0)
+    {
+        // Open quest item in inventory, containing related items (e.g Gnarlpine necklace, containing Tallonkai's Jewel)
+        WorldPacket* const packet = new WorldPacket(CMSG_OPEN_ITEM, 2);
+        *packet << item->GetBagSlot();
+        *packet << item->GetSlot();
+        m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+        return;
+    }
+
+    WorldPacket *packet = new WorldPacket(CMSG_USE_ITEM, 28);
+    *packet << bagIndex << slot << cast_count << spellId << item_guid
+            << glyphIndex << unk_flags << targetFlag;
+
+    if (targetFlag & (TARGET_FLAG_UNIT | TARGET_FLAG_ITEM | TARGET_FLAG_GAMEOBJECT))
+        *packet << targetGUID;//.WriteAsPacked();
+
+    m_bot->GetSession()->QueuePacket(packet);
+
+    SpellInfo const * spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TellMaster("Can't find spell entry for spell %u on item %u", spellId, item->GetEntry());
+        return;
+    }
+
+    SpellCastTimesEntry const * castingTimeEntry = spellInfo->CastTimeEntry;
+    if (!castingTimeEntry)
+    {
+        TellMaster("Can't find casting time entry for spell %u with index %u", spellId, spellInfo->CastTimeEntry);
+        return;
+    }
+
+    uint8 duration, castTime;
+    castTime = (uint8) ((float) castingTimeEntry->CastTime / 1000.0f);
+
+    if (item->GetTemplate()->Class == ITEM_CLASS_CONSUMABLE && item->GetTemplate()->SubClass == ITEM_SUBCLASS_FOOD)
+    {
+        duration = (uint8) ((float)spellInfo->GetDuration() / 1000.0f);
+        SetIgnoreUpdateTime(castTime + duration);
+    }
+    else
+        SetIgnoreUpdateTime(castTime);
+}
+
+// submits packet to use an item
+void PlayerbotAI::EquipItem(Item* src_Item)
+{
+    uint8 src_bagIndex = src_Item->GetBagSlot();
+    uint8 src_slot = src_Item->GetSlot();
+
+    // sLog->outDebug(LOG_FILTER_NONE, "PlayerbotAI::EquipItem: %s in srcbag = %u, srcslot = %u", src_Item->GetTemplate()->Name1, src_bagIndex, src_slot);
+
+    uint16 dest;
+    InventoryResult msg = m_bot->CanEquipItem(NULL_SLOT, dest, src_Item, !src_Item->IsBag());
+    if (msg != EQUIP_ERR_OK)
+    {
+        m_bot->SendEquipError(msg, src_Item, NULL);
+        return;
+    }
+
+    uint16 src = src_Item->GetPos();
+    if (dest == src)                                        // prevent equip in same slot, only at cheat
+        return;
+
+    Item *dest_Item = m_bot->GetItemByPos(dest);
+    if (!dest_Item)                                          // empty slot, simple case
+    {
+        m_bot->RemoveItem(src_bagIndex, src_slot, true);
+        m_bot->EquipItem(dest, src_Item, true);
+        m_bot->AutoUnequipOffhandIfNeed();
+    }
+    else                                                    // have currently equipped item, not simple case
+    {
+        uint8 dest_bagIndex = dest_Item->GetBagSlot();
+        uint8 dest_slot = dest_Item->GetSlot();
+
+        msg = m_bot->CanUnequipItem(dest, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, dest_Item, NULL);
+            return;
+        }
+
+        // check dest->src move possibility
+        ItemPosCountVec sSrc;
+        if (m_bot->IsInventoryPos(src))
+        {
+            msg = m_bot->CanStoreItem(src_bagIndex, src_slot, sSrc, dest_Item, true);
+            if (msg != EQUIP_ERR_OK)
+                msg = m_bot->CanStoreItem(src_bagIndex, NULL_SLOT, sSrc, dest_Item, true);
+            if (msg != EQUIP_ERR_OK)
+                msg = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, sSrc, dest_Item, true);
+        }
+
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, dest_Item, src_Item);
+            return;
+        }
+
+        // now do moves, remove...
+        m_bot->RemoveItem(dest_bagIndex, dest_slot, false);
+        m_bot->RemoveItem(src_bagIndex, src_slot, false);
+
+        // add to dest
+        m_bot->EquipItem(dest, src_Item, true);
+
+        // add to src
+        if (m_bot->IsInventoryPos(src))
+            m_bot->StoreItem(sSrc, dest_Item, true);
+
+        m_bot->AutoUnequipOffhandIfNeed();
+    }
+}
+
+// submits packet to trade an item (trade window must already be open)
+// default slot is -1 which means trade slots 0 to 5. if slot is set
+// to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+// 'Will not be traded' slot.
+bool PlayerbotAI::TradeItem(const Item& item, int8 slot)
+{
+    //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: TradeItem - slot=%d, hasTrader=%d, itemInTrade=%d, itemTradeable=%d",
+               //slot,
+               //(m_bot->GetTrader() ? 1 : 0),
+               //(item.IsInTrade() ? 1 : 0),
+               //(item.CanBeTraded() ? 1 : 0)
+               //);
+
+    if (!m_bot->GetTrader() || item.IsInTrade() || (!item.CanBeTraded() && slot != TRADE_SLOT_NONTRADED))
+        return false;
+
+    int8 tradeSlot = -1;
+
+    TradeData* pTrade = m_bot->GetTradeData();
+    if ((slot >= 0 && slot < TRADE_SLOT_COUNT) && pTrade->GetItem(TradeSlots(slot)) == NULL)
+        tradeSlot = slot;
+    else
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == NULL)
+            {
+                tradeSlot = i;
+                // reserve trade slot to allow multiple items to be traded
+                pTrade->SetItem(TradeSlots(i), const_cast<Item*>(&item));
+            }
+        }
+
+    if (tradeSlot == -1) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+            << (uint8) item.GetSlot();
+    m_bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+// submits packet to trade copper (trade window must be open)
+bool PlayerbotAI::TradeCopper(uint32 copper)
+{
+    if (copper > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        m_bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+    return false;
+}
+
+//bool PlayerbotAI::DoTeleport(WorldObject &obj)
+//{
+//    m_ignoreAIUpdatesUntilTime = time(NULL) + 6;
+//    Player *mstr = m_master;
+//    PlayerbotChatHandler ch(m_master->GetSession());
+//    if (!ch.teleport(*m_bot, obj))
+//    {
+//        ch.sysmessage(".. could not be teleported ..");
+//        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoTeleport - %s failed to teleport", m_bot->GetName() );
+//        return false;
+//    }
+//    return true;
+//}
+
+void PlayerbotAI::HandleTeleportAck()
+{
+    //TellMaster("Debug: HandleTeleportAck()");
+    m_ignoreAIUpdatesUntilTime = time(NULL) + 1;
+    m_bot->GetMotionMaster()->Clear(true);
+    if (m_bot->IsBeingTeleportedNear())
+    {
+        WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+        p.appendPackGUID(m_bot->GetGUID());
+        p << (uint32) 0; // supposed to be flags? not used currently
+        p << (uint32) time(NULL); // time - not currently used
+        m_bot->GetSession()->HandleMoveTeleportAck(p);
+    }
+    else if (m_bot->IsBeingTeleportedFar())
+        m_bot->GetSession()->HandleMoveWorldportAckOpcode();
+}
+
+// Localization support
+void PlayerbotAI::ItemLocalization(std::string& itemName, const uint32 itemID) const
+{
+    uint32 loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const *pItemInfo = sObjectMgr->GetItemLocale(itemID);
+    if (pItemInfo)
+        if (pItemInfo->Name.size() > loc && !pItemInfo->Name[loc].empty())
+        {
+            const std::string name = pItemInfo->Name[loc];
+            if (Utf8FitTo(name, wnamepart))
+                itemName = name.c_str();
+        }
+}
+
+void PlayerbotAI::QuestLocalization(std::string& questTitle, const uint32 questID) const
+{
+    uint32 loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const *pQuestInfo = sObjectMgr->GetQuestLocale(questID);
+    if (pQuestInfo)
+        if (pQuestInfo->Title.size() > loc && !pQuestInfo->Title[loc].empty())
+        {
+            const std::string title = pQuestInfo->Title[loc];
+            if (Utf8FitTo(title, wnamepart))
+                questTitle = title.c_str();
+        }
+}
+
+void PlayerbotAI::CreatureLocalization(std::string& creatureName, const uint32 entry) const
+{
+    uint32 loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    CreatureLocale const *pCreatureInfo = sObjectMgr->GetCreatureLocale(entry);
+    if (pCreatureInfo)
+        if (pCreatureInfo->Name.size() > loc && !pCreatureInfo->Name[loc].empty())
+        {
+            const std::string title = pCreatureInfo->Name[loc];
+            if (Utf8FitTo(title, wnamepart))
+                creatureName = title.c_str();
+        }
+}
+
+void PlayerbotAI::GameObjectLocalization(std::string& gameobjectName, const uint32 entry) const
+{
+    uint32 loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    GameObjectLocale const *pGameObjectInfo = sObjectMgr->GetGameObjectLocale(entry);
+    if (pGameObjectInfo)
+        if (pGameObjectInfo->Name.size() > loc && !pGameObjectInfo->Name[loc].empty())
+        {
+            const std::string title = pGameObjectInfo->Name[loc];
+            if (Utf8FitTo(title, wnamepart))
+                gameobjectName = title.c_str();
+        }
+}
+
+// Helper function for automatically selling poor quality items to the vendor
+void PlayerbotAI::_doSellItem(Item *item, std::ostringstream &report, std::ostringstream &canSell, uint32 &TotalCost, uint32 &TotalSold)
+{
+    if (!item)
+        return;
+
+    uint8 autosell = 0;
+
+    std::ostringstream mout;
+    if (item->CanBeTraded() && item->GetTemplate()->Quality == ITEM_QUALITY_POOR) // trash sells automatically.
+        autosell = 1;
+    if (SellWhite == 1) // set this with the command 'sell all'
+    {
+        // here we'll do some checks for other items that are safe to automatically sell such as
+        // white items that are a number of levels lower than anything we could possibly use.
+        // We'll check to make sure its not a tradeskill tool, quest item etc, things that we don't want to lose.
+        if (item->GetTemplate()->SellPrice > 0 && (item->GetTemplate()->Quality == ITEM_QUALITY_NORMAL || item->GetTemplate()->Quality == ITEM_QUALITY_UNCOMMON) && item->GetTemplate()->SubClass != ITEM_SUBCLASS_QUEST)
+        {
+            ItemTemplate const *pProto = item->GetTemplate();
+            if (pProto->RequiredLevel < (m_bot->getLevel() - gConfigSellLevelDiff) && pProto->SubClass != ITEM_SUBCLASS_WEAPON_MISC && pProto->FoodType == 0)
+            {
+                if (pProto->Class == ITEM_CLASS_WEAPON)
+                    autosell = 1;
+                if (pProto->Class == ITEM_CLASS_ARMOR)
+                    autosell = 1;
+            }
+            if (pProto->SubClass == ITEM_SUBCLASS_FOOD && (pProto->RequiredLevel < (m_bot->getLevel() - gConfigSellLevelDiff)))
+            {
+                autosell = 1;
+            }
+        }
+    }
+
+    if (autosell == 1) // set this switch above and this item gets sold automatically. Only set this for automatic sales e.g junk etc.
+    {
+
+        uint32 cost = item->GetCount() * item->GetTemplate()->SellPrice;
+        m_bot->ModifyMoney(cost);
+        m_bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+        m_bot->AddItemToBuyBackSlot(item);
+
+        ++TotalSold;
+        TotalCost += cost;
+
+        report << "Sold ";
+        MakeItemLink(item, report, true);
+        report << " for ";
+
+        report << Cash(cost);
+    }
+    else if (item->GetTemplate()->SellPrice > 0)
+        MakeItemLink(item, canSell, true);
+}
+
+bool PlayerbotAI::Withdraw(const uint32 itemid)
+{
+    Item* pItem = FindItemInBank(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        ItemPosCountVec dest;
+        InventoryResult msg = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, pItem, NULL);
+            return false;
+        }
+
+        m_bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->StoreItem(dest, pItem, true);
+
+        report << "Withdrawn ";
+        MakeItemLink(pItem, report, true);
+
+        TellMaster(report.str());
+    }
+    return true;
+}
+
+bool PlayerbotAI::Deposit(const uint32 itemid)
+{
+    Item* pItem = FindItem(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        ItemPosCountVec dest;
+        InventoryResult msg = m_bot->CanBankItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, pItem, NULL);
+            return false;
+        }
+
+        m_bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->BankItem(dest, pItem, true);
+
+        report << "Deposited ";
+        MakeItemLink(pItem, report, true);
+
+        TellMaster(report.str());
+    }
+    return true;
+}
+
+void PlayerbotAI::BankBalance()
+{
+    std::ostringstream report;
+
+    report << "In my bank\n ";
+    report << "My item slots: ";
+
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; ++slot)
+    {
+        Item* const item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (item)
+            MakeItemLink(item, report, true);
+    }
+    TellMaster(report.str());
+
+    // and each of my bank bags
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        std::ostringstream goods;
+        const Bag* const pBag = static_cast<Bag *>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            goods << "\nMy ";
+            const ItemTemplate* const pBagProto = pBag->GetTemplate();
+            std::string bagName = pBagProto->Name1;
+            ItemLocalization(bagName, pBagProto->ItemId);
+            goods << bagName << " slot: ";
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = m_bot->GetItemByPos(bag, slot);
+                if (item)
+                    MakeItemLink(item, goods, true);
+            }
+            TellMaster(goods.str());
+        }
+    }
+}
+
+bool PlayerbotAI::Talent(Creature* trainer)
+{
+    if (!(m_bot->ResetTalents()))
+    {
+        WorldPacket* const packet = new WorldPacket(MSG_TALENT_WIPE_CONFIRM, 8 + 4);    //you do not have any talent
+        *packet << ObjectGuid(ObjectGuid::Empty);
+        *packet << uint32(0);
+        m_bot->GetSession()->QueuePacket(packet);
+        return false;
+    }
+
+    m_bot->SendTalentsInfoData(false);
+    trainer->CastSpell(m_bot, 14867, true);                  //spell: "Untalent Visual Effect"
+    return true;
+}
+
+void PlayerbotAI::InspectUpdate()
+{
+    WorldPacket packet(SMSG_INSPECT_TALENT, 50);
+    packet << (m_bot->GetPackGUID());
+    m_bot->BuildPlayerTalentsInfoData(&packet);
+    m_bot->BuildEnchantmentsInfoData(&packet);
+    m_master->GetSession()->SendPacket(&packet);
+}
+
+void PlayerbotAI::Repair(const uint32 itemid, Creature* rCreature)
+{
+    Item* rItem = FindItem(itemid); // if item equipped or in bags
+    uint8 IsInGuild = (m_bot->GetGuildId() != 0) ? uint8(1) : uint8(0);
+    ObjectGuid itemGuid = (rItem) ? rItem->GetGUID() : ObjectGuid::Empty;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_REPAIR_ITEM, 8 + 8 + 1);
+    *packet << rCreature->GetGUID();  // repair npc guid
+    *packet << itemGuid; // if item specified then repair this, else repair all
+    *packet << IsInGuild;  // guildbank yes=1 no=0
+    m_bot->GetSession()->QueuePacket(packet);  // queue the packet to get around race condition
+}
+
+bool PlayerbotAI::RemoveAuction(const uint32 auctionid)
+{
+    QueryResult result = CharacterDatabase.PQuery(
+        //"SELECT houseid,itemguid,item_template,itemowner,buyoutprice,time,buyguid,lastbid,startbid,deposit FROM auction WHERE id = '%u'", auctionid);
+        "SELECT auctioneerguid,itemguid,itemowner,buyoutprice,time,buyguid,lastbid,startbid,deposit FROM auctionhouse WHERE id = '%u'", auctionid);
+
+    AuctionEntry *auction;
+
+    if (result)
+    {
+        Field *fields = result->Fetch();
+
+        auction = new AuctionEntry;
+        auction->Id = auctionid;
+        auction->houseId = fields[0].GetUInt32();
+        auction->itemGUIDLow = fields[1].GetUInt32();
+        auction->itemEntry = fields[2].GetUInt32();
+        auction->owner = fields[3].GetUInt32();
+        auction->buyout = fields[4].GetUInt32();
+        auction->expire_time = fields[5].GetUInt32();
+        auction->bidder = fields[6].GetUInt32();
+        auction->bid = fields[7].GetUInt32();
+        auction->startbid = fields[8].GetUInt32();
+        auction->deposit = fields[9].GetUInt32();
+        auction->auctionHouseEntry = NULL;                  // init later
+
+        // check if sold item exists for guid
+        // and item_template in fact (GetAItem will fail if problematic in result check in AuctionHouseMgr::LoadAuctionItems)
+        Item* pItem = sAuctionMgr->GetAItem(auction->itemGUIDLow);
+        if (!pItem)
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            auction->DeleteFromDB(trans);
+            CharacterDatabase.CommitTransaction(trans);
+            //sLog->outError("Auction %u has not a existing item : %u, deleted", auction->Id, auction->itemGUIDLow);
+            delete auction;
+            //delete result;
+            return false;
+        }
+
+        auction->auctionHouseEntry = sAuctionHouseStore.LookupEntry(auction->houseId);
+
+        // Attempt send item back to owner
+        std::ostringstream msgAuctionCanceledOwner;
+        msgAuctionCanceledOwner << auction->itemEntry << ":0:" << AUCTION_CANCELED << ":0:0";
+
+        // item will deleted or added to received mail list
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+        MailDraft(msgAuctionCanceledOwner.str(), "")    // TODO: fix body
+        .AddItem(pItem)
+        .SendMailTo(trans, MailReceiver(auction->owner), auction, MAIL_CHECK_MASK_COPIED);
+
+
+        if (sAuctionMgr->RemoveAItem(auction->itemGUIDLow))
+            m_bot->GetSession()->SendAuctionCommandResult(auction->Id, AUCTION_CANCEL, ERR_AUCTION_OK);
+
+        auction->DeleteFromDB(trans);
+
+        CharacterDatabase.CommitTransaction(trans);
+
+        delete auction;
+        //delete result;
+    }
+    return true;
+}
+
+// Subject - 9360:0:2
+// Subject - item:0:MailAuctionAnswer
+// Body - 0:2650:2650:120:132
+// Body - 0:High Bid:Buyout:Deposit:AuctionHouse Cut
+
+std::string PlayerbotAI::AuctionResult(std::string subject, std::string body)
+{
+    std::ostringstream out;
+    std::string winner;
+    int pos;
+
+    subject.append(":");
+    if (body.size() > 0)
+    {
+        pos = body.find_first_not_of(" ");
+        subject.append(body, pos, body.size() - pos);
+        subject.append(":");
+    }
+
+    //sLog->outDebug(LOG_FILTER_NONE, "Auctions string (%s)", subject.c_str());
+    pos = 0;
+    int sublen = subject.size() / 2;
+    uint32 a_info[15];
+    for (int i = 0; i < sublen; i++)
+    {
+        int endpos = subject.find(':', pos);
+        std::string idc = subject.substr(pos, endpos - pos);
+        a_info[i] = atol(idc.c_str());
+        //sLog->outDebug(LOG_FILTER_NONE, "a_info[%d] = (%u)", i, a_info[i]);
+        pos = endpos + 1;
+    }
+
+    if (a_info[4] != a_info[5])
+        winner =  "High Bidder";
+    else
+        winner =  "Buyout";
+
+    ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(a_info[0]);
+    if (!pProto)
+        return out.str();
+
+    switch (a_info[2])
+    {
+        case AUCTION_OUTBIDDED:           //= 0,
+            out << "Subject: Outbid on: " << pProto->Name1;
+            break;
+        case AUCTION_WON:                 //= 1,
+            out << "Subject: Auction won: " << pProto->Name1 << "\n";
+            out << "Item Purchased: " << pProto->Name1 << "\n";
+            break;
+        case AUCTION_SUCCESSFUL:          //= 2,
+        {
+            out << "Subject: Auction successful: " << pProto->Name1 << "\n";
+            out << "Item Sold: " << pProto->Name1 << "\n";
+            out << "\n[" << winner << " Sale: " << Cash(a_info[4]) << "]";
+            out << "\n( |cff1eff00Deposit:|cffccffff " << Cash(a_info[6]) << " |cffff0000- Tax:|cffccffff " << Cash(a_info[7]) << " ) |cff1eff00+|cffccffff";
+            break;
+        }
+        case AUCTION_EXPIRED:             //= 3,
+            out << "Subject: Auction expired: " << pProto->Name1;
+            break;
+        case AUCTION_CANCELLED_TO_BIDDER: //= 4,
+            out << "Subject: Auction cancelled to bidder: " << pProto->Name1;
+            break;
+        case AUCTION_CANCELED:            //= 5,
+            out << "Subject: Auction cancelled: " << pProto->Name1;
+            break;
+        case AUCTION_SALE_PENDING:        //= 6
+            out << "Subject: Auction sale pending: " << pProto->Name1;
+            break;
+    }
+    return out.str();
+}
+
+std::string PlayerbotAI::Cash(uint32 copper)
+{
+    using namespace std;
+    std::ostringstream change;
+
+    uint32 gold = uint32(copper / 10000);
+    copper -= (gold * 10000);
+    uint32 silver = uint32(copper / 100);
+    copper -= (silver * 100);
+
+    if (gold > 0)
+        change << gold <<  " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+    if (silver > 0)
+        change << std::setfill(' ') << std::setw(2) << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+    change << std::setfill(' ') << std::setw(2) << copper << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+
+    return change.str();
+}
+
+void PlayerbotAI::ListQuests(WorldObject * questgiver)
+{
+    if (!questgiver)
+        return;
+
+    // list all bot quests this NPC has
+    m_bot->PrepareQuestMenu(questgiver->GetGUID());
+    QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+    std::ostringstream out;
+    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+    {
+        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+        uint32 questID = qItem.QuestId;
+        Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+
+        std::string questTitle  = pQuest->GetTitle();
+        QuestLocalization(questTitle, questID);
+
+        if (m_bot->SatisfyQuestStatus(pQuest, false))
+            out << "|cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+    }
+    if (!out.str().empty())
+        TellMaster(out.str());
+}
+
+bool PlayerbotAI::AddQuest(const uint32 entry, WorldObject * questgiver)
+{
+    std::ostringstream out;
+
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(entry);
+    if (!qInfo)
+    {
+        ChatHandler(m_master->GetSession()).PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        return false;
+    }
+
+    if (m_bot->GetQuestStatus(entry) == QUEST_STATUS_COMPLETE)
+    {
+        TellMaster("I already completed that quest.");
+        return false;
+    }
+    else if (!m_bot->CanTakeQuest(qInfo, false))
+    {
+        if (!m_bot->SatisfyQuestStatus(qInfo, false))
+            TellMaster("I already have that quest.");
+        else
+            TellMaster("I can't take that quest.");
+        return false;
+    }
+    else if (!m_bot->SatisfyQuestLog(false))
+    {
+        TellMaster("My quest log is full.");
+        return false;
+    }
+    else if (m_bot->CanAddQuest(qInfo, false))
+    {
+        m_bot->AddQuest(qInfo, questgiver);
+
+        std::string questTitle  = qInfo->GetTitle();
+        QuestLocalization(questTitle, entry);
+
+        out << "|cffffff00Quest taken " << "|cff808080|Hquest:" << entry << ':' << qInfo->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+        if (m_bot->CanCompleteQuest(entry))
+            m_bot->CompleteQuest(entry);
+
+        // build needed items if quest contains any
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredItemCount[i] > 0)
+            {
+                SetQuestNeedItems();
+                break;
+            }
+
+        // build needed creatures if quest contains any
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredNpcOrGoCount[i] > 0)
+            {
+                SetQuestNeedCreatures();
+                break;
+            }
+
+        TellMaster(out.str());
+        return true;
+    }
+    return false;
+}
+
+void PlayerbotAI::ListAuctions()
+{
+    std::ostringstream report;
+
+    QueryResult result = CharacterDatabase.PQuery(
+        //"SELECT id,itemguid,item_template,time,buyguid,lastbid FROM auction WHERE itemowner = '%u'", m_bot->GetGUID().GetCounter());
+        "SELECT id,itemguid,time,buyguid,lastbid FROM auctionhouse WHERE itemowner = '%u'", m_bot->GetGUID().GetCounter());
+    if (result)
+    {
+        report << "My active auctions are: \n";
+        do
+        {
+            Field *fields = result->Fetch();
+
+            uint32 Id = fields[0].GetUInt32();
+            uint32 itemGuidLow = fields[1].GetUInt32();
+            AuctionEntry *auction = AuctionHouseObject().GetAuction(Id);
+            uint32 itemTemplate = auction->itemEntry;//fields[2].GetUInt32();
+            time_t expireTime = fields[2].GetUInt32();
+            uint32 bidder = fields[3].GetUInt32();
+            uint32 bid = fields[4].GetUInt32();
+
+            // current time
+            time_t currtime = time(NULL);
+            time_t remtime = expireTime - currtime;
+
+            tm* aTm = gmtime(&remtime);
+
+            if (expireTime > currtime)
+            {
+                Item* aItem = sAuctionMgr->GetAItem(itemGuidLow);
+                if (aItem)
+                {
+                    // Name
+                    uint32 count = aItem->GetCount();
+                    std::string name = aItem->GetTemplate()->Name1;
+                    ItemLocalization(name, itemTemplate);
+                    report << "\n|cffffffff|Htitle:" << Id << "|h[" << name;
+                    if (count > 1)
+                        report << "|cff00ff00x" << count << "|cffffffff" << "]|h|r";
+                    else
+                        report << "]|h|r";
+                }
+
+                if (bidder)
+                {
+                    uint32 guid = bidder;
+/* Fix Me
+                    std::string bidder_name;
+                    if (sObjectMgr->GetPlayerNameByGUID(guid, bidder_name))
+                        report << " " << bidder_name << ": ";
+*/
+                    report << Cash(bid);
+                }
+                if (aItem)
+                    report << " ends: " << aTm->tm_hour << "|cff0070dd|hH|h|r " << aTm->tm_min << "|cff0070dd|hmin|h|r";
+            }
+        } while (result->NextRow());
+
+        //delete result;
+        TellMaster(report.str().c_str());
+    }
+}
+
+void PlayerbotAI::AddAuction(const uint32 itemid, Creature* aCreature)
+{
+    Item* aItem = FindItem(itemid);
+    if (aItem)
+    {
+        std::ostringstream out;
+        srand(time(NULL));
+        uint32 duration[3] = { 720, 1440, 2880 };  // 720 = 12hrs, 1440 = 24hrs, 2880 = 48hrs
+        uint32 etime = duration[rand() % 3];
+
+        uint32 min = urand(aItem->GetTemplate()->SellPrice * aItem->GetCount(), aItem->GetTemplate()->BuyPrice * aItem->GetCount()) * (aItem->GetTemplate()->Quality + 1);
+        uint32 max = urand(aItem->GetTemplate()->SellPrice * aItem->GetCount(), aItem->GetTemplate()->BuyPrice * aItem->GetCount()) * (aItem->GetTemplate()->Quality + 1);
+
+        out << "Auctioning ";
+        MakeItemLink(aItem, out, true);
+        out << " with " << aCreature->GetCreatureTemplate()->Name;
+        TellMaster(out.str().c_str());
+
+        WorldPacket* const packet = new WorldPacket(CMSG_AUCTION_SELL_ITEM, 8 + 4 + 8 + 4 + 4 + 4 + 4);
+        *packet << aCreature->GetGUID();     // auctioneer guid
+        *packet << uint32(1);                      // const 1
+        *packet << aItem->GetGUID();         // item guid
+        *packet << aItem->GetCount();      // stacksize
+        *packet << uint32((min < max) ? min : max);  // starting bid
+        *packet << uint32((max > min) ? max : min);  // buyout
+        *packet << uint32(etime);  // auction duration
+
+        m_bot->GetSession()->QueuePacket(packet);  // queue the packet to get around race condition
+    }
+}
+
+void PlayerbotAI::Buy(ObjectGuid vendorguid, const uint32 itemid)
+{
+    Creature *pCreature = m_bot->GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
+
+    if (!pCreature)
+        return;
+
+    VendorItemData const* vItems = pCreature->GetVendorItems();
+    VendorItemData const* tItems = pCreature->GetVendorItems();
+
+    uint8 customitems = vItems ? vItems->GetItemCount() : 0;
+    uint8 numitems = customitems + (tItems ? tItems->GetItemCount() : 0);
+
+    for (uint8 vendorslot = 0; vendorslot < numitems; ++vendorslot)
+    {
+        VendorItem const* crItem = vendorslot < customitems ? vItems->GetItem(vendorslot) : tItems->GetItem(vendorslot - customitems);
+
+        if (crItem)
+        {
+            if (itemid != crItem->item)
+                continue;
+
+            ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(itemid);
+            if (pProto)
+            {
+                // class wrong item skip only for bindable case
+                if ((pProto->AllowableClass & m_bot->getClassMask()) == 0 && pProto->Bonding == BIND_WHEN_PICKED_UP)
+                    continue;
+
+                // race wrong item skip always
+                if ((pProto->Flags2 & 1) && m_bot->GetTeam() != HORDE)//Horde only
+                    continue;
+
+                if ((pProto->Flags2 & 2) && m_bot->GetTeam() != ALLIANCE)//Alliance only
+                    continue;
+
+                if ((pProto->AllowableRace & m_bot->getRaceMask()) == 0)
+                    continue;
+
+                //// possible item coverting for BoA case
+                //if (pProto->Flags == ITEM_PROTO_FLAG_BIND_TO_ACCOUNT)
+                //    // convert if can use and then buy
+                //    if (pProto->RequiredReputationFaction && uint32(m_bot->GetReputationRank(pProto->RequiredReputationFaction)) >= pProto->RequiredReputationRank)
+                //        // checked at convert data loading as existed
+                //        if (uint32 newItemId = sObjectMgr->GetItemConvert(itemid, m_bot->getRaceMask()))
+                //            pProto = sObjectMgr->GetItemTemplate(newItemId);
+                m_bot->BuyItemFromVendorSlot(vendorguid, vendorslot, itemid, 1, NULL_BAG, NULL_SLOT);
+                return;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::Sell(const uint32 itemid)
+{
+    Item* pItem = FindItem(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        uint32 cost = pItem->GetCount() * pItem->GetTemplate()->SellPrice;
+        m_bot->ModifyMoney(cost);
+        m_bot->MoveItemFromInventory(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->AddItemToBuyBackSlot(pItem);
+
+        report << "Sold ";
+        MakeItemLink(pItem, report, true);
+        report << " for ";
+
+        report << Cash(cost);
+
+        TellMaster(report.str());
+    }
+}
+
+void PlayerbotAI::SellGarbage(Player & /*plyer*/, bool /*bListNonTrash*/, bool bDetailTrashSold, bool bVerbose)
+{
+    uint32 SoldCost = 0;
+    uint32 SoldQuantity = 0;
+    std::ostringstream report, goods;
+    ChatHandler ch(m_master->GetSession());
+
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item* const item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (item)
+            _doSellItem(item, report, goods, SoldCost, SoldQuantity);
+    }
+
+    uint8 notempty = 0;
+    if (goods.str().size() != 0)
+    {
+        notempty = 1;
+        TellMaster("Heres a list of items I can sell:");
+    }
+    // and each of our other packs
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) // check for extra bags
+    {
+        // we want to output the item list to links one bag at a time and clear it, to prevent the list from overloading
+        if (goods.str().size() != 0) // This will be one bag behind in the check. if the previous bag listed anything, llist that now and clear the list
+        {
+            if (notempty == 0)
+            {
+                TellMaster("Heres a list of items I can sell:");
+                notempty = 1; // at least one bag must have had something in it, used at end of this function
+            }
+            else
+            {
+                ch.SendSysMessage(goods.str().c_str()); // previous bags list contents, including main backpack first.
+                goods.str(""); // clear the list for next bag
+            }
+        }
+
+        const Bag* const pBag = static_cast<Bag *>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            // Very nice, but who cares what bag it's in?
+            //const ItemTemplate* const pBagProto = pBag->GetTemplate();
+            //std::string bagName = pBagProto->Name1;
+            //ItemLocalization(bagName, pBagProto->ItemId);
+            //goods << "\nIn my " << bagName << ":";
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = m_bot->GetItemByPos(bag, slot);
+                if (item)
+                    _doSellItem(item, report, goods, SoldCost, SoldQuantity);
+            }
+        }
+    }
+
+    if (goods.str().size() != 0) // This will make sure items in the last bag were output to links
+    {
+        ch.SendSysMessage(goods.str().c_str());
+        goods.str(""); // clear the list
+        notempty = 1; // at least one bag must have had something in it, used at end of this function
+    }
+    if (notempty == 1)
+        TellMaster("All of the above items could be sold"); // links are complete, notify master
+
+    if (!bDetailTrashSold) // no trash got sold
+        report.str("");  // clear ostringstream
+
+    if (SoldCost > 0)
+    {
+        if (bDetailTrashSold)
+            report << "Sold total " << SoldQuantity << " item(s) for ";
+        else
+            report << "Sold " << SoldQuantity << " trash item(s) for ";
+        report << Cash(SoldCost);
+
+        if (bVerbose)
+            TellMaster(report.str());
+        if (SellWhite == 1)
+            SellWhite = 0;
+    }
+
+    // For all bags, non-gray sellable items
+    if (bVerbose)
+    {
+        if (SoldQuantity == 0 && notempty == 0)
+            TellMaster("No items to sell, trash or otherwise.");
+    }
+}
+
+std::string PlayerbotAI::DropItem(const uint32 itemid)
+{
+    Item* pItem = FindItem(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        // Yea, that's right, get the item info BEFORE you destroy it :)
+        MakeItemText(pItem, report, true);
+
+        m_bot->DestroyItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+
+        return report.str();
+    }
+
+    return "";
+}
+
+void PlayerbotAI::GetTaxi(ObjectGuid guid, BotTaxiNode& nodes)
+{
+    // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: GetTaxi - %s node[0] %d node[1] %d", m_bot->GetName(), nodes[0], nodes[1]);
+
+    Creature *unit = m_bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_FLIGHTMASTER);
+    if (!unit)
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: GetTaxi - %u not found or you can't interact with it.", guid);
+        return;
+    }
+
+    if (m_bot->m_taxi.IsTaximaskNodeKnown(nodes[0]) ? 0 : 1)
+        return;
+
+    if (m_bot->m_taxi.IsTaximaskNodeKnown(nodes[nodes.size() - 1]) ? 0 : 1)
+        return;
+
+    if (m_bot->GetPlayerbotAI()->GetMovementOrder() != MOVEMENT_STAY)
+    {
+        m_taxiNodes = nodes;
+        m_taxiMaster = guid;
+        SetState(BOTSTATE_FLYING);
+    }
+}
+
+// handle commands sent through chat channels
+void PlayerbotAI::HandleCommand(const std::string& text, Player& fromPlayer)
+{
+    // prevent bot task spam
+    m_inventory_full = false;
+    m_tasks.unique();
+    m_findNPC.unique();
+
+    // sLog->outDebug(LOG_FILTER_NONE, "chat(%s)",text.c_str());
+
+    // ignore any messages from Addons
+    if (text.empty() ||
+        text.find("X-Perl") != std::wstring::npos ||
+        text.find("HealBot") != std::wstring::npos ||
+        text.find("LOOT_OPENED") != std::wstring::npos ||
+        text.find("CTRA") != std::wstring::npos ||
+        text.find("GathX") == 0) // Gatherer
+        return;
+
+    // if message is not from a player in the masters account auto reply and ignore
+    if (!canObeyCommandFrom(fromPlayer))
+    {
+        // only tell the player once instead of endlessly nagging them
+        if (m_ignorePlayersChat.find(fromPlayer.GetGUID()) == m_ignorePlayersChat.end())
+        {
+            std::string msg = "I can't talk to you. Please speak to my master ";
+            msg += m_master->GetName();
+            SendWhisper(msg, fromPlayer);
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_NO);
+            m_ignorePlayersChat.insert(fromPlayer.GetGUID());
+        }
+        return;
+    }
+
+    // Passed along to ExtractCommand, if (sub)command is found "input" will only contain the rest of the string (or "")
+    std::string input = text.c_str();
+
+    // if in the middle of a trade, and player asks for an item/money
+    // WARNING: This makes it so you can't use any other commands during a trade!
+    if (m_bot->GetTrader() && m_bot->GetTrader()->GetGUID() == fromPlayer.GetGUID())
+    {
+        uint32 copper = extractMoney(text);
+        if (copper > 0)
+            TradeCopper(copper);
+
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (itemIds.size() == 0)
+            SendWhisper("Show me what item you want by shift clicking the item in the chat window.", fromPlayer);
+        else if (!strncmp(text.c_str(), "nt ", 3))
+        {
+            if (itemIds.size() > 1)
+                SendWhisper("There is only one 'Will not be traded' slot. Shift-click just one item, please!", fromPlayer);
+            else
+            {
+                std::list<Item*> itemList;
+                findItemsInEquip(itemIds, itemList);
+                findItemsInInv(itemIds, itemList);
+                if (itemList.size() > 0)
+                    TradeItem((**itemList.begin()), TRADE_SLOT_NONTRADED);
+                else
+                    SendWhisper("I do not have this item equipped or in my bags!", fromPlayer);
+            }
+        }
+        else
+        {
+            std::list<Item*> itemList;
+            findItemsInInv(itemIds, itemList);
+            for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+                TradeItem(**it);
+        }
+    }
+
+    else if (ExtractCommand("help", input))
+        _HandleCommandHelp(input, fromPlayer);
+
+    else if (fromPlayer.GetSession()->GetSecurity() > SEC_PLAYER && ExtractCommand("gm", input))
+        _HandleCommandGM(input, fromPlayer);
+
+    else if (ExtractCommand("reset", input))
+        _HandleCommandReset(input, fromPlayer);
+    else if (ExtractCommand("orders", input))
+        _HandleCommandOrders(input, fromPlayer);
+    else if (ExtractCommand("follow", input) || ExtractCommand("come", input))
+        _HandleCommandFollow(input, fromPlayer);
+    else if (ExtractCommand("stay", input) || ExtractCommand("stop", input))
+        _HandleCommandStay(input, fromPlayer);
+    else if (ExtractCommand("attack", input))
+        _HandleCommandAttack(input, fromPlayer);
+
+    else if (ExtractCommand("cast", input, true)) // true -> "cast" OR "c"
+        _HandleCommandCast(input, fromPlayer);
+
+    else if (ExtractCommand("sell", input))
+        _HandleCommandSell(input, fromPlayer);
+
+    else if (ExtractCommand("buy", input))
+        _HandleCommandBuy(input, fromPlayer);
+
+    else if (ExtractCommand("drop", input))
+        _HandleCommandDrop(input, fromPlayer);
+
+    else if (ExtractCommand("repair", input))
+        _HandleCommandRepair(input, fromPlayer);
+
+    else if (ExtractCommand("auction", input))
+        _HandleCommandAuction(input, fromPlayer);
+
+    else if (ExtractCommand("mail", input))
+        _HandleCommandMail(input, fromPlayer);
+
+    else if (ExtractCommand("bank", input))
+        _HandleCommandBank(input, fromPlayer);
+
+    else if (ExtractCommand("talent", input))
+        _HandleCommandTalent(input, fromPlayer);
+
+    else if (ExtractCommand("use", input, true)) // true -> "use" OR "u"
+        _HandleCommandUse(input, fromPlayer);
+
+    else if (ExtractCommand("equip", input, true)) // true -> "equip" OR "e"
+        _HandleCommandEquip(input, fromPlayer);
+
+    else if (ExtractCommand("autoequip", input, true)) // switches autoequip on or off if on already
+        _HandleCommandAutoEquip(input, fromPlayer);
+
+    // find project: 20:50 02/12/10 rev.4 item in world and wait until ordered to follow
+    else if (ExtractCommand("find", input, true)) // true -> "find" OR "f"
+        _HandleCommandFind(input, fromPlayer);
+
+    // get project: 20:50 02/12/10 rev.4 compact edition, handles multiple linked gameobject & improves visuals
+    else if (ExtractCommand("get", input, true)) // true -> "get" OR "g"
+        _HandleCommandGet(input, fromPlayer);
+
+    // Handle all collection related commands here
+    else if (ExtractCommand("collect", input))
+        _HandleCommandCollect(input, fromPlayer);
+
+    else if (ExtractCommand("quest", input))
+        _HandleCommandQuest(input, fromPlayer);
+
+    else if (ExtractCommand("craft", input))
+        _HandleCommandCraft(input, fromPlayer);
+
+    else if (ExtractCommand("enchant", input))
+        _HandleCommandEnchant(input, fromPlayer);
+
+    else if (ExtractCommand("process", input))
+        _HandleCommandProcess(input, fromPlayer);
+
+    else if (ExtractCommand("pet", input))
+        _HandleCommandPet(input, fromPlayer);
+
+    else if (ExtractCommand("spells", input))
+        _HandleCommandSpells(input, fromPlayer);
+
+    // survey project: 20:50 02/12/10 rev.4 compact edition
+    else if (ExtractCommand("survey", input))
+        _HandleCommandSurvey(input, fromPlayer);
+
+    // Handle class & professions training:
+    else if (ExtractCommand("skill", input))
+        _HandleCommandSkill(input, fromPlayer);
+
+    // stats project: 11:30 15/12/10 rev.2 display bot statistics
+    else if (ExtractCommand("stats", input))
+        _HandleCommandStats(input, fromPlayer);
+
+    else
+    {
+        // if this looks like an item link, reward item it completed quest and talking to NPC
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (!itemIds.empty()) {
+            uint32 itemId = itemIds.front();
+            bool wasRewarded = false;
+            ObjectGuid questRewarderGUID = m_bot->GetTarget();
+            Object* pNpc = ObjectAccessor::GetObjectByTypeMask(*m_bot, questRewarderGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+            for (uint32 iI = 0; !wasRewarded && iI < questMenu.GetMenuItemCount(); ++iI)
+            {
+                QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+                uint32 questID = qItem.QuestId;
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+                QuestStatus status = m_bot->GetQuestStatus(questID);
+
+                // if quest is complete, turn it in
+                if (status == QUEST_STATUS_COMPLETE &&
+                    !m_bot->GetQuestRewardStatus(questID) &&
+                    pQuest->GetRewChoiceItemsCount() > 1 &&
+                    m_bot->CanRewardQuest(pQuest, false))
+                    for (uint8 rewardIdx = 0; !wasRewarded && rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+                    {
+                        ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                        if (itemId == pRewardItem->ItemId)
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, false);
+
+                            std::string questTitle  = pQuest->GetTitle();
+                            QuestLocalization(questTitle, questID);
+                            std::string itemName = pRewardItem->Name1;
+                            ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            std::ostringstream out;
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r rewarded";
+                            SendWhisper(out.str(), fromPlayer);
+                            wasRewarded = true;
+                        }
+                    }
+            }
+        }
+        else
+        {
+            // TODO: make this only in response to direct whispers (chatting in party chat can in fact be between humans)
+            std::string msg = "What? For a list of commands, ask for 'help'.";
+            SendWhisper(msg, fromPlayer);
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+        }
+    }
+}
+
+/**
+ * ExtractCommand looks for a command in a text string
+ * sLookingFor       - string you're looking for (e.g. "help")
+ * text              - string which may or may not start with sLookingFor
+ * bUseShort         - does this command accept the shorthand command? If true, "help" would ALSO look for "h"
+ *
+ * returns true if the string has been found
+ * returns false if the string has not been found
+ */
+bool PlayerbotAI::ExtractCommand(const std::string sLookingFor, std::string &text, bool bUseShort)
+{
+    // ("help" + " ") < "help X"  AND  text's start (as big as sLookingFor) == sLookingFor
+    // Recommend AGAINST adapting this for non-space situations (thinking MangosZero)
+    // - unknown would risk being (short for "use") 'u' + "nknown"
+    if (sLookingFor.size() + 1 < text.size() && text.at(sLookingFor.size()) == ' '
+        && 0 == text.substr(0, sLookingFor.size()).compare(sLookingFor))
+    {
+        text = text.substr(sLookingFor.size() + 1);
+        return true;
+    }
+
+    if (0 == text.compare(sLookingFor))
+    {
+        text = "";
+        return true;
+    }
+
+    if (bUseShort)
+    {
+        if (text.size() > 1 && sLookingFor.at(0) == text.at(0) && text.at(1) == ' ')
+        {
+            text = text.substr(2);
+            return true;
+        }
+        else if (text.size() == 1 && sLookingFor.at(0) == text.at(0))
+        {
+            text = "";
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void PlayerbotAI::_HandleCommandReset(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("reset does not have a subcommand.", fromPlayer);
+        return;
+    }
+    SetState(BOTSTATE_NORMAL);
+    MovementReset();
+    SetQuestNeedItems();
+    SetQuestNeedCreatures();
+    UpdateAttackerInfo();
+    m_lootTargets.clear();
+    m_lootCurrent = ObjectGuid::Empty;
+    m_targetCombat = 0;
+    ClearActiveTalentSpec();
+}
+
+void PlayerbotAI::_HandleCommandOrders(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("orders cannot have a subcommand.", fromPlayer);
+        return;
+    }
+    SendOrders(*m_master);
+}
+
+void PlayerbotAI::_HandleCommandFollow(std::string &text, Player &fromPlayer)
+{
+    if (ExtractCommand("auto", text)) // switch to automatic follow distance
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
+            return;
+        }
+        DistOverRide = 0; // this resets follow distance to config default
+        IsUpOrDown = 0;
+        std::ostringstream msg;
+        gTempDist = 1;
+        gTempDist2 = 2;
+
+        if (FollowAutoGo != 2)
+        {
+            FollowAutoGo = 1;
+            msg << "Automatic Follow Distance is now ON";
+            SendWhisper(msg.str(),fromPlayer);
+            return;
+        }
+        else
+        {
+            FollowAutoGo = 0;
+            msg << "Automatic Follow Distance is now OFF";
+            SendWhisper(msg.str(),fromPlayer);
+        }
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+        return;
+    }
+    if (ExtractCommand("reset", text)) // switch to reset follow distance
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
+            return;
+        }
+        DistOverRide = 0; // this resets follow distance to config default
+        IsUpOrDown = 0;
+        std::ostringstream msg;
+        gTempDist = 1;
+        gTempDist2 = 2;
+        msg << "Bit crowded isn't it?";
+        SendWhisper(msg.str(),fromPlayer);
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+        return;
+    }
+    if (ExtractCommand("far", text)) // switch to increment follow distance
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
+            return;
+        }
+        DistOverRide = (DistOverRide + 1); // this increments follow distance
+        std::ostringstream msg;
+        msg << "Increasing My follow distance";
+        SendWhisper(msg.str(),fromPlayer);
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+        return;
+    }
+    if (ExtractCommand("near", text)) // switch to increment follow distance
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
+            return;
+        }
+        if (DistOverRide > 0)
+            DistOverRide = (DistOverRide - 1); // this increments follow distance,
+
+        std::ostringstream msg;
+        if (DistOverRide == 0)
+        {
+            IsUpOrDown = 0;
+            DistOverRide = 0;
+            gTempDist = 1;
+            gTempDist2 = 2;
+            msg << "I'm NOT getting any closer than this";
+        }
+        if (DistOverRide != 0)
+            msg << "Decreasing My follow distance";
+        SendWhisper(msg.str(),fromPlayer);
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+        return;
+    }
+    if (text != "")
+    {
+        SendWhisper("see help for details on using follow.", fromPlayer);
+        return;
+    }
+
+    SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+}
+
+void PlayerbotAI::_HandleCommandStay(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("stay cannot have a subcommand.", fromPlayer);
+        return;
+    }
+    SetMovementOrder(MOVEMENT_STAY);
+}
+
+void PlayerbotAI::_HandleCommandAttack(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("attack cannot have a subcommand.", fromPlayer);
+        return;
+    }
+    ObjectGuid attackOnGuid = fromPlayer.GetTarget();
+    if (attackOnGuid)
+    {
+        if (Unit * thingToAttack = ObjectAccessor::GetUnit(*m_bot, attackOnGuid))
+            if (!m_bot->IsFriendlyTo(thingToAttack) && m_bot->IsWithinLOSInMap(thingToAttack))
+                GetCombatTarget(thingToAttack);
+    }
+    else
+    {
+        SendWhisper("No target is selected.", fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+}
+
+void PlayerbotAI::_HandleCommandCast(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+    {
+        SendWhisper("cast must be used with a single spell link (shift + click the spell).", fromPlayer);
+        return;
+    }
+
+    std::string spellStr = text;
+    uint32 spellId = uint32(atol(spellStr.c_str()));
+
+    // try and get spell ID by name
+    if (spellId == 0)
+    {
+        spellId = getSpellId(spellStr.c_str(), true);
+
+        // try link if text NOT (spellid OR spellname)
+        if (spellId == 0)
+            extractSpellId(text, spellId);
+    }
+
+    if (m_bot->HasAura(spellId))
+    {
+        m_bot->RemoveAurasDueToSpell(spellId, m_bot->GetGUID());
+        return;
+    }
+
+    ObjectGuid castOnGuid = fromPlayer.GetTarget();
+    if (spellId != 0 && m_bot->HasSpell(spellId))
+    {
+        m_spellIdCommand = spellId;
+        if (castOnGuid)
+            m_targetGuidCommand = castOnGuid;
+        else
+            m_targetGuidCommand = m_bot->GetGUID();
+    }
+}
+
+// _HandleCommandSell: Handle selling items
+// sell [Item Link][Item Link] .. -- Sells bot(s) items from inventory
+void PlayerbotAI::_HandleCommandSell(std::string &text, Player &fromPlayer)
+{
+    if (ExtractCommand("all", text)) // switch to auto sell low level white items
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'sell all'", fromPlayer);
+            return;
+        }
+        SellWhite = 1; // this gets reset once sale is complete.  for testing purposes
+        std::ostringstream msg;
+        msg << "I will sell all my low level normal items the next time you sell.";
+        SendWhisper(msg.str(),fromPlayer);
+        return;
+    }
+    if (text == "")
+    {
+        SendWhisper("sell must be used with one or more item links (shift + click the item).", fromPlayer);
+        return;
+    }
+
+    enum NPCFlags VENDOR_MASK = (enum NPCFlags) (UNIT_NPC_FLAG_VENDOR
+                                                 | UNIT_NPC_FLAG_VENDOR_AMMO
+                                                 | UNIT_NPC_FLAG_VENDOR_FOOD
+                                                 | UNIT_NPC_FLAG_VENDOR_POISON
+                                                 | UNIT_NPC_FLAG_VENDOR_REAGENT);
+
+    std::list<uint32> itemIds;
+    extractItemIds(text, itemIds);
+    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(SELL_ITEMS, *it));
+    m_findNPC.push_back(VENDOR_MASK);
+}
+
+// _HandleCommandBuy: Handle buying items
+// buy [Item Link][Item Link] .. -- Buys items from vendor
+void PlayerbotAI::_HandleCommandBuy(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+    {
+        SendWhisper("buy must be used with one or more item links (shift + click the item).", fromPlayer);
+        return;
+    }
+
+    ObjectGuid vendorguid = fromPlayer.GetTarget();
+    if (!vendorguid)
+    {
+        SendWhisper("No vendor is selected.", fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+        return;
+    }
+
+    std::list<uint32> itemIds;
+    extractItemIds(text, itemIds);
+    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+        Buy(vendorguid, *it);
+}
+
+// _HandleCommandDrop: Handle dropping items
+// drop [Item Link][Item Link] .. -- Drops item(s) from bot's inventory
+void PlayerbotAI::_HandleCommandDrop(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+    {
+        SendWhisper("drop must be used with one or more item links (shift + click the item).", fromPlayer);
+        return;
+    }
+
+    std::ostringstream report;
+    std::list<uint32> itemIds;
+    extractItemIds(text, itemIds);
+    report << "Dropped ";
+    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+        report << DropItem(*it);
+
+    if (report.str() == "Dropped ")
+    {
+        SendWhisper("No items were dropped. It would appear something has gone hinky.", fromPlayer);
+        return;
+    }
+
+    report << ".";
+    SendWhisper(report.str(), fromPlayer);
+}
+
+// _HandleCommandRepair: Handle repair items
+// repair  all                      -- repair all bot(s) items
+// repair [Item Link][Item Link] .. -- repair select bot(s) items
+void PlayerbotAI::_HandleCommandRepair(std::string &text, Player &fromPlayer)
+{
+    if (ExtractCommand("all", text))
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'repair all'", fromPlayer);
+            return;
+        }
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(REPAIR_ITEMS, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_REPAIR);
+        return;
+    }
+
+    std::list<uint32> itemIds;
+    extractItemIds(text, itemIds);
+
+    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); it++)
+    {
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(REPAIR_ITEMS, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_REPAIR);
+    }
+}
+
+// _HandleCommandAuction: Handle auctions:
+// auction                                        -- Lists bot(s) active auctions.
+// auction add [Item Link][Item Link] ..          -- Create bot(s) active auction.
+// auction remove [Auction Link][Auction Link] .. -- Cancel bot(s) active auction. ([Auction Link] from auction)
+void PlayerbotAI::_HandleCommandAuction(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER); // list all bot auctions
+    else if (ExtractCommand("add", text))
+    {
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(ADD_AUCTION, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER);
+    }
+    else if (ExtractCommand("remove", text))
+    {
+        std::list<uint32> auctionIds;
+        extractAuctionIds(text, auctionIds);
+        for (std::list<uint32>::iterator it = auctionIds.begin(); it != auctionIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(REMOVE_AUCTION, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER);
+    }
+    else
+        SendWhisper("I don't understand what you're trying to do", fromPlayer);
+}
+
+void PlayerbotAI::_HandleCommandMail(std::string &text, Player &fromPlayer)
+{
+    ChatHandler ch(fromPlayer.GetSession());
+
+    if (text == "")
+    {
+        ch.SendSysMessage("Syntax: mail <inbox [Mailbox] | getcash [mailid].. | getitem [mailid].. | delete [mailid]..>");
+        return;
+    }
+    else if (ExtractCommand("inbox", text))
+    {
+        uint32 mail_count = 0;
+        extractGOinfo(text, m_lootTargets);
+
+        if (m_lootTargets.empty())
+        {
+            ch.SendSysMessage("Syntax: mail <inbox [Mailbox]>");
+            return;
+        }
+
+        ObjectGuid m_mailboxGuid = m_lootTargets.front();
+        m_lootTargets.pop_front();
+        m_lootTargets.clear();
+
+        if (!m_bot->GetGameObjectIfCanInteractWith(m_mailboxGuid, GAMEOBJECT_TYPE_MAILBOX))
+        {
+            Announce(CANT_USE_TOO_FAR);
+            return;
+        }
+
+        TellMaster("Inbox:\n");
+
+        for (PlayerMails::iterator itr = m_bot->GetMailBegin(); itr != m_bot->GetMailEnd(); ++itr)
+        {
+            std::ostringstream msg;
+            ++mail_count;
+
+            msg << "|cffffcccc|Hmail:" << (*itr)->messageID << "|h[" << (*itr)->messageID << "]|h|r ";
+
+            switch ((*itr)->messageType)
+            {
+                case MAIL_NORMAL:
+                {
+                    msg << "|cffffffff"; // white
+                    if ((*itr)->subject != "")
+                        msg << "Subject: " << (*itr)->subject << "\n";
+
+                    if ((*itr)->body != "")
+                        msg << (*itr)->body << "\n";
+                    break;
+                }
+                case MAIL_CREATURE:
+                {
+                    msg << "|cffccffccMAIL_CREATURE\n"; // green
+                    break;
+                }
+                case MAIL_GAMEOBJECT:
+                {
+                    msg << "|cffccffccMAIL_GAMEOBJECT\n"; // green
+                    break;
+                }
+                case MAIL_AUCTION:
+                {
+                    msg << "|cffccffff"; // blue
+                    msg << AuctionResult((*itr)->subject, (*itr)->body) << "\n";
+                    break;
+                }
+                case 1: // MAIL_ITEM:
+                {
+                    msg << "|cffccffccMAIL_ITEM\n"; // green
+                    break;
+                }
+            }
+
+            if ((*itr)->money)
+                msg << "[To Collect: " << Cash((*itr)->money) << " ]\n";
+
+            uint8 item_count = (*itr)->items.size(); // max count is MAX_MAIL_ITEMS (12)
+            if (item_count > 0)
+            {
+                msg << "Items: ";
+                for (uint8 i = 0; i < item_count; ++i)
+                {
+                    Item *item = m_bot->GetMItem((*itr)->items[i].item_guid);
+                    if (item)
+                        MakeItemLink(item, msg, true);
+                }
+            }
+            msg << "\n";
+            ch.SendSysMessage(msg.str().c_str());
+        }
+
+        if (mail_count == 0)
+            ch.SendSysMessage("|cff009900My inbox is empty.");
+    }
+    else if (ExtractCommand("getcash", text))
+    {
+        std::ostringstream msg;
+        std::list<uint32> mailIds;
+        extractMailIds(text, mailIds);
+        uint32 total = 0;
+
+        if (mailIds.empty())
+        {
+            ch.SendSysMessage("Syntax: mail <getcash [mailId]..>");
+            return;
+        }
+
+        for (std::list<uint32>::iterator it = mailIds.begin(); it != mailIds.end(); ++it)
+        {
+            Mail* m = m_bot->GetMail(*it);
+            if (!m || m->state == MAIL_STATE_DELETED || m->deliver_time > time(NULL))
+            {
+                m_bot->SendMailResult(*it, MAIL_MONEY_TAKEN, MAIL_ERR_INTERNAL_ERROR);
+                return;
+            }
+
+            m_bot->SendMailResult(*it, MAIL_MONEY_TAKEN, MAIL_OK);
+            m_bot->ModifyMoney(m->money);
+            total += m->money;
+            m->money = 0;
+            m->state = MAIL_STATE_CHANGED;
+            m_bot->m_mailsUpdated = true;
+            m_bot->UpdateMail();
+        }
+        if (total > 0)
+        {
+            msg << "|cff009900" << "I received: |r" << Cash(total);
+            ch.SendSysMessage(msg.str().c_str());
+        }
+    }
+    else if (ExtractCommand("getitem", text))
+    {
+        std::list<uint32> mailIds;
+        extractMailIds(text, mailIds);
+
+        if (mailIds.empty())
+        {
+            ch.SendSysMessage("Syntax: mail <getitem [mailId]..>");
+            return;
+        }
+
+        for (std::list<uint32>::iterator it = mailIds.begin(); it != mailIds.end(); it++)
+        {
+            Mail* m = m_bot->GetMail(*it);
+            if (!m || m->state == MAIL_STATE_DELETED || m->deliver_time > time(NULL))
+            {
+                m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_ERR_INTERNAL_ERROR);
+                return;
+            }
+
+            // prevent cheating with skip client money check
+            if (m_bot->GetMoney() < m->COD)
+            {
+                m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_ERR_NOT_ENOUGH_MONEY);
+                return;
+            }
+
+            if (m->HasItems())
+            {
+                bool has_items = true;
+                std::ostringstream msg;
+
+                msg << "|cff009900" << "I received item: |r";
+                for (MailItemInfoVec::const_iterator itr = m->items.begin(); itr != m->items.end(); )
+                {
+                    has_items = true;
+                    Item *item = m_bot->GetMItem(itr->item_guid);
+                    if (!item)
+                    {
+                        ch.SendSysMessage("item not found");
+                        return;
+                    }
+
+                    ItemPosCountVec dest;
+
+                    InventoryResult res = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, item, false);
+                    if (res == EQUIP_ERR_OK)
+                    {
+                        m->removedItems.push_back(itr->item_guid);
+
+                        if (m->COD > 0)  // if there is COD, take COD money from player and send them to sender by mail
+                        {
+                            ObjectGuid sender_guid = ObjectGuid(HighGuid::Player, m->sender);
+                            Player *sender = ObjectAccessor::FindPlayer(sender_guid);
+
+                            uint32 sender_accId = 0;
+/*
+                            if (m_master->GetSession()->GetSecurity() > SEC_PLAYER && sWorld->getBoolConfig(CONFIG_GM_LOG_TRADE))
+                            {
+                                std::string sender_name;
+                                if (sender)
+                                {
+                                    sender_accId = sender->GetSession()->GetAccountId();
+                                    sender_name = sender->GetName();
+                                }
+                                else if (sender_guid)
+                                {
+                                    // can be calculated early
+                                    sender_accId = sObjectMgr->GetPlayerAccountIdByGUID(sender_guid);
+
+                                    if (!sObjectMgr->GetPlayerNameByGUID(sender_guid, sender_name))
+                                        sender_name = sObjectMgr->GetTrinityStringForDBCLocale(LANG_UNKNOWN);
+                                }
+                                //sLog->outCommand(m_master->GetSession()->GetAccountId(), "GM %s (Account: %u) receive mail item: %s (Entry: %u Count: %u) and send COD money: %u to player: %s (Account: %u)",
+                                                //m_master->GetSession()->GetPlayerName(), m_master->GetSession()->GetAccountId(), item->GetTemplate()->Name1, item->GetEntry(), item->GetCount(), m->COD, sender_name.c_str(), sender_accId);
+                            }
+                            else */if (!sender)
+                                sender_accId = sObjectMgr->GetPlayerAccountIdByGUID(sender_guid);
+
+                            // check player existence
+                            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                            if (sender || sender_accId)
+                                MailDraft(m->subject, "")
+                                .AddMoney(m->COD)
+                                .SendMailTo(trans, MailReceiver(sender, sender_guid), m_bot, MAIL_CHECK_MASK_COD_PAYMENT);
+                            CharacterDatabase.CommitTransaction(trans);
+                            m_bot->ModifyMoney(-int32(m->COD));
+                        }
+                        m->COD = 0;
+                        m->state = MAIL_STATE_CHANGED;
+                        m_bot->m_mailsUpdated = true;
+                        m_bot->RemoveMItem(item->GetGUID().GetCounter());
+
+                        uint32 count = item->GetCount(); // save counts before store and possible merge with deleting
+                        m_bot->MoveItemToInventory(dest, item, true);
+                        m_bot->UpdateMail();
+                        m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_OK, 0, itr->item_guid, count);
+                        if (m->RemoveItem(itr->item_guid))
+                        {
+                            MakeItemLink(item, msg, true);
+                            has_items = false;
+                        }
+                    }
+                    else
+                        m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_ERR_EQUIP_ERROR, res);
+                }
+
+                if (!has_items)
+                {
+                    //SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                    CharacterDatabase.PExecute("UPDATE mail SET has_items = 0 WHERE id = %u", *it);
+                    //CharacterDatabase.CommitTransaction(trans);
+                }
+                msg << "\n";
+                ch.SendSysMessage(msg.str().c_str());
+            }
+        }
+    }
+    else if (ExtractCommand("delete", text))
+    {
+        std::ostringstream msg;
+        std::list<uint32> mailIds;
+        extractMailIds(text, mailIds);
+
+        if (mailIds.empty())
+        {
+            ch.SendSysMessage("Syntax: mail <delete [mailId]..>");
+            return;
+        }
+
+        msg << "|cff009900Mail ";
+        for (std::list<uint32>::iterator it = mailIds.begin(); it != mailIds.end(); ++it)
+        {
+            m_bot->m_mailsUpdated = true;
+
+            if (Mail * m = m_bot->GetMail(*it))
+            {
+                // delete shouldn't show up for COD mails
+                if (m->COD)
+                {
+                    m_bot->SendMailResult(*it, MAIL_DELETED, MAIL_ERR_INTERNAL_ERROR);
+                    return;
+                }
+                m->state = MAIL_STATE_DELETED;
+            }
+
+            m_bot->SendMailResult(*it, MAIL_DELETED, MAIL_OK);
+            //CharacterDatabase.BeginTransaction();
+            CharacterDatabase.PExecute("DELETE FROM mail WHERE id = '%u'", *it);
+            CharacterDatabase.PExecute("DELETE FROM mail_items WHERE mail_id = '%u'", *it);
+            //CharacterDatabase.CommitTransaction();
+            m_bot->RemoveMail(*it);
+            msg << "|cffffcccc|h[" << *it << "]|h|r";
+        }
+        msg << "|cff009900 has been deleted..";
+        ch.SendSysMessage(msg.str().c_str());
+    }
+}
+
+// _HandleCommandBank: Handle bank:
+// bank                                        -- Lists bot(s) bank balance.
+// bank deposit [Item Link][Item Link] ..      -- Deposit item(s) in bank.
+// bank withdraw [Item Link][Item Link] ..     -- Withdraw item(s) from bank. ([Item Link] from bank)
+void PlayerbotAI::_HandleCommandBank(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER); // list all bot balance
+    else if (ExtractCommand("deposit", text))
+    {
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(BANK_DEPOSIT, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER);
+    }
+    else if (ExtractCommand("withdraw", text))
+    {
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(BANK_WITHDRAW, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER);
+    }
+    else
+        SendWhisper("I don't understand what you're trying to do", fromPlayer);
+}
+
+// _HandleCommandTalent: Handle talents & glyphs:
+// talent                           -- Lists bot(s) active talents [TALENT LINK] & glyphs [GLYPH LINK], unspent points & cost to reset
+// talent learn [TALENT LINK] ..    -- Learn selected talent from bot client 'inspect' dialog -> 'talent' tab or from talent command (shift click icon/link)
+// talent reset                     -- Resets all talents
+// talent spec                      -- Lists various talentspecs for this bot's class
+// talent spec #                    -- Sets talent spec # as active talentspec
+void PlayerbotAI::_HandleCommandTalent(std::string &text, Player &fromPlayer)
+{
+    std::ostringstream out;
+    if (ExtractCommand("learn", text))
+    {
+        std::list<talentPair>talents;
+        extractTalentIds(text, talents);
+
+        for (std::list<talentPair>::iterator itr = talents.begin(); itr != talents.end(); ++itr)
+        {
+            uint32 talentid = itr->first;
+            uint32 rank = itr->second;
+
+            m_bot->LearnTalent(talentid, ++rank);
+            m_bot->SendTalentsInfoData(false);
+            InspectUpdate();
+        }
+
+        m_bot->MakeTalentGlyphLink(out);
+        SendWhisper(out.str(), fromPlayer);
+    }
+    else if (ExtractCommand("reset", text))
+    {
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(RESET_TALENTS, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_TRAINER_CLASS);
+    }
+    else if (ExtractCommand("spec", text))
+    {
+        if (0 == GetTalentSpecsAmount())
+        {
+            //SendWhisper("Database does not contain any Talent Specs (for any classes).", fromPlayer);
+            SendWhisper("spec subcommand is disabled. Sorry", fromPlayer);
+            return;
+        }
+        if (text.size() == 0) // no spec chosen nor other subcommand
+        {
+            std::list<TalentSpec> classSpecs = GetTalentSpecs(long(m_bot->getClass()));
+            std::list<TalentSpec>::iterator it;
+            int count = 0;
+
+            SendWhisper("Please select a talent spec to activate (reply 'talent spec #'):", fromPlayer);
+            for (it = classSpecs.begin(); it != classSpecs.end(); it++)
+            {
+                count++;
+
+                std::ostringstream oss;
+                oss << count << ". " << it->specName;
+                SendWhisper(oss.str(), fromPlayer);
+            }
+            if (count == 0)
+            {
+                std::ostringstream oss;
+                oss << "Error: No TalentSpecs listed. Specs retrieved from DB for this class: %u" << m_bot->getClass();
+                SendWhisper(oss.str(), fromPlayer);
+            }
+        }
+        else
+        {
+            uint32 chosenSpec = strtoul(text.c_str(), NULL, 0); // non-int returns 0; too big returns UINT MAX (or somesuch)
+
+            // Warning: also catches non-int sub2command's - e.g. 'talent spec foobar'
+            if (0 == chosenSpec)
+            {
+                ClearActiveTalentSpec();
+                SendWhisper("The talent spec has been cleared.", fromPlayer);
+            }
+            else if (chosenSpec > GetTalentSpecsAmount(long(m_bot->getClass())))
+                SendWhisper("The talent spec you have chosen is invalid. Please select one from the valid range (reply 'talent spec' for options).", fromPlayer);
+            else
+            {
+                TalentSpec ts = GetTalentSpec(long(m_bot->getClass()), chosenSpec);
+
+                // no use setting it to an invalid (and probably - hopefully - empty) TalentSpec
+                if (0 != ts.specClass && TSP_NONE != ts.specPurpose)
+                {
+                    out << "Activated talent spec: " << chosenSpec << ". " << ts.specName;
+                    SendWhisper(out.str(), fromPlayer);
+                    SetActiveTalentSpec(ts);
+                    if (!ApplyActiveTalentSpec())
+                        SendWhisper("The talent spec has been set active but could not be applied. It appears something has gone awry.", fromPlayer);
+                    //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Could set TalentSpec but could not apply it - 'talent spec #': Class: %i; chosenSpec: %li", (long)m_bot->getClass(), chosenSpec);
+                    InspectUpdate();
+                }
+                else
+                {
+                    SendWhisper("An error has occured. Please let a Game Master know. This error has been logged.", fromPlayer);
+                    //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Could not GetTalentSpec to set & apply - 'talent spec #': Class: %i; chosenSpec: %li", (long) m_bot->getClass(), chosenSpec);
+                }
+            }
+        }
+    }
+    // no valid subcommand found for command 'talent'
+    else
+    {
+        uint32 gold = uint32(m_bot->ResetTalentsCost() / 10000);
+
+        if (gold > 0)
+            out << "Cost to reset all Talents is " << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+
+        m_bot->MakeTalentGlyphLink(out);
+        SendWhisper(out.str(), fromPlayer);
+    }
+}
+
+void PlayerbotAI::_HandleCommandProcess(std::string &text, Player &fromPlayer)
+{
+    uint32 spellId;
+
+    if (ExtractCommand("disenchant", text, true)) // true -> "process disenchant" OR "process d"
+    {
+        if (m_bot->HasSkill(SKILL_ENCHANTING))
+            spellId = DISENCHANTING_1;
+        else
+        {
+            SendWhisper("|cffff0000I can't disenchant, I don't have the skill.", fromPlayer);
+            return;
+        }
+    }
+    else if (ExtractCommand("mill", text, true)) // true -> "process mill" OR "process m"
+    {
+        if (m_bot->HasSkill(SKILL_INSCRIPTION))
+            spellId = MILLING_1;
+        else
+        {
+            SendWhisper("|cffff0000I can't mill, I don't have the skill.", fromPlayer);
+            return;
+        }
+    }
+    else if (ExtractCommand("prospect", text, true)) // true -> "process prospect" OR "process p"
+    {
+        if (m_bot->HasSkill(SKILL_JEWELCRAFTING) && m_bot->GetPureSkillValue(SKILL_JEWELCRAFTING) >= 20)
+            spellId = PROSPECTING_1;
+        else
+        {
+            SendWhisper("|cffff0000I can't prospect, I don't have the skill.", fromPlayer);
+            return;
+        }
+    }
+    else
+        return;
+
+    std::list<uint32> itemIds;
+    std::list<Item*> itemList;
+    extractItemIds(text, itemIds);
+    findItemsInInv(itemIds, itemList);
+
+    if (itemList.empty())
+    {
+        SendWhisper("|cffff0000I can't process that!", fromPlayer);
+        return;
+    }
+
+    Item* reagent = itemList.back();
+    itemList.pop_back();
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return;
+
+    if (reagent)
+    {
+        SpellCastTargets targets;
+        m_itemTarget = reagent->GetTemplate()->ItemId;
+        targets.SetItemTarget(reagent);
+        Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+        spell->prepare(&targets);
+    }
+}
+
+void PlayerbotAI::_HandleCommandUse(std::string &text, Player &fromPlayer)
+{
+    std::list<uint32> itemIds;
+    std::list<Item*> itemList;
+    extractItemIds(text, itemIds);
+    findItemsInInv(itemIds, itemList);
+
+    if (itemList.empty())
+    {
+        SendWhisper("|cffff0000I can't use that!", fromPlayer);
+        return;
+    }
+
+    Item* tool = itemList.back();
+    itemList.pop_back();
+    if (tool)
+    {
+        // set target
+        Unit* unit = ObjectAccessor::GetUnit(*m_bot, fromPlayer.GetTarget());
+        findItemsInEquip(itemIds, itemList);
+        extractGOinfo(text, m_lootTargets);
+        // sLog->outDebug(LOG_FILTER_NONE, "tool (%s)",tool->GetTemplate()->Name1);
+
+        if (!itemList.empty())
+        {
+            Item* itarget = itemList.back();
+            if (itarget)
+            {
+                // sLog->outDebug(LOG_FILTER_NONE, "target (%s)",itarget->GetTemplate()->Name1);
+                UseItem(tool, _findItemSlot(itarget)); // on equipped item
+                SetState(BOTSTATE_ENCHANT);
+                SetIgnoreUpdateTime(1);
+            }
+        }
+        else if (!m_lootTargets.empty())
+        {
+            ObjectGuid gotarget = m_lootTargets.front();
+            m_lootTargets.pop_front();
+
+            GameObject *go = m_bot->GetMap()->GetGameObject(gotarget);
+            if (go)
+                // sLog->outDebug(LOG_FILTER_NONE, "tool (%s) on target gameobject (%s)",tool->GetTemplate()->Name1,go->GetGOInfo()->name);
+                UseItem(tool, TARGET_FLAG_GAMEOBJECT, gotarget); // on gameobject
+        }
+        else if (unit)
+            // sLog->outDebug(LOG_FILTER_NONE, "tool (%s) on selected target unit",tool->GetTemplate()->Name1);
+            UseItem(tool, unit); // on unit
+        else
+            // sLog->outDebug(LOG_FILTER_NONE, "tool (%s) on self",tool->GetTemplate()->Name1);
+            UseItem(tool); // on self
+    }
+    return;
+}
+
+void PlayerbotAI::_HandleCommandAutoEquip(std::string &text, Player &fromPlayer)
+{
+    std::ostringstream msg;
+    if (ExtractCommand("now", text, true)) // run autoequip cycle right now
+    {
+        msg << "Running Auto Equip cycle One time. My current setting is" << (AutoEquipPlug ? "ON" : "OFF");
+        SendWhisper(msg.str(),fromPlayer);
+        if (AutoEquipPlug == 0)
+            AutoEquipPlug = 2;
+        Player* const bot = GetPlayerBot();
+        AutoUpgradeEquipment(*bot);
+        return;
+    }
+    else if (ExtractCommand("on", text, true)) // true -> "autoequip on"
+    {
+        AutoEquipPlug = 1;
+        msg << "AutoEquip is now ON";
+        SendWhisper(msg.str(),fromPlayer);
+        return;
+    }
+    else if (ExtractCommand("off", text, true)) // true -> "autoequip off"
+    {
+        AutoEquipPlug = 0;
+        msg << "AutoEquip is now OFF";
+        SendWhisper(msg.str(),fromPlayer);
+        return;
+    }
+    if (AutoEquipPlug != 1)
+        AutoEquipPlug = 1;
+    else
+        AutoEquipPlug = 0;
+    msg << "AutoEquip is now " << (AutoEquipPlug ? "ON" : "OFF");
+    SendWhisper(msg.str(),fromPlayer);
+}
+
+void PlayerbotAI::_HandleCommandEquip(std::string &text, Player & /*fromPlayer*/)
+{
+    std::list<uint32> itemIds;
+    std::list<Item*> itemList;
+    extractItemIds(text, itemIds);
+    findItemsInInv(itemIds, itemList);
+    for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+        EquipItem(*it);
+    InspectUpdate();
+    SendNotEquipList(*m_bot);
+}
+
+void PlayerbotAI::_HandleCommandFind(std::string &text, Player & /*fromPlayer*/)
+{
+    if (text == "")
+        return;
+    extractGOinfo(text, m_lootTargets);
+
+    if (m_lootTargets.empty())
+        return;
+
+    m_lootCurrent = m_lootTargets.front();
+    m_lootTargets.pop_front();
+
+    GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+    if (!go)
+    {
+        m_lootTargets.clear();
+        m_lootCurrent = ObjectGuid::Empty;
+        return;
+    }
+
+    SetMovementOrder(MOVEMENT_STAY);
+    m_bot->GetMotionMaster()->MovePoint(go->GetMapId(), go->GetPositionX(), go->GetPositionY(), go->GetPositionZ());
+    m_lootTargets.clear();
+    m_lootCurrent = ObjectGuid::Empty;
+}
+
+void PlayerbotAI::_HandleCommandGet(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        extractGOinfo(text, m_lootTargets);
+        SetState(BOTSTATE_LOOTING);
+        return;
+    }
+
+    // get a selected lootable corpse
+    ObjectGuid getOnGuid = fromPlayer.GetTarget();
+    if (getOnGuid)
+    {
+        Creature *c = m_bot->GetMap()->GetCreature(getOnGuid);
+        if (!c)
+            return;
+
+        uint32 skillId = 0;
+        if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+            skillId = c->GetCreatureTemplate()->GetRequiredLootSkill();
+
+        if (c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) ||
+            (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && m_bot->HasSkill(skillId)))
+        {
+            m_lootTargets.push_back(getOnGuid);
+            SetState(BOTSTATE_LOOTING);
+        }
+        else
+            SendWhisper("Target is not lootable by me.", fromPlayer);
+    }
+    else
+    {
+        SendWhisper("No target is selected.", fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+}
+
+void PlayerbotAI::_HandleCommandCollect(std::string &text, Player &fromPlayer)
+{
+    while (text.size() > 0)
+    {
+        if (ExtractCommand("combat", text))
+            SetCollectFlag(COLLECT_FLAG_COMBAT);
+        else if (ExtractCommand("loot", text))
+            SetCollectFlag(COLLECT_FLAG_LOOT);
+        else if (ExtractCommand("quest", text))
+            SetCollectFlag(COLLECT_FLAG_QUEST);
+        else if (ExtractCommand("profession", text) || ExtractCommand("skill", text))
+            SetCollectFlag(COLLECT_FLAG_PROFESSION);
+        else if (ExtractCommand("skin", text) && m_bot->HasSkill(SKILL_SKINNING)) // removes skin even if bot does not have skill
+            SetCollectFlag(COLLECT_FLAG_SKIN);
+        else if (ExtractCommand("objects", text) || ExtractCommand("nearby", text))
+        {
+            SetCollectFlag(COLLECT_FLAG_NEAROBJECT);
+            if (!HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+                m_collectObjects.clear();
+        }
+        else if (ExtractCommand("distance:", text))
+        {
+            uint32 distance;
+            sscanf(text.c_str(), "distance:%u", &distance);
+            if (distance > 0 && distance <= m_confCollectDistanceMax)
+            {
+                m_confCollectDistance = distance;
+                std::ostringstream oss;
+                oss << "I will now collect items within " << m_confCollectDistance << " yards.";
+                SendWhisper(oss.str(), fromPlayer);
+            }
+            else
+            {
+                m_confCollectDistance = m_confCollectDistanceMax;
+                std::stringstream oss;
+                oss << "I will now collect items within " << m_confCollectDistanceMax << " yards. " << distance << " yards is just too far away.",
+                SendWhisper(oss.str(), fromPlayer);
+            }
+        }
+        else if (ExtractCommand("none", text) || ExtractCommand("nothing", text))
+        {
+            m_collectionFlags = 0;
+            m_collectObjects.clear();
+            break;  // because none is an exclusive choice
+        }
+        else
+        {
+            std::ostringstream oss;
+            oss << "Collect <collectable(s)>: none | distance:<1-" << m_confCollectDistanceMax << ">, combat, loot, quest, profession, objects";
+            if (m_bot->HasSkill(SKILL_SKINNING))
+                oss << ", skin";
+            // TODO: perhaps change the command syntax, this way may be lacking in ease of use
+            SendWhisper(oss.str(), fromPlayer);
+            break;
+        }
+    }
+
+    std::string collset = "";
+    if (HasCollectFlag(COLLECT_FLAG_LOOT))
+        collset += ", all loot";
+    if (HasCollectFlag(COLLECT_FLAG_PROFESSION))
+        collset += ", profession";
+    if (HasCollectFlag(COLLECT_FLAG_QUEST))
+        collset += ", quest";
+    if (HasCollectFlag(COLLECT_FLAG_SKIN))
+        collset += ", skin";
+    if (collset.length() > 1)
+    {
+        if (HasCollectFlag(COLLECT_FLAG_COMBAT))
+            collset += " items after combat";
+        else
+            collset += " items";
+    }
+
+    if (HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+    {
+        if (collset.length() > 1)
+            collset += " and ";
+        else
+            collset += " ";    // padding for substr
+        collset += "nearby objects (";
+        if (!m_collectObjects.empty())
+        {
+            std::string strobjects = "";
+            for (BotEntryList::iterator itr = m_collectObjects.begin(); itr != m_collectObjects.end(); ++itr)
+            {
+                uint32 objectentry = *(itr);
+                GameObjectTemplate const * gInfo = sObjectMgr->GetGameObjectTemplate(objectentry);
+                strobjects += ", ";
+                strobjects += gInfo->name;
+            }
+            collset += strobjects.substr(2);
+        }
+        else
+            collset += "use survey and get to set";
+        collset += ")";
+    }
+
+    if (collset.length() > 1)
+        SendWhisper("I'm collecting " + collset.substr(2), fromPlayer);
+    else
+        SendWhisper("I'm collecting nothing.", fromPlayer);
+}
+
+void PlayerbotAI::_HandleCommandEnchant(std::string &text, Player &fromPlayer)
+{
+    // sLog->outDebug(LOG_FILTER_NONE, "Enchant (%s)",text.c_str());
+
+    if (!m_bot->HasSkill(SKILL_ENCHANTING))
+    {
+        SendWhisper("|cffff0000I can't enchant, I don't have the skill.", fromPlayer);
+        return;
+    }
+
+    if (text.size() > 0)
+    {
+        uint32 spellId;
+        extractSpellId(text, spellId);
+
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!spellInfo)
+            return;
+
+        std::list<uint32> itemIds;
+        std::list<Item*> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInEquip(itemIds, itemList);
+        findItemsInInv(itemIds, itemList);
+
+        if (itemList.empty())
+        {
+            SendWhisper("|cffff0000I can't enchant that!", fromPlayer);
+            return;
+        }
+
+        Item* iTarget = itemList.back();
+        itemList.pop_back();
+
+        if (iTarget)
+        {
+            SpellCastTargets targets;
+            targets.SetItemTarget(iTarget);
+            Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+            spell->prepare(&targets);
+            SetState(BOTSTATE_ENCHANT);
+            SetIgnoreUpdateTime(1);
+        }
+        return;
+    }
+    else
+    {
+        std::ostringstream msg;
+        uint32 charges;
+        uint32 linkcount = 0;
+
+        m_spellsToLearn.clear();
+        m_bot->skill(m_spellsToLearn);
+        SendWhisper("I can enchant:\n", fromPlayer);
+        ChatHandler ch(fromPlayer.GetSession());
+        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+        {
+            SkillLineEntry const *SkillLine = sSkillLineStore.LookupEntry(*it);
+
+            if (SkillLine->categoryId == SKILL_CATEGORY_PROFESSION && *it == SKILL_ENCHANTING)
+                for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+                {
+                    SkillLineAbilityEntry const *SkillAbility = sSkillLineAbilityStore.LookupEntry(j);
+                    if (!SkillAbility)
+                        continue;
+
+                    SpellEntry const* spellInfo = sSpellStore.LookupEntry(SkillAbility->spellId);
+                    if (!spellInfo)
+                        continue;
+
+                    if (IsPrimaryProfessionSkill(*it) && spellInfo->Effect[0] != SPELL_EFFECT_ENCHANT_ITEM)
+                        continue;
+
+                    if (SkillAbility->skillId == *it && m_bot->HasSpell(SkillAbility->spellId) && SkillAbility->forward_spellid == 0 && ((SkillAbility->classmask & m_bot->getClassMask()) == 0))
+                    {
+                        MakeSpellLink(spellInfo, msg);
+                        ++linkcount;
+                        if ((charges = GetSpellCharges(SkillAbility->spellId)) > 0)
+                            msg << "[" << charges << "]";
+                        if (linkcount >= 10)
+                        {
+                            ch.SendSysMessage(msg.str().c_str());
+                            linkcount = 0;
+                            msg.str("");
+                        }
+                    }
+                }
+        }
+        m_noToolList.unique();
+        for (std::list<uint32>::iterator it = m_noToolList.begin(); it != m_noToolList.end(); it++)
+            HasTool(*it);
+        ch.SendSysMessage(msg.str().c_str());
+        m_noToolList.clear();
+        m_spellsToLearn.clear();
+    }
+}
+
+void PlayerbotAI::_HandleCommandCraft(std::string &text, Player &fromPlayer)
+{
+    // sLog->outDebug(LOG_FILTER_NONE, "Craft (%s)",text.c_str());
+
+    std::ostringstream msg;
+    uint32 charges;
+    uint32 skill;
+    int32 category;
+    uint32 linkcount = 0;
+
+    if (ExtractCommand("alchemy", text, true)) // true -> "craft alchemy" OR "craft a"
+    {
+        if (m_bot->HasSkill(SKILL_ALCHEMY))
+        {
+            skill = SKILL_ALCHEMY;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("blacksmithing", text, true)) // true -> "craft blacksmithing" OR "craft b"
+    {
+        if (m_bot->HasSkill(SKILL_BLACKSMITHING))
+        {
+            skill = SKILL_BLACKSMITHING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("cooking", text, true)) // true -> "craft cooking" OR "craft c"
+    {
+        if (m_bot->HasSkill(SKILL_COOKING))
+        {
+            skill = SKILL_COOKING;
+            category = SKILL_CATEGORY_SECONDARY;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("engineering", text, true)) // true -> "craft engineering" OR "craft e"
+    {
+        if (m_bot->HasSkill(SKILL_ENGINEERING))
+        {
+            skill = SKILL_ENGINEERING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("firstaid", text, true)) // true -> "craft firstaid" OR "craft f"
+    {
+        if (m_bot->HasSkill(SKILL_FIRST_AID))
+        {
+            skill = SKILL_FIRST_AID;
+            category = SKILL_CATEGORY_SECONDARY;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("inscription", text, true)) // true -> "craft inscription" OR "craft i"
+    {
+        if (m_bot->HasSkill(SKILL_INSCRIPTION))
+        {
+            skill = SKILL_INSCRIPTION;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("jewelcrafting", text, true)) // true -> "craft jewelcrafting" OR "craft j"
+    {
+        if (m_bot->HasSkill(SKILL_JEWELCRAFTING))
+        {
+            skill = SKILL_JEWELCRAFTING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("leatherworking", text, true)) // true -> "craft leatherworking" OR "craft l"
+    {
+        if (m_bot->HasSkill(SKILL_LEATHERWORKING))
+        {
+            skill = SKILL_LEATHERWORKING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("magic", text, true)) // true -> "craft magic" OR "craft m"
+    {
+        if (m_bot->HasSkill(SKILL_ENCHANTING))
+        {
+            skill = SKILL_ENCHANTING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("smelting", text, true)) // true -> "craft smelting" OR "craft s"
+    {
+        if (m_bot->HasSkill(SKILL_MINING))
+        {
+            skill = SKILL_MINING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("tailoring", text, true)) // true -> "craft tailoring" OR "craft t"
+    {
+        if (m_bot->HasSkill(SKILL_TAILORING))
+        {
+            skill = SKILL_TAILORING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else
+    {
+        uint32 spellId;
+        extractSpellId(text, spellId);
+
+        if (!m_bot->HasSpell(spellId))
+        {
+            SendWhisper("|cffff0000I don't have that spell.", fromPlayer);
+            return;
+        }
+
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!spellInfo)
+            return;
+
+        SpellCastTargets targets;
+        Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+
+        if (text.find("all", 0) != std::string::npos)
+        {
+            SpellCastResult result = spell->CheckCast(true);
+
+            if (result != SPELL_CAST_OK)
+                spell->SendCastResult(result);
+            else
+            {
+                spell->prepare(&targets);
+                m_CurrentlyCastingSpellId = spellId;
+                SetState(BOTSTATE_CRAFT);
+            }
+        }
+        else
+            spell->prepare(&targets);
+        return;
+    }
+
+    m_spellsToLearn.clear();
+    m_bot->skill(m_spellsToLearn);
+    SendWhisper("I can create:\n", fromPlayer);
+    ChatHandler ch(fromPlayer.GetSession());
+    for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+    {
+        SkillLineEntry const *SkillLine = sSkillLineStore.LookupEntry(*it);
+
+        if (SkillLine->categoryId == category && *it == skill)
+            for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+            {
+                SkillLineAbilityEntry const *SkillAbility = sSkillLineAbilityStore.LookupEntry(j);
+                if (!SkillAbility)
+                    continue;
+
+                SpellEntry const* spellInfo = sSpellStore.LookupEntry(SkillAbility->spellId);
+                if (!spellInfo)
+                    continue;
+
+                if (IsPrimaryProfessionSkill(*it) && spellInfo->Effect[0] != SPELL_EFFECT_CREATE_ITEM)
+                    continue;
+
+                if (SkillAbility->skillId == *it && m_bot->HasSpell(SkillAbility->spellId) && SkillAbility->forward_spellid == 0 && ((SkillAbility->classmask & m_bot->getClassMask()) == 0))
+                {
+                    MakeSpellLink(spellInfo, msg);
+                    ++linkcount;
+                    if ((charges = GetSpellCharges(SkillAbility->spellId)) > 0)
+                        msg << "[" << charges << "]";
+                    if (linkcount >= 10)
+                    {
+                        ch.SendSysMessage(msg.str().c_str());
+                        linkcount = 0;
+                        msg.str("");
+                    }
+                }
+            }
+    }
+    m_noToolList.unique();
+    for (std::list<uint32>::iterator it = m_noToolList.begin(); it != m_noToolList.end(); it++)
+        HasTool(*it);
+    ch.SendSysMessage(msg.str().c_str());
+    m_noToolList.clear();
+    m_spellsToLearn.clear();
+}
+
+void PlayerbotAI::_HandleCommandQuest(std::string &text, Player &fromPlayer)
+{
+    std::ostringstream msg;
+
+    if (ExtractCommand("add", text, true)) // true -> "quest add" OR "quest a"
+    {
+        std::list<uint32> questIds;
+        extractQuestIds(text, questIds);
+        for (std::list<uint32>::iterator it = questIds.begin(); it != questIds.end(); it++)
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(TAKE_QUEST, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+    }
+    else if (ExtractCommand("drop", text, true)) // true -> "quest drop" OR "quest d"
+    {
+        fromPlayer.SetSelection(m_bot->GetGUID());
+        PlayerbotChatHandler ch(m_master->GetSession());
+        int8 linkStart = text.find("|");
+        if (text.find("|") != std::string::npos)
+        {
+            if (!ch.dropQuest((char *) text.substr(linkStart).c_str()))
+                ch.sysmessage("ERROR: could not drop quest");
+            else
+            {
+                SetQuestNeedItems();
+                SetQuestNeedCreatures();
+            }
+        }
+    }
+    else if (ExtractCommand("list", text, true)) // true -> "quest list" OR "quest l"
+    {
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(LIST_QUEST, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+    }
+    else if (ExtractCommand("report", text))
+        SendQuestNeedList();
+    else if (ExtractCommand("end", text, true)) // true -> "quest end" OR "quest e"
+    {
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(END_QUEST, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+    }
+    else
+    {
+        bool hasIncompleteQuests = false;
+        std::ostringstream incomout;
+        incomout << "my incomplete quests are:";
+        bool hasCompleteQuests = false;
+        std::ostringstream comout;
+        comout << "my complete quests are:";
+        for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+        {
+            if (uint32 questId = m_bot->GetQuestSlotQuestId(slot))
+            {
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(questId);
+
+                std::string questTitle  = pQuest->GetTitle();
+                QuestLocalization(questTitle, questId);
+
+                if (m_bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+                {
+                    hasCompleteQuests = true;
+                    comout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                }
+                else
+                {
+                    Item* qitem = FindItem(pQuest->GetSrcItemId());
+                    if (qitem)
+                        incomout << " use " << "|cffffffff|Hitem:" << qitem->GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << qitem->GetTemplate()->Name1 << "]|h|r" << " on ";
+                    hasIncompleteQuests = true;
+                    incomout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" <<  questTitle << "]|h|r";
+                }
+            }
+        }
+        if (hasCompleteQuests)
+            SendWhisper(comout.str(), fromPlayer);
+        if (hasIncompleteQuests)
+            SendWhisper(incomout.str(), fromPlayer);
+        if (!hasCompleteQuests && !hasIncompleteQuests)
+            SendWhisper("I have no quests.", fromPlayer);
+    }
+}
+
+void PlayerbotAI::_HandleCommandPet(std::string &text, Player &fromPlayer)
+{
+    if (ExtractCommand("tame", text))
+    {
+        if (m_bot->GetPetGUID())
+        {
+            SendWhisper("I already have a pet!", fromPlayer);
+            return;
+        }
+
+        ObjectGuid castOnGuid = fromPlayer.GetTarget();
+        if (castOnGuid && m_bot->HasSpell(TAME_BEAST_1))
+        {
+            if (ASPECT_OF_THE_MONKEY > 0 && !m_bot->HasAura(ASPECT_OF_THE_MONKEY, ObjectGuid::Empty))
+                CastSpell(ASPECT_OF_THE_MONKEY, *m_bot);
+            m_targetGuidCommand = castOnGuid;
+            SetState(BOTSTATE_TAME);
+        }
+        else
+            SendWhisper("I can't tame that!", fromPlayer);
+        return;
+    }
+
+    Pet * pet = m_bot->GetPet();
+    if (!pet)
+    {
+        SendWhisper("I have no pet.", fromPlayer);
+        return;
+    }
+
+    if (ExtractCommand("abandon", text))
+    {
+        // abandon pet
+        WorldPacket* const packet = new WorldPacket(CMSG_PET_ABANDON, 8);
+        *packet << pet->GetGUID();
+        m_bot->GetSession()->QueuePacket(packet);
+
+    }
+    else if (ExtractCommand("react", text))
+    {
+        if (ExtractCommand("aggressive", text, true))
+            pet->SetReactState(REACT_AGGRESSIVE);
+        else if (ExtractCommand("defensive", text, true))
+            pet->SetReactState(REACT_DEFENSIVE);
+        else if (ExtractCommand("passive", text, true))
+            pet->SetReactState(REACT_PASSIVE);
+        else
+            _HandleCommandHelp("pet react", fromPlayer);
+    }
+    else if (ExtractCommand("state", text))
+    {
+        if (text != "")
+        {
+            SendWhisper("'pet state' does not support subcommands.", fromPlayer);
+            return;
+        }
+
+        std::string state;
+        switch (pet->GetReactState())
+        {
+            case REACT_AGGRESSIVE:
+                SendWhisper("My pet is aggressive.", fromPlayer);
+                break;
+            case REACT_DEFENSIVE:
+                SendWhisper("My pet is defensive.", fromPlayer);
+                break;
+            case REACT_PASSIVE:
+                SendWhisper("My pet is passive.", fromPlayer);
+        }
+    }
+    else if (ExtractCommand("cast", text))
+    {
+        if (text == "")
+        {
+            _HandleCommandHelp("pet cast", fromPlayer);
+            return;
+        }
+
+        uint32 spellId = (uint32) atol(text.c_str());
+
+        if (spellId == 0)
+        {
+            spellId = getPetSpellId(text.c_str());
+            if (spellId == 0)
+                extractSpellId(text, spellId);
+        }
+
+        if (spellId != 0 && pet->HasSpell(spellId))
+        {
+            if (pet->HasAura(spellId))
+            {
+                pet->RemoveAurasDueToSpell(spellId, pet->GetGUID());
+                return;
+            }
+
+            ObjectGuid castOnGuid = fromPlayer.GetTarget();
+            Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, castOnGuid);
+            CastPetSpell(spellId, pTarget);
+        }
+    }
+    else if (ExtractCommand("toggle", text))
+    {
+        if (text == "")
+        {
+            _HandleCommandHelp("pet toggle", fromPlayer);
+            return;
+        }
+
+        uint32 spellId = (uint32) atol(text.c_str());
+
+        if (spellId == 0)
+        {
+            spellId = getPetSpellId(text.c_str());
+            if (spellId == 0)
+                extractSpellId(text, spellId);
+        }
+
+        if (spellId != 0 && pet->HasSpell(spellId))
+        {
+            PetSpellMap::iterator itr = pet->m_spells.find(spellId);
+            if (itr != pet->m_spells.end())
+            {
+                if (itr->second.active == ACT_ENABLED)
+                {
+                    pet->ToggleAutocast(sSpellMgr->GetSpellInfo(spellId), false);
+                    if (pet->HasAura(spellId))
+                        pet->RemoveAurasDueToSpell(spellId, pet->GetGUID());
+                }
+                else
+                    pet->ToggleAutocast(sSpellMgr->GetSpellInfo(spellId), true);
+            }
+        }
+    }
+    else if (ExtractCommand("spells", text))
+    {
+        if (text != "")
+        {
+            SendWhisper("'pet spells' does not support subcommands.", fromPlayer);
+            return;
+        }
+
+        int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+        std::ostringstream posOut;
+        std::ostringstream negOut;
+
+        for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+        {
+            const uint32 spellId = itr->first;
+
+            if (itr->second.state == PETSPELL_REMOVED || sSpellMgr->GetSpellInfo(spellId)->IsPassive())
+                continue;
+
+            const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (!pSpellInfo)
+                continue;
+
+            std::string color;
+            switch (itr->second.active)
+            {
+                case ACT_ENABLED:
+                    color = "cff35d22d"; // Some flavor of green
+                    break;
+                default:
+                    color = "cffffffff";
+            }
+
+            if (sSpellMgr->GetSpellInfo(spellId)->IsPositive())
+                posOut << " |" << color << "|Hspell:" << spellId << "|h["
+                       << pSpellInfo->SpellName[loc] << "]|h|r";
+            else
+                negOut << " |" << color << "|Hspell:" << spellId << "|h["
+                       << pSpellInfo->SpellName[loc] << "]|h|r";
+        }
+
+        ChatHandler ch(fromPlayer.GetSession());
+        SendWhisper("Here's my pet's non-attack spells:", fromPlayer);
+        ch.SendSysMessage(posOut.str().c_str());
+        SendWhisper("and here's my pet's attack spells:", fromPlayer);
+        ch.SendSysMessage(negOut.str().c_str());
+    }
+}
+
+void PlayerbotAI::_HandleCommandSpells(std::string & /*text*/, Player &fromPlayer)
+{
+    int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+    std::ostringstream posOut;
+    std::ostringstream negOut;
+
+    typedef std::map<std::string, uint32> spellMap;
+
+    spellMap posSpells, negSpells;
+    std::string spellName;
+
+    uint32 ignoredSpells[] = {1843, 5019, 2479, 6603, 3365, 8386, 21651, 21652, 6233, 6246, 6247,
+                              61437, 22810, 22027, 45927, 7266, 7267, 6477, 6478, 7355, 68398};
+    uint32 ignoredSpellsCount = sizeof(ignoredSpells) / sizeof(uint32);
+
+    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        const uint32 spellId = itr->first;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || sSpellMgr->GetSpellInfo(spellId)->IsPassive())
+            continue;
+
+        const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        spellName = pSpellInfo->SpellName[loc];
+
+        SkillLineAbilityMapBounds const bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellId);
+
+        bool isProfessionOrRidingSpell = false;
+        for (SkillLineAbilityMap::const_iterator skillIter = bounds.first; skillIter != bounds.second; ++skillIter)
+        {
+            if (IsProfessionOrRidingSkill(skillIter->second->skillId) && skillIter->first == spellId) {
+                isProfessionOrRidingSpell = true;
+                break;
+            }
+        }
+        if (isProfessionOrRidingSpell)
+            continue;
+
+        bool isIgnoredSpell = false;
+        for (uint8 i = 0; i < ignoredSpellsCount; ++i)
+        {
+            if (spellId == ignoredSpells[i]) {
+                isIgnoredSpell = true;
+                break;
+            }
+        }
+        if (isIgnoredSpell)
+            continue;
+
+        if (sSpellMgr->GetSpellInfo(spellId)->IsPositive()) {
+            if (posSpells.find(spellName) == posSpells.end())
+                posSpells[spellName] = spellId;
+            else if (posSpells[spellName] < spellId)
+                posSpells[spellName] = spellId;
+        }
+        else
+        {
+            if (negSpells.find(spellName) == negSpells.end())
+                negSpells[spellName] = spellId;
+            else if (negSpells[spellName] < spellId)
+                negSpells[spellName] = spellId;
+        }
+    }
+
+    for (spellMap::const_iterator iter = posSpells.begin(); iter != posSpells.end(); ++iter)
+    {
+        posOut << " |cffffffff|Hspell:" << iter->second << "|h[" << iter->first << "]|h|r";
+    }
+
+    for (spellMap::const_iterator iter = negSpells.begin(); iter != negSpells.end(); ++iter)
+    {
+        negOut << " |cffffffff|Hspell:" << iter->second << "|h[" << iter->first << "]|h|r";
+    }
+
+    ChatHandler ch(fromPlayer.GetSession());
+    SendWhisper("here's my non-attack spells:", fromPlayer);
+    ch.SendSysMessage(posOut.str().c_str());
+    SendWhisper("and here's my attack spells:", fromPlayer);
+    ch.SendSysMessage(negOut.str().c_str());
+}
+
+void PlayerbotAI::_HandleCommandSurvey(std::string & /*text*/, Player &fromPlayer)
+{
+    uint32 count = 0;
+    std::ostringstream detectout;
+    QueryResult result;
+    GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr->GetActiveEventList();
+    std::ostringstream eventFilter;
+    eventFilter << " AND (eventEntry IS NULL ";
+    bool initString = true;
+
+    for (GameEventMgr::ActiveEvents::const_iterator itr = activeEventsList.begin(); itr != activeEventsList.end(); ++itr)
+    {
+        if (initString)
+        {
+            eventFilter <<  "OR eventEntry IN (" << *itr;
+            initString = false;
+        }
+        else
+            eventFilter << "," << *itr;
+    }
+
+    if (!initString)
+        eventFilter << "))";
+    else
+        eventFilter << ")";
+
+    result = WorldDatabase.PQuery("SELECT gameobject.guid, id, position_x, position_y, position_z, map, "
+                                  "(POW(position_x - %f, 2) + POW(position_y - %f, 2) + POW(position_z - %f, 2)) AS order_ FROM gameobject "
+                                  "LEFT OUTER JOIN game_event_gameobject on gameobject.guid=game_event_gameobject.guid WHERE map = '%i' %s ORDER BY order_ ASC LIMIT 10",
+                                  m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), m_bot->GetMapId(), eventFilter.str().c_str());
+
+    if (result)
+    {
+        do
+        {
+            Field *fields = result->Fetch();
+            uint32 guid = fields[0].GetUInt32();
+            uint32 entry = fields[1].GetUInt32();
+
+            GameObject *go = m_bot->GetMap()->GetGameObject(ObjectGuid(HighGuid::GameObject, guid));
+            if (!go)
+                continue;
+
+            if (!go->isSpawned())
+                continue;
+
+            detectout << "|cFFFFFF00|Hfound:" << guid << ":" << entry  << ":" <<  "|h[" << go->GetGOInfo()->name << "]|h|r";
+            ++count;
+        } while (result->NextRow());
+
+        //delete result;
+    }
+    SendWhisper(detectout.str().c_str(), fromPlayer);
+}
+
+// _HandleCommandSkill: Handle class & professions training:
+// skill                           -- Lists bot(s) Primary profession skills & weapon skills
+// skill learn                     -- List available class or profession (Primary or Secondary) skills, spells & abilities from selected trainer.
+// skill learn [HLINK][HLINK] ..   -- Learn selected skill and spells, from selected trainer ([HLINK] from skill learn).
+// skill unlearn [HLINK][HLINK] .. -- Unlearn selected primary profession skill(s) and all associated spells ([HLINK] from skill)
+void PlayerbotAI::_HandleCommandSkill(std::string &text, Player &fromPlayer)
+{
+    uint32 rank[8] = {0, 75, 150, 225, 300, 375, 450, 525};
+
+    std::ostringstream msg;
+
+    if (ExtractCommand("learn", text))
+    {
+        uint32 totalCost = 0;
+
+        Unit* unit = ObjectAccessor::GetUnit(*m_bot, fromPlayer.GetTarget());
+        if (!unit)
+        {
+            SendWhisper("Please select the trainer!", fromPlayer);
+            return;
+        }
+
+        if (!unit->IsTrainer())
+        {
+            SendWhisper("This is not a trainer!", fromPlayer);
+            return;
+        }
+
+        Creature *creature =  m_bot->GetMap()->GetCreature(fromPlayer.GetTarget());
+        if (!creature)
+            return;
+
+        if (!creature->isCanTrainingAndResetTalentsOf(m_bot))
+        {
+            SendWhisper("This trainer can not teach me anything!", fromPlayer);
+            return;
+        }
+
+        // check present spell in trainer spell list
+        TrainerSpellData const* cSpells = creature->GetTrainerSpells();
+        //TrainerSpellData const* tSpells = creature->GetTrainerTemplateSpells();
+        if (!cSpells)
+        {
+            SendWhisper("No spells can be learnt from this trainer", fromPlayer);
+            return;
+        }
+
+        // reputation discount
+        float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+
+        // Handle: Learning class or profession (primary or secondary) skill & spell(s) for selected trainer, skill learn [HLINK][HLINK][HLINK].. ([HLINK] from skill train)
+        if (text.size() > 0)
+        {
+            msg << "I have learned the following spells:\r";
+            uint32 totalSpellLearnt = 0;
+            bool visuals = true;
+            m_spellsToLearn.clear();
+            extractSpellIdList(text, m_spellsToLearn);
+            for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); it++)
+            {
+                uint32 spellId = *it;
+
+                if (!spellId)
+                    break;
+
+                TrainerSpell const* trainer_spell = cSpells->Find(spellId);
+                if (!trainer_spell)
+                    continue;
+
+                uint32 reqLevel = 0;
+                if (!trainer_spell->learnedSpell[0] && !m_bot->IsSpellFitByClassAndRace(trainer_spell->learnedSpell[0]))
+                    continue;
+
+                if (sSpellMgr->GetSpellInfo(trainer_spell->learnedSpell[0])->IsPrimaryProfession() && m_bot->HasSpell(trainer_spell->learnedSpell[0]))
+                    continue;
+
+                reqLevel = trainer_spell->reqLevel ? trainer_spell->reqLevel : std::max(reqLevel, trainer_spell->reqLevel);
+
+                TrainerSpellState state =  m_bot->GetTrainerSpellState(trainer_spell);
+                if (state != TRAINER_SPELL_GREEN)
+                    continue;
+
+                // apply reputation discount
+                uint32 cost = uint32(floor(trainer_spell->spellCost * fDiscountMod));
+                // check money requirement
+                if (m_bot->GetMoney() < cost)
+                {
+                    Announce(CANT_AFFORD);
+                    continue;
+                }
+
+                m_bot->ModifyMoney(-int32(cost));
+                // learn explicitly or cast explicitly
+                if (trainer_spell->IsCastable())
+                    m_bot->CastSpell(m_bot, trainer_spell->spell, true);
+                else
+                    m_bot->LearnSpell(spellId, false);
+                ++totalSpellLearnt;
+                totalCost += cost;
+                const SpellEntry *const pSpellInfo = sSpellStore.LookupEntry(spellId);
+                if (!pSpellInfo)
+                    continue;
+
+                if (visuals)
+                {
+                    visuals = false;
+                    WorldPacket data(SMSG_PLAY_SPELL_VISUAL, 12);           // visual effect on trainer
+                    data << ObjectGuid(fromPlayer.GetTarget());
+                    data << uint32(0xB3);                                   // index from SpellVisualKit.dbc
+                    m_master->GetSession()->SendPacket(&data);
+
+                    data.Initialize(SMSG_PLAY_SPELL_IMPACT, 12);            // visual effect on player
+                    data << m_bot->GetGUID();
+                    data << uint32(0x016A);                                 // index from SpellVisualKit.dbc
+                    m_master->GetSession()->SendPacket(&data);
+                }
+
+                WorldPacket data(SMSG_TRAINER_BUY_SUCCEEDED, 12);
+                data << ObjectGuid(fromPlayer.GetTarget());
+                data << uint32(spellId);                                // should be same as in packet from client
+                m_master->GetSession()->SendPacket(&data);
+
+                MakeSpellLink(pSpellInfo, msg);
+                msg << " ";
+                msg << Cash(cost) << "\n";
+            }
+            ReloadAI();
+            msg << "Total of " << totalSpellLearnt << " spell";
+            if (totalSpellLearnt != 1) msg << "s";
+            msg << " learnt, ";
+            msg << Cash(totalCost) << " spent.";
+        }
+        // Handle: List class or profession skills, spells & abilities for selected trainer
+        else
+        {
+            msg << "The spells I can learn and their cost:\r";
+
+            for (TrainerSpellMap::const_iterator itr =  cSpells->spellList.begin(); itr !=  cSpells->spellList.end(); ++itr)
+            {
+                TrainerSpell const* tSpell = &itr->second;
+
+                if (!tSpell)
+                    break;
+
+                uint32 reqLevel = 0;
+                if (!tSpell->learnedSpell[0] && !m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[0]))
+                    continue;
+
+                if (sSpellMgr->GetSpellInfo(tSpell->learnedSpell[0])->IsPrimaryProfession() && m_bot->HasSpell(tSpell->learnedSpell[0]))
+                    continue;
+
+                reqLevel = tSpell->reqLevel ? tSpell->reqLevel : std::max(reqLevel, tSpell->reqLevel);
+
+                TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell);
+                if (state != TRAINER_SPELL_GREEN)
+                    continue;
+
+                uint32 spellId = tSpell->spell;
+                const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+                if (!pSpellInfo)
+                    continue;
+                uint32 cost = uint32(floor(tSpell->spellCost *  fDiscountMod));
+                totalCost += cost;
+                MakeSpellLink(pSpellInfo, msg);
+                msg << " ";
+                msg << Cash(cost) << "\n";
+            }
+            int32 moneyDiff = m_bot->GetMoney() - totalCost;
+            if (moneyDiff >= 0)
+            {
+                // calculate how much money bot has
+                msg << " ";
+                msg << Cash(moneyDiff) << " left.";
+            }
+            else
+            {
+                Announce(CANT_AFFORD);
+                moneyDiff *= -1;
+                msg << "I need ";
+                msg << Cash(moneyDiff) << " more to learn all the spells!";
+            }
+        }
+    }
+    // Handle: Unlearning selected primary profession skill(s) and all associated spells, skill unlearn [HLINK][HLINK].. ([HLINK] from skill)
+    else if (ExtractCommand("unlearn", text))
+    {
+        m_spellsToLearn.clear();
+        extractSpellIdList(text, m_spellsToLearn);
+        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+        {
+            if (sSpellMgr->GetSpellInfo(*it)->IsPrimaryProfession())
+            {
+                SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(*it);
+
+                uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(*it);
+                if (!prev_spell)                                    // first rank, remove skill
+                    GetPlayer()->SetSkill(spellLearnSkill->skill, GetPlayer()->GetSkillStep(spellLearnSkill->skill), 0, 0);
+                else
+                {
+                    // search prev. skill setting by spell ranks chain
+                    SpellLearnSkillNode const* prevSkill = sSpellMgr->GetSpellLearnSkill(prev_spell);
+                    while (!prevSkill && prev_spell)
+                    {
+                        prev_spell = sSpellMgr->GetPrevSpellInChain(prev_spell);
+                        prevSkill = sSpellMgr->GetSpellLearnSkill(sSpellMgr->GetFirstSpellInChain(prev_spell));
+                    }
+                    if (!prevSkill)                                 // not found prev skill setting, remove skill
+                        GetPlayer()->SetSkill(spellLearnSkill->skill, GetPlayer()->GetSkillStep(spellLearnSkill->skill), 0, 0);
+                }
+            }
+        }
+    }
+    // Handle: Lists bot(s) primary profession skills & weapon skills.
+    else
+    {
+        m_spellsToLearn.clear();
+        m_bot->skill(m_spellsToLearn);
+        msg << "My Primary Professions: ";
+        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+        {
+            if (IsPrimaryProfessionSkill(*it))
+                for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+                {
+                    SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(j);
+                    if (!skillLine)
+                        continue;
+
+                    // has skill
+                    if (skillLine->skillId == *it && skillLine->AutolearnType == 0)
+                    {
+                        SpellEntry const* spellInfo = sSpellStore.LookupEntry(skillLine->spellId);
+                        if (!spellInfo)
+                            continue;
+
+                        if (m_bot->GetSkillValue(*it) <= rank[sSpellMgr->GetSpellRank(skillLine->spellId)] && m_bot->HasSpell(skillLine->spellId))
+                        {
+                            // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: HandleCommand - skill (%u)(%u)(%u):",skillLine->spellId, rank[sSpellMgr->GetSpellRank(skillLine->spellId)], m_bot->GetSkillValue(*it));
+                            MakeSpellLink(spellInfo, msg);
+                            break;
+                        }
+                    }
+                }
+        }
+
+        msg << "\nMy Weapon skills: ";
+        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+        {
+            SkillLineEntry const *SkillLine = sSkillLineStore.LookupEntry(*it);
+            // has weapon skill
+            if (SkillLine->categoryId == SKILL_CATEGORY_WEAPON)
+                for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+                {
+                    SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(j);
+                    if (!skillLine)
+                        continue;
+
+                    SpellEntry const* spellInfo = sSpellStore.LookupEntry(skillLine->spellId);
+                    if (!spellInfo)
+                        continue;
+
+                    if (skillLine->skillId == *it && spellInfo->Effect[0] == SPELL_EFFECT_WEAPON)
+                        MakeWeaponSkillLink(spellInfo, msg, *it);
+                }
+        }
+    }
+    SendWhisper(msg.str(), fromPlayer);
+    m_spellsToLearn.clear();
+    //m_bot->GetPlayerbotAI()->GetClassAI();
+}
+
+void PlayerbotAI::_HandleCommandStats(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("'stats' does not have subcommands", fromPlayer);
+        return;
+    }
+
+    std::ostringstream out;
+
+    uint32 totalused = 0;
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+            totalused++;
+    }
+    uint32 totalfree = 16 - totalused;
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+                totalfree =  totalfree + pBag->GetFreeSlots();
+        }
+
+    }
+
+    // estimate how much item damage the bot has
+    out << "|cffffffff[|h|cff00ffff" << m_bot->GetName() << "|h|cffffffff] has |cff00ff00";
+    out << totalfree << " |h|cffffffff bag slots,|h" << " |cff00ff00";
+    out << Cash(EstRepairAll());
+
+    // calculate how much money bot has
+    uint32 copper = m_bot->GetMoney();
+    out << "|h|cffffffff item damage & has " << "|r|cff00ff00";
+    out << Cash(copper);
+    ChatHandler ch(fromPlayer.GetSession());
+    ch.SendSysMessage(out.str().c_str());
+}
+
+void PlayerbotAI::_HandleCommandGM(std::string &text, Player &fromPlayer)
+{
+    // Check should happen OUTSIDE this function, but this is account security we're talking about, so let's be doubly sure
+    if (fromPlayer.GetSession()->GetSecurity() <= SEC_PLAYER)
+        return;  // no excuses, no warning
+
+    if (text == "")
+    {
+        SendWhisper("gm must have a subcommand.", fromPlayer);
+        return;
+    }
+    else if (ExtractCommand("check", text))
+    {
+        if (ExtractCommand("talent", text))
+        {
+            if (ExtractCommand("spec", text))
+            {
+                uint32 tsDBError = TalentSpecDBContainsError();
+                if (0 != tsDBError)
+                {
+                    std::ostringstream oss;
+                    oss << "Error found in TalentSpec: " << tsDBError;
+                    SendWhisper(oss.str(), fromPlayer);
+                }
+                else
+                    SendWhisper("No errors found. High five!", fromPlayer);
+            }
+        }
+        else
+            SendWhisper("'gm check' does not have that subcommand.", fromPlayer);
+    }
+    else
+        SendWhisper("'gm' does not have that subcommand.", fromPlayer);
+}
+
+void PlayerbotAI::_HandleCommandHelp(std::string &text, Player &fromPlayer)
+{
+    ChatHandler ch(fromPlayer.GetSession());
+
+    // "help help"? Seriously?
+    if (ExtractCommand("help", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("help", "Lists all the things you can order me to do... But it's up to me whether to follow your orders... Or not.").c_str());
+        return;
+    }
+
+    bool bMainHelp = (text == "") ? true : false;
+    const std::string sInvalidSubcommand = "That's not a valid subcommand.";
+    std::string msg = "";
+    // All of these must containt the 'bMainHelp' clause -> help lists all major commands
+    // Further indented 'ExtractCommand("subcommand")' conditionals make sure these aren't printed for basic "help"
+    if (bMainHelp || ExtractCommand("attack", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("attack", "Attack the selected target. Which would, of course, require a valid target.", HL_TARGET).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("follow", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("follow", "I will follow you - this also revives me if dead and teleports me if I'm far away.").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("follow far", "I will follow at a father distance away from you.").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("follow near", "I will follow at a closer distance to you.").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("follow reset", "I will reset my follow distance to its original state.").c_str());
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("stay", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("stay", "I will stay put until told otherwise.").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("autoequip", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("autoequip", "Used with no parameter: Toggles Auto Equipping for one or all bots to ON or OFF depending on their current setting.").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("autoequip < on >", "Turns Auto equipping ON for one, or all bots in group").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("autoequip < off >", "Turns Auto equipping OFF for one, or all bots in group").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("autoequip < now >", "Ignores current autoequip setting, Runs the auto equip cycle ONCE for one or all bots (/t or /p)").c_str());
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("assist", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("assist", "I will assist the character listed, attacking as they attack.", HL_NAME).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("spells", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("spells", "I will list all the spells I know.").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("craft", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("craft", "I will create a single specified recipe", HL_RECIPE).c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("craft [RECIPE] all", "I will create all specified recipes").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < alchemy | a >", "List all learnt alchemy recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < blacksmithing | b >", "List all learnt blacksmith recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < cooking | c >", "List all learnt cooking recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < engineering | e >", "List all learnt engineering recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < firstaid | f >", "List all learnt firstaid recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < inscription | i >", "List all learnt inscription recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < jewelcrafting | j >", "List all learnt jewelcrafting recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < leatherworking | l >", "List all learnt leatherworking recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < magic | m >", "List all learnt enchanting recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < smelting | s >", "List all learnt mining recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < tailoring | t >", "List all learnt tailoring recipes").c_str());
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("process", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("process < disenchant | d >", "Disenchants a green coloured [ITEM] or better", HL_ITEM).c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("process < mill | m >", "Grinds 5 herbs [ITEM] to produce pigments", HL_ITEM).c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("process < prospect | p >", "Searches 5 metal ore [ITEM] for precious gems", HL_ITEM).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("enchant", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("enchant", "Lists all enchantments [SPELL] learnt by the bot").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("enchant [SPELL]", "Enchants selected tradable [ITEM] either equipped or in bag", HL_ITEM).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("cast", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("cast", "I will cast the spell or ability listed.", HL_SPELL).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("use", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("use", "I will use the linked item.", HL_ITEM).c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("use [ITEM]", "I will use the first linked item on a selected TARGET.", HL_TARGET).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("use [ITEM]", "I will use the first linked item on an equipped linked item.", HL_ITEM).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("use [ITEM]", "I will use the first linked item on a linked gameobject.", HL_GAMEOBJECT).c_str());
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("equip", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("equip", "I will equip the linked item(s).", HL_ITEM, true).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("reset", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("reset", "I will reset all my states, orders, loot list, talent spec, ... Hey, that's kind of like memory loss.").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("stats", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("stats", "This will inform you of my wealth, free bag slots and estimated equipment repair costs.").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("survey", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("survey", "Lists all available game objects near me.").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("find", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("find", "I will find said game object, walk right up to it, and wait.", HL_GAMEOBJECT).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("get", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("get", "I will get said game object and return to your side.", HL_GAMEOBJECT).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("quest", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("quest", "Lists my current quests.").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("quest add", "Adds this quest to my quest log.", HL_QUEST).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("quest drop", "Removes this quest from my quest log.", HL_QUEST).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("quest end", "Turns in my completed quests.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("quest list", "Lists the quests offered to me by this target.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("quest report", "This will give you a full report of all the items, creatures or gameobjects I still need to finish my quests.", HL_QUEST).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("add", text, true)) {}
+            else if (ExtractCommand("drop", text, true)) {}
+            else if (ExtractCommand("end", text, true)) {}
+            else if (ExtractCommand("list", text, true)) {}
+            else if (ExtractCommand("report", text, true)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("orders", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("orders", "Shows you my orders. Free will is overrated, right?").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("pet", text))
+    {
+        if (bMainHelp)
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet", "Helps command my pet. Must always be used with a subcommand.").c_str());
+        else if (text == "") // not "help" AND "help pet"
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet", "This by itself is not a valid command. Just so you know. To be used with a subcommand, such as...").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet abandon", "Abandons active hunter pet.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet cast", "Has my pet cast this spell. May require a treat. Or at least ask nicely.", HL_SPELL).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet react", "Sets my pet's aggro mode.", HL_PETAGGRO).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet spells", "Shows you the spells my pet knows.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet state", "Shows my pet's aggro mode.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet tame", "Allows a hunter to acquire a pet.", HL_TARGET).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet toggle", "Toggles autocast for this spell.", HL_SPELL).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("spells", text)) {}
+            else if (ExtractCommand("tame", text)) {}
+            else if (ExtractCommand("abandon", text)) {}
+            else if (ExtractCommand("cast", text)) {}
+            else if (ExtractCommand("toggle", text)) {}
+            else if (ExtractCommand("state", text)) {}
+            else if (ExtractCommand("react", text))
+            {
+                ch.SendSysMessage(_HandleCommandHelpHelper("pet react", "has three modes.").c_str());
+                ch.SendSysMessage(_HandleCommandHelpHelper("aggressive", "sets it so my precious attacks everything in sight.", HL_NONE, false, true).c_str());
+                ch.SendSysMessage(_HandleCommandHelpHelper("defensive", "sets it so it automatically attacks anything that attacks me, or anything I attack.", HL_NONE, false, true).c_str());
+                ch.SendSysMessage(_HandleCommandHelpHelper("passive", "makes it so my pet won't attack anything unless directly told to.", HL_NONE, false, true).c_str());
+
+                // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+                if (ExtractCommand("aggressive", text, true)) {}
+                else if (ExtractCommand("defensive", text, true)) {}
+                else if (ExtractCommand("passive", text, true)) {}
+                if (text != "")
+                    ch.SendSysMessage(sInvalidSubcommand.c_str());
+            }
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("collect", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("collect", "Tells you what my current collect status is. Also lists possible options.").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("collect", "Sets what I collect. Obviously the 'none' option should be used alone, but all the others can be mixed.", HL_OPTION, true).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("sell", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("sell", "Adds this to my 'for sale' list.", HL_ITEM, true).c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("sell all", "The next time you sell, I'll sell all my low level white items.").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("sell all", "This command must be called each time before you sell, OR I won't auto sell white items.").c_str());
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("buy", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("buy", "Adds this to my 'purchase' list.", HL_ITEM, true).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("drop", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("drop", "Drops the linked item(s). Permanently.", HL_ITEM, true).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("auction", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("auction", "Lists all my active auctions. With pretty little links and such. Hi hi hi... I'm gonna be sooo rich!").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("auction add", "Adds the item to my 'auction off later' list. I have a lot of lists, you see...", HL_ITEM).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("auction remove", "Adds the item to my 'Don't auction after all' list. Hope it hasn't sold by then!", HL_AUCTION).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("add", text, true)) {}
+            else if (ExtractCommand("remove", text, true)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("repair", text))
+    {
+        if (!bMainHelp && text == "")
+            ch.SendSysMessage(_HandleCommandHelpHelper("repair", "This by itself is not a valid command. Just so you know. To be used with a subcommand, such as...").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("repair", "Has me find an armorer and repair the items you listed.", HL_ITEM).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("repair all", "Has me find an armorer and repair all my items, be they equipped or just taking up bagspace.").c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("all", text)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("talent", text))
+    {
+        msg = _HandleCommandHelpHelper("talent", "Lists my talents, glyphs, unspent talent points and the cost to reset all talents.");
+        ch.SendSysMessage(msg.c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("talent learn", "Has me learn the linked talent.", HL_TALENT).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("talent reset", "Resets my talents. Assuming I have the appropriate amount of sparkly gold, shiny silver, and... unrusted copper.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("talent spec", "Lists all talent specs I can use.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("talent spec #", "I will follow this talent spec. Well, I will if you picked a talent spec that exists.").c_str());
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+        if (!bMainHelp) return;
+    }
+    if (bMainHelp || ExtractCommand("bank", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("bank", "Gives you my bank balance. I thought that was private.").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("bank deposit", "Deposits the listed items in my bank.", HL_ITEM, true).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("bank withdraw", "Withdraw the listed items from my bank.", HL_ITEM, true).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("deposit", text)) {}
+            else if (ExtractCommand("withdraw", text)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("skill", text))
+    {
+        msg = _HandleCommandHelpHelper("skill", "Lists my primary professions & weapon skills.");
+        ch.SendSysMessage(msg.c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("skill learn", "Lists the things this trainer can teach me. If you've targeted a trainer, that is.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("skill learn", "Have me learn this skill from the selected trainer.", HL_SKILL).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("skill unlearn", "Unlearn the linked (primary) profession and everything that goes with it.", HL_PROFESSION).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("learn", text)) {}
+            else if (ExtractCommand("unlearn", text)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (fromPlayer.GetSession()->GetSecurity() > SEC_PLAYER && (bMainHelp || ExtractCommand("gm", text)))
+    {
+        msg = _HandleCommandHelpHelper("gm", "Lists actions available to GM account level and up.");
+        ch.SendSysMessage(msg.c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("gm check", "Lists the things you can run a check on.").c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("check", text))
+            {
+                ch.SendSysMessage(_HandleCommandHelpHelper("gm check talent", "Lists talent mechanics you can run a check on.").c_str());
+
+                if (ExtractCommand("talent", text))
+                {
+                    ch.SendSysMessage(_HandleCommandHelpHelper("gm check talent spec", "Checks the talent spec database for various errors. Only the first error (if any) is returned.").c_str());
+
+                    if (ExtractCommand("spec", text)) {}
+
+                    if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+                    return;
+                }
+
+                if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+                return;
+            }
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("mail", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("mail inbox |cFFFFFF00|h[Mailbox]|h|r", "Lists all bot mail from selected [Mailbox]").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("mail getcash", "Gets money from all selected [Mailid]..", HL_MAIL, true).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("mail getitem", "Gets items from all selected [Mailid]..", HL_MAIL, true).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("mail delete", "Delete all selected [Mailid]..", HL_MAIL, true).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("inbox", text, true)) {}
+            else if (ExtractCommand("getcash", text, true)) {}
+            else if (ExtractCommand("getitem", text, true)) {}
+            else if (ExtractCommand("delete", text, true)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+
+    if (bMainHelp)
+        ch.SendSysMessage(_HandleCommandHelpHelper("help", "Gives you this listing of main commands... But then, you know that already don't you.").c_str());
+
+    if (text != "")
+        ch.SendSysMessage("Either that is not a valid command, or someone forgot to add it to my help journal. I mean seriously, they can't expect me to remember *all* this stuff, can they?");
+}
+
+std::string PlayerbotAI::_HandleCommandHelpHelper(std::string sCommand, std::string sExplain, HELPERLINKABLES reqLink, bool bReqLinkMultiples, bool bCommandShort)
+{
+    if (sCommand == "")
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI] _HandleCommandHelpHelper called with an empty sCommand. Ignoring call.");
+        return "";
+    }
+
+    std::ostringstream oss;
+    oss << "'|cffffffff";
+    if (bCommandShort)
+        oss << "(" << sCommand.at(0) << ")" << sCommand.substr(1);
+    else
+        oss << sCommand;
+
+    if (reqLink != HL_NONE)
+    {
+        if (reqLink == HL_PROFESSION)
+        {
+            oss << " [PROFESSION]";
+            if (bReqLinkMultiples)
+                oss << " [PROFESSION] ..";
+        }
+        else if (reqLink == HL_ITEM)
+        {
+            oss << " [ITEM]";
+            if (bReqLinkMultiples)
+                oss << " [ITEM] ..";
+        }
+        else if (reqLink == HL_TALENT)
+        {
+            oss << " [TALENT]";
+            if (bReqLinkMultiples)
+                oss << " [TALENT] ..";
+        }
+        else if (reqLink == HL_SKILL)
+        {
+            oss << " [SKILL]";
+            if (bReqLinkMultiples)
+                oss << " [SKILL] ..";
+        }
+        else if (reqLink == HL_OPTION)
+        {
+            oss << " <OPTION>";
+            if (bReqLinkMultiples)
+                oss << " <OPTION> ..";
+        }
+        else if (reqLink == HL_PETAGGRO)
+        {
+            oss << " <(a)ggressive | (d)efensive | (p)assive>";
+            //if (bReqLinkMultiples)
+                //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI] _HandleCommandHelpHelper: sCommand \"pet\" with bReqLinkMultiples \"true\". ... Why? Bug, surely.");
+        }
+        else if (reqLink == HL_QUEST)
+        {
+            oss << " [QUEST]";
+            if (bReqLinkMultiples)
+                oss << " [QUEST] ..";
+        }
+        else if (reqLink == HL_GAMEOBJECT)
+        {
+            oss << " [GAMEOBJECT]";
+            if (bReqLinkMultiples)
+                oss << " [GAMEOBJECT] ..";
+        }
+        else if (reqLink == HL_SPELL)
+        {
+            oss << " <Id# | (part of) name | [SPELL]>";
+            if (bReqLinkMultiples)
+                oss << " <Id# | (part of) name | [SPELL]> ..";
+        }
+        else if (reqLink == HL_TARGET)
+        {
+            oss << " (TARGET)";
+            if (bReqLinkMultiples)
+                oss << " (TARGET) ..";
+        }
+        else if (reqLink == HL_NAME)
+        {
+            oss << " <NAME>";
+            if (bReqLinkMultiples)
+                oss << " <NAME> ..";
+        }
+        else if (reqLink == HL_AUCTION)
+        {
+            oss << " [AUCTION]";
+            if (bReqLinkMultiples)
+                oss << " [AUCTION] ..";
+        }
+        else if (reqLink == HL_RECIPE)
+        {
+            oss << " [RECIPE]";
+            if (bReqLinkMultiples)
+                oss << " [RECIPE] ..";
+        }
+        else if (reqLink == HL_MAIL)
+        {
+            oss << " [MAILID]";
+            if (bReqLinkMultiples)
+                oss << " [MAILID] ..";
+        }
+        else
+        {
+            oss << " {unknown}";
+            if (bReqLinkMultiples)
+                oss << " {unknown} ..";
+            //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: _HandleCommandHelpHelper - Uncaught case");
+        }
+    }
+
+    oss << "|r': " << sExplain;
+
+    return oss.str();
+}
+
+void PlayerbotAI::HandleMasterIncomingPacket(const WorldPacket& packet, WorldSession& session)
+{
+    //WorldSession *session = m_master->GetSession();
+    switch (packet.GetOpcode())
+    {
+        case CMSG_ACTIVATETAXI:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+
+            ObjectGuid guid;
+            std::vector<uint32> nodes;
+            nodes.resize(2);
+            uint8 delay = 9;
+
+            p >> guid >> nodes[0] >> nodes[1];
+
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_ACTIVATETAXI from %d to %d", nodes[0], nodes[1]);
+
+            delay = delay + 3;
+
+            Group* group = m_bot->GetGroup();
+            if (!group)
+                return;
+
+            Unit *target = ObjectAccessor::GetUnit(*m_bot, guid);
+
+            SetIgnoreUpdateTime(delay);
+
+            m_bot->GetMotionMaster()->Clear(true);
+            m_bot->GetMotionMaster()->MoveFollow(target, INTERACTION_DISTANCE, m_bot->GetOrientation());
+            GetTaxi(guid, nodes);
+            return;
+        }
+
+        case CMSG_ACTIVATETAXIEXPRESS:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+
+            ObjectGuid guid;
+            uint32 node_count;
+            uint8 delay = 9;
+
+            p >> guid >> node_count;
+
+            std::vector<uint32> nodes;
+
+            for (uint32 i = 0; i < node_count; ++i)
+            {
+                uint32 node;
+                p >> node;
+                nodes.push_back(node);
+            }
+
+            if (nodes.empty())
+                return;
+
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_ACTIVATETAXIEXPRESS from %d to %d", nodes.front(), nodes.back());
+
+            delay = delay + 3;
+
+            Group* group = m_bot->GetGroup();
+            if (!group)
+                return;
+
+            Unit *target = ObjectAccessor::GetUnit(*m_bot, guid);
+
+            SetIgnoreUpdateTime(delay);
+
+            m_bot->GetMotionMaster()->Clear(true);
+            m_bot->GetMotionMaster()->MoveFollow(target, INTERACTION_DISTANCE, m_bot->GetOrientation());
+            GetTaxi(guid, nodes);
+            return;
+        }
+
+        //case CMSG_MOVE_SPLINE_DONE:
+        //{
+            //// DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_MOVE_SPLINE_DONE");
+
+            //WorldPacket p(packet);
+            //p.rpos(0); // reset reader
+
+            //ObjectGuid guid = extractGuid(p);                           // used only for proper packet read
+            //MovementInfo movementInfo;                              // used only for proper packet read
+
+            //p >> guid;
+            //p >> movementInfo;
+            //p >> Unused<uint32>();                          // unk
+
+            //for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            //{
+
+            //    Player* const bot = it->second;
+            //    if (!bot)
+            //        return;
+
+            //    // in taxi flight packet received in 2 case:
+            //    // 1) end taxi path in far (multi-node) flight
+            //    // 2) switch from one map to other in case multi-map taxi path
+            //    // we need process only (1)
+            //    uint32 curDest = bot->m_taxi.GetTaxiDestination();
+            //    if (!curDest)
+            //        return;
+
+            //    TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
+
+            //    // far teleport case
+            //    if (curDestNode && curDestNode->map_id != bot->GetMapId())
+            //    {
+            //        if (bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE)
+            //        {
+            //            // short preparations to continue flight
+            //            FlightPathMovementGenerator* flight = (FlightPathMovementGenerator *) (bot->GetMotionMaster()->top());
+
+            //            flight->Interrupt(*bot);                // will reset at map landing
+
+            //            flight->SetCurrentNodeAfterTeleport();
+            //            TaxiPathNodeEntry const& node = flight->GetPath()[flight->GetCurrentNode()];
+            //            flight->SkipCurrentNode();
+
+            //            bot->TeleportTo(curDestNode->map_id, node.x, node.y, node.z, bot->GetOrientation());
+            //        }
+            //        return;
+            //    }
+
+            //    uint32 destinationnode = bot->m_taxi.NextTaxiDestination();
+            //    if (destinationnode > 0)                                // if more destinations to go
+            //    {
+            //        // current source node for next destination
+            //        uint32 sourcenode = bot->m_taxi.GetTaxiSource();
+
+            //        // Add to taximask middle hubs in taxicheat mode (to prevent having player with disabled taxicheat and not having back flight path)
+            //        if (bot->isTaxiCheater())
+            //            if (bot->m_taxi.SetTaximaskNode(sourcenode))
+            //            {
+            //                WorldPacket data(SMSG_NEW_TAXI_PATH, 0);
+            //                bot->GetSession()->SendPacket(&data);
+            //            }
+
+            //        // DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_MOVE_SPLINE_DONE Taxi has to go from %u to %u", sourcenode, destinationnode);
+
+            //        uint32 mountDisplayId = sObjectMgr.GetTaxiMountDisplayId(sourcenode, bot->GetTeam());
+
+            //        uint32 path, cost;
+            //        sObjectMgr.GetTaxiPath(sourcenode, destinationnode, path, cost);
+
+            //        if (path && mountDisplayId)
+            //            bot->GetSession()->SendDoFlight(mountDisplayId, path, 1);          // skip start fly node
+            //        else
+            //            bot->m_taxi.ClearTaxiDestinations();    // clear problematic path and next
+            //    }
+            //    else
+            //        /* std::ostringstream out;
+            //           out << "Destination reached" << bot->GetName();
+            //           ChatHandler ch(m_master);
+            //           ch.SendSysMessage(out.str().c_str()); */
+            //        bot->m_taxi.ClearTaxiDestinations();        // Destination, clear source node
+            //}
+            //return;
+        //}
+
+        // if master is logging out, log out all bots
+        //case CMSG_LOGOUT_REQUEST:
+        //{
+        //    LogoutAllBots();
+        //    return;
+        //}
+
+        // If master inspects one of his bots, give the master useful info in chat window
+        // such as inventory that can be equipped
+        //case CMSG_INSPECT:
+        //{
+        //    WorldPacket p(packet);
+        //    p.rpos(0); // reset reader
+        //    ObjectGuid guid;
+        //    p >> guid;
+        //    Player* const bot = GetPlayerBot(guid);
+        //    if (bot) bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+        //    return;
+        //}
+
+        case CMSG_REPAIR_ITEM:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            ObjectGuid npcGUID;
+            p >> npcGUID;
+
+            WorldObject *const pNpc = (WorldObject*)ObjectAccessor::GetObjectByTypeMask(*session.GetPlayer(), npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            if (m_bot->GetDistance(pNpc) > 20.0f)
+                TellMaster("I'm too far away to repair items!");
+            else
+            {
+                TellMaster("Repairing my items.");
+                m_bot->DurabilityRepairAll(false, 0.0f, false);
+            }
+            return;
+        }
+
+        // handle emotes from the master
+        //case CMSG_EMOTE:
+        case CMSG_TEXT_EMOTE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+            uint32 emoteNum;
+            p >> emoteNum;
+
+            /* std::ostringstream out;
+               out << "emote is: " << emoteNum;
+               ChatHandler ch(m_master);
+               ch.SendSysMessage(out.str().c_str()); */
+
+            switch (emoteNum)
+            {
+                case TEXT_EMOTE_BOW:
+                {
+                    // Buff anyone who bows before me. Useful for players not in bot's group
+                    // How do I get correct target???
+                    //Player* const pPlayer = GetPlayerBot(m_master->GetTarget());
+                    //if (pPlayer->GetPlayerbotAI()->GetClassAI())
+                    //    pPlayer->GetPlayerbotAI()->GetClassAI()->BuffPlayer(pPlayer);
+                    return;
+                }
+                /*case TEXT_EMOTE_SALUTE:
+                {
+                    if (Player* const bot = session.GetPlayerBot(m_master->GetTarget()))
+                        if (PlayerbotAI *ai = bot->GetPlayerbotAI())
+                            ai->SendNotEquipList(*m_master);
+                    return;
+                }*/
+
+                   case TEXT_EMOTE_BONK:
+                   {
+                    Player* const pPlayer = m_master->GetSession()->GetPlayerBot(m_master->GetTarget());
+                    if (!pPlayer || !pPlayer->GetPlayerbotAI())
+                        return;
+                    PlayerbotAI* const pBot = pPlayer->GetPlayerbotAI();
+
+                    ChatHandler ch(m_master->GetSession());
+                    {
+                        std::ostringstream out;
+                        out << "time(0): " << time(0)
+                            << " m_ignoreAIUpdatesUntilTime: " << pBot->m_ignoreAIUpdatesUntilTime;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "m_TimeDoneEating: " << pBot->m_TimeDoneEating
+                            << " m_TimeDoneDrinking: " << pBot->m_TimeDoneDrinking;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "m_CurrentlyCastingSpellId: " << pBot->m_CurrentlyCastingSpellId;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "IsBeingTeleported() " << pBot->GetPlayer()->IsBeingTeleported();
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        bool tradeActive = (pBot->GetPlayer()->GetTrader()) ? true : false;
+                        out << "tradeActive: " << tradeActive;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "IsCharmed() " << pBot->GetPlayer()->IsCharmed();
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    return;
+                   }
+
+
+                case TEXT_EMOTE_EAT:
+                case TEXT_EMOTE_DRINK:
+                {
+                    Feast();
+                    return;
+                }
+
+                // emote to attack selected target
+                case TEXT_EMOTE_POINT:
+                {
+                    ObjectGuid attackOnGuid = m_master->GetTarget();
+                    if (!attackOnGuid)
+                        return;
+
+                    Unit* thingToAttack = ObjectAccessor::GetUnit(*m_master, attackOnGuid);
+                    if (!thingToAttack) return;
+
+                    if (!m_bot->IsFriendlyTo(thingToAttack) && m_bot->IsWithinLOSInMap(thingToAttack))
+                        GetCombatTarget(thingToAttack);
+                    return;
+                }
+
+                // emote to stay
+                case TEXT_EMOTE_STAND:
+                {
+                    ObjectGuid selection = m_master->GetTarget();
+                    if (!selection || selection == m_bot->GetGUID())
+                        SetMovementOrder(MOVEMENT_STAY);
+
+                    return;
+                }
+
+                // 324 is the followme emote (not defined in enum)
+                // if master has bot selected then only bot follows, else all bots follow
+                case 324:
+                case TEXT_EMOTE_WAVE:
+                {
+                    ObjectGuid selection = m_master->GetTarget();
+                    if (!selection || selection == m_bot->GetGUID())
+                        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+
+                    return;
+                }
+            }
+            return;
+        } /* EMOTE ends here */
+
+        case CMSG_GAMEOBJ_USE: // not sure if we still need this one
+        case CMSG_GAMEOBJ_REPORT_USE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);     // reset reader
+            ObjectGuid objGUID;
+            p >> objGUID;
+
+
+            GameObject *obj = m_master->GetMap()->GetGameObject(objGUID);
+            if (!obj)
+                return;
+
+            // add other go types here, i.e.:
+            // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+            if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+            {
+                TurnInQuests(obj);
+
+                // auto accept every available quest this NPC has
+                m_bot->PrepareQuestMenu(objGUID);
+                QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+                for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+                {
+                    QuestMenuItem const& qItem = questMenu.GetItem(iI);
+                    uint32 questID = qItem.QuestId;
+                    if (!AddQuest(questID, obj))
+                        m_bot->Whisper("Couldn't take quest", LANG_UNIVERSAL, m_master);
+                }
+            }
+        }
+        //break;
+        return;
+
+        case CMSG_QUESTGIVER_HELLO:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            ObjectGuid npcGUID;
+            p >> npcGUID;
+
+            WorldObject* pNpc = (WorldObject*)ObjectAccessor::GetObjectByTypeMask(*m_bot, npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            TurnInQuests(pNpc);
+
+            return;
+        }
+
+        // if master accepts a quest, bots should also try to accept quest
+        case CMSG_QUESTGIVER_ACCEPT_QUEST:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            ObjectGuid guid;
+            uint32 quest;
+            uint32 unk1;
+            p >> guid >> quest >> unk1;
+
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_QUESTGIVER_ACCEPT_QUEST npc = %s, quest = %u, unk1 = %u", guid.GetString().c_str(), quest, unk1);
+
+            Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+            if (qInfo)
+            {
+
+                if (m_bot->GetQuestStatus(quest) == QUEST_STATUS_COMPLETE)
+                    TellMaster("I already completed that quest.");
+                else if (!m_bot->CanTakeQuest(qInfo, false))
+                {
+                    if (!m_bot->SatisfyQuestStatus(qInfo, false))
+                        TellMaster("I already have that quest.");
+                    else
+                        TellMaster("I can't take that quest.");
+                }
+                else if (!m_bot->SatisfyQuestLog(false))
+                    TellMaster("My quest log is full.");
+                else if (!m_bot->CanAddQuest(qInfo, false))
+                    TellMaster("I can't take that quest because it requires that I take items, but my bags are full!");
+
+                else
+                {
+                    p.rpos(0);         // reset reader
+                    m_bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+                    TellMaster("Got the quest.");
+
+                    // build needed items if quest contains any
+                    for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+                    {
+                        if (qInfo->RequiredItemCount[i] > 0)
+                        {
+                            SetQuestNeedItems();
+                            break;
+                        }
+                    }
+
+                    // build needed creatures if quest contains any
+                    for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+                    {
+                        if (qInfo->RequiredNpcOrGoCount[i] > 0)
+                        {
+                            SetQuestNeedCreatures();
+                            break;
+                        }
+                    }
+                }
+            }
+            return;
+        }
+
+        case CMSG_AREATRIGGER:
+        {
+            WorldPacket p(packet);
+
+            if (m_bot->IsWithinDistInMap(m_master, 50))
+            {
+                p.rpos(0);         // reset reader
+                m_bot->GetSession()->HandleAreaTriggerOpcode(p);
+            }
+            return;
+        }
+
+        case CMSG_QUESTGIVER_COMPLETE_QUEST:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            uint32 quest;
+            ObjectGuid npcGUID;
+            p >> npcGUID >> quest;
+
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_QUESTGIVER_COMPLETE_QUEST npc = %s, quest = %u", npcGUID.GetString().c_str(), quest);
+
+            Creature* pNpc = ObjectAccessor::GetCreature(*m_master, npcGUID);
+            if (!pNpc)
+                return;
+
+            TurnInQuests(pNpc);
+            return;
+        }
+
+        case CMSG_LOOT_ROLL:
+        {
+            WorldPacket p(packet);    //WorldPacket packet for CMSG_LOOT_ROLL, (8+4+1)
+            ObjectGuid Guid;
+            uint32 NumberOfPlayers;
+            uint8 rollType;
+            p.rpos(0);              //reset packet pointer
+            p >> Guid;              //guid of the lootable target
+            p >> NumberOfPlayers;   //number of players invited to roll
+            p >> rollType;          //need,greed or pass on roll
+
+            Creature *c = m_master->GetMap()->GetCreature(Guid);
+            GameObject *g = m_master->GetMap()->GetGameObject(Guid);
+            if (!c && !g)
+                return;
+
+            Loot *loot = &c->loot;
+            if (!loot)
+                loot = &g->loot;
+
+            LootItem& lootItem = loot->items[NumberOfPlayers];
+
+            uint32 choice = 0;
+
+            Group* group = m_bot->GetGroup();
+            if (!group)
+                return;
+
+            ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(lootItem.itemid);
+            if (!pProto)
+                return;
+
+            if (CanStore())
+            {
+                if (m_bot->CanUseItem(pProto) == EQUIP_ERR_OK && IsItemUseful(lootItem.itemid))
+                    choice = 1;  // Need
+                else if (m_bot->HasSkill(SKILL_ENCHANTING))
+                    choice = 3;  // Disenchant
+                else
+                    choice = 2;  // Greed
+            }
+            else
+                choice = 0;  // Pass
+
+            group->CountRollVote(m_bot->GetGUID(), Guid, RollVote(choice));
+
+            switch (choice)
+            {
+                case ROLL_NEED:
+                    m_bot->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_NEED, 1);
+                    break;
+                case ROLL_GREED:
+                    m_bot->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_GREED, 1);
+                    break;
+            }
+            return;
+        }
+
+        // Handle GOSSIP activate actions, prior to GOSSIP select menu actions
+        case CMSG_GOSSIP_HELLO:
+        {
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_GOSSIP_HELLO");
+
+            WorldPacket p(packet);    //WorldPacket packet for CMSG_GOSSIP_HELLO, (8)
+            ObjectGuid guid;
+            p.rpos(0);                //reset packet pointer
+            p >> guid;
+
+
+            Creature *pCreature = m_bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
+            if (!pCreature)
+            {
+                //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: HandleMasterIncomingPacket - Received  CMSG_GOSSIP_HELLO object %s not found or you can't interact with him.", pCreature ? pCreature->GetName() : (char*)guid);
+                return;
+            }
+
+            GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(pCreature->GetCreatureTemplate()->GossipMenuId);
+            for (GossipMenuItemsContainer::const_iterator itr = pMenuItemBounds.first; itr != pMenuItemBounds.second; ++itr)
+            {
+                uint32 npcflags = pCreature->GetUInt32Value(UNIT_NPC_FLAGS);
+
+                if (!(itr->second.OptionNpcflag & npcflags))
+                    continue;
+
+                switch (itr->second.OptionType)
+                {
+                    case GOSSIP_OPTION_TAXIVENDOR:
+                    {
+                        // bot->GetPlayerbotAI()->TellMaster("PlayerbotAI:GOSSIP_OPTION_TAXIVENDOR");
+                        m_bot->GetSession()->SendLearnNewTaxiNode(pCreature);
+                        break;
+                    }
+                    case GOSSIP_OPTION_QUESTGIVER:
+                    {
+                        // TellMaster("PlayerbotAI:GOSSIP_OPTION_QUESTGIVER");
+                        TurnInQuests(pCreature);
+                        break;
+                    }
+                    case GOSSIP_OPTION_VENDOR:
+                    {
+                        // bot->GetPlayerbotAI()->TellMaster("PlayerbotAI:GOSSIP_OPTION_VENDOR");
+                        if (!m_confSellGarbage)
+                            return;
+
+                        SellGarbage(*m_bot);
+                        break;
+                    }
+                    case GOSSIP_OPTION_STABLEPET:
+                    {
+                        // TellMaster("PlayerbotAI:GOSSIP_OPTION_STABLEPET");
+                        break;
+                    }
+                    case GOSSIP_OPTION_AUCTIONEER:
+                    {
+                        // TellMaster("PlayerbotAI:GOSSIP_OPTION_AUCTIONEER");
+                        break;
+                    }
+                    case GOSSIP_OPTION_BANKER:
+                    {
+                        // TellMaster("PlayerbotAI:GOSSIP_OPTION_BANKER");
+                        break;
+                    }
+                    case GOSSIP_OPTION_INNKEEPER:
+                    {
+                        // TellMaster("PlayerbotAI:GOSSIP_OPTION_INNKEEPER");
+                        break;
+                    }
+                }
+            }
+            return;
+        }
+
+        case CMSG_SPIRIT_HEALER_ACTIVATE:
+        {
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_SPIRIT_HEALER_ACTIVATE SpiritHealer is resurrecting the Player %s",m_master->GetName());
+            Group *grp = m_bot->GetGroup();
+            if (grp)
+                grp->RemoveMember(m_bot->GetGUID(), GROUP_REMOVEMETHOD_KICK);
+            return;
+        }
+
+        case CMSG_LIST_INVENTORY:
+        {
+            if (m_confSellGarbage)
+                return;
+
+            WorldPacket p(packet);
+            p.rpos(0);  // reset reader
+            ObjectGuid npcGUID;
+            p >> npcGUID;
+
+            WorldObject* pNpc = (WorldObject*)ObjectAccessor::GetObjectByTypeMask(*m_bot, npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+
+            if (!pNpc)
+                return;
+            if (!m_bot->IsInMap(pNpc))
+            {
+                TellMaster("I'm too far away to sell items!");
+                return;
+            }
+            else
+                SellGarbage(*m_bot);
+            return;
+        }
+
+            /*
+               case CMSG_NAME_QUERY:
+               case MSG_MOVE_START_FORWARD:
+               case MSG_MOVE_STOP:
+               case MSG_MOVE_SET_FACING:
+               case MSG_MOVE_START_STRAFE_LEFT:
+               case MSG_MOVE_START_STRAFE_RIGHT:
+               case MSG_MOVE_STOP_STRAFE:
+               case MSG_MOVE_START_BACKWARD:
+               case MSG_MOVE_HEARTBEAT:
+               case CMSG_STANDSTATECHANGE:
+               case CMSG_QUERY_TIME:
+               case CMSG_CREATURE_QUERY:
+               case CMSG_GAMEOBJECT_QUERY:
+               case MSG_MOVE_JUMP:
+               case MSG_MOVE_FALL_LAND:
+                return;
+
+               default:
+               {
+                const char* oc = LookupOpcodeName(packet.GetOpcode());
+                // ChatHandler ch(m_master);
+                // ch.SendSysMessage(oc);
+
+                std::ostringstream out;
+                out << "masterin: " << oc;
+                //sLog->outError(out.str().c_str());
+               }
+             */
+    }
+}
+
+float PlayerbotClassAI::GetCombatDistance(const Unit* target) const
+{
+    float dist = target->GetCombatReach();
+    if (dist < 0.1f)
+        dist = DEFAULT_COMBAT_REACH;
+    return dist;
+    //float radius = target->GetCombatReach() + m_bot->GetCombatReach();
+    //float dx = m_bot->GetPositionX() - target->GetPositionX();
+    //float dy = m_bot->GetPositionY() - target->GetPositionY();
+    //float dz = m_bot->GetPositionZ() - target->GetPositionZ();
+    //float dist = sqrt((dx*dx) + (dy*dy) + (dz*dz)) - radius;
+    //return ( dist > 0 ? dist : 0);
+}
+
+bool PlayerbotClassAI::HasAuraName(Unit *unit, uint32 spellId, ObjectGuid casterGuid) const
+{
+    const SpellInfo *const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+        return false;
+    uint8 loc = m_master->GetSession()->GetSessionDbcLocale();
+    const std::string  name = pSpellInfo->SpellName[loc];
+    if (name.length() == 0)
+        return false;
+    return HasAuraName(unit, name, casterGuid);
+}
+
+bool PlayerbotClassAI::HasAuraName(Unit *target, std::string spell, ObjectGuid casterGuid) const
+{
+    uint8 loc = m_master->GetSession()->GetSessionDbcLocale();
+
+    Unit::AuraMap const &vAuras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const *spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName[loc];
+        if (spell == name)
+            if (casterGuid == 0 || (casterGuid != 0 && casterGuid == itr->second->GetCasterGUID())) //only if correct caster casted it
+                return true;
+    }
+    return false;
+};
+
+//See MainSpec enum in PlayerbotAI.h for details on class return values
+uint32 Player::GetSpec()
+{
+    uint32 row = 0, spec = 0;//disabled
+
+    //Iterate through the 3 talent trees
+    for (uint32 i = 0; i < 3; ++i)
+    {
+        for (PlayerTalentMap::iterator iter = m_talents[m_activeSpec]->begin(); iter != m_talents[m_activeSpec]->end(); ++iter)
+        {
+            TalentEntry const *talentId = sTalentStore.LookupEntry((*iter).first);
+            if (!talentId)
+                continue;
+
+            //If current talent is deeper into a tree, that is our new max talent
+            if (talentId->Row > row)
+            {
+                row = talentId->Row;
+
+                //Set the tree the deepest talent is on
+                spec = talentId->TalentTab;
+            }
+        }
+    }
+
+    //Return the tree with the deepest talent
+    return spec;
+}
+
+void Player::UpdateMail()
+{
+    // save money,items and mail to prevent cheating
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    //SaveGoldToDB(trans);
+    SaveInventoryAndGoldToDB(trans);
+    _SaveMail(trans);
+    CharacterDatabase.CommitTransaction(trans);
+}
+
+bool Player::requiredQuests(const char* pQuestIdString)
+{
+    if (pQuestIdString != NULL)
+    {
+        unsigned int pos = 0;
+        unsigned int id;
+        std::string confString(pQuestIdString);
+        chompAndTrim(confString);
+        while (getNextQuestId(confString, pos, id))
+        {
+            QuestStatus status = GetQuestStatus(id);
+            if (status == QUEST_STATUS_COMPLETE)
+                return true;
+        }
+    }
+    return false;
+}
+
+void Player::chompAndTrim(std::string& str)
+{
+    while (str.length() > 0)
+    {
+        char lc = str[str.length() - 1];
+        if (lc == '\r' || lc == '\n' || lc == ' ' || lc == '"' || lc == '\'')
+            str = str.substr(0, str.length() - 1);
+        else
+            break;
+    }
+
+    while (str.length() > 0)
+    {
+        char lc = str[0];
+        if (lc == ' ' || lc == '"' || lc == '\'')
+            str = str.substr(1, str.length() - 1);
+        else
+            break;
+    }
+}
+
+bool Player::getNextQuestId(const std::string& pString, unsigned int& pStartPos, unsigned int& pId)
+{
+    bool result = false;
+    unsigned int i;
+    for (i = pStartPos; i < pString.size(); ++i)
+    {
+        if (pString[i] == ',')
+            break;
+    }
+    if (i > pStartPos)
+    {
+        std::string idString = pString.substr(pStartPos, i - pStartPos);
+        pStartPos = i + 1;
+        chompAndTrim(idString);
+        pId = atoi(idString.c_str());
+        result = true;
+    }
+    return(result);
+}
+
+void Player::skill(std::list<uint32>& m_spellsToLearn)
+{
+    for (SkillStatusMap::const_iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
+        if (itr->second.uState != SKILL_DELETED)
+            m_spellsToLearn.push_back(itr->first);
+}
+
+void Player::MakeTalentGlyphLink(std::ostringstream &out)
+{
+    // |cff4e96f7|Htalent:1396:4|h[Unleashed Fury]|h|r
+    // |cff66bbff|Hglyph:23:460|h[Glyph of Fortitude]|h|r
+
+    if (m_specsCount)
+        // loop through all specs (only 1 for now)
+        for (uint8 specIdx = 0; specIdx < m_specsCount; ++specIdx)
+        {
+            // find class talent tabs (all players have 3 talent tabs)
+            uint32 const* talentTabIds = GetTalentTabPages(getClass());
+
+            out << "\n" << "Active Talents ";
+
+            for (uint8 i = 0; i < 3; ++i)
+            {
+                uint32 talentTabId = talentTabIds[i];
+                for (PlayerTalentMap::iterator iter = m_talents[specIdx]->begin(); iter != m_talents[specIdx]->end(); ++iter)
+                {
+                    PlayerTalent* talent = (*iter).second;
+                    TalentEntry const *talentId = sTalentStore.LookupEntry((*iter).first);
+                    if (!talentId)
+                        continue;
+
+                    if (talent->state == PLAYERSPELL_REMOVED)
+                        continue;
+
+                    // skip another tab talents
+                    if (talentId->TalentTab != talentTabId)
+                        continue;
+
+                    SpellInfo const *_spellEntry;
+                    int8 rank = 0;
+                    for (rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+                    {
+                        if (talentId->RankID[rank] == 0)
+                            continue;
+                        _spellEntry = sSpellMgr->GetSpellInfo(talentId->RankID[rank]);
+                        if (!_spellEntry)
+                            continue;
+                        if (m_bot->HasSpell(talentId->RankID[rank]))
+                            break;
+                    }
+
+                    if (rank == 0)
+                        continue;
+
+                    _spellEntry = sSpellMgr->GetSpellInfo(talentId->RankID[rank]);
+
+                    out << "|cff4e96f7|Htalent:" << talentId->TalentID << ":" << rank
+                        << " |h[" << _spellEntry->SpellName[GetSession()->GetSessionDbcLocale()] << "]|h|r";
+                }
+            }
+
+            uint32 freepoints = GetFreeTalentPoints();
+
+            out << " Unspent points : ";
+            out << "|h|cffff0000" << freepoints << "|h|r";
+            out << "\n" << "Active Glyphs ";
+
+            // GlyphProperties.dbc
+            for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
+            {
+                GlyphPropertiesEntry const* glyph = sGlyphPropertiesStore.LookupEntry(m_Glyphs[specIdx][i]);
+                if (!glyph)
+                    continue;
+
+                SpellInfo const *spell_entry = sSpellMgr->GetSpellInfo(glyph->SpellId);
+
+                out << "|cff66bbff|Hglyph:" << GetGlyphSlot(i) << ":" << m_Glyphs[specIdx][i]
+                    << " |h[" << spell_entry->SpellName[GetSession()->GetSessionDbcLocale()] << "]|h|r";
+
+            }
+        }
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotAI.h b/src/server/game/AI/PlayerBots/PlayerbotAI.h
new file mode 100644
index 0000000..01df0c8
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotAI.h
@@ -0,0 +1,2130 @@
+#ifndef _PLAYERBOTAI_H
+#define _PLAYERBOTAI_H
+
+#include "Chat.h"
+
+class PlayerbotAI;
+class PlayerbotClassAI;
+
+// ChatHandler already implements some useful commands the master can call on bots
+// These commands are protected inside the ChatHandler class so this class provides access to the commands
+// we'd like to call on our bots
+class PlayerbotChatHandler : protected ChatHandler
+{
+public:
+    PlayerbotChatHandler(WorldSession* pMasterSession) : ChatHandler(pMasterSession) {}
+    bool revive(Player& botPlayer);
+    bool teleport(const Player& botPlayer);
+    bool teleport(Player& botPlayer, WorldObject& obj);
+    void sysmessage(const char* str) { SendSysMessage(str); }
+    bool dropQuest(char* str) { return HandleQuestRemove(this, str); }
+private:
+    static bool HandleSummonCommand(ChatHandler* handler, char const* args);
+    static bool HandleQuestRemove(ChatHandler* handler, const char* args);
+};
+
+enum Special
+{
+    SPELL_ROOT              = 42716 //Self Root Forever (No Visual)
+};
+
+enum SpellSpecific
+{
+    SPELL_NORMAL            = 0,
+    SPELL_SEAL              = 1,
+    SPELL_BLESSING          = 2,
+    SPELL_AURA              = 3,
+    SPELL_STING             = 4,
+    SPELL_CURSE             = 5,
+    SPELL_ASPECT            = 6,
+    SPELL_TRACKER           = 7,
+    SPELL_WARLOCK_ARMOR     = 8,
+    SPELL_MAGE_ARMOR        = 9,
+    SPELL_ELEMENTAL_SHIELD  = 10,
+    SPELL_MAGE_POLYMORPH    = 11,
+    SPELL_POSITIVE_SHOUT    = 12,
+    SPELL_JUDGEMENT         = 13,
+    SPELL_BATTLE_ELIXIR     = 14,
+    SPELL_GUARDIAN_ELIXIR   = 15,
+    SPELL_FLASK_ELIXIR      = 16,
+    SPELL_PRESENCE          = 17,
+    SPELL_HAND              = 18,
+    SPELL_WELL_FED          = 19,
+    SPELL_FOOD              = 20,
+    SPELL_WATER             = 21,
+    SPELL_FOOD_AND_DRINK    = 22,
+    SPELL_UA_IMMOLATE       = 23,                           // Unstable Affliction and Immolate
+};
+
+enum RacialTraits
+{
+    ARCANE_TORRENT_MANA_CLASSES    = 28730,
+    ARCANE_TORRENT_DEATH_KNIGHT    = 50613,
+    ARCANE_TORRENT_ROGUE           = 25046,
+    BERSERKING_ALL                 = 26297,
+    BLOOD_FURY_MELEE_CLASSES       = 20572,
+    BLOOD_FURY_WARLOCK             = 33702,
+    BLOOD_FURY_SHAMAN              = 33697,
+    ESCAPE_ARTIST_ALL              = 20589,
+    EVERY_MAN_FOR_HIMSELF_ALL      = 59752,
+    GIFT_OF_THE_NAARU_DEATH_KNIGHT = 59545,
+    GIFT_OF_THE_NAARU_HUNTER       = 59543,
+    GIFT_OF_THE_NAARU_MAGE         = 59548,
+    GIFT_OF_THE_NAARU_PALADIN      = 59542,
+    GIFT_OF_THE_NAARU_PRIEST       = 59544,
+    GIFT_OF_THE_NAARU_SHAMAN       = 59547,
+    GIFT_OF_THE_NAARU_WARRIOR      = 28880,
+    SHADOWMELD_ALL                 = 58984,
+    STONEFORM_ALL                  = 20594,
+    WAR_STOMP_ALL                  = 20549,
+    WILL_OF_THE_FORSAKEN_ALL       = 7744
+};
+
+enum BotProfessionSpells
+{
+    ALCHEMY_1                      = 2259,
+    BLACKSMITHING_1                = 2018,
+    COOKING_1                      = 2550,
+    ENCHANTING_1                   = 7411,
+    ENGINEERING_1                  = 4036,
+    FIRST_AID_1                    = 3273,
+    FISHING_1                      = 7620,
+    HERB_GATHERING_1               = 2366,
+    INSCRIPTION_1                  = 45357,
+    JEWELCRAFTING_1                = 25229,
+    MINING_1                       = 2575,
+    SKINNING_1                     = 8613,
+    TAILORING_1                    = 3908,
+    MILLING_1                      = 51005,
+    DISENCHANTING_1                = 13262,
+    PROSPECTING_1                  = 31252
+};
+
+enum TalentsDeathKnight  // 0x020
+{
+    DEATHKNIGHT_BUTCHERY                        = 1939,  // TabId = 398, Tab = 0, Row = 0, Column = 0
+    DEATHKNIGHT_SUBVERSION                      = 1945,  // TabId = 398, Tab = 0, Row = 0, Column = 1
+    DEATHKNIGHT_BLADE_BARRIER                   = 2017,  // TabId = 398, Tab = 0, Row = 0, Column = 2
+    DEATHKNIGHT_BLADED_ARMOR                    = 1938,  // TabId = 398, Tab = 0, Row = 1, Column = 0
+    DEATHKNIGHT_SCENT_OF_BLOOD                  = 1948,  // TabId = 398, Tab = 0, Row = 1, Column = 1
+    DEATHKNIGHT_TWOHANDED_WEAPON_SPECIALIZATION = 2217,  // TabId = 398, Tab = 0, Row = 1, Column = 2
+    DEATHKNIGHT_RUNE_TAP                        = 1941,  // TabId = 398, Tab = 0, Row = 2, Column = 0
+    DEATHKNIGHT_DARK_CONVICTION                 = 1943,  // TabId = 398, Tab = 0, Row = 2, Column = 1
+    DEATHKNIGHT_DEATH_RUNE_MASTERY              = 2086,  // TabId = 398, Tab = 0, Row = 2, Column = 2
+    DEATHKNIGHT_IMPROVED_RUNE_TAP               = 1942,  // TabId = 398, Tab = 0, Row = 3, Column = 0
+    DEATHKNIGHT_SPELL_DEFLECTION                = 2018,  // TabId = 398, Tab = 0, Row = 3, Column = 2
+    DEATHKNIGHT_VENDETTA                        = 1953,  // TabId = 398, Tab = 0, Row = 3, Column = 3
+    DEATHKNIGHT_BLOODY_STRIKES                  = 2015,  // TabId = 398, Tab = 0, Row = 4, Column = 0
+    DEATHKNIGHT_VETERAN_OF_THE_THIRD_WAR        = 1950,  // TabId = 398, Tab = 0, Row = 4, Column = 2
+    DEATHKNIGHT_MARK_OF_BLOOD                   = 1949,  // TabId = 398, Tab = 0, Row = 4, Column = 3
+    DEATHKNIGHT_BLOODY_VENGEANCE                = 1944,  // TabId = 398, Tab = 0, Row = 5, Column = 1
+    DEATHKNIGHT_ABOMINATIONS_MIGHT              = 2105,  // TabId = 398, Tab = 0, Row = 5, Column = 2
+    DEATHKNIGHT_BLOOD_WORMS                     = 1960,  // TabId = 398, Tab = 0, Row = 6, Column = 0
+    DEATHKNIGHT_HYSTERIA                        = 1954,  // TabId = 398, Tab = 0, Row = 6, Column = 1
+    DEATHKNIGHT_IMPROVED_BLOOD_PRESENCE         = 1936,  // TabId = 398, Tab = 0, Row = 6, Column = 2
+    DEATHKNIGHT_IMPROVED_DEATH_STRIKE           = 2259,  // TabId = 398, Tab = 0, Row = 7, Column = 0
+    DEATHKNIGHT_SUDDEN_DOOM                     = 1955,  // TabId = 398, Tab = 0, Row = 7, Column = 1
+    DEATHKNIGHT_VAMPIRIC_BLOOD                  = 2019,  // TabId = 398, Tab = 0, Row = 7, Column = 2
+    DEATHKNIGHT_WILL_OF_THE_NECROPOLIS          = 1959,  // TabId = 398, Tab = 0, Row = 8, Column = 0
+    DEATHKNIGHT_HEART_STRIKE                    = 1957,  // TabId = 398, Tab = 0, Row = 8, Column = 1
+    DEATHKNIGHT_MIGHT_OF_MOGRAINE               = 1958,  // TabId = 398, Tab = 0, Row = 8, Column = 2
+    DEATHKNIGHT_BLOOD_GORGED                    = 2034,  // TabId = 398, Tab = 0, Row = 9, Column = 1
+    DEATHKNIGHT_DANCING_RUNE_WEAPON             = 1961,  // TabId = 398, Tab = 0, Row = 10, Column = 1
+    DEATHKNIGHT_IMPROVED_ICY_TOUCH              = 2031,  // TabId = 399, Tab = 1, Row = 0, Column = 0
+    DEATHKNIGHT_RUNIC_POWER_MASTERY             = 2020,  // TabId = 399, Tab = 1, Row = 0, Column = 1
+    DEATHKNIGHT_TOUGHNESS                       = 1968,  // TabId = 399, Tab = 1, Row = 0, Column = 2
+    DEATHKNIGHT_ICY_REACH                       = 2035,  // TabId = 399, Tab = 1, Row = 1, Column = 1
+    DEATHKNIGHT_BLACK_ICE                       = 1973,  // TabId = 399, Tab = 1, Row = 1, Column = 2
+    DEATHKNIGHT_NERVES_OF_COLD_STEEL            = 2022,  // TabId = 399, Tab = 1, Row = 1, Column = 3
+    DEATHKNIGHT_ICY_TALONS                      = 2042,  // TabId = 399, Tab = 1, Row = 2, Column = 0
+    DEATHKNIGHT_LICHBORNE                       = 2215,  // TabId = 399, Tab = 1, Row = 2, Column = 1
+    DEATHKNIGHT_ANNIHILATION                    = 2048,  // TabId = 399, Tab = 1, Row = 2, Column = 2
+    DEATHKNIGHT_KILLING_MACHINE                 = 2044,  // TabId = 399, Tab = 1, Row = 3, Column = 1
+    DEATHKNIGHT_CHILL_OF_THE_GRAVE              = 1981,  // TabId = 399, Tab = 1, Row = 3, Column = 2
+    DEATHKNIGHT_ENDLESS_WINTER                  = 1971,  // TabId = 399, Tab = 1, Row = 3, Column = 3
+    DEATHKNIGHT_FRIGID_DREADPLATE               = 1990,  // TabId = 399, Tab = 1, Row = 4, Column = 1
+    DEATHKNIGHT_GLACIER_ROT                     = 2030,  // TabId = 399, Tab = 1, Row = 4, Column = 2
+    DEATHKNIGHT_DEATHCHILL                      = 1980,  // TabId = 399, Tab = 1, Row = 4, Column = 3
+    DEATHKNIGHT_IMPROVED_ICY_TALONS             = 2223,  // TabId = 399, Tab = 1, Row = 5, Column = 0
+    DEATHKNIGHT_MERCILESS_COMBAT                = 1993,  // TabId = 399, Tab = 1, Row = 5, Column = 1
+    DEATHKNIGHT_RIME                            = 1992,  // TabId = 399, Tab = 1, Row = 5, Column = 2
+    DEATHKNIGHT_CHILLBLAINS                     = 2260,  // TabId = 399, Tab = 1, Row = 6, Column = 0
+    DEATHKNIGHT_HUNGERING_COLD                  = 1999,  // TabId = 399, Tab = 1, Row = 6, Column = 1
+    DEATHKNIGHT_IMPROVED_FROST_PRESENCE         = 2029,  // TabId = 399, Tab = 1, Row = 6, Column = 2
+    DEATHKNIGHT_THREAT_OF_THASSARIAN            = 2284,  // TabId = 399, Tab = 1, Row = 7, Column = 0
+    DEATHKNIGHT_BLOOD_OF_THE_NORTH              = 2210,  // TabId = 399, Tab = 1, Row = 7, Column = 1
+    DEATHKNIGHT_UNBREAKABLE_ARMOR               = 1979,  // TabId = 399, Tab = 1, Row = 7, Column = 2
+    DEATHKNIGHT_ACCLIMATION                     = 1997,  // TabId = 399, Tab = 1, Row = 8, Column = 0
+    DEATHKNIGHT_FROST_STRIKE                    = 1975,  // TabId = 399, Tab = 1, Row = 8, Column = 1
+    DEATHKNIGHT_GUILE_OF_GOREFIEND              = 2040,  // TabId = 399, Tab = 1, Row = 8, Column = 2
+    DEATHKNIGHT_TUNDRA_STALKER                  = 1998,  // TabId = 399, Tab = 1, Row = 9, Column = 1
+    DEATHKNIGHT_HOWLING_BLAST                   = 1989,  // TabId = 399, Tab = 1, Row = 10, Column = 1
+    DEATHKNIGHT_VICIOUS_STRIKES                 = 2082,  // TabId = 400, Tab = 2, Row = 0, Column = 0
+    DEATHKNIGHT_VIRULENCE                       = 1932,  // TabId = 400, Tab = 2, Row = 0, Column = 1
+    DEATHKNIGHT_ANTICIPATION                    = 2218,  // TabId = 400, Tab = 2, Row = 0, Column = 2
+    DEATHKNIGHT_EPIDEMIC                        = 1963,  // TabId = 400, Tab = 2, Row = 1, Column = 0
+    DEATHKNIGHT_MORBIDITY                       = 1933,  // TabId = 400, Tab = 2, Row = 1, Column = 1
+    DEATHKNIGHT_UNHOLY_COMMAND                  = 2025,  // TabId = 400, Tab = 2, Row = 1, Column = 2
+    DEATHKNIGHT_RAVENOUS_DEAD                   = 1934,  // TabId = 400, Tab = 2, Row = 1, Column = 3
+    DEATHKNIGHT_OUTBREAK                        = 2008,  // TabId = 400, Tab = 2, Row = 2, Column = 0
+    DEATHKNIGHT_NECROSIS                        = 2047,  // TabId = 400, Tab = 2, Row = 2, Column = 1
+    DEATHKNIGHT_CORPSE_EXPLOSION                = 1985,  // TabId = 400, Tab = 2, Row = 2, Column = 2
+    DEATHKNIGHT_ON_A_PALE_HORSE                 = 2039,  // TabId = 400, Tab = 2, Row = 3, Column = 1
+    DEATHKNIGHT_BLOODCAKED_BLADE                = 2004,  // TabId = 400, Tab = 2, Row = 3, Column = 2
+    DEATHKNIGHT_NIGHT_OF_THE_DEAD               = 2225,  // TabId = 400, Tab = 2, Row = 3, Column = 3
+    DEATHKNIGHT_UNHOLY_BLIGHT                   = 1996,  // TabId = 400, Tab = 2, Row = 4, Column = 0
+    DEATHKNIGHT_IMPURITY                        = 2005,  // TabId = 400, Tab = 2, Row = 4, Column = 1
+    DEATHKNIGHT_DIRGE                           = 2011,  // TabId = 400, Tab = 2, Row = 4, Column = 2
+    DEATHKNIGHT_DESECRATION                     = 2226,  // TabId = 400, Tab = 2, Row = 5, Column = 0
+    DEATHKNIGHT_MAGIC_SUPPRESSION               = 2009,  // TabId = 400, Tab = 2, Row = 5, Column = 1
+    DEATHKNIGHT_REAPING                         = 2001,  // TabId = 400, Tab = 2, Row = 5, Column = 2
+    DEATHKNIGHT_MASTER_OF_GHOULS                = 1984,  // TabId = 400, Tab = 2, Row = 5, Column = 3
+    DEATHKNIGHT_DESOLATION                      = 2285,  // TabId = 400, Tab = 2, Row = 6, Column = 0
+    DEATHKNIGHT_ANTIMAGIC_ZONE                  = 2221,  // TabId = 400, Tab = 2, Row = 6, Column = 1
+    DEATHKNIGHT_IMPROVED_UNHOLY_PRESENCE        = 2013,  // TabId = 400, Tab = 2, Row = 6, Column = 2
+    DEATHKNIGHT_GHOUL_FRENZY                    = 2085,  // TabId = 400, Tab = 2, Row = 6, Column = 3
+    DEATHKNIGHT_CRYPT_FEVER                     = 1962,  // TabId = 400, Tab = 2, Row = 7, Column = 1
+    DEATHKNIGHT_BONE_SHIELD                     = 2007,  // TabId = 400, Tab = 2, Row = 7, Column = 2
+    DEATHKNIGHT_WANDERING_PLAGUE                = 2003,  // TabId = 400, Tab = 2, Row = 8, Column = 0
+    DEATHKNIGHT_EBON_PLAGUEBRINGER              = 2043,  // TabId = 400, Tab = 2, Row = 8, Column = 1
+    DEATHKNIGHT_SCOURGE_STRIKE                  = 2216,  // TabId = 400, Tab = 2, Row = 8, Column = 2
+    DEATHKNIGHT_RAGE_OF_RIVENDARE               = 2036,  // TabId = 400, Tab = 2, Row = 9, Column = 1
+    DEATHKNIGHT_SUMMON_GARGOYLE                 = 2000   // TabId = 400, Tab = 2, Row = 10, Column = 1
+};
+
+enum TalentsDruid  // 0x400
+{
+    DRUID_FEROCITY                              = 796,   // TabId = 281, Tab = 1, Row = 0, Column = 1
+    DRUID_FERAL_AGGRESSION                      = 795,   // TabId = 281, Tab = 1, Row = 0, Column = 2
+    DRUID_FERAL_INSTINCT                        = 799,   // TabId = 281, Tab = 1, Row = 1, Column = 0
+    DRUID_SAVAGE_FURY                           = 805,   // TabId = 281, Tab = 1, Row = 1, Column = 1
+    DRUID_THICK_HIDE                            = 794,   // TabId = 281, Tab = 1, Row = 1, Column = 2
+    DRUID_FERAL_SWIFTNESS                       = 807,   // TabId = 281, Tab = 1, Row = 2, Column = 0
+    DRUID_SURVIVAL_INSTINCTS                    = 1162,  // TabId = 281, Tab = 1, Row = 2, Column = 1
+    DRUID_SHARPENED_CLAWS                       = 798,   // TabId = 281, Tab = 1, Row = 2, Column = 2
+    DRUID_SHREDDING_ATTACKS                     = 802,   // TabId = 281, Tab = 1, Row = 3, Column = 0
+    DRUID_PREDATORY_STRIKES                     = 803,   // TabId = 281, Tab = 1, Row = 3, Column = 1
+    DRUID_PRIMAL_FURY                           = 801,   // TabId = 281, Tab = 1, Row = 3, Column = 2
+    DRUID_PRIMAL_PRECISION                      = 1914,  // TabId = 281, Tab = 1, Row = 3, Column = 3
+    DRUID_BRUTAL_IMPACT                         = 797,   // TabId = 281, Tab = 1, Row = 4, Column = 0
+    DRUID_FERAL_CHARGE                          = 804,   // TabId = 281, Tab = 1, Row = 4, Column = 2
+    DRUID_NURTURING_INSTINCT                    = 1792,  // TabId = 281, Tab = 1, Row = 4, Column = 3
+    DRUID_NATURAL_REACTION                      = 2242,  // TabId = 281, Tab = 1, Row = 5, Column = 0
+    DRUID_HEART_OF_THE_WILD                     = 808,   // TabId = 281, Tab = 1, Row = 5, Column = 1
+    DRUID_SURVIVAL_OF_THE_FITTEST               = 1794,  // TabId = 281, Tab = 1, Row = 5, Column = 2
+    DRUID_LEADER_OF_THE_PACK                    = 809,   // TabId = 281, Tab = 1, Row = 6, Column = 1
+    DRUID_IMPROVED_LEADER_OF_THE_PACK           = 1798,  // TabId = 281, Tab = 1, Row = 6, Column = 2
+    DRUID_PRIMAL_TENACITY                       = 1793,  // TabId = 281, Tab = 1, Row = 6, Column = 3
+    DRUID_PROTECTOR_OF_THE_PACK                 = 2241,  // TabId = 281, Tab = 1, Row = 7, Column = 0
+    DRUID_PREDATORY_INSTINCTS                   = 1795,  // TabId = 281, Tab = 1, Row = 7, Column = 2
+    DRUID_INFECTED_WOUNDS                       = 1919,  // TabId = 281, Tab = 1, Row = 7, Column = 3
+    DRUID_KING_OF_THE_JUNGLE                    = 1921,  // TabId = 281, Tab = 1, Row = 8, Column = 0
+    DRUID_MANGLE                                = 1796,  // TabId = 281, Tab = 1, Row = 8, Column = 1
+    DRUID_IMPROVED_MANGLE                       = 1920,  // TabId = 281, Tab = 1, Row = 8, Column = 2
+    DRUID_REND_AND_TEAR                         = 1918,  // TabId = 281, Tab = 1, Row = 9, Column = 1
+    DRUID_PRIMAL_GORE                           = 2266,  // TabId = 281, Tab = 1, Row = 9, Column = 2
+    DRUID_BERSERK                               = 1927,  // TabId = 281, Tab = 1, Row = 10, Column = 1
+    DRUID_IMPROVED_MARK_OF_THE_WILD             = 821,   // TabId = 282, Tab = 2, Row = 0, Column = 0
+    DRUID_NATURES_FOCUS                         = 823,   // TabId = 282, Tab = 2, Row = 0, Column = 1
+    DRUID_FUROR                                 = 822,   // TabId = 282, Tab = 2, Row = 0, Column = 2
+    DRUID_NATURALIST                            = 824,   // TabId = 282, Tab = 2, Row = 1, Column = 0
+    DRUID_SUBTLETY                              = 841,   // TabId = 282, Tab = 2, Row = 1, Column = 1
+    DRUID_NATURAL_SHAPESHIFTER                  = 826,   // TabId = 282, Tab = 2, Row = 1, Column = 2
+    DRUID_INTENSITY                             = 829,   // TabId = 282, Tab = 2, Row = 2, Column = 0
+    DRUID_OMEN_OF_CLARITY                       = 827,   // TabId = 282, Tab = 2, Row = 2, Column = 1
+    DRUID_MASTER_SHAPESHIFTER                   = 1915,  // TabId = 282, Tab = 2, Row = 2, Column = 2
+    DRUID_TRANQUIL_SPIRIT                       = 843,   // TabId = 282, Tab = 2, Row = 3, Column = 1
+    DRUID_IMPROVED_REJUVENATION                 = 830,   // TabId = 282, Tab = 2, Row = 3, Column = 2
+    DRUID_NATURES_SWIFTNESS                     = 831,   // TabId = 282, Tab = 2, Row = 4, Column = 0
+    DRUID_GIFT_OF_NATURE                        = 828,   // TabId = 282, Tab = 2, Row = 4, Column = 1
+    DRUID_IMPROVED_TRANQUILITY                  = 842,   // TabId = 282, Tab = 2, Row = 4, Column = 3
+    DRUID_EMPOWERED_TOUCH                       = 1788,  // TabId = 282, Tab = 2, Row = 5, Column = 0
+    DRUID_NATURES_BOUNTY                        = 825,   // TabId = 282, Tab = 2, Row = 5, Column = 2
+    DRUID_LIVING_SPIRIT                         = 1797,  // TabId = 282, Tab = 2, Row = 6, Column = 0
+    DRUID_SWIFTMEND                             = 844,   // TabId = 282, Tab = 2, Row = 6, Column = 1
+    DRUID_NATURAL_PERFECTION                    = 1790,  // TabId = 282, Tab = 2, Row = 6, Column = 2
+    DRUID_EMPOWERED_REJUVENATION                = 1789,  // TabId = 282, Tab = 2, Row = 7, Column = 1
+    DRUID_LIVING_SEED                           = 1922,  // TabId = 282, Tab = 2, Row = 7, Column = 2
+    DRUID_REVITALIZE                            = 1929,  // TabId = 282, Tab = 2, Row = 8, Column = 0
+    DRUID_TREE_OF_LIFE                          = 1791,  // TabId = 282, Tab = 2, Row = 8, Column = 1
+    DRUID_IMPROVED_TREE_OF_LIFE                 = 1930,  // TabId = 282, Tab = 2, Row = 8, Column = 2
+    DRUID_IMPROVED_BARKSKIN                     = 2264,  // TabId = 282, Tab = 2, Row = 9, Column = 0
+    DRUID_GIFT_OF_THE_EARTHMOTHER               = 1916,  // TabId = 282, Tab = 2, Row = 9, Column = 2
+    DRUID_WILD_GROWTH                           = 1917,  // TabId = 282, Tab = 2, Row = 10, Column = 1
+    DRUID_STARLIGHT_WRATH                       = 762,   // TabId = 283, Tab = 0, Row = 0, Column = 1
+    DRUID_GENESIS                               = 2238,  // TabId = 283, Tab = 0, Row = 0, Column = 2
+    DRUID_MOONGLOW                              = 783,   // TabId = 283, Tab = 0, Row = 1, Column = 0
+    DRUID_NATURES_MAJESTY                       = 1822,  // TabId = 283, Tab = 0, Row = 1, Column = 1
+    DRUID_IMPROVED_MOONFIRE                     = 763,   // TabId = 283, Tab = 0, Row = 1, Column = 3
+    DRUID_BRAMBLES                              = 782,   // TabId = 283, Tab = 0, Row = 2, Column = 0
+    DRUID_NATURES_GRACE                         = 789,   // TabId = 283, Tab = 0, Row = 2, Column = 1
+    DRUID_NATURES_SPLENDOR_A                    = 2240,  // TabId = 283, Tab = 0, Row = 2, Column = 2
+    DRUID_NATURES_REACH                         = 764,   // TabId = 283, Tab = 0, Row = 2, Column = 3
+    DRUID_VENGEANCE                             = 792,   // TabId = 283, Tab = 0, Row = 3, Column = 1
+    DRUID_CELESTIAL_FOCUS                       = 784,   // TabId = 283, Tab = 0, Row = 3, Column = 2
+    DRUID_LUNAR_GUIDANCE                        = 1782,  // TabId = 283, Tab = 0, Row = 4, Column = 0
+    DRUID_INSECT_SWARM                          = 788,   // TabId = 283, Tab = 0, Row = 4, Column = 1
+    DRUID_IMPROVED_INSECT_SWARM                 = 2239,  // TabId = 283, Tab = 0, Row = 4, Column = 2
+    DRUID_DREAMSTATE                            = 1784,  // TabId = 283, Tab = 0, Row = 5, Column = 0
+    DRUID_MOONFURY                              = 790,   // TabId = 283, Tab = 0, Row = 5, Column = 1
+    DRUID_BALANCE_OF_POWER                      = 1783,  // TabId = 283, Tab = 0, Row = 5, Column = 2
+    //DRUID_MOONKIN_FORM                          = 793,   // TabId = 283, Tab = 0, Row = 6, Column = 1
+    DRUID_IMPROVED_MOONKIN_FORM                 = 1912,  // TabId = 283, Tab = 0, Row = 6, Column = 2
+    DRUID_IMPROVED_FAERIE_FIRE                  = 1785,  // TabId = 283, Tab = 0, Row = 6, Column = 3
+    DRUID_OWLKIN_FRENZY                         = 1913,  // TabId = 283, Tab = 0, Row = 7, Column = 0
+    DRUID_WRATH_OF_CENARIUS                     = 1786,  // TabId = 283, Tab = 0, Row = 7, Column = 2
+    DRUID_ECLIPSE                               = 1924,  // TabId = 283, Tab = 0, Row = 8, Column = 0
+    DRUID_TYPHOON                               = 1923,  // TabId = 283, Tab = 0, Row = 8, Column = 1
+    DRUID_FORCE_OF_NATURE                       = 1787,  // TabId = 283, Tab = 0, Row = 8, Column = 2
+    DRUID_GALE_WINDS                            = 1925,  // TabId = 283, Tab = 0, Row = 8, Column = 3
+    DRUID_EARTH_AND_MOON                        = 1928,  // TabId = 283, Tab = 0, Row = 9, Column = 1
+    DRUID_STARFALL                              = 1926   // TabId = 283, Tab = 0, Row = 10, Column = 1
+};
+
+enum TalentsHunter  // 0x004
+{
+    HUNTER_IMPROVED_ASPECT_OF_THE_HAWK          = 1382,  // TabId = 361, Tab = 0, Row = 0, Column = 1
+    HUNTER_ENDURANCE_TRAINING                   = 1389,  // TabId = 361, Tab = 0, Row = 0, Column = 2
+    HUNTER_FOCUSED_FIRE                         = 1624,  // TabId = 361, Tab = 0, Row = 1, Column = 0
+    HUNTER_IMPROVED_ASPECT_OF_THE_MONKEY        = 1381,  // TabId = 361, Tab = 0, Row = 1, Column = 1
+    HUNTER_THICK_HIDE                           = 1395,  // TabId = 361, Tab = 0, Row = 1, Column = 2
+    HUNTER_IMPROVED_REVIVE_PET                  = 1625,  // TabId = 361, Tab = 0, Row = 1, Column = 3
+    HUNTER_PATHFINDING                          = 1384,  // TabId = 361, Tab = 0, Row = 2, Column = 0
+    HUNTER_ASPECT_MASTERY                       = 2138,  // TabId = 361, Tab = 0, Row = 2, Column = 1
+    HUNTER_UNLEASHED_FURY                       = 1396,  // TabId = 361, Tab = 0, Row = 2, Column = 2
+    HUNTER_IMPROVED_MEND_PET                    = 1385,  // TabId = 361, Tab = 0, Row = 3, Column = 1
+    HUNTER_FEROCITY                             = 1393,  // TabId = 361, Tab = 0, Row = 3, Column = 2
+    HUNTER_SPIRIT_BOND                          = 1388,  // TabId = 361, Tab = 0, Row = 4, Column = 0
+    HUNTER_INTIMIDATION                         = 1387,  // TabId = 361, Tab = 0, Row = 4, Column = 1
+    HUNTER_BESTIAL_DISCIPLINE                   = 1390,  // TabId = 361, Tab = 0, Row = 4, Column = 3
+    HUNTER_ANIMAL_HANDLER                       = 1799,  // TabId = 361, Tab = 0, Row = 5, Column = 0
+    HUNTER_FRENZY                               = 1397,  // TabId = 361, Tab = 0, Row = 5, Column = 2
+    HUNTER_FEROCIOUS_INSPIRATION                = 1800,  // TabId = 361, Tab = 0, Row = 6, Column = 0
+    HUNTER_BESTIAL_WRATH                        = 1386,  // TabId = 361, Tab = 0, Row = 6, Column = 1
+    HUNTER_CATLIKE_REFLEXES                     = 1801,  // TabId = 361, Tab = 0, Row = 6, Column = 2
+    HUNTER_INVIGORATION                         = 2136,  // TabId = 361, Tab = 0, Row = 7, Column = 0
+    HUNTER_SERPENTS_SWIFTNESS                   = 1802,  // TabId = 361, Tab = 0, Row = 7, Column = 2
+    HUNTER_LONGEVITY                            = 2140,  // TabId = 361, Tab = 0, Row = 8, Column = 0
+    HUNTER_THE_BEAST_WITHIN                     = 1803,  // TabId = 361, Tab = 0, Row = 8, Column = 1
+    HUNTER_COBRA_STRIKES                        = 2137,  // TabId = 361, Tab = 0, Row = 8, Column = 2
+    HUNTER_KINDRED_SPIRITS                      = 2227,  // TabId = 361, Tab = 0, Row = 9, Column = 1
+    HUNTER_BEAST_MASTERY                        = 2139,  // TabId = 361, Tab = 0, Row = 10, Column = 1
+    HUNTER_IMPROVED_TRACKING                    = 1623,  // TabId = 362, Tab = 2, Row = 0, Column = 0
+    HUNTER_HAWK_EYE                             = 1820,  // TabId = 362, Tab = 2, Row = 0, Column = 1
+    HUNTER_SAVAGE_STRIKES                       = 1621,  // TabId = 362, Tab = 2, Row = 0, Column = 2
+    HUNTER_SUREFOOTED                           = 1310,  // TabId = 362, Tab = 2, Row = 1, Column = 0
+    HUNTER_ENTRAPMENT                           = 1304,  // TabId = 362, Tab = 2, Row = 1, Column = 1
+    HUNTER_TRAP_MASTERY                         = 1305,  // TabId = 362, Tab = 2, Row = 1, Column = 2
+    HUNTER_SURVIVAL_INSTINCTS                   = 1810,  // TabId = 362, Tab = 2, Row = 1, Column = 3
+    HUNTER_SURVIVALIST                          = 1622,  // TabId = 362, Tab = 2, Row = 2, Column = 0
+    HUNTER_SCATTER_SHOT                         = 1814,  // TabId = 362, Tab = 2, Row = 2, Column = 1
+    HUNTER_DEFLECTION                           = 1311,  // TabId = 362, Tab = 2, Row = 2, Column = 2
+    HUNTER_SURVIVAL_TACTICS                     = 1309,  // TabId = 362, Tab = 2, Row = 2, Column = 3
+    HUNTER_TNT                                  = 2229,  // TabId = 362, Tab = 2, Row = 3, Column = 1
+    HUNTER_LOCK_AND_LOAD                        = 1306,  // TabId = 362, Tab = 2, Row = 3, Column = 3
+    HUNTER_HUNTER_VS_WILD                       = 2228,  // TabId = 362, Tab = 2, Row = 4, Column = 0
+    HUNTER_KILLER_INSTINCT                      = 1321,  // TabId = 362, Tab = 2, Row = 4, Column = 1
+    HUNTER_COUNTERATTACK                        = 1312,  // TabId = 362, Tab = 2, Row = 4, Column = 2
+    HUNTER_LIGHTNING_REFLEXES                   = 1303,  // TabId = 362, Tab = 2, Row = 5, Column = 0
+    HUNTER_RESOURCEFULNESS                      = 1809,  // TabId = 362, Tab = 2, Row = 5, Column = 2
+    HUNTER_EXPOSE_WEAKNESS                      = 1812,  // TabId = 362, Tab = 2, Row = 6, Column = 0
+    HUNTER_WYVERN_STING                         = 1325,  // TabId = 362, Tab = 2, Row = 6, Column = 1
+    HUNTER_THRILL_OF_THE_HUNT                   = 1811,  // TabId = 362, Tab = 2, Row = 6, Column = 2
+    HUNTER_MASTER_TACTICIAN                     = 1813,  // TabId = 362, Tab = 2, Row = 7, Column = 0
+    HUNTER_NOXIOUS_STINGS                       = 2141,  // TabId = 362, Tab = 2, Row = 7, Column = 1
+    HUNTER_POINT_OF_NO_ESCAPE                   = 2142,  // TabId = 362, Tab = 2, Row = 8, Column = 0
+    HUNTER_BLACK_ARROW                          = 1322,  // TabId = 362, Tab = 2, Row = 8, Column = 1
+    HUNTER_SNIPER_TRAINING                      = 2143,  // TabId = 362, Tab = 2, Row = 8, Column = 3
+    HUNTER_HUNTING_PARTY                        = 2144,  // TabId = 362, Tab = 2, Row = 9, Column = 2
+    HUNTER_EXPLOSIVE_SHOT                       = 2145,  // TabId = 362, Tab = 2, Row = 10, Column = 1
+    HUNTER_IMPROVED_CONCUSSIVE_SHOT             = 1341,  // TabId = 363, Tab = 1, Row = 0, Column = 0
+    HUNTER_FOCUSED_AIM                          = 2197,  // TabId = 363, Tab = 1, Row = 0, Column = 1
+    HUNTER_LETHAL_SHOTS                         = 1344,  // TabId = 363, Tab = 1, Row = 0, Column = 2
+    HUNTER_CAREFUL_AIM                          = 1806,  // TabId = 363, Tab = 1, Row = 1, Column = 0
+    HUNTER_IMPROVED_HUNTERS_MARK                = 1343,  // TabId = 363, Tab = 1, Row = 1, Column = 1
+    HUNTER_MORTAL_SHOTS                         = 1349,  // TabId = 363, Tab = 1, Row = 1, Column = 2
+    HUNTER_GO_FOR_THE_THROAT                    = 1818,  // TabId = 363, Tab = 1, Row = 2, Column = 0
+    HUNTER_IMPROVED_ARCANE_SHOT                 = 1346,  // TabId = 363, Tab = 1, Row = 2, Column = 1
+    HUNTER_AIMED_SHOT                           = 1345,  // TabId = 363, Tab = 1, Row = 2, Column = 2
+    HUNTER_RAPID_KILLING                        = 1819,  // TabId = 363, Tab = 1, Row = 2, Column = 3
+    HUNTER_IMPROVED_STINGS                      = 1348,  // TabId = 363, Tab = 1, Row = 3, Column = 1
+    HUNTER_EFFICIENCY                           = 1342,  // TabId = 363, Tab = 1, Row = 3, Column = 2
+    HUNTER_CONCUSSIVE_BARRAGE                   = 1351,  // TabId = 363, Tab = 1, Row = 4, Column = 0
+    HUNTER_READINESS                            = 1353,  // TabId = 363, Tab = 1, Row = 4, Column = 1
+    HUNTER_BARRAGE                              = 1347,  // TabId = 363, Tab = 1, Row = 4, Column = 2
+    HUNTER_COMBAT_EXPERIENCE                    = 1804,  // TabId = 363, Tab = 1, Row = 5, Column = 0
+    HUNTER_RANGED_WEAPON_SPECIALIZATION         = 1362,  // TabId = 363, Tab = 1, Row = 5, Column = 3
+    HUNTER_PIERCING_SHOTS                       = 2130,  // TabId = 363, Tab = 1, Row = 6, Column = 0
+    HUNTER_TRUESHOT_AURA                        = 1361,  // TabId = 363, Tab = 1, Row = 6, Column = 1
+    HUNTER_IMPROVED_BARRAGE                     = 1821,  // TabId = 363, Tab = 1, Row = 6, Column = 2
+    HUNTER_MASTER_MARKSMAN                      = 1807,  // TabId = 363, Tab = 1, Row = 7, Column = 1
+    HUNTER_RAPID_RECUPERATION                   = 2131,  // TabId = 363, Tab = 1, Row = 7, Column = 2
+    HUNTER_WILD_QUIVER                          = 2132,  // TabId = 363, Tab = 1, Row = 8, Column = 0
+    HUNTER_SILENCING_SHOT                       = 1808,  // TabId = 363, Tab = 1, Row = 8, Column = 1
+    HUNTER_IMPROVED_STEADY_SHOT                 = 2133,  // TabId = 363, Tab = 1, Row = 8, Column = 2
+    HUNTER_MARKED_FOR_DEATH                     = 2134,  // TabId = 363, Tab = 1, Row = 9, Column = 1
+    HUNTER_CHIMERA_SHOT                         = 2135  // TabId = 363, Tab = 1, Row = 10, Column = 1
+};
+
+enum TalentsMage  // 0x080
+{
+    MAGE_IMPROVED_FIRE_BLAST                    = 27,    // TabId = 41, Tab = 1, Row = 0, Column = 0
+    MAGE_INCINERATION                           = 1141,  // TabId = 41, Tab = 1, Row = 0, Column = 1
+    MAGE_IMPROVED_FIREBALL                      = 26,    // TabId = 41, Tab = 1, Row = 0, Column = 2
+    MAGE_IGNITE                                 = 34,    // TabId = 41, Tab = 1, Row = 1, Column = 0
+    MAGE_BURNING_DETERMINATION                  = 2212,  // TabId = 41, Tab = 1, Row = 1, Column = 1
+    MAGE_WORLD_IN_FLAMES                        = 31,    // TabId = 41, Tab = 1, Row = 1, Column = 2
+    MAGE_FLAME_THROWING                         = 28,    // TabId = 41, Tab = 1, Row = 2, Column = 0
+    MAGE_IMPACT                                 = 30,    // TabId = 41, Tab = 1, Row = 2, Column = 1
+    MAGE_PYROBLAST                              = 29,    // TabId = 41, Tab = 1, Row = 2, Column = 2
+    MAGE_BURNING_SOUL                           = 23,    // TabId = 41, Tab = 1, Row = 2, Column = 3
+    MAGE_IMPROVED_SCORCH                        = 25,    // TabId = 41, Tab = 1, Row = 3, Column = 0
+    MAGE_MOLTEN_SHIELDS                         = 24,    // TabId = 41, Tab = 1, Row = 3, Column = 1
+    MAGE_MASTER_OF_ELEMENTS                     = 1639,  // TabId = 41, Tab = 1, Row = 3, Column = 3
+    MAGE_PLAYING_WITH_FIRE                      = 1730,  // TabId = 41, Tab = 1, Row = 4, Column = 0
+    MAGE_CRITICAL_MASS                          = 33,    // TabId = 41, Tab = 1, Row = 4, Column = 1
+    MAGE_BLAST_WAVE                             = 32,    // TabId = 41, Tab = 1, Row = 4, Column = 2
+    MAGE_BLAZING_SPEED                          = 1731,  // TabId = 41, Tab = 1, Row = 5, Column = 0
+    MAGE_FIRE_POWER                             = 35,    // TabId = 41, Tab = 1, Row = 5, Column = 2
+    MAGE_PYROMANIAC                             = 1733,  // TabId = 41, Tab = 1, Row = 6, Column = 0
+    MAGE_COMBUSTION                             = 36,    // TabId = 41, Tab = 1, Row = 6, Column = 1
+    MAGE_MOLTEN_FURY                            = 1732,  // TabId = 41, Tab = 1, Row = 6, Column = 2
+    MAGE_FIERY_PAYBACK                          = 1848,  // TabId = 41, Tab = 1, Row = 7, Column = 0
+    MAGE_EMPOWERED_FIRE                         = 1734,  // TabId = 41, Tab = 1, Row = 7, Column = 2
+    MAGE_FIRESTARTER                            = 1849,  // TabId = 41, Tab = 1, Row = 8, Column = 0
+    MAGE_DRAGONS_BREATH                         = 1735,  // TabId = 41, Tab = 1, Row = 8, Column = 1
+    MAGE_HOT_STREAK                             = 1850,  // TabId = 41, Tab = 1, Row = 8, Column = 2
+    MAGE_BURNOUT                                = 1851,  // TabId = 41, Tab = 1, Row = 9, Column = 1
+    MAGE_LIVING_BOMB                            = 1852,  // TabId = 41, Tab = 1, Row = 10, Column = 1
+    MAGE_FROSTBITE                              = 38,    // TabId = 61, Tab = 2, Row = 0, Column = 0
+    MAGE_IMPROVED_FROSTBOLT                     = 37,    // TabId = 61, Tab = 2, Row = 0, Column = 1
+    MAGE_ICE_FLOES                              = 62,    // TabId = 61, Tab = 2, Row = 0, Column = 2
+    MAGE_ICE_SHARDS                             = 73,    // TabId = 61, Tab = 2, Row = 1, Column = 0
+    MAGE_FROST_WARDING                          = 70,    // TabId = 61, Tab = 2, Row = 1, Column = 1
+    MAGE_PRECISION                              = 1649,  // TabId = 61, Tab = 2, Row = 1, Column = 2
+    MAGE_PERMAFROST                             = 65,    // TabId = 61, Tab = 2, Row = 1, Column = 3
+    MAGE_PIERCING_ICE                           = 61,    // TabId = 61, Tab = 2, Row = 2, Column = 0
+    MAGE_ICY_VEINS                              = 69,    // TabId = 61, Tab = 2, Row = 2, Column = 1
+    MAGE_IMPROVED_BLIZZARD                      = 63,    // TabId = 61, Tab = 2, Row = 2, Column = 2
+    MAGE_ARCTIC_REACH                           = 741,   // TabId = 61, Tab = 2, Row = 3, Column = 0
+    MAGE_FROST_CHANNELING                       = 66,    // TabId = 61, Tab = 2, Row = 3, Column = 1
+    MAGE_SHATTER                                = 67,    // TabId = 61, Tab = 2, Row = 3, Column = 2
+    MAGE_COLD_SNAP                              = 72,    // TabId = 61, Tab = 2, Row = 4, Column = 1
+    MAGE_IMPROVED_CONE_OF_COLD                  = 64,    // TabId = 61, Tab = 2, Row = 4, Column = 2
+    MAGE_FROZEN_CORE                            = 1736,  // TabId = 61, Tab = 2, Row = 4, Column = 3
+    MAGE_COLD_AS_ICE                            = 1737,  // TabId = 61, Tab = 2, Row = 5, Column = 0
+    MAGE_WINTERS_CHILL                          = 68,    // TabId = 61, Tab = 2, Row = 5, Column = 2
+    MAGE_SHATTERED_BARRIER                      = 2214,  // TabId = 61, Tab = 2, Row = 6, Column = 0
+    MAGE_ICE_BARRIER                            = 71,    // TabId = 61, Tab = 2, Row = 6, Column = 1
+    MAGE_ARCTIC_WINDS                           = 1738,  // TabId = 61, Tab = 2, Row = 6, Column = 2
+    MAGE_EMPOWERED_FROSTBOLT                    = 1740,  // TabId = 61, Tab = 2, Row = 7, Column = 1
+    MAGE_FINGERS_OF_FROST                       = 1853,  // TabId = 61, Tab = 2, Row = 7, Column = 2
+    MAGE_BRAIN_FREEZE                           = 1854,  // TabId = 61, Tab = 2, Row = 8, Column = 0
+    MAGE_SUMMON_WATER_ELEMENTAL                 = 1741,  // TabId = 61, Tab = 2, Row = 8, Column = 1
+    MAGE_ENDURING_WINTER                        = 1855,  // TabId = 61, Tab = 2, Row = 8, Column = 2
+    MAGE_CHILLD_TO_THE_BONE                     = 1856,  // TabId = 61, Tab = 2, Row = 9, Column = 1
+    MAGE_DEEP_FREEZE                            = 1857,  // TabId = 61, Tab = 2, Row = 10, Column = 1
+    MAGE_ARCANE_SUBTLETY                        = 74,    // TabId = 81, Tab = 0, Row = 0, Column = 0
+    MAGE_ARCANE_FOCUS                           = 76,    // TabId = 81, Tab = 0, Row = 0, Column = 1
+    MAGE_ARCANE_STABILITY                       = 80,    // TabId = 81, Tab = 0, Row = 0, Column = 2
+    MAGE_ARCANE_FORTITUDE                       = 85,    // TabId = 81, Tab = 0, Row = 1, Column = 0
+    MAGE_MAGIC_ABSORPTION                       = 1650,  // TabId = 81, Tab = 0, Row = 1, Column = 1
+    MAGE_ARCANE_CONCENTRATION                   = 75,    // TabId = 81, Tab = 0, Row = 1, Column = 2
+    MAGE_MAGIC_ATTUNEMENT                       = 82,    // TabId = 81, Tab = 0, Row = 2, Column = 0
+    MAGE_SPELL_IMPACT                           = 81,    // TabId = 81, Tab = 0, Row = 2, Column = 1
+    MAGE_STUDENT_OF_THE_MIND                    = 1845,  // TabId = 81, Tab = 0, Row = 2, Column = 2
+    MAGE_FOCUS_MAGIC                            = 2211,  // TabId = 81, Tab = 0, Row = 2, Column = 3
+    MAGE_ARCANE_SHIELDING                       = 83,    // TabId = 81, Tab = 0, Row = 3, Column = 0
+    MAGE_IMPROVED_COUNTERSPELL                  = 88,    // TabId = 81, Tab = 0, Row = 3, Column = 1
+    MAGE_ARCANE_MEDITATION                      = 1142,  // TabId = 81, Tab = 0, Row = 3, Column = 2
+    MAGE_TORMENT_THE_WEAK                       = 2222,  // TabId = 81, Tab = 0, Row = 3, Column = 3
+    MAGE_IMPROVED_BLINK                         = 1724,  // TabId = 81, Tab = 0, Row = 4, Column = 0
+    MAGE_PRESENCE_OF_MIND                       = 86,    // TabId = 81, Tab = 0, Row = 4, Column = 1
+    MAGE_ARCANE_MIND                            = 77,    // TabId = 81, Tab = 0, Row = 4, Column = 3
+    MAGE_PRISMATIC_CLOAK                        = 1726,  // TabId = 81, Tab = 0, Row = 5, Column = 0
+    MAGE_ARCANE_INSTABILITY                     = 421,   // TabId = 81, Tab = 0, Row = 5, Column = 1
+    MAGE_ARCANE_POTENCY                         = 1725,  // TabId = 81, Tab = 0, Row = 5, Column = 2
+    MAGE_ARCANE_EMPOWERMENT                     = 1727,  // TabId = 81, Tab = 0, Row = 6, Column = 0
+    MAGE_ARCANE_POWER                           = 87,    // TabId = 81, Tab = 0, Row = 6, Column = 1
+    MAGE_INCANTERS_ABSORPTION                   = 1844,  // TabId = 81, Tab = 0, Row = 6, Column = 2
+    MAGE_ARCANE_FLOWS                           = 1843,  // TabId = 81, Tab = 0, Row = 7, Column = 1
+    MAGE_MIND_MASTERY                           = 1728,  // TabId = 81, Tab = 0, Row = 7, Column = 2
+    MAGE_SLOW                                   = 1729,  // TabId = 81, Tab = 0, Row = 8, Column = 1
+    MAGE_MISSILE_BARRAGE                        = 2209,  // TabId = 81, Tab = 0, Row = 8, Column = 2
+    MAGE_NETHERWIND_PRESENCE                    = 1846,  // TabId = 81, Tab = 0, Row = 9, Column = 1
+    MAGE_SPELL_POWER                            = 1826,  // TabId = 81, Tab = 0, Row = 9, Column = 2
+    MAGE_ARCANE_BARRAGE                         = 1847  // TabId = 81, Tab = 0, Row = 10, Column = 1
+};
+
+enum TalentsPaladin  // 0x002
+{
+    PALADIN_DEFLECTION                          = 1403,  // TabId = 381, Tab = 2, Row = 0, Column = 1
+    PALADIN_BENEDICTION                         = 1407,  // TabId = 381, Tab = 2, Row = 0, Column = 2
+    PALADIN_IMPROVED_JUDGEMENTS                 = 1631,  // TabId = 381, Tab = 2, Row = 1, Column = 0
+    PALADIN_HEART_OF_THE_CRUSADER               = 1464,  // TabId = 381, Tab = 2, Row = 1, Column = 1
+    PALADIN_IMPROVED_BLESSING_OF_MIGHT          = 1401,  // TabId = 381, Tab = 2, Row = 1, Column = 2
+    PALADIN_VINDICATION                         = 1633,  // TabId = 381, Tab = 2, Row = 2, Column = 0
+    PALADIN_CONVICTION                          = 1411,  // TabId = 381, Tab = 2, Row = 2, Column = 1
+    PALADIN_SEAL_OF_COMMAND                     = 1481,  // TabId = 381, Tab = 2, Row = 2, Column = 2
+    PALADIN_PURSUIT_OF_JUSTICE                  = 1634,  // TabId = 381, Tab = 2, Row = 2, Column = 3
+    PALADIN_EYE_FOR_AN_EYE                      = 1632,  // TabId = 381, Tab = 2, Row = 3, Column = 0
+    PALADIN_SANCTITY_OF_BATTLE                  = 1761,  // TabId = 381, Tab = 2, Row = 3, Column = 2
+    PALADIN_CRUSADE                             = 1755,  // TabId = 381, Tab = 2, Row = 3, Column = 3
+    PALADIN_TWOHANDED_WEAPON_SPECIALIZATION     = 1410,  // TabId = 381, Tab = 2, Row = 4, Column = 0
+    PALADIN_SANCTIFIED_RETRIBUTION              = 1756,  // TabId = 381, Tab = 2, Row = 4, Column = 2
+    PALADIN_VENGEANCE                           = 1402,  // TabId = 381, Tab = 2, Row = 5, Column = 1
+    PALADIN_DIVINE_PURPOSE                      = 1757,  // TabId = 381, Tab = 2, Row = 5, Column = 2
+    PALADIN_THE_ART_OF_WAR                      = 2176,  // TabId = 381, Tab = 2, Row = 6, Column = 0
+    PALADIN_REPENTANCE                          = 1441,  // TabId = 381, Tab = 2, Row = 6, Column = 1
+    PALADIN_JUDGEMENTS_OF_THE_WISE              = 1758,  // TabId = 381, Tab = 2, Row = 6, Column = 2
+    PALADIN_FANATICISM                          = 1759,  // TabId = 381, Tab = 2, Row = 7, Column = 1
+    PALADIN_SANCTIFIED_WRATH                    = 2147,  // TabId = 381, Tab = 2, Row = 7, Column = 2
+    PALADIN_SWIFT_RETRIBUTION                   = 2148,  // TabId = 381, Tab = 2, Row = 8, Column = 0
+    PALADIN_CRUSADER_STRIKE                     = 1823,  // TabId = 381, Tab = 2, Row = 8, Column = 1
+    PALADIN_SHEATH_OF_LIGHT                     = 2179,  // TabId = 381, Tab = 2, Row = 8, Column = 2
+    PALADIN_RIGHTEOUS_VENGEANCE                 = 2149,  // TabId = 381, Tab = 2, Row = 9, Column = 1
+    PALADIN_DIVINE_STORM                        = 2150,  // TabId = 381, Tab = 2, Row = 10, Column = 1
+    PALADIN_SPIRITUAL_FOCUS                     = 1432,  // TabId = 382, Tab = 0, Row = 0, Column = 1
+    PALADIN_SEALS_OF_THE_PURE                   = 1463,  // TabId = 382, Tab = 0, Row = 0, Column = 2
+    PALADIN_HEALING_LIGHT                       = 1444,  // TabId = 382, Tab = 0, Row = 1, Column = 0
+    PALADIN_DIVINE_INTELLECT                    = 1449,  // TabId = 382, Tab = 0, Row = 1, Column = 1
+    PALADIN_UNYIELDING_FAITH                    = 1628,  // TabId = 382, Tab = 0, Row = 1, Column = 2
+    PALADIN_AURA_MASTERY                        = 1435,  // TabId = 382, Tab = 0, Row = 2, Column = 0
+    PALADIN_ILLUMINATION                        = 1461,  // TabId = 382, Tab = 0, Row = 2, Column = 1
+    PALADIN_IMPROVED_LAY_ON_HANDS               = 1443,  // TabId = 382, Tab = 0, Row = 2, Column = 2
+    PALADIN_IMPROVED_CONCENTRATION_AURA         = 1450,  // TabId = 382, Tab = 0, Row = 3, Column = 0
+    PALADIN_IMPROVED_BLESSING_OF_WISDOM         = 1446,  // TabId = 382, Tab = 0, Row = 3, Column = 2
+    PALADIN_BLESSED_HANDS                       = 2198,  // TabId = 382, Tab = 0, Row = 3, Column = 3
+    PALADIN_PURE_OF_HEART                       = 1742,  // TabId = 382, Tab = 0, Row = 4, Column = 0
+    PALADIN_DIVINE_FAVOR                        = 1433,  // TabId = 382, Tab = 0, Row = 4, Column = 1
+    PALADIN_SANCTIFIED_LIGHT                    = 1465,  // TabId = 382, Tab = 0, Row = 4, Column = 2
+    PALADIN_PURIFYING_POWER                     = 1743,  // TabId = 382, Tab = 0, Row = 5, Column = 0
+    PALADIN_HOLY_POWER                          = 1627,  // TabId = 382, Tab = 0, Row = 5, Column = 2
+    PALADIN_LIGHTS_GRACE                        = 1745,  // TabId = 382, Tab = 0, Row = 6, Column = 0
+    PALADIN_HOLY_SHOCK                          = 1502,  // TabId = 382, Tab = 0, Row = 6, Column = 1
+    PALADIN_BLESSED_LIFE                        = 1744,  // TabId = 382, Tab = 0, Row = 6, Column = 2
+    PALADIN_SACRED_CLEANSING                    = 2190,  // TabId = 382, Tab = 0, Row = 7, Column = 0
+    PALADIN_HOLY_GUIDANCE                       = 1746,  // TabId = 382, Tab = 0, Row = 7, Column = 2
+    PALADIN_DIVINE_ILLUMINATION                 = 1747,  // TabId = 382, Tab = 0, Row = 8, Column = 0
+    PALADIN_JUDGEMENTS_OF_THE_PURE              = 2199,  // TabId = 382, Tab = 0, Row = 8, Column = 2
+    PALADIN_INFUSION_OF_LIGHT                   = 2193,  // TabId = 382, Tab = 0, Row = 9, Column = 1
+    PALADIN_ENLIGHTENED_JUDGEMENTS              = 2191,  // TabId = 382, Tab = 0, Row = 9, Column = 2
+    PALADIN_BEACON_OF_LIGHT                     = 2192,  // TabId = 382, Tab = 0, Row = 10, Column = 1
+    PALADIN_DIVINITY                            = 1442,  // TabId = 383, Tab = 1, Row = 0, Column = 1
+    PALADIN_DIVINE_STRENGTH                     = 2185,  // TabId = 383, Tab = 1, Row = 0, Column = 2
+    PALADIN_STOICISM                            = 1748,  // TabId = 383, Tab = 1, Row = 1, Column = 0
+    PALADIN_GUARDIANS_FAVOR                     = 1425,  // TabId = 383, Tab = 1, Row = 1, Column = 1
+    PALADIN_ANTICIPATION                        = 1629,  // TabId = 383, Tab = 1, Row = 1, Column = 2
+    PALADIN_DIVINE_SACRIFICE                    = 2280,  // TabId = 383, Tab = 1, Row = 2, Column = 0
+    PALADIN_IMPROVED_RIGHTEOUS_FURY             = 1501,  // TabId = 383, Tab = 1, Row = 2, Column = 1
+    PALADIN_TOUGHNESS                           = 1423,  // TabId = 383, Tab = 1, Row = 2, Column = 2
+    PALADIN_DIVINE_GUARDIAN                     = 2281,  // TabId = 383, Tab = 1, Row = 3, Column = 0
+    PALADIN_IMPROVED_HAMMER_OF_JUSTICE          = 1521,  // TabId = 383, Tab = 1, Row = 3, Column = 1
+    PALADIN_IMPROVED_DEVOTION_AURA              = 1422,  // TabId = 383, Tab = 1, Row = 3, Column = 2
+    PALADIN_BLESSING_OF_SANCTUARY               = 1431,  // TabId = 383, Tab = 1, Row = 4, Column = 1
+    PALADIN_RECKONING                           = 1426,  // TabId = 383, Tab = 1, Row = 4, Column = 2
+    PALADIN_SACRED_DUTY                         = 1750,  // TabId = 383, Tab = 1, Row = 5, Column = 0
+    PALADIN_ONEHANDED_WEAPON_SPECIALIZATION     = 1429,  // TabId = 383, Tab = 1, Row = 5, Column = 2
+    PALADIN_SPIRITUAL_ATTUNEMENT                = 2282,  // TabId = 383, Tab = 1, Row = 6, Column = 0
+    PALADIN_HOLY_SHIELD                         = 1430,  // TabId = 383, Tab = 1, Row = 6, Column = 1
+    PALADIN_ARDENT_DEFENDER                     = 1751,  // TabId = 383, Tab = 1, Row = 6, Column = 2
+    PALADIN_REDOUBT                             = 1421,  // TabId = 383, Tab = 1, Row = 7, Column = 0
+    PALADIN_COMBAT_EXPERTISE                    = 1753,  // TabId = 383, Tab = 1, Row = 7, Column = 2
+    PALADIN_TOUCHER_BY_THE_LIGHT                = 2195,  // TabId = 383, Tab = 1, Row = 8, Column = 0
+    PALADIN_AVENGERS_SHIELD                     = 1754,  // TabId = 383, Tab = 1, Row = 8, Column = 1
+    PALADIN_GUARDED_BY_THE_LIGHT                = 2194,  // TabId = 383, Tab = 1, Row = 8, Column = 2
+    PALADIN_SHIELD_OF_THE_TEMPLAR               = 2204,  // TabId = 383, Tab = 1, Row = 9, Column = 1
+    PALADIN_JUDGEMENT_OF_THE_JUST               = 2200,  // TabId = 383, Tab = 1, Row = 9, Column = 2
+    PALADIN_HAMMER_OF_THE_RIGHTEOUS             = 2196   // TabId = 383, Tab = 1, Row = 10, Column = 1
+};
+
+enum TalentsPriest  // 0x010
+{
+    PRIEST_UNBREAKABLE_WILL                     = 342,   // TabId = 201, Tab = 0, Row = 0, Column = 1
+    PRIEST_TWIN_DISCIPLINES                     = 1898,  // TabId = 201, Tab = 0, Row = 0, Column = 2
+    PRIEST_SILENT_RESOLVE                       = 352,   // TabId = 201, Tab = 0, Row = 1, Column = 0
+    PRIEST_IMPROVED_INNER_FIRE                  = 346,   // TabId = 201, Tab = 0, Row = 1, Column = 1
+    PRIEST_IMPROVED_POWER_WORD_FORTITUDE        = 344,   // TabId = 201, Tab = 0, Row = 1, Column = 2
+    PRIEST_MARTYRDOM                            = 321,   // TabId = 201, Tab = 0, Row = 1, Column = 3
+    PRIEST_MEDITATION                           = 347,   // TabId = 201, Tab = 0, Row = 2, Column = 0
+    PRIEST_INNER_FOCUS                          = 348,   // TabId = 201, Tab = 0, Row = 2, Column = 1
+    PRIEST_IMPROVED_POWER_WORD_SHIELD           = 343,   // TabId = 201, Tab = 0, Row = 2, Column = 2
+    PRIEST_ABSOLUTION                           = 1769,  // TabId = 201, Tab = 0, Row = 3, Column = 0
+    PRIEST_MENTAL_AGILITY                       = 341,   // TabId = 201, Tab = 0, Row = 3, Column = 1
+    PRIEST_IMPROVED_MANA_BURN                   = 350,   // TabId = 201, Tab = 0, Row = 3, Column = 3
+    PRIEST_REFLECTIVE_SHIELD                    = 2268,  // TabId = 201, Tab = 0, Row = 4, Column = 0
+    PRIEST_MENTAL_STRENGTH                      = 1201,  // TabId = 201, Tab = 0, Row = 4, Column = 1
+    PRIEST_SOUL_WARDING                         = 351,   // TabId = 201, Tab = 0, Row = 4, Column = 2
+    PRIEST_FOCUSED_POWER                        = 1771,  // TabId = 201, Tab = 0, Row = 5, Column = 0
+    PRIEST_ENLIGHTENMENT                        = 1772,  // TabId = 201, Tab = 0, Row = 5, Column = 2
+    PRIEST_FOCUSED_WILL                         = 1858,  // TabId = 201, Tab = 0, Row = 6, Column = 0
+    PRIEST_POWER_INFUSION                       = 322,   // TabId = 201, Tab = 0, Row = 6, Column = 1
+    PRIEST_IMPROVED_FLASH_HEAL                  = 1773,  // TabId = 201, Tab = 0, Row = 6, Column = 2
+    PRIEST_RENEWED_HOPE                         = 2235,  // TabId = 201, Tab = 0, Row = 7, Column = 0
+    PRIEST_RAPTURE                              = 1896,  // TabId = 201, Tab = 0, Row = 7, Column = 1
+    PRIEST_ASPIRATION                           = 1894,  // TabId = 201, Tab = 0, Row = 7, Column = 2
+    PRIEST_DIVINE_AEGIS                         = 1895,  // TabId = 201, Tab = 0, Row = 8, Column = 0
+    PRIEST_PAIN_SUPPRESSION                     = 1774,  // TabId = 201, Tab = 0, Row = 8, Column = 1
+    PRIEST_GRACE                                = 1901,  // TabId = 201, Tab = 0, Row = 8, Column = 2
+    PRIEST_BORROWED_TIME                        = 1202,  // TabId = 201, Tab = 0, Row = 9, Column = 1
+    PRIEST_PENANCE                              = 1897,  // TabId = 201, Tab = 0, Row = 10, Column = 1
+    PRIEST_HEALING_FOCUS                        = 410,   // TabId = 202, Tab = 1, Row = 0, Column = 0
+    PRIEST_IMPROVED_RENEW                       = 406,   // TabId = 202, Tab = 1, Row = 0, Column = 1
+    PRIEST_HOLY_SPECIALIZATION                  = 401,   // TabId = 202, Tab = 1, Row = 0, Column = 2
+    PRIEST_SPELL_WARDING                        = 411,   // TabId = 202, Tab = 1, Row = 1, Column = 1
+    PRIEST_DIVINE_FURY                          = 1181,  // TabId = 202, Tab = 1, Row = 1, Column = 2
+    PRIEST_DESPERATE_PRAYER                     = 442,   // TabId = 202, Tab = 1, Row = 2, Column = 0
+    PRIEST_BLESSED_RECOVERY                     = 1636,  // TabId = 202, Tab = 1, Row = 2, Column = 1
+    PRIEST_INSPIRATION                          = 361,   // TabId = 202, Tab = 1, Row = 2, Column = 3
+    PRIEST_HOLY_REACH                           = 1635,  // TabId = 202, Tab = 1, Row = 3, Column = 0
+    PRIEST_IMPROVED_HEALIN                      = 408,   // TabId = 202, Tab = 1, Row = 3, Column = 1
+    PRIEST_SEARING_LIGHT                        = 403,   // TabId = 202, Tab = 1, Row = 3, Column = 2
+    PRIEST_HEALING_PRAYERS                      = 413,   // TabId = 202, Tab = 1, Row = 4, Column = 0
+    PRIEST_SPIRIT_OF_REDEMPTION                 = 1561,  // TabId = 202, Tab = 1, Row = 4, Column = 1
+    PRIEST_SPIRITUAL_GUIDANCE                   = 402,   // TabId = 202, Tab = 1, Row = 4, Column = 2
+    PRIEST_SURGE_OF_LIGHT                       = 1766,  // TabId = 202, Tab = 1, Row = 5, Column = 0
+    PRIEST_SPIRITUAL_HEALING                    = 404,   // TabId = 202, Tab = 1, Row = 5, Column = 2
+    PRIEST_HOLY_CONCENTRATION                   = 1768,  // TabId = 202, Tab = 1, Row = 6, Column = 0
+    PRIEST_LIGHTWELL                            = 1637,  // TabId = 202, Tab = 1, Row = 6, Column = 1
+    PRIEST_BLESSED_RESILIENCE                   = 1765,  // TabId = 202, Tab = 1, Row = 6, Column = 2
+    PRIEST_BODY_AND_SOUL                        = 2279,  // TabId = 202, Tab = 1, Row = 7, Column = 0
+    PRIEST_EMPOWERED_HEALING                    = 1767,  // TabId = 202, Tab = 1, Row = 7, Column = 1
+    PRIEST_SERENDIPITY                          = 1904,  // TabId = 202, Tab = 1, Row = 7, Column = 2
+    PRIEST_EMPOWERED_RENEW                      = 1902,  // TabId = 202, Tab = 1, Row = 8, Column = 0
+    PRIEST_CIRCLE_OF_HEALING                    = 1815,  // TabId = 202, Tab = 1, Row = 8, Column = 1
+    PRIEST_TEST_OF_FAITH                        = 1903,  // TabId = 202, Tab = 1, Row = 8, Column = 2
+    PRIEST_DIVINE_PROVIDENCE                    = 1905,  // TabId = 202, Tab = 1, Row = 9, Column = 1
+    PRIEST_GUARDIAN_SPIRIT                      = 1911,  // TabId = 202, Tab = 1, Row = 10, Column = 1
+    PRIEST_SPIRIT_TAP                           = 465,   // TabId = 203, Tab = 2, Row = 0, Column = 0
+    PRIEST_IMPROVED_SPIRIT_TAP                  = 2027,  // TabId = 203, Tab = 2, Row = 0, Column = 1
+    PRIEST_DARKNESS                             = 462,   // TabId = 203, Tab = 2, Row = 0, Column = 2
+    PRIEST_SHADOW_AFFINITY                      = 466,   // TabId = 203, Tab = 2, Row = 1, Column = 0
+    PRIEST_IMPROVED_SHADOW_WORD_PAIN            = 482,   // TabId = 203, Tab = 2, Row = 1, Column = 1
+    PRIEST_SHADOW_FOCUS                         = 463,   // TabId = 203, Tab = 2, Row = 1, Column = 2
+    PRIEST_IMPROVED_PSYCHIC_SCREAM              = 542,   // TabId = 203, Tab = 2, Row = 2, Column = 0
+    PRIEST_IMPROVED_MIND_BLAST                  = 481,   // TabId = 203, Tab = 2, Row = 2, Column = 1
+    PRIEST_MIND_FLAY                            = 501,   // TabId = 203, Tab = 2, Row = 2, Column = 2
+    PRIEST_VEILED_SHADOWS                       = 483,   // TabId = 203, Tab = 2, Row = 3, Column = 1
+    PRIEST_SHADOW_REACH                         = 881,   // TabId = 203, Tab = 2, Row = 3, Column = 2
+    PRIEST_SHADOW_WEAVING                       = 461,   // TabId = 203, Tab = 2, Row = 3, Column = 3
+    PRIEST_SILENCE                              = 541,   // TabId = 203, Tab = 2, Row = 4, Column = 0
+    PRIEST_VAMPIRIC_EMBRACE                     = 484,   // TabId = 203, Tab = 2, Row = 4, Column = 1
+    PRIEST_IMPROVED_VAMPIRIC_EMBRACE            = 1638,  // TabId = 203, Tab = 2, Row = 4, Column = 2
+    PRIEST_FOCUSED_MIND                         = 1777,  // TabId = 203, Tab = 2, Row = 4, Column = 3
+    PRIEST_MIND_MELT                            = 1781,  // TabId = 203, Tab = 2, Row = 5, Column = 0
+    PRIEST_IMPROVED_DEVOURING_PLAGUE            = 2267,  // TabId = 203, Tab = 2, Row = 5, Column = 2
+    PRIEST_SHADOWFORM                           = 521,   // TabId = 203, Tab = 2, Row = 6, Column = 1
+    PRIEST_SHADOW_POWER                         = 1778,  // TabId = 203, Tab = 2, Row = 6, Column = 2
+    PRIEST_IMPROVED_SHADOWFORM                  = 1906,  // TabId = 203, Tab = 2, Row = 7, Column = 0
+    PRIEST_MISERY                               = 1816,  // TabId = 203, Tab = 2, Row = 7, Column = 2
+    PRIEST_PSYCHIC_HORROR                       = 1908,  // TabId = 203, Tab = 2, Row = 8, Column = 0
+    PRIEST_VAMPIRIC_TOUCH                       = 1779,  // TabId = 203, Tab = 2, Row = 8, Column = 1
+    PRIEST_PAIN_AND_SUFFERING                   = 1909,  // TabId = 203, Tab = 2, Row = 8, Column = 2
+    PRIEST_TWISTED_FAITH                        = 1907,  // TabId = 203, Tab = 2, Row = 9, Column = 2
+    PRIEST_DISPERSION                           = 1910   // TabId = 203, Tab = 2, Row = 10, Column = 1
+};
+
+enum TalentsRogue  // 0x008
+{
+    ROGUE_IMPROVED_GOUGE                        = 203,   // TabId = 181, Tab = 1, Row = 0, Column = 0
+    ROGUE_IMPROVED_SINISTER_STRIKE              = 201,   // TabId = 181, Tab = 1, Row = 0, Column = 1
+    ROGUE_DUAL_WIELD_SPECIALIZATION             = 221,   // TabId = 181, Tab = 1, Row = 0, Column = 2
+    ROGUE_IMPROVED_SLICE_AND_DICE               = 1827,  // TabId = 181, Tab = 1, Row = 1, Column = 0
+    ROGUE_DEFLECTION                            = 187,   // TabId = 181, Tab = 1, Row = 1, Column = 1
+    ROGUE_PRECISION                             = 181,   // TabId = 181, Tab = 1, Row = 1, Column = 3
+    ROGUE_ENDURANCE                             = 204,   // TabId = 181, Tab = 1, Row = 2, Column = 0
+    ROGUE_RIPOSTE                               = 301,   // TabId = 181, Tab = 1, Row = 2, Column = 1
+    ROGUE_CLOSE_QUARTERS_COMBAT                 = 182,   // TabId = 181, Tab = 1, Row = 2, Column = 2
+    ROGUE_IMPROVED_KICK                         = 206,   // TabId = 181, Tab = 1, Row = 3, Column = 0
+    ROGUE_IMPROVED_SPRINT                       = 222,   // TabId = 181, Tab = 1, Row = 3, Column = 1
+    ROGUE_LIGHTNING_REFLEXES                    = 186,   // TabId = 181, Tab = 1, Row = 3, Column = 2
+    ROGUE_AGGRESSION                            = 1122,  // TabId = 181, Tab = 1, Row = 3, Column = 3
+    ROGUE_MACE_SPECIALIZATION                   = 184,   // TabId = 181, Tab = 1, Row = 4, Column = 0
+    ROGUE_BLADE_FLURRY                          = 223,   // TabId = 181, Tab = 1, Row = 4, Column = 1
+    ROGUE_HACK_AND_SLASH                        = 242,   // TabId = 181, Tab = 1, Row = 4, Column = 2
+    ROGUE_WEAPON_EXPERTISE                      = 1703,  // TabId = 181, Tab = 1, Row = 5, Column = 1
+    ROGUE_BLADE_TWISTING                        = 1706,  // TabId = 181, Tab = 1, Row = 5, Column = 2
+    ROGUE_VITALITY                              = 1705,  // TabId = 181, Tab = 1, Row = 6, Column = 0
+    ROGUE_ADRENALINE_RUSH                       = 205,   // TabId = 181, Tab = 1, Row = 6, Column = 1
+    ROGUE_NERVES_OF_STEEL                       = 1707,  // TabId = 181, Tab = 1, Row = 6, Column = 2
+    ROGUE_THROWING_SPECIALIZATION               = 2072,  // TabId = 181, Tab = 1, Row = 7, Column = 0
+    ROGUE_COMBAT_POTENCY                        = 1825,  // TabId = 181, Tab = 1, Row = 7, Column = 2
+    ROGUE_UNFAIR_ADVANTAGE                      = 2073,  // TabId = 181, Tab = 1, Row = 8, Column = 0
+    ROGUE_SURPRISE_ATTACKS                      = 1709,  // TabId = 181, Tab = 1, Row = 8, Column = 1
+    ROGUE_SAVAGE_COMBAT                         = 2074,  // TabId = 181, Tab = 1, Row = 8, Column = 2
+    ROGUE_PREY_ON_THE_WEAK                      = 2075,  // TabId = 181, Tab = 1, Row = 9, Column = 1
+    ROGUE_KILLING_SPREE                         = 2076,  // TabId = 181, Tab = 1, Row = 10, Column = 1
+    ROGUE_IMPROVED_EVISCERATE                   = 276,   // TabId = 182, Tab = 0, Row = 0, Column = 0
+    ROGUE_REMORSELESS_ATTACKS                   = 272,   // TabId = 182, Tab = 0, Row = 0, Column = 1
+    ROGUE_MALICE                                = 270,   // TabId = 182, Tab = 0, Row = 0, Column = 2
+    ROGUE_RUTHLESSNESS                          = 273,   // TabId = 182, Tab = 0, Row = 1, Column = 0
+    ROGUE_BLOOD_SPATTER                         = 2068,  // TabId = 182, Tab = 0, Row = 1, Column = 1
+    ROGUE_PUNCTURING_WOUNDS                     = 277,   // TabId = 182, Tab = 0, Row = 1, Column = 3
+    ROGUE_VIGOR                                 = 382,   // TabId = 182, Tab = 0, Row = 2, Column = 0
+    ROGUE_IMPROVED_EXPOSE_ARMOR                 = 278,   // TabId = 182, Tab = 0, Row = 2, Column = 1
+    ROGUE_LETHALITY                             = 269,   // TabId = 182, Tab = 0, Row = 2, Column = 2
+    ROGUE_VILE_POISONS                          = 682,   // TabId = 182, Tab = 0, Row = 3, Column = 1
+    ROGUE_IMPROVED_POISONS                      = 268,   // TabId = 182, Tab = 0, Row = 3, Column = 2
+    ROGUE_FLEET_FOOTED                          = 1721,  // TabId = 182, Tab = 0, Row = 4, Column = 0
+    ROGUE_COLD_BLOOD                            = 280,   // TabId = 182, Tab = 0, Row = 4, Column = 1
+    ROGUE_IMPROVED_KIDNEY_SHOT                  = 279,   // TabId = 182, Tab = 0, Row = 4, Column = 2
+    ROGUE_QUICK_RECOVERY                        = 1762,  // TabId = 182, Tab = 0, Row = 4, Column = 3
+    ROGUE_SEAL_FATE                             = 283,   // TabId = 182, Tab = 0, Row = 5, Column = 1
+    ROGUE_MURDER                                = 274,   // TabId = 182, Tab = 0, Row = 5, Column = 2
+    ROGUE_DEADLY_BREW                           = 2065,  // TabId = 182, Tab = 0, Row = 6, Column = 0
+    ROGUE_OVERKILL                              = 281,   // TabId = 182, Tab = 0, Row = 6, Column = 1
+    ROGUE_DEADENED_NERVES                       = 1723,  // TabId = 182, Tab = 0, Row = 6, Column = 2
+    ROGUE_FOCUSED_ATTACKS                       = 2069,  // TabId = 182, Tab = 0, Row = 7, Column = 0
+    ROGUE_FIND_WEAKNESS                         = 1718,  // TabId = 182, Tab = 0, Row = 7, Column = 2
+    ROGUE_MASTER_POISONER                       = 1715,  // TabId = 182, Tab = 0, Row = 8, Column = 0
+    ROGUE_MUTILATE                              = 1719,  // TabId = 182, Tab = 0, Row = 8, Column = 1
+    ROGUE_TURN_THE_TABLES                       = 2066,  // TabId = 182, Tab = 0, Row = 8, Column = 2
+    ROGUE_CUT_TO_THE_CHASE                      = 2070,  // TabId = 182, Tab = 0, Row = 9, Column = 1
+    ROGUE_HUNGER_FOR_BLOOD                      = 2071,  // TabId = 182, Tab = 0, Row = 10, Column = 1
+    ROGUE_RELENTLESS_STRIKES                    = 2244,  // TabId = 183, Tab = 2, Row = 0, Column = 0
+    ROGUE_MASTER_OF_DECEPTION                   = 241,   // TabId = 183, Tab = 2, Row = 0, Column = 1
+    ROGUE_OPPORTUNITY                           = 261,   // TabId = 183, Tab = 2, Row = 0, Column = 2
+    ROGUE_SLEIGHT_OF_HAND                       = 1700,  // TabId = 183, Tab = 2, Row = 1, Column = 0
+    ROGUE_DIRTY_TRICKS                          = 262,   // TabId = 183, Tab = 2, Row = 1, Column = 1
+    ROGUE_CAMOUFLAGE                            = 244,   // TabId = 183, Tab = 2, Row = 1, Column = 2
+    ROGUE_ELUSIVENESS                           = 247,   // TabId = 183, Tab = 2, Row = 2, Column = 0
+    ROGUE_GHOSTLY_STRIKE                        = 303,   // TabId = 183, Tab = 2, Row = 2, Column = 1
+    ROGUE_SERRATED_BLADES                       = 1123,  // TabId = 183, Tab = 2, Row = 2, Column = 2
+    ROGUE_SETUP                                 = 246,   // TabId = 183, Tab = 2, Row = 3, Column = 0
+    ROGUE_INITIATIVE                            = 245,   // TabId = 183, Tab = 2, Row = 3, Column = 1
+    ROGUE_IMPROVED_AMBUSH                       = 263,   // TabId = 183, Tab = 2, Row = 3, Column = 2
+    ROGUE_HEIGHTENED_SENSES                     = 1701,  // TabId = 183, Tab = 2, Row = 4, Column = 0
+    ROGUE_PREPARATION                           = 284,   // TabId = 183, Tab = 2, Row = 4, Column = 1
+    ROGUE_DIRTY_DEEDS                           = 265,   // TabId = 183, Tab = 2, Row = 4, Column = 2
+    ROGUE_HEMORRHAGE                            = 681,   // TabId = 183, Tab = 2, Row = 4, Column = 3
+    ROGUE_MASTER_OF_SUBTLETY                    = 1713,  // TabId = 183, Tab = 2, Row = 5, Column = 0
+    ROGUE_DEADLINESS                            = 1702,  // TabId = 183, Tab = 2, Row = 5, Column = 2
+    ROGUE_ENVELOPING_SHADOWS                    = 1711,  // TabId = 183, Tab = 2, Row = 6, Column = 0
+    ROGUE_PREMEDITATION                         = 381,   // TabId = 183, Tab = 2, Row = 6, Column = 1
+    ROGUE_CHEAT_DEATH                           = 1722,  // TabId = 183, Tab = 2, Row = 6, Column = 2
+    ROGUE_SINISTER_CALLING                      = 1712,  // TabId = 183, Tab = 2, Row = 7, Column = 1
+    ROGUE_WAYLAY                                = 2077,  // TabId = 183, Tab = 2, Row = 7, Column = 2
+    ROGUE_HONOR_AMONG_THIEVES                   = 2078,  // TabId = 183, Tab = 2, Row = 8, Column = 0
+    ROGUE_SHADOWSTEP                            = 1714,  // TabId = 183, Tab = 2, Row = 8, Column = 1
+    ROGUE_FILTHY_TRICKS                         = 2079,  // TabId = 183, Tab = 2, Row = 8, Column = 2
+    ROGUE_SLAUGHTER_FROM_THE_SHADOWS            = 2080,  // TabId = 183, Tab = 2, Row = 9, Column = 1
+    ROGUE_SHADOW_DANCE                          = 2081   // TabId = 183, Tab = 2, Row = 10, Column = 1
+};
+
+enum TalentsShaman  // 0x040
+{
+    SHAMAN_CONVECTION                           = 564,   // TabId = 261, Tab = 0, Row = 0, Column = 1
+    SHAMAN_CONCUSSION                           = 563,   // TabId = 261, Tab = 0, Row = 0, Column = 2
+    SHAMAN_CALL_OF_FLAME                        = 561,   // TabId = 261, Tab = 0, Row = 1, Column = 0
+    SHAMAN_ELEMENTAL_WARDING                    = 1640,  // TabId = 261, Tab = 0, Row = 1, Column = 1
+    SHAMAN_ELEMENTAL_DEVASTATION                = 1645,  // TabId = 261, Tab = 0, Row = 1, Column = 2
+    SHAMAN_REVERBERATION                        = 575,   // TabId = 261, Tab = 0, Row = 2, Column = 0
+    SHAMAN_ELEMENTAL_FOCUS                      = 574,   // TabId = 261, Tab = 0, Row = 2, Column = 1
+    SHAMAN_ELEMENTAL_FURY                       = 565,   // TabId = 261, Tab = 0, Row = 2, Column = 2
+    SHAMAN_IMPROVED_FIRE_NOVA                   = 567,   // TabId = 261, Tab = 0, Row = 3, Column = 0
+    SHAMAN_EYE_OF_THE_STORM                     = 1642,  // TabId = 261, Tab = 0, Row = 3, Column = 3
+    SHAMAN_ELEMENTAL_REACH                      = 1641,  // TabId = 261, Tab = 0, Row = 4, Column = 0
+    SHAMAN_CALL_OF_THUNDER                      = 562,   // TabId = 261, Tab = 0, Row = 4, Column = 1
+    SHAMAN_UNRELENTING_STORM                    = 1682,  // TabId = 261, Tab = 0, Row = 4, Column = 3
+    SHAMAN_ELEMENTAL_PRECISION                  = 1685,  // TabId = 261, Tab = 0, Row = 5, Column = 0
+    SHAMAN_LIGHTNING_MASTERY                    = 721,   // TabId = 261, Tab = 0, Row = 5, Column = 2
+    SHAMAN_ELEMENTAL_MASTERY                    = 573,   // TabId = 261, Tab = 0, Row = 6, Column = 1
+    SHAMAN_STORM_EARTH_AND_FIRE                 = 2052,  // TabId = 261, Tab = 0, Row = 6, Column = 2
+    SHAMAN_BOOMING_ECHOES                       = 2262,  // TabId = 261, Tab = 0, Row = 7, Column = 0
+    SHAMAN_ELEMENTAL_OATH                       = 2049,  // TabId = 261, Tab = 0, Row = 7, Column = 1
+    SHAMAN_LIGHTNING_OVERLOAD                   = 1686,  // TabId = 261, Tab = 0, Row = 7, Column = 2
+    SHAMAN_ASTRAL_SHIFT                         = 2050,  // TabId = 261, Tab = 0, Row = 8, Column = 0
+    SHAMAN_TOTEM_OF_WRATH                       = 1687,  // TabId = 261, Tab = 0, Row = 8, Column = 1
+    SHAMAN_LAVA_FLOWS                           = 2051,  // TabId = 261, Tab = 0, Row = 8, Column = 2
+    SHAMAN_SHAMANISM                            = 2252,  // TabId = 261, Tab = 0, Row = 9, Column = 1
+    SHAMAN_THUNDERSTORM                         = 2053,  // TabId = 261, Tab = 0, Row = 10, Column = 1
+    SHAMAN_IMPROVED_HEALING_WAVE                = 586,   // TabId = 262, Tab = 2, Row = 0, Column = 1
+    SHAMAN_TOTEMIC_FOCUS                        = 595,   // TabId = 262, Tab = 2, Row = 0, Column = 2
+    SHAMAN_IMPROVED_REINCARNATION               = 589,   // TabId = 262, Tab = 2, Row = 1, Column = 0
+    SHAMAN_HEALING_GRACE                        = 1646,  // TabId = 262, Tab = 2, Row = 1, Column = 1
+    SHAMAN_TIDAL_FOCUS                          = 593,   // TabId = 262, Tab = 2, Row = 1, Column = 2
+    SHAMAN_IMPROVED_WATER_SHIELD                = 583,   // TabId = 262, Tab = 2, Row = 2, Column = 0
+    SHAMAN_HEALING_FOCUS                        = 587,   // TabId = 262, Tab = 2, Row = 2, Column = 1
+    SHAMAN_TIDAL_FORCE                          = 582,   // TabId = 262, Tab = 2, Row = 2, Column = 2
+    SHAMAN_ANCESTRAL_HEALING                    = 581,   // TabId = 262, Tab = 2, Row = 2, Column = 3
+    SHAMAN_RESTORATIVE_TOTEMS                   = 588,   // TabId = 262, Tab = 2, Row = 3, Column = 1
+    SHAMAN_TIDAL_MASTERY                        = 594,   // TabId = 262, Tab = 2, Row = 3, Column = 2
+    SHAMAN_HEALING_WAY                          = 1648,  // TabId = 262, Tab = 2, Row = 4, Column = 0
+    SHAMAN_NATURES_SWIFTNESS                    = 591,   // TabId = 262, Tab = 2, Row = 4, Column = 2
+    SHAMAN_FOCUSED_MIND                         = 1695,  // TabId = 262, Tab = 2, Row = 4, Column = 3
+    SHAMAN_PURIFICATION                         = 592,   // TabId = 262, Tab = 2, Row = 5, Column = 2
+    SHAMAN_NATURES_GUARDIAN                     = 1699,  // TabId = 262, Tab = 2, Row = 6, Column = 0
+    SHAMAN_MANA_TIDE_TOTEM                      = 590,   // TabId = 262, Tab = 2, Row = 6, Column = 1
+    SHAMAN_CLEANSE_SPIRIT                       = 2084,  // TabId = 262, Tab = 2, Row = 6, Column = 2
+    SHAMAN_BLESSING_OF_THE_ETERNALS             = 2060,  // TabId = 262, Tab = 2, Row = 7, Column = 0
+    SHAMAN_IMPROVED_CHAIN_HEAL                  = 1697,  // TabId = 262, Tab = 2, Row = 7, Column = 1
+    SHAMAN_NATURES_BLESSING                     = 1696,  // TabId = 262, Tab = 2, Row = 7, Column = 2
+    SHAMAN_ANCESTRAL_AWAKENING                  = 2061,  // TabId = 262, Tab = 2, Row = 8, Column = 0
+    SHAMAN_EARTH_SHIELD                         = 1698,  // TabId = 262, Tab = 2, Row = 8, Column = 1
+    SHAMAN_IMPROVED_EARTH_SHIELD                = 2059,  // TabId = 262, Tab = 2, Row = 8, Column = 2
+    SHAMAN_TIDAL_WAVES                          = 2063,  // TabId = 262, Tab = 2, Row = 9, Column = 1
+    SHAMAN_RIPTIDE                              = 2064,  // TabId = 262, Tab = 2, Row = 10, Column = 1
+    SHAMAN_ENHANCING_TOTEMS                     = 610,   // TabId = 263, Tab = 1, Row = 0, Column = 0
+    SHAMAN_EARTHS_GRASP                         = 2101,  // TabId = 263, Tab = 1, Row = 0, Column = 1
+    SHAMAN_ANCESTRAL_KNOWLEDGE                  = 614,   // TabId = 263, Tab = 1, Row = 0, Column = 2
+    SHAMAN_GUARDIAN_TOTEMS                      = 609,   // TabId = 263, Tab = 1, Row = 1, Column = 0
+    SHAMAN_THUNDERING_STRIKES                   = 613,   // TabId = 263, Tab = 1, Row = 1, Column = 1
+    SHAMAN_IMPROVED_GHOST_WOLF                  = 605,   // TabId = 263, Tab = 1, Row = 1, Column = 2
+    SHAMAN_IMPROVED_SHIELDS                     = 607,   // TabId = 263, Tab = 1, Row = 1, Column = 3
+    SHAMAN_ELEMENTAL_WEAPONS                    = 611,   // TabId = 263, Tab = 1, Row = 2, Column = 0
+    SHAMAN_SHAMANISTIC_FOCUS                    = 617,   // TabId = 263, Tab = 1, Row = 2, Column = 2
+    SHAMAN_ANTICIPATION                         = 601,   // TabId = 263, Tab = 1, Row = 2, Column = 3
+    SHAMAN_FLURRY                               = 602,   // TabId = 263, Tab = 1, Row = 3, Column = 1
+    SHAMAN_TOUGHNESS                            = 615,   // TabId = 263, Tab = 1, Row = 3, Column = 2
+    SHAMAN_IMPROVED_WINDFURY_TOTEM              = 1647,  // TabId = 263, Tab = 1, Row = 4, Column = 0
+    SHAMAN_SPIRIT_WEAPONS                       = 616,   // TabId = 263, Tab = 1, Row = 4, Column = 1
+    SHAMAN_MENTAL_DEXTERITY                     = 2083,  // TabId = 263, Tab = 1, Row = 4, Column = 2
+    SHAMAN_UNLEASHED_RAGE                       = 1689,  // TabId = 263, Tab = 1, Row = 5, Column = 0
+    SHAMAN_WEAPON_MASTERY                       = 1643,  // TabId = 263, Tab = 1, Row = 5, Column = 2
+    SHAMAN_FROZEN_POWER                         = 2263,  // TabId = 263, Tab = 1, Row = 5, Column = 3
+    SHAMAN_DUAL_WIELD_SPECIALIZATION            = 1692,  // TabId = 263, Tab = 1, Row = 6, Column = 0
+    SHAMAN_DUAL_WIELD                           = 1690,  // TabId = 263, Tab = 1, Row = 6, Column = 1
+    SHAMAN_STORMSTRIKE                          = 901,   // TabId = 263, Tab = 1, Row = 6, Column = 2
+    SHAMAN_STATIC_SHOCK                         = 2055,  // TabId = 263, Tab = 1, Row = 7, Column = 0
+    SHAMAN_LAVA_LASH                            = 2249,  // TabId = 263, Tab = 1, Row = 7, Column = 1
+    SHAMAN_IMPROVED_STORMSTRIKE                 = 2054,  // TabId = 263, Tab = 1, Row = 7, Column = 2
+    SHAMAN_MENTAL_QUICKNESS                     = 1691,  // TabId = 263, Tab = 1, Row = 8, Column = 0
+    SHAMAN_SHAMANISTIC_RAGE                     = 1693,  // TabId = 263, Tab = 1, Row = 8, Column = 1
+    SHAMAN_EARTHEN_POWER                        = 2056,  // TabId = 263, Tab = 1, Row = 8, Column = 2
+    SHAMAN_MAELSTROM_WEAPON                     = 2057,  // TabId = 263, Tab = 1, Row = 9, Column = 1
+    SHAMAN_FERAL_SPIRIT                         = 2058   // TabId = 263, Tab = 1, Row = 10, Column = 1
+};
+
+enum TalentsWarlock  // 0x100
+{
+    WARLOCK_IMPROVED_SHADOW_BOLT                = 944,   // TabId = 301, Tab = 2, Row = 0, Column = 1
+    WARLOCK_BANE                                = 943,   // TabId = 301, Tab = 2, Row = 0, Column = 2
+    WARLOCK_AFTERMATH                           = 982,   // TabId = 301, Tab = 2, Row = 1, Column = 0
+    WARLOCK_MOLTEN_SKIN                         = 1887,  // TabId = 301, Tab = 2, Row = 1, Column = 1
+    WARLOCK_CATACLYSM                           = 941,   // TabId = 301, Tab = 2, Row = 1, Column = 2
+    WARLOCK_DEMONIC_POWER                       = 983,   // TabId = 301, Tab = 2, Row = 2, Column = 0
+    WARLOCK_SHADOWBURN                          = 963,   // TabId = 301, Tab = 2, Row = 2, Column = 1
+    WARLOCK_RUIN                                = 967,   // TabId = 301, Tab = 2, Row = 2, Column = 2
+    WARLOCK_INTENSITY                           = 985,   // TabId = 301, Tab = 2, Row = 3, Column = 0
+    WARLOCK_DESTRUCTIVE_REACH                   = 964,   // TabId = 301, Tab = 2, Row = 3, Column = 1
+    WARLOCK_IMPROVED_SEARING_PAIN               = 965,   // TabId = 301, Tab = 2, Row = 3, Column = 3
+    WARLOCK_BACKLASH                            = 1817,  // TabId = 301, Tab = 2, Row = 4, Column = 0
+    WARLOCK_IMPROVED_IMMOLATE                   = 961,   // TabId = 301, Tab = 2, Row = 4, Column = 1
+    WARLOCK_DEVASTATION                         = 981,   // TabId = 301, Tab = 2, Row = 4, Column = 2
+    WARLOCK_NETHER_PROTECTION                   = 1679,  // TabId = 301, Tab = 2, Row = 5, Column = 0
+    WARLOCK_EMBERSTORM                          = 966,   // TabId = 301, Tab = 2, Row = 5, Column = 2
+    WARLOCK_CONFLAGRATE                         = 968,   // TabId = 301, Tab = 2, Row = 6, Column = 1
+    WARLOCK_SOUL_LEECH                          = 1678,  // TabId = 301, Tab = 2, Row = 6, Column = 2
+    WARLOCK_PYROCLASM                           = 986,   // TabId = 301, Tab = 2, Row = 6, Column = 3
+    WARLOCK_SHADOW_AND_FLAME                    = 1677,  // TabId = 301, Tab = 2, Row = 7, Column = 1
+    WARLOCK_IMPROVED_SOUL_LEECH                 = 1889,  // TabId = 301, Tab = 2, Row = 7, Column = 2
+    WARLOCK_BACKDRAFT                           = 1888,  // TabId = 301, Tab = 2, Row = 8, Column = 0
+    WARLOCK_SHADOWFURY                          = 1676,  // TabId = 301, Tab = 2, Row = 8, Column = 1
+    WARLOCK_EMPOWERED_IMP                       = 2045,  // TabId = 301, Tab = 2, Row = 8, Column = 2
+    WARLOCK_FIRE_AND_BRIMSTONE                  = 1890,  // TabId = 301, Tab = 2, Row = 9, Column = 1
+    WARLOCK_CHAOS_BOLT                          = 1891,  // TabId = 301, Tab = 2, Row = 10, Column = 1
+    WARLOCK_IMPROVED_CURSE_OF_AGONY             = 1284,  // TabId = 302, Tab = 0, Row = 0, Column = 0
+    WARLOCK_SUPPRESSION                         = 1005,  // TabId = 302, Tab = 0, Row = 0, Column = 1
+    WARLOCK_IMPROVED_CORRUPTION                 = 1003,  // TabId = 302, Tab = 0, Row = 0, Column = 2
+    WARLOCK_IMPROVED_CURSE_OF_WEAKNESS          = 1006,  // TabId = 302, Tab = 0, Row = 1, Column = 0
+    WARLOCK_IMPROVED_DRAIN_SOUL                 = 1101,  // TabId = 302, Tab = 0, Row = 1, Column = 1
+    WARLOCK_IMPROVED_LIFE_TAP                   = 1007,  // TabId = 302, Tab = 0, Row = 1, Column = 2
+    WARLOCK_SOUL_SIPHON                         = 1004,  // TabId = 302, Tab = 0, Row = 1, Column = 3
+    WARLOCK_IMPROVED_FEAR                       = 2205,  // TabId = 302, Tab = 0, Row = 2, Column = 0
+    WARLOCK_FEL_CONCENTRATION                   = 1001,  // TabId = 302, Tab = 0, Row = 2, Column = 1
+    WARLOCK_AMPLIFY_CURSE                       = 1061,  // TabId = 302, Tab = 0, Row = 2, Column = 2
+    WARLOCK_GRIM_REACH                          = 1021,  // TabId = 302, Tab = 0, Row = 3, Column = 0
+    WARLOCK_NIGHTFALL                           = 1002,  // TabId = 302, Tab = 0, Row = 3, Column = 1
+    WARLOCK_EMPOWERED_CORRUPTION                = 1764,  // TabId = 302, Tab = 0, Row = 3, Column = 3
+    WARLOCK_SHADOW_EMBRACE                      = 1763,  // TabId = 302, Tab = 0, Row = 4, Column = 0
+    WARLOCK_SIPHON_LIFE                         = 1041,  // TabId = 302, Tab = 0, Row = 4, Column = 1
+    WARLOCK_CURSE_OF_EXHAUSTION                 = 1081,  // TabId = 302, Tab = 0, Row = 4, Column = 2
+    WARLOCK_IMPROVED_FELHUNTER                  = 1873,  // TabId = 302, Tab = 0, Row = 5, Column = 0
+    WARLOCK_SHADOW_MASTERY                      = 1042,  // TabId = 302, Tab = 0, Row = 5, Column = 1
+    WARLOCK_ERADICATION                         = 1878,  // TabId = 302, Tab = 0, Row = 6, Column = 0
+    WARLOCK_CONTAGION                           = 1669,  // TabId = 302, Tab = 0, Row = 6, Column = 1
+    WARLOCK_DARK_PACT                           = 1022,  // TabId = 302, Tab = 0, Row = 6, Column = 2
+    WARLOCK_IMPROVED_HOWL_OF_TERROR             = 1668,  // TabId = 302, Tab = 0, Row = 7, Column = 0
+    WARLOCK_MALEDICTION                         = 1667,  // TabId = 302, Tab = 0, Row = 7, Column = 2
+    WARLOCK_DEATHS_EMBRACE                      = 1875,  // TabId = 302, Tab = 0, Row = 8, Column = 0
+    WARLOCK_UNSTABLE_AFFLICTION                 = 1670,  // TabId = 302, Tab = 0, Row = 8, Column = 1
+    WARLOCK_PANDEMIC                            = 2245,  // TabId = 302, Tab = 0, Row = 8, Column = 2
+    WARLOCK_EVERLASTING_AFFLICTION              = 1876,  // TabId = 302, Tab = 0, Row = 9, Column = 1
+    WARLOCK_HAUNT                               = 2041,  // TabId = 302, Tab = 0, Row = 10, Column = 1
+    WARLOCK_IMPROVED_HEALTHSTONE                = 1221,  // TabId = 303, Tab = 1, Row = 0, Column = 0
+    WARLOCK_IMPROVED_IMP                        = 1222,  // TabId = 303, Tab = 1, Row = 0, Column = 1
+    WARLOCK_DEMONIC_EMBRACE                     = 1223,  // TabId = 303, Tab = 1, Row = 0, Column = 2
+    WARLOCK_FEL_SYNERGY                         = 1883,  // TabId = 303, Tab = 1, Row = 0, Column = 3
+    WARLOCK_IMPROVED_HEALTH_FUNNEL              = 1224,  // TabId = 303, Tab = 1, Row = 1, Column = 0
+    WARLOCK_DEMONIC_BRUTALITY                   = 1225,  // TabId = 303, Tab = 1, Row = 1, Column = 1
+    WARLOCK_FEL_VITALITY                        = 1242,  // TabId = 303, Tab = 1, Row = 1, Column = 2
+    WARLOCK_IMPROVED_SUCCUBUS                   = 1243,  // TabId = 303, Tab = 1, Row = 2, Column = 0
+    WARLOCK_SOUL_LINK                           = 1282,  // TabId = 303, Tab = 1, Row = 2, Column = 1
+    WARLOCK_FEL_DOMINATION                      = 1226,  // TabId = 303, Tab = 1, Row = 2, Column = 2
+    WARLOCK_DEMONIC_AEGIS                       = 1671,  // TabId = 303, Tab = 1, Row = 2, Column = 3
+    WARLOCK_UNHOLY_POWER                        = 1262,  // TabId = 303, Tab = 1, Row = 3, Column = 1
+    WARLOCK_MASTER_SUMMONER                     = 1227,  // TabId = 303, Tab = 1, Row = 3, Column = 2
+    WARLOCK_MANA_FEED                           = 1281,  // TabId = 303, Tab = 1, Row = 4, Column = 0
+    WARLOCK_MASTER_CONJURER                     = 1261,  // TabId = 303, Tab = 1, Row = 4, Column = 2
+    WARLOCK_MASTER_DEMONOLOGIST                 = 1244,  // TabId = 303, Tab = 1, Row = 5, Column = 1
+    WARLOCK_MOLTEN_CORE                         = 1283,  // TabId = 303, Tab = 1, Row = 5, Column = 2
+    WARLOCK_DEMONIC_RESILIENCE                  = 1680,  // TabId = 303, Tab = 1, Row = 6, Column = 0
+    WARLOCK_DEMONIC_EMPOWERMENT                 = 1880,  // TabId = 303, Tab = 1, Row = 6, Column = 1
+    WARLOCK_DEMONIC_KNOWLEDGE                   = 1263,  // TabId = 303, Tab = 1, Row = 6, Column = 2
+    WARLOCK_DEMONIC_TACTICS                     = 1673,  // TabId = 303, Tab = 1, Row = 7, Column = 1
+    WARLOCK_DECIMATION                          = 2261,  // TabId = 303, Tab = 1, Row = 7, Column = 2
+    WARLOCK_IMPROVED_DEMONIC_TACTICS            = 1882,  // TabId = 303, Tab = 1, Row = 8, Column = 0
+    WARLOCK_SUMMON_FELGUARD                     = 1672,  // TabId = 303, Tab = 1, Row = 8, Column = 1
+    WARLOCK_NEMESIS                             = 1884,  // TabId = 303, Tab = 1, Row = 8, Column = 2
+    WARLOCK_DEMONIC_PACT                        = 1885,  // TabId = 303, Tab = 1, Row = 9, Column = 1
+    WARLOCK_METAMORPHOSIS                       = 1886   // TabId = 303, Tab = 1, Row = 10, Column = 1
+};
+
+enum TalentsWarrior  // 0x001
+{
+    WARRIOR_IMPROVED_HEROIC_STRIKE              = 124,   // TabId = 161, Tab = 0, Row = 0, Column = 0
+    WARRIOR_DEFLECTION                          = 130,   // TabId = 161, Tab = 0, Row = 0, Column = 1
+    WARRIOR_IMPROVED_REND                       = 127,   // TabId = 161, Tab = 0, Row = 0, Column = 2
+    WARRIOR_IMPROVED_CHARGE                     = 126,   // TabId = 161, Tab = 0, Row = 1, Column = 0
+    WARRIOR_IRON_WILL                           = 641,   // TabId = 161, Tab = 0, Row = 1, Column = 1
+    WARRIOR_TACTICAL_MASTERY                    = 128,   // TabId = 161, Tab = 0, Row = 1, Column = 2
+    WARRIOR_IMPROVED_OVERPOWER                  = 131,   // TabId = 161, Tab = 0, Row = 2, Column = 0
+    WARRIOR_ANGER_MANAGEMENT                    = 137,   // TabId = 161, Tab = 0, Row = 2, Column = 1
+    WARRIOR_IMPALE                              = 662,   // TabId = 161, Tab = 0, Row = 2, Column = 2
+    WARRIOR_DEEP_WOUNDS                         = 121,   // TabId = 161, Tab = 0, Row = 2, Column = 3
+    WARRIOR_TWOHANDED_WEAPON_SPECIALIZATION     = 136,   // TabId = 161, Tab = 0, Row = 3, Column = 1
+    WARRIOR_TASTE_FOR_BLOOD                     = 2232,  // TabId = 161, Tab = 0, Row = 3, Column = 2
+    WARRIOR_POLEAXE_SPECIALIZATION              = 132,   // TabId = 161, Tab = 0, Row = 4, Column = 0
+    WARRIOR_SWEEPING_STRIKES                    = 133,   // TabId = 161, Tab = 0, Row = 4, Column = 1
+    WARRIOR_MACE_SPECIALIZATION                 = 125,   // TabId = 161, Tab = 0, Row = 4, Column = 2
+    WARRIOR_SWORD_SPECIALIZATION                = 123,   // TabId = 161, Tab = 0, Row = 4, Column = 3
+    WARRIOR_WEAPON_MASTERY                      = 134,   // TabId = 161, Tab = 0, Row = 5, Column = 0
+    WARRIOR_IMPROVED_HAMSTRING                  = 129,   // TabId = 161, Tab = 0, Row = 5, Column = 2
+    WARRIOR_TRAUMA                              = 1859,  // TabId = 161, Tab = 0, Row = 5, Column = 3
+    WARRIOR_SECOND_WIND                         = 1663,  // TabId = 161, Tab = 0, Row = 6, Column = 0
+    WARRIOR_MORTAL_STRIKE                       = 135,   // TabId = 161, Tab = 0, Row = 6, Column = 1
+    WARRIOR_STRENGTH_OF_ARMS                    = 1862,  // TabId = 161, Tab = 0, Row = 6, Column = 2
+    WARRIOR_IMPROVED_SLAM                       = 2233,  // TabId = 161, Tab = 0, Row = 6, Column = 3
+    WARRIOR_JUGGERNAUT                          = 2283,  // TabId = 161, Tab = 0, Row = 7, Column = 0
+    WARRIOR_IMPROVED_MORTAL_STRIKE              = 1824,  // TabId = 161, Tab = 0, Row = 7, Column = 1
+    WARRIOR_UNRELENTING_ASSAULT                 = 1860,  // TabId = 161, Tab = 0, Row = 7, Column = 2
+    WARRIOR_SUDDEN_DEATH                        = 1662,  // TabId = 161, Tab = 0, Row = 8, Column = 0
+    WARRIOR_ENDLESS_RAGE                        = 1661,  // TabId = 161, Tab = 0, Row = 8, Column = 1
+    WARRIOR_BLOOD_FRENZY                        = 1664,  // TabId = 161, Tab = 0, Row = 8, Column = 2
+    WARRIOR_WRECKING_CREW                       = 2231,  // TabId = 161, Tab = 0, Row = 9, Column = 1
+    WARRIOR_BLADESTORM                          = 1863,  // TabId = 161, Tab = 0, Row = 10, Column = 1
+    WARRIOR_IMPROVED_BLOODRAGE                  = 142,   // TabId = 163, Tab = 2, Row = 0, Column = 0
+    WARRIOR_SHIELD_SPECIALIZATION               = 1601,  // TabId = 163, Tab = 2, Row = 0, Column = 1
+    WARRIOR_IMPROVED_THUNDER_CLAP               = 141,   // TabId = 163, Tab = 2, Row = 0, Column = 2
+    WARRIOR_INCITE                              = 144,   // TabId = 163, Tab = 2, Row = 1, Column = 1
+    WARRIOR_ANTICIPATION                        = 138,   // TabId = 163, Tab = 2, Row = 1, Column = 2
+    WARRIOR_LAST_STAND                          = 153,   // TabId = 163, Tab = 2, Row = 2, Column = 0
+    WARRIOR_IMPROVED_REVENGE                    = 147,   // TabId = 163, Tab = 2, Row = 2, Column = 1
+    WARRIOR_SHIELD_MASTERY                      = 1654,  // TabId = 163, Tab = 2, Row = 2, Column = 2
+    WARRIOR_TOUGHNESS                           = 140,   // TabId = 163, Tab = 2, Row = 2, Column = 3
+    WARRIOR_IMPROVED_SPELL_REFLECTION           = 2247,  // TabId = 163, Tab = 2, Row = 3, Column = 0
+    WARRIOR_IMPROVED_DISARM                     = 151,   // TabId = 163, Tab = 2, Row = 3, Column = 1
+    WARRIOR_PUNCTURE                            = 146,   // TabId = 163, Tab = 2, Row = 3, Column = 2
+    WARRIOR_IMPROVED_DISCIPLINES                = 150,   // TabId = 163, Tab = 2, Row = 4, Column = 0
+    WARRIOR_CONCUSSION_BLOW                     = 152,   // TabId = 163, Tab = 2, Row = 4, Column = 1
+    WARRIOR_GAG_ORDER                           = 149,   // TabId = 163, Tab = 2, Row = 4, Column = 2
+    WARRIOR_ONEHANDED_WEAPON_SPECIALIZATION     = 702,   // TabId = 163, Tab = 2, Row = 5, Column = 2
+    WARRIOR_IMPROVED_DEFENSIVE_STANCE           = 1652,  // TabId = 163, Tab = 2, Row = 6, Column = 0
+    WARRIOR_VIGILANCE                           = 148,   // TabId = 163, Tab = 2, Row = 6, Column = 1
+    WARRIOR_FOCUSED_RAGE                        = 1660,  // TabId = 163, Tab = 2, Row = 6, Column = 2
+    WARRIOR_VITALITY                            = 1653,  // TabId = 163, Tab = 2, Row = 7, Column = 1
+    WARRIOR_SAFEGUARD                           = 1870,  // TabId = 163, Tab = 2, Row = 7, Column = 2
+    WARRIOR_WARBRINGER                          = 2236,  // TabId = 163, Tab = 2, Row = 8, Column = 0
+    WARRIOR_DEVASTATE                           = 1666,  // TabId = 163, Tab = 2, Row = 8, Column = 1
+    WARRIOR_CRITICAL_BLOCK                      = 1893,  // TabId = 163, Tab = 2, Row = 8, Column = 2
+    WARRIOR_SWORD_AND_BOARD                     = 1871,  // TabId = 163, Tab = 2, Row = 9, Column = 1
+    WARRIOR_DAMAGE_SHIELD                       = 2246,  // TabId = 163, Tab = 2, Row = 9, Column = 2
+    WARRIOR_SHOCKWAVE                           = 1872,  // TabId = 163, Tab = 2, Row = 10, Column = 1
+    WARRIOR_ARMORED_TO_THE_TEETH                = 2250,  // TabId = 164, Tab = 1, Row = 0, Column = 0
+    WARRIOR_BOOMING_VOICE                       = 158,   // TabId = 164, Tab = 1, Row = 0, Column = 1
+    WARRIOR_CRUELTY                             = 157,   // TabId = 164, Tab = 1, Row = 0, Column = 2
+    WARRIOR_IMPROVED_DEMORALIZING_SHOUT         = 161,   // TabId = 164, Tab = 1, Row = 1, Column = 1
+    WARRIOR_UNBRIDLED_WRATH                     = 159,   // TabId = 164, Tab = 1, Row = 1, Column = 2
+    WARRIOR_IMPROVED_CLEAVE                     = 166,   // TabId = 164, Tab = 1, Row = 2, Column = 0
+    WARRIOR_PIERCING_HOWL                       = 160,   // TabId = 164, Tab = 1, Row = 2, Column = 1
+    WARRIOR_BLOOD_CRAZE                         = 661,   // TabId = 164, Tab = 1, Row = 2, Column = 2
+    WARRIOR_COMMANDING_PRESENCE                 = 154,   // TabId = 164, Tab = 1, Row = 2, Column = 3
+    WARRIOR_DUAL_WIELD_SPECIALIZATION           = 1581,  // TabId = 164, Tab = 1, Row = 3, Column = 0
+    WARRIOR_IMPROVED_EXECUTE                    = 1542,  // TabId = 164, Tab = 1, Row = 3, Column = 1
+    WARRIOR_ENRAGE                              = 155,   // TabId = 164, Tab = 1, Row = 3, Column = 2
+    WARRIOR_PRECISION                           = 1657,  // TabId = 164, Tab = 1, Row = 4, Column = 0
+    WARRIOR_DEATH_WISH                          = 165,   // TabId = 164, Tab = 1, Row = 4, Column = 1
+    WARRIOR_IMPROVED_INTERCEPT                  = 1543,  // TabId = 164, Tab = 1, Row = 4, Column = 2
+    WARRIOR_IMPROVED_BERSERKER_RAGE             = 1541,  // TabId = 164, Tab = 1, Row = 5, Column = 0
+    WARRIOR_FLURRY                              = 156,   // TabId = 164, Tab = 1, Row = 5, Column = 2
+    WARRIOR_INTENSIFY_RAGE                      = 1864,  // TabId = 164, Tab = 1, Row = 6, Column = 0
+    WARRIOR_BLOODTHIRST                         = 167,   // TabId = 164, Tab = 1, Row = 6, Column = 1
+    WARRIOR_IMPROVED_WHIRLWIND                  = 1655,  // TabId = 164, Tab = 1, Row = 6, Column = 3
+    WARRIOR_FURIOUS_ATTACKS                     = 1865,  // TabId = 164, Tab = 1, Row = 7, Column = 0
+    WARRIOR_IMPROVED_BERSERKER_STANCE           = 1658,  // TabId = 164, Tab = 1, Row = 7, Column = 3
+    WARRIOR_HEROIC_FURY                         = 1868,  // TabId = 164, Tab = 1, Row = 8, Column = 0
+    WARRIOR_RAMPAGE                             = 1659,  // TabId = 164, Tab = 1, Row = 8, Column = 1
+    WARRIOR_BLOODSURGE                          = 1866,  // TabId = 164, Tab = 1, Row = 8, Column = 2
+    WARRIOR_UNENDING_FURY                       = 2234,  // TabId = 164, Tab = 1, Row = 9, Column = 1
+    WARRIOR_TITANS_GRIP                         = 1867   // TabId = 164, Tab = 1, Row = 10, Column = 1
+};
+
+enum TalentsPet  // 0x000
+{
+    PET_TENACITY_COBRA_REFLEXES                 = 2114,  // TabId = 409, Tab = 0, Row = 0, Column = 0
+    PET_TENACITY_CHARGE                         = 2237,  // TabId = 409, Tab = 0, Row = 0, Column = 1
+    PET_TENACITY_GREAT_STAMINA                  = 2116,  // TabId = 409, Tab = 0, Row = 0, Column = 2
+    PET_TENACITY_NATURAL_ARMOR                  = 2117,  // TabId = 409, Tab = 0, Row = 0, Column = 3
+    PET_TENACITY_SPIKED_COLLAR                  = 2126,  // TabId = 409, Tab = 0, Row = 1, Column = 0
+    PET_TENACITY_BOARS_SPEED                    = 2160,  // TabId = 409, Tab = 0, Row = 1, Column = 1
+    PET_TENACITY_BLOOD_OF_THE_RHINO             = 2173,  // TabId = 409, Tab = 0, Row = 1, Column = 2
+    PET_TENACITY_PET_BARDING                    = 2122,  // TabId = 409, Tab = 0, Row = 1, Column = 3
+    PET_TENACITY_CULLING_THE_HERD               = 2110,  // TabId = 409, Tab = 0, Row = 2, Column = 0
+    PET_TENACITY_GUARD_DOG                      = 2123,  // TabId = 409, Tab = 0, Row = 2, Column = 1
+    PET_TENACITY_LIONHEARTED                    = 2162,  // TabId = 409, Tab = 0, Row = 2, Column = 2
+    PET_TENACITY_THUNDERSTOMP                   = 2277,  // TabId = 409, Tab = 0, Row = 2, Column = 3
+    PET_TENACITY_GRACE_OF_THE_MANTIS            = 2163,  // TabId = 409, Tab = 0, Row = 3, Column = 2
+    PET_TENACITY_GREAT_RESISTANCE               = 2161,  // TabId = 409, Tab = 0, Row = 3, Column = 3
+    PET_TENACITY_LAST_STAND                     = 2171,  // TabId = 409, Tab = 0, Row = 4, Column = 0
+    PET_TENACITY_TAUNT                          = 2170,  // TabId = 409, Tab = 0, Row = 4, Column = 1
+    PET_TENACITY_ROAR_OF_SACRIFICE              = 2172,  // TabId = 409, Tab = 0, Row = 4, Column = 2
+    PET_TENACITY_INTERVENE                      = 2169,  // TabId = 409, Tab = 0, Row = 4, Column = 3
+    PET_TENACITY_SILVERBACK                     = 2258,  // TabId = 409, Tab = 0, Row = 5, Column = 1
+    PET_TENACITY_WILD_HUNT                      = 2255,  // TabId = 409, Tab = 0, Row = 5, Column = 2
+    PET_FEROCITY_COBRA_REFLEXES                 = 2107,  // TabId = 410, Tab = 0, Row = 0, Column = 0
+    // TODO: same spell, one for flying pets other for land pets. Figure out which is which if it ever matters.
+    PET_FEROCITY_DASHDIVE1                      = 2109,  // TabId = 410, Tab = 0, Row = 0, Column = 1
+    PET_FEROCITY_DASHDIVE2                      = 2203,  // TabId = 410, Tab = 0, Row = 0, Column = 1
+    PET_FEROCITY_GREAT_STAMINA                  = 2112,  // TabId = 410, Tab = 0, Row = 0, Column = 2
+    PET_FEROCITY_NATURAL_ARMOR                  = 2113,  // TabId = 410, Tab = 0, Row = 0, Column = 3
+    PET_FEROCITY_IMPROVED_COWER                 = 2124,  // TabId = 410, Tab = 0, Row = 1, Column = 0
+    PET_FEROCITY_BLOODTHIRSTY                   = 2128,  // TabId = 410, Tab = 0, Row = 1, Column = 1
+    PET_FEROCITY_SPIKED_COLLAR                  = 2125,  // TabId = 410, Tab = 0, Row = 1, Column = 2
+    PET_FEROCITY_BOARS_SPEED                    = 2151,  // TabId = 410, Tab = 0, Row = 1, Column = 3
+    PET_FEROCITY_CULLING_THE_HERD               = 2106,  // TabId = 410, Tab = 0, Row = 2, Column = 0
+    PET_FEROCITY_LIONHEARTED                    = 2152,  // TabId = 410, Tab = 0, Row = 2, Column = 2
+    // TODO: same spell, one for flying pets other for land pets. Figure out which is which if it ever matters.
+    PET_FEROCITY_CHARGESWOOP1                   = 2111,  // TabId = 410, Tab = 0, Row = 2, Column = 3
+    PET_FEROCITY_CHARGESWOOP2                   = 2219,  // TabId = 410, Tab = 0, Row = 2, Column = 3
+    PET_FEROCITY_HEART_OF_THE_PHOENIX           = 2156,  // TabId = 410, Tab = 0, Row = 3, Column = 1
+    PET_FEROCITY_SPIDERS_BITE                   = 2129,  // TabId = 410, Tab = 0, Row = 3, Column = 2
+    PET_FEROCITY_GREAT_RESISTANCE               = 2154,  // TabId = 410, Tab = 0, Row = 3, Column = 3
+    PET_FEROCITY_RABID                          = 2155,  // TabId = 410, Tab = 0, Row = 4, Column = 0
+    PET_FEROCITY_LICK_YOUR_WOUNDS               = 2153,  // TabId = 410, Tab = 0, Row = 4, Column = 1
+    PET_FEROCITY_CALL_OF_THE_WILD               = 2157,  // TabId = 410, Tab = 0, Row = 4, Column = 2
+    PET_FEROCITY_SHARK_ATTACK                   = 2254,  // TabId = 410, Tab = 0, Row = 5, Column = 0
+    PET_FEROCITY_WILD_HUNT                      = 2253,  // TabId = 410, Tab = 0, Row = 5, Column = 2
+    PET_CUNNING_COBRA_REFLEXES                  = 2118,  // TabId = 411, Tab = 0, Row = 0, Column = 0
+    // TODO: same spell, one for flying pets other for land pets. Figure out which is which if it ever matters.
+    PET_CUNNING_DASHDIVE1                       = 2119,  // TabId = 411, Tab = 0, Row = 0, Column = 1
+    PET_CUNNING_DASHDIVE2                       = 2201,  // TabId = 411, Tab = 0, Row = 0, Column = 1
+    PET_CUNNING_GREAT_STAMINA                   = 2120,  // TabId = 411, Tab = 0, Row = 0, Column = 2
+    PET_CUNNING_NATURAL_ARMOR                   = 2121,  // TabId = 411, Tab = 0, Row = 0, Column = 3
+    PET_CUNNING_BOARS_SPEED                     = 2165,  // TabId = 411, Tab = 0, Row = 1, Column = 0
+    // TODO: Frankly, not sure what the difference is. Presumably one for land, one for air? Because they require Dash or Dive.
+    PET_CUNNING_MOBILITY1                       = 2207,  // TabId = 411, Tab = 0, Row = 1, Column = 1
+    PET_CUNNING_MOBILITY2                       = 2208,  // TabId = 411, Tab = 0, Row = 1, Column = 1
+    PET_CUNNING_OWLS_FOCUS                      = 2182,  // TabId = 411, Tab = 0, Row = 1, Column = 2
+    PET_CUNNING_SPIKED_COLLAR                   = 2127,  // TabId = 411, Tab = 0, Row = 1, Column = 3
+    PET_CUNNING_CULLING_THE_HERD                = 2166,  // TabId = 411, Tab = 0, Row = 2, Column = 0
+    PET_CUNNING_LIONHEARTED                     = 2167,  // TabId = 411, Tab = 0, Row = 2, Column = 1
+    PET_CUNNING_CARRION_FEEDER                  = 2206,  // TabId = 411, Tab = 0, Row = 2, Column = 2
+    PET_CUNNING_GREAT_RESISTANCE                = 2168,  // TabId = 411, Tab = 0, Row = 3, Column = 1
+    PET_CUNNING_CORNERED                        = 2177,  // TabId = 411, Tab = 0, Row = 3, Column = 2
+    PET_CUNNING_FEEDING_FRENZY                  = 2183,  // TabId = 411, Tab = 0, Row = 3, Column = 3
+    PET_CUNNING_WOLVERINE_BITE                  = 2181,  // TabId = 411, Tab = 0, Row = 4, Column = 0
+    PET_CUNNING_ROAR_OF_RECOVERY                = 2184,  // TabId = 411, Tab = 0, Row = 4, Column = 1
+    PET_CUNNING_BULLHEADED                      = 2175,  // TabId = 411, Tab = 0, Row = 4, Column = 2
+    PET_CUNNING_GRACE_OF_THE_MANTIS             = 2257,  // TabId = 411, Tab = 0, Row = 4, Column = 3
+    PET_CUNNING_WILD_HUNT                       = 2256,  // TabId = 411, Tab = 0, Row = 5, Column = 0
+    PET_CUNNING_ROAR_OF_SACRIFICE               = 2278  // TabId = 411, Tab = 0, Row = 5, Column = 3
+};
+
+enum Glyphs
+{
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DARK_COMMAND         = 511,   // Level 55  Spell ID: 58613
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_ANTIMAGIC_SHELL      = 512,   // Level 55  Spell ID: 58623
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_HEART_STRIKE         = 513,   // Unknown   Spell ID: 58616
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_BONE_SHIELD          = 515,   // Level 55  Spell ID: 58673
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_CHAINS_OF_ICE        = 516,   // Level 55  Spell ID: 58620
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_GRIP           = 519,   // Level 55  Spell ID: 62259
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_AND_DECAY      = 520,   // Level 55  Spell ID: 58629
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_FROST_STRIKE         = 521,   // Level 55  Spell ID: 58647
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_ICEBOUND_FORTITUDE   = 523,   // Level 55  Spell ID: 58625
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_ICY_TOUCH            = 524,   // Level 55  Spell ID: 58631
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_OBLITERATE           = 525,   // Level 55  Spell ID: 58671
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_PLAGUE_STRIKE        = 526,   // Level 55  Spell ID: 58657
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_THE_GHOUL            = 527,   // Level 55  Spell ID: 58686
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_RUNE_STRIKE          = 528,   // Level 55  Spell ID: 58669
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_SCOURGE_STRIKE       = 529,   // Level 55  Spell ID: 58642
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_STRANGULATE          = 530,   // Level 55  Spell ID: 58618
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_UNBREAKABLE_ARMOR    = 531,   // Level 55  Spell ID: 58635
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_VAMPIRIC_BLOOD       = 532,   // Level 55  Spell ID: 58676
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_RUNE_TAP             = 556,   // Level 55  Spell ID: 59327
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_BLOOD_STRIKE         = 557,   // Level 55  Spell ID: 59332
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_STRIKE         = 558,   // Level 55  Spell ID: 59336
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DANCING_RUNE_WEAPON  = 768,   // Level 60  Spell ID: 63330
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_HUNGERING_COLD       = 769,   // Level 60  Spell ID: 63331
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_UNHOLY_BLIGHT        = 770,   // Level 60  Spell ID: 63332
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DARK_DEATH           = 771,   // Level 55  Spell ID: 63333
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DISEASE              = 772,   // Level 55  Spell ID: 63334
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_HOWLING_BLAST        = 773,   // Level 60  Spell ID: 63335
+    DEATH_KNIGHT_MINOR_GLYPH_OF_BLOOD_TAP            = 514,   // Level 55  Spell ID: 58640
+    DEATH_KNIGHT_MINOR_GLYPH_OF_DEATHS_EMBRACE       = 518,   // Level 55  Spell ID: 58677
+    DEATH_KNIGHT_MINOR_GLYPH_OF_HORN_OF_WINTER       = 522,   // Level 55  Spell ID: 58680
+    DEATH_KNIGHT_MINOR_GLYPH_OF_PESTILENCE           = 553,   // Level 55  Spell ID: 59309
+    DEATH_KNIGHT_MINOR_GLYPH_OF_CORPSE_EXPLOSION     = 554,   // Level 55  Spell ID: 59307
+    // TODO: Hmm, this looks suspiciously alike... yet not. What's up?
+    DEATH_KNIGHT_MINOR_GLYPH_OF_RAISE_DEAD           = 555,   // Level 55  Spell ID: 60200
+    DEATH_KNIGHT_MINOR_GLYPH_OF_RAISE_DEAD2          = 571,   // Level 55  Spell ID: 60200
+    DRUID_MAJOR_GLYPH_OF_FRENZIED_REGENERATION       = 161,   // Level 36  Spell ID: 54810
+    DRUID_MAJOR_GLYPH_OF_MAUL                        = 162,   // Level 15  Spell ID: 54811
+    DRUID_MAJOR_GLYPH_OF_MANGLE                      = 164,   // Level 50  Spell ID: 54813
+    DRUID_MAJOR_GLYPH_OF_SHRED                       = 165,   // Level 22  Spell ID: 54815
+    DRUID_MAJOR_GLYPH_OF_RIP                         = 166,   // Level 20  Spell ID: 54818
+    DRUID_MAJOR_GLYPH_OF_RAKE                        = 167,   // Level 24  Spell ID: 54821
+    DRUID_MAJOR_GLYPH_OF_SWIFTMEND                   = 168,   // Level 40  Spell ID: 54824
+    DRUID_MAJOR_GLYPH_OF_INNERVATE                   = 169,   // Level 40  Spell ID: 54832
+    DRUID_MAJOR_GLYPH_OF_REBIRTH                     = 170,   // Level 20  Spell ID: 54733
+    DRUID_MAJOR_GLYPH_OF_REGROWTH                    = 171,   // Level 15  Spell ID: 54743
+    DRUID_MAJOR_GLYPH_OF_REJUVENATION                = 172,   // Level 15  Spell ID: 54754
+    DRUID_MAJOR_GLYPH_OF_HEALING_TOUCH               = 173,   // Level 15  Spell ID: 54825
+    DRUID_MAJOR_GLYPH_OF_LIFEBLOOM                   = 174,   // Level 64  Spell ID: 54826
+    DRUID_MAJOR_GLYPH_OF_STARFIRE                    = 175,   // Level 20  Spell ID: 54845
+    DRUID_MAJOR_GLYPH_OF_INSECT_SWARM                = 176,   // Level 20  Spell ID: 54830
+    DRUID_MAJOR_GLYPH_OF_HURRICANE                   = 177,   // Level 40  Spell ID: 54831
+    DRUID_MAJOR_GLYPH_OF_STARFALL                    = 178,   // Level 60  Spell ID: 54828
+    DRUID_MAJOR_GLYPH_OF_WRATH                       = 179,   // Level 15  Spell ID: 54756
+    DRUID_MAJOR_GLYPH_OF_MOONFIRE                    = 180,   // Level 15  Spell ID: 54829
+    DRUID_MAJOR_GLYPH_OF_ENTANGLING_ROOTS            = 181,   // Level 15  Spell ID: 54760
+    DRUID_MAJOR_GLYPH_OF_FOCUS                       = 631,   // Level 70  Spell ID: 62080
+    DRUID_MAJOR_GLYPH_OF_BERSERK                     = 671,   // Level 60  Spell ID: 62969
+    DRUID_MAJOR_GLYPH_OF_WILD_GROWTH                 = 672,   // Level 60  Spell ID: 62970
+    DRUID_MAJOR_GLYPH_OF_NOURISH                     = 673,   // Level 80  Spell ID: 62971
+    DRUID_MAJOR_GLYPH_OF_SAVAGE_ROAR                 = 674,   // Level 75  Spell ID: 63055
+    DRUID_MAJOR_GLYPH_OF_MONSOON                     = 675,   // Level 50  Spell ID: 63056
+    DRUID_MAJOR_GLYPH_OF_BARKSKIN                    = 676,   // Level 44  Spell ID: 63057
+    DRUID_MAJOR_GLYPH_OF_SURVIVAL_INSTINCTS          = 811,   // Level 20  Spell ID: 65243
+    DRUID_MAJOR_GLYPH_OF_CLAW                        = 831,   // Level 20  Spell ID: 67598
+    DRUID_MAJOR_GLYPH_OF_RAPID_REJUVENATION          = 891,   // Level 15  Spell ID: 71013
+    DRUID_MINOR_GLYPH_OF_AQUATIC_FORM                = 431,   // Level 16  Spell ID: 57856
+    DRUID_MINOR_GLYPH_OF_CHALLENGING_ROAR            = 432,   // Level 28  Spell ID: 57858
+    DRUID_MINOR_GLYPH_OF_THE_WILD                    = 433,   // Level 15  Spell ID: 57855
+    DRUID_MINOR_GLYPH_OF_UNBURDENED_REBIRTH          = 434,   // Level 20  Spell ID: 57857
+    DRUID_MINOR_GLYPH_OF_THORNS                      = 435,   // Level 15  Spell ID: 57862
+    DRUID_MINOR_GLYPH_OF_DASH                        = 551,   // Level 16  Spell ID: 59219
+    DRUID_MINOR_GLYPH_OF_TYPHOON                     = 613,   // Level 70  Spell ID: 62135
+    HUNTER_MAJOR_GLYPH_OF_AIMED_SHOT                 = 351,   // Level 20  Spell ID: 56824
+    HUNTER_MAJOR_GLYPH_OF_ARCANE_SHOT                = 352,   // Level 15  Spell ID: 56841
+    HUNTER_MAJOR_GLYPH_OF_THE_BEAST                  = 353,   // Level 30  Spell ID: 56857
+    HUNTER_MAJOR_GLYPH_OF_MENDING                    = 354,   // Level 15  Spell ID: 56833
+    HUNTER_MAJOR_GLYPH_OF_ASPECT_OF_THE_VIPER        = 355,   // Level 20  Spell ID: 56851
+    HUNTER_MAJOR_GLYPH_OF_BESTIAL_WRATH              = 356,   // Level 40  Spell ID: 56830
+    HUNTER_MAJOR_GLYPH_OF_DETERRENCE                 = 357,   // Level 20  Spell ID: 56850
+    HUNTER_MAJOR_GLYPH_OF_DISENGAGE                  = 358,   // Level 20  Spell ID: 56844
+    HUNTER_MAJOR_GLYPH_OF_FREEZING_TRAP              = 359,   // Level 20  Spell ID: 56845
+    HUNTER_MAJOR_GLYPH_OF_FROST_TRAP                 = 360,   // Level 28  Spell ID: 56847
+    HUNTER_MAJOR_GLYPH_OF_HUNTERS_MARK               = 361,   // Level 15  Spell ID: 56829
+    HUNTER_MAJOR_GLYPH_OF_IMMOLATION_TRAP            = 362,   // Level 16  Spell ID: 56846
+    HUNTER_MAJOR_GLYPH_OF_MULTISHOT                  = 364,   // Level 18  Spell ID: 56836
+    HUNTER_MAJOR_GLYPH_OF_RAPID_FIRE                 = 365,   // Level 26  Spell ID: 56828
+    HUNTER_MAJOR_GLYPH_OF_SERPENT_STING              = 366,   // Level 15  Spell ID: 56832
+    HUNTER_MAJOR_GLYPH_OF_SNAKE_TRAP                 = 367,   // Level 68  Spell ID: 56849
+    HUNTER_MAJOR_GLYPH_OF_STEADY_SHOT                = 368,   // Level 62  Spell ID: 56826
+    HUNTER_MAJOR_GLYPH_OF_TRUESHOT_AURA              = 369,   // Level 40  Spell ID: 56842
+    HUNTER_MAJOR_GLYPH_OF_VOLLEY                     = 370,   // Level 40  Spell ID: 56838
+    HUNTER_MAJOR_GLYPH_OF_WYVERN_STING               = 371,   // Level 40  Spell ID: 56848
+    HUNTER_MAJOR_GLYPH_OF_CHIMERA_SHOT               = 677,   // Level 60  Spell ID: 63065
+    HUNTER_MAJOR_GLYPH_OF_EXPLOSIVE_SHOT             = 691,   // Level 60  Spell ID: 63066
+    HUNTER_MAJOR_GLYPH_OF_KILL_SHOT                  = 692,   // Level 71  Spell ID: 63067
+    HUNTER_MAJOR_GLYPH_OF_EXPLOSIVE_TRAP             = 693,   // Level 34  Spell ID: 63068
+    HUNTER_MAJOR_GLYPH_OF_SCATTER_SHOT               = 694,   // Level 20  Spell ID: 63069
+    HUNTER_MAJOR_GLYPH_OF_RAPTOR_STRIKE              = 695,   // Level 15  Spell ID: 63086
+    HUNTER_MINOR_GLYPH_OF_REVIVE_PET                 = 439,   // Level 15  Spell ID: 57866
+    HUNTER_MINOR_GLYPH_OF_MEND_PET                   = 440,   // Level 15  Spell ID: 57870
+    HUNTER_MINOR_GLYPH_OF_FEIGN_DEATH                = 441,   // Level 30  Spell ID: 57903
+    HUNTER_MINOR_GLYPH_OF_SCARE_BEAST                = 442,   // Level 15  Spell ID: 57902
+    HUNTER_MINOR_GLYPH_OF_THE_PACK                   = 443,   // Level 40  Spell ID: 57904
+    HUNTER_MINOR_GLYPH_OF_POSSESSED_STRENGTH         = 444,   // Level 15  Spell ID: 57900
+    MAGE_MAJOR_GLYPH_OF_ARCANE_EXPLOSION             = 311,   // Level 15  Spell ID: 56360
+    MAGE_MAJOR_GLYPH_OF_ARCANE_MISSILES              = 312,   // Level 15  Spell ID: 56363
+    MAGE_MAJOR_GLYPH_OF_ARCANE_POWER                 = 313,   // Level 40  Spell ID: 56381
+    MAGE_MAJOR_GLYPH_OF_BLINK                        = 314,   // Level 20  Spell ID: 56365
+    MAGE_MAJOR_GLYPH_OF_EVOCATION                    = 315,   // Level 20  Spell ID: 56380
+    MAGE_MAJOR_GLYPH_OF_FIREBALL                     = 316,   // Level 15  Spell ID: 56368
+    MAGE_MAJOR_GLYPH_OF_FIRE_BLAST                   = 317,   // Level 15  Spell ID: 56369
+    MAGE_MAJOR_GLYPH_OF_FROST_NOVA                   = 318,   // Level 15  Spell ID: 56376
+    MAGE_MAJOR_GLYPH_OF_FROSTBOLT                    = 319,   // Level 15  Spell ID: 56370
+    MAGE_MAJOR_GLYPH_OF_ICE_ARMOR                    = 320,   // Level 15  Spell ID: 56384
+    MAGE_MAJOR_GLYPH_OF_ICE_BLOCK                    = 321,   // Level 30  Spell ID: 56372
+    MAGE_MAJOR_GLYPH_OF_ICE_LANCE                    = 322,   // Level 66  Spell ID: 56377
+    MAGE_MAJOR_GLYPH_OF_ICY_VEINS                    = 323,   // Level 20  Spell ID: 56374
+    MAGE_MAJOR_GLYPH_OF_SCORCH                       = 324,   // Level 20  Spell ID: 56371
+    MAGE_MAJOR_GLYPH_OF_INVISIBILITY                 = 325,   // Level 68  Spell ID: 56366
+    MAGE_MAJOR_GLYPH_OF_MAGE_ARMOR                   = 326,   // Level 34  Spell ID: 56383
+    MAGE_MAJOR_GLYPH_OF_MANA_GEM                     = 327,   // Level 30  Spell ID: 56367
+    MAGE_MAJOR_GLYPH_OF_MOLTEN_ARMOR                 = 328,   // Level 62  Spell ID: 56382
+    MAGE_MAJOR_GLYPH_OF_POLYMORPH                    = 329,   // Level 15  Spell ID: 56375
+    MAGE_MAJOR_GLYPH_OF_REMOVE_CURSE                 = 330,   // Level 18  Spell ID: 56364
+    MAGE_MAJOR_GLYPH_OF_WATER_ELEMENTAL              = 331,   // Level 50  Spell ID: 56373
+    MAGE_MAJOR_GLYPH_OF_FROSTFIRE                    = 591,   // Level 75  Spell ID: 61205
+    MAGE_MAJOR_GLYPH_OF_ARCANE_BLAST                 = 651,   // Level 64  Spell ID: 62210
+    MAGE_MAJOR_GLYPH_OF_DEEP_FREEZE                  = 696,   // Level 60  Spell ID: 63090
+    MAGE_MAJOR_GLYPH_OF_LIVING_BOMB                  = 697,   // Level 60  Spell ID: 63091
+    MAGE_MAJOR_GLYPH_OF_ARCANE_BARRAGE               = 698,   // Level 60  Spell ID: 63092
+    MAGE_MAJOR_GLYPH_OF_MIRROR_IMAGE                 = 699,   // Level 80  Spell ID: 63093
+    MAGE_MAJOR_GLYPH_OF_ICE_BARRIER                  = 700,   // Level 46  Spell ID: 63095
+    MAGE_MAJOR_GLYPH_OF_ETERNAL_WATER                = 871,   // Level 50  Spell ID: 70937
+    MAGE_MINOR_GLYPH_OF_ARCANE_INTELLECT             = 445,   // Level 15  Spell ID: 57924
+    MAGE_MINOR_GLYPH_OF_BLAST_WAVE                   = 611,   // Level 70  Spell ID: 62126
+    MAGE_MINOR_GLYPH_OF_FIRE_WARD                    = 446,   // Level 20  Spell ID: 57926
+    MAGE_MINOR_GLYPH_OF_FROST_WARD                   = 447,   // Level 22  Spell ID: 57927
+    MAGE_MINOR_GLYPH_OF_FROST_ARMOR                  = 448,   // Level 15  Spell ID: 57928
+    MAGE_MINOR_GLYPH_OF_THE_PENGUIN                  = 450,   // Level 15  Spell ID: 52648
+    MAGE_MINOR_GLYPH_OF_SLOW_FALL                    = 451,   // Level 15  Spell ID: 57925
+    PALADIN_MAJOR_GLYPH_OF_JUDGEMENT                 = 183,   // Level 15  Spell ID: 54922
+    PALADIN_MAJOR_GLYPH_OF_SEAL_OF_COMMAND           = 184,   // Level 20  Spell ID: 54925
+    PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_JUSTICE         = 185,   // Level 15  Spell ID: 54923
+    PALADIN_MAJOR_GLYPH_OF_SPIRITUAL_ATTUNEMENT      = 186,   // Level 18  Spell ID: 54924
+    PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_WRATH           = 187,   // Level 44  Spell ID: 54926
+    PALADIN_MAJOR_GLYPH_OF_CRUSADER_STRIKE           = 188,   // Level 20  Spell ID: 54927
+    PALADIN_MAJOR_GLYPH_OF_CONSECRATION              = 189,   // Level 20  Spell ID: 54928
+    PALADIN_MAJOR_GLYPH_OF_RIGHTEOUS_DEFENSE         = 190,   // Level 15  Spell ID: 54929
+    PALADIN_MAJOR_GLYPH_OF_AVENGERS_SHIELD           = 191,   // Level 50  Spell ID: 54930
+    PALADIN_MAJOR_GLYPH_OF_TURN_EVIL                 = 192,   // Level 24  Spell ID: 54931
+    PALADIN_MAJOR_GLYPH_OF_EXORCISM                  = 193,   // Level 20  Spell ID: 54934
+    PALADIN_MAJOR_GLYPH_OF_CLEANSING                 = 194,   // Level 35  Spell ID: 54935
+    PALADIN_MAJOR_GLYPH_OF_FLASH_OF_LIGHT            = 195,   // Level 20  Spell ID: 54936
+    PALADIN_MAJOR_GLYPH_OF_HOLY_LIGHT                = 196,   // Level 15  Spell ID: 54937
+    PALADIN_MAJOR_GLYPH_OF_AVENGING_WRATH            = 197,   // Level 70  Spell ID: 54938
+    PALADIN_MAJOR_GLYPH_OF_DIVINITY                  = 198,   // Level 15  Spell ID: 54939
+    PALADIN_MAJOR_GLYPH_OF_SEAL_OF_WISDOM            = 199,   // Level 38  Spell ID: 54940
+    PALADIN_MAJOR_GLYPH_OF_SEAL_OF_LIGHT             = 200,   // Level 30  Spell ID: 54943
+    PALADIN_MAJOR_GLYPH_OF_HOLY_WRATH                = 559,   // Unknown   Spell ID: 56420
+    PALADIN_MAJOR_GLYPH_OF_SEAL_OF_RIGHTEOUSNESS     = 560,   // Level 50  Spell ID: 56414
+    PALADIN_MAJOR_GLYPH_OF_SEAL_OF_VENGEANCE         = 561,   // Level 50  Spell ID: 56416
+    PALADIN_MAJOR_GLYPH_OF_BEACON_OF_LIGHT           = 701,   // Level 60  Spell ID: 63218
+    PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_THE_RIGHTEOUS   = 702,   // Level 60  Spell ID: 63219
+    PALADIN_MAJOR_GLYPH_OF_DIVINE_STORM              = 703,   // Level 60  Spell ID: 63220
+    PALADIN_MAJOR_GLYPH_OF_SHIELD_OF_RIGHTEOUSNESS   = 704,   // Level 75  Spell ID: 63222
+    PALADIN_MAJOR_GLYPH_OF_DIVINE_PLEA               = 705,   // Level 71  Spell ID: 63223
+    PALADIN_MAJOR_GLYPH_OF_HOLY_SHOCK                = 706,   // Level 40  Spell ID: 63224
+    PALADIN_MAJOR_GLYPH_OF_SALVATION                 = 707,   // Level 26  Spell ID: 63225
+    PALADIN_MINOR_GLYPH_OF_BLESSING_OF_KINGS         = 452,   // Level 20  Spell ID: 57937
+    PALADIN_MINOR_GLYPH_OF_BLESSING_OF_MIGHT         = 453,   // Level 15  Spell ID: 57958
+    PALADIN_MINOR_GLYPH_OF_BLESSING_OF_WISDOM        = 454,   // Level 15  Spell ID: 57979
+    PALADIN_MINOR_GLYPH_OF_LAY_ON_HANDS              = 455,   // Level 15  Spell ID: 57955
+    PALADIN_MINOR_GLYPH_OF_SENSE_UNDEAD              = 456,   // Level 20  Spell ID: 57947
+    PALADIN_MINOR_GLYPH_OF_THE_WISE                  = 457,   // Level 15  Spell ID: 57954
+    PRIEST_MAJOR_GLYPH_OF_CIRCLE_OF_HEALING          = 251,   // Level 50  Spell ID: 55675
+    PRIEST_MAJOR_GLYPH_OF_DISPEL_MAGIC               = 252,   // Level 18  Spell ID: 55677
+    PRIEST_MAJOR_GLYPH_OF_FADE                       = 253,   // Level 15  Spell ID: 55684
+    PRIEST_MAJOR_GLYPH_OF_FEAR_WARD                  = 254,   // Level 20  Spell ID: 55678
+    PRIEST_MAJOR_GLYPH_OF_FLASH_HEAL                 = 255,   // Level 20  Spell ID: 55679
+    PRIEST_MAJOR_GLYPH_OF_HOLY_NOVA                  = 256,   // Level 20  Spell ID: 55683
+    PRIEST_MAJOR_GLYPH_OF_INNER_FIRE                 = 257,   // Level 15  Spell ID: 55686
+    PRIEST_MAJOR_GLYPH_OF_LIGHTWELL                  = 258,   // Level 40  Spell ID: 55673
+    PRIEST_MAJOR_GLYPH_OF_MASS_DISPEL                = 259,   // Level 70  Spell ID: 55691
+    PRIEST_MAJOR_GLYPH_OF_MIND_CONTROL               = 260,   // Level 30  Spell ID: 55688
+    PRIEST_MAJOR_GLYPH_OF_SHADOW_WORD_PAIN           = 261,   // Level 15  Spell ID: 55681
+    PRIEST_MAJOR_GLYPH_OF_SHADOW                     = 262,   // Level 20  Spell ID: 55689
+    PRIEST_MAJOR_GLYPH_OF_POWER_WORD_SHIELD          = 263,   // Level 15  Spell ID: 55672
+    PRIEST_MAJOR_GLYPH_OF_PRAYER_OF_HEALING          = 264,   // Level 30  Spell ID: 55680
+    PRIEST_MAJOR_GLYPH_OF_PSYCHIC_SCREAM             = 265,   // Level 15  Spell ID: 55676
+    PRIEST_MAJOR_GLYPH_OF_RENEW                      = 266,   // Level 15  Spell ID: 55674
+    PRIEST_MAJOR_GLYPH_OF_SCOURGE_IMPRISONMENT       = 267,   // Level 20  Spell ID: 55690
+    PRIEST_MAJOR_GLYPH_OF_SHADOW_WORD_DEATH          = 268,   // Level 62  Spell ID: 55682
+    PRIEST_MAJOR_GLYPH_OF_MIND_FLAY                  = 269,   // Level 20  Spell ID: 55687
+    PRIEST_MAJOR_GLYPH_OF_SMITE                      = 270,   // Level 15  Spell ID: 55692
+    PRIEST_MAJOR_GLYPH_OF_SPIRIT_OF_REDEMPTION       = 271,   // Level 30  Spell ID: 55685
+    PRIEST_MAJOR_GLYPH_OF_DISPERSION                 = 708,   // Level 60  Spell ID: 63229
+    PRIEST_MAJOR_GLYPH_OF_GUARDIAN_SPIRIT            = 709,   // Level 60  Spell ID: 63231
+    PRIEST_MAJOR_GLYPH_OF_PENANCE                    = 710,   // Level 60  Spell ID: 63235
+    PRIEST_MAJOR_GLYPH_OF_MIND_SEAR                  = 711,   // Level 75  Spell ID: 63237
+    PRIEST_MAJOR_GLYPH_OF_HYMN_OF_HOPE               = 712,   // Level 60  Spell ID: 63246
+    PRIEST_MAJOR_GLYPH_OF_PAIN_SUPPRESSION           = 713,   // Level 50  Spell ID: 63248
+    PRIEST_MINOR_GLYPH_OF_FADING                     = 458,   // Level 15  Spell ID: 57985
+    PRIEST_MINOR_GLYPH_OF_LEVITATE                   = 459,   // Level 34  Spell ID: 57987
+    PRIEST_MINOR_GLYPH_OF_FORTITUDE                  = 460,   // Level 15  Spell ID: 58009
+    PRIEST_MINOR_GLYPH_OF_SHACKLE_UNDEAD             = 461,   // Level 20  Spell ID: 57986
+    PRIEST_MINOR_GLYPH_OF_SHADOW_PROTECTION          = 462,   // Level 30  Spell ID: 58015
+    PRIEST_MINOR_GLYPH_OF_SHADOWFIEND                = 463,   // Level 66  Spell ID: 58228
+    ROGUE_MAJOR_GLYPH_OF_ADRENALINE_RUSH             = 391,   // Level 40  Spell ID: 56808
+    ROGUE_MAJOR_GLYPH_OF_AMBUSH                      = 392,   // Level 18  Spell ID: 56813
+    ROGUE_MAJOR_GLYPH_OF_BACKSTAB                    = 393,   // Level 15  Spell ID: 56800
+    ROGUE_MAJOR_GLYPH_OF_BLADE_FLURRY                = 394,   // Level 30  Spell ID: 56818
+    ROGUE_MAJOR_GLYPH_OF_CRIPPLING_POISON            = 395,   // Level 20  Spell ID: 56820
+    ROGUE_MAJOR_GLYPH_OF_DEADLY_THROW                = 396,   // Level 64  Spell ID: 56806
+    ROGUE_MAJOR_GLYPH_OF_EVASION                     = 397,   // Level 15  Spell ID: 56799
+    ROGUE_MAJOR_GLYPH_OF_EVISCERATE                  = 398,   // Level 15  Spell ID: 56802
+    ROGUE_MAJOR_GLYPH_OF_EXPOSE_ARMOR                = 399,   // Level 15  Spell ID: 56803
+    ROGUE_MAJOR_GLYPH_OF_FEINT                       = 400,   // Level 16  Spell ID: 56804
+    ROGUE_MAJOR_GLYPH_OF_GARROTE                     = 401,   // Level 15  Spell ID: 56812
+    ROGUE_MAJOR_GLYPH_OF_GHOSTLY_STRIKE              = 402,   // Level 20  Spell ID: 56814
+    ROGUE_MAJOR_GLYPH_OF_GOUGE                       = 403,   // Level 15  Spell ID: 56809
+    ROGUE_MAJOR_GLYPH_OF_HEMORRHAGE                  = 404,   // Level 30  Spell ID: 56807
+    ROGUE_MAJOR_GLYPH_OF_PREPARATION                 = 405,   // Level 30  Spell ID: 56819
+    ROGUE_MAJOR_GLYPH_OF_RUPTURE                     = 406,   // Level 20  Spell ID: 56801
+    ROGUE_MAJOR_GLYPH_OF_SAP                         = 407,   // Level 15  Spell ID: 56798
+    ROGUE_MAJOR_GLYPH_OF_VIGOR                       = 408,   // Level 70  Spell ID: 56805
+    ROGUE_MAJOR_GLYPH_OF_SINISTER_STRIKE             = 409,   // Level 15  Spell ID: 56821
+    ROGUE_MAJOR_GLYPH_OF_SLICE_AND_DICE              = 410,   // Level 15  Spell ID: 56810
+    ROGUE_MAJOR_GLYPH_OF_SPRINT                      = 411,   // Level 15  Spell ID: 56811
+    ROGUE_MAJOR_GLYPH_OF_HUNGER_FOR_BLOOD            = 714,   // Level 60  Spell ID: 63249
+    ROGUE_MAJOR_GLYPH_OF_KILLING_SPREE               = 715,   // Level 60  Spell ID: 63252
+    ROGUE_MAJOR_GLYPH_OF_SHADOW_DANCE                = 716,   // Level 60  Spell ID: 63253
+    ROGUE_MAJOR_GLYPH_OF_FAN_OF_KNIVES               = 731,   // Level 80  Spell ID: 63254
+    ROGUE_MAJOR_GLYPH_OF_TRICKS_OF_THE_TRADE         = 732,   // Level 75  Spell ID: 63256
+    ROGUE_MAJOR_GLYPH_OF_MUTILATE                    = 733,   // Level 50  Spell ID: 63268
+    ROGUE_MAJOR_GLYPH_OF_CLOAK_OF_SHADOWS            = 734,   // Level 66  Spell ID: 63269
+    ROGUE_MINOR_GLYPH_OF_DISTRACT                    = 464,   // Level 22  Spell ID: 58032
+    ROGUE_MINOR_GLYPH_OF_PICK_LOCK                   = 465,   // Level 16  Spell ID: 58027
+    ROGUE_MINOR_GLYPH_OF_PICK_POCKET                 = 466,   // Level 15  Spell ID: 58017
+    ROGUE_MINOR_GLYPH_OF_SAFE_FALL                   = 467,   // Level 40  Spell ID: 58033
+    ROGUE_MINOR_GLYPH_OF_BLURRED_SPEED               = 468,   // Level 15  Spell ID: 58039
+    ROGUE_MINOR_GLYPH_OF_VANISH                      = 469,   // Level 22  Spell ID: 58038
+    SHAMAN_MAJOR_GLYPH_OF_WATER_MASTERY              = 211,   // Level 20  Spell ID: 55436
+    SHAMAN_MAJOR_GLYPH_OF_CHAIN_HEAL                 = 212,   // Level 40  Spell ID: 55437
+    SHAMAN_MAJOR_GLYPH_OF_CHAIN_LIGHTNING            = 213,   // Level 32  Spell ID: 55449
+    SHAMAN_MAJOR_GLYPH_OF_LAVA                       = 214,   // Level 66  Spell ID: 55454
+    SHAMAN_MAJOR_GLYPH_OF_SHOCKING                   = 215,   // Unknown   Spell ID: 55442
+    SHAMAN_MAJOR_GLYPH_OF_EARTHLIVING_WEAPON         = 216,   // Level 30  Spell ID: 55439
+    SHAMAN_MAJOR_GLYPH_OF_FIRE_ELEMENTAL_TOTEM       = 217,   // Level 68  Spell ID: 55455
+    SHAMAN_MAJOR_GLYPH_OF_FIRE_NOVA                  = 218,   // Level 15  Spell ID: 55450
+    SHAMAN_MAJOR_GLYPH_OF_FLAME_SHOCK                = 219,   // Level 15  Spell ID: 55447
+    SHAMAN_MAJOR_GLYPH_OF_FLAMETONGUE_WEAPON         = 220,   // Level 15  Spell ID: 55451
+    SHAMAN_MAJOR_GLYPH_OF_FROST_SHOCK                = 221,   // Level 20  Spell ID: 55443
+    SHAMAN_MAJOR_GLYPH_OF_HEALING_STREAM_TOTEM       = 222,   // Level 20  Spell ID: 55456
+    SHAMAN_MAJOR_GLYPH_OF_HEALING_WAVE               = 223,   // Level 15  Spell ID: 55440
+    SHAMAN_MAJOR_GLYPH_OF_LESSER_HEALING_WAVE        = 224,   // Level 20  Spell ID: 55438
+    SHAMAN_MAJOR_GLYPH_OF_LIGHTNING_SHIELD           = 225,   // Level 15  Spell ID: 55448
+    SHAMAN_MAJOR_GLYPH_OF_LIGHTNING_BOLT             = 226,   // Level 15  Spell ID: 55453
+    SHAMAN_MAJOR_GLYPH_OF_STORMSTRIKE                = 228,   // Level 40  Spell ID: 55446
+    SHAMAN_MAJOR_GLYPH_OF_LAVA_LASH                  = 229,   // Level 15  Spell ID: 55444
+    SHAMAN_MAJOR_GLYPH_OF_ELEMENTAL_MASTERY          = 230,   // Level 50  Spell ID: 55452
+    SHAMAN_MAJOR_GLYPH_OF_WINDFURY_WEAPON            = 231,   // Level 30  Spell ID: 55445
+    SHAMAN_MAJOR_GLYPH_OF_THUNDER                    = 735,   // Level 60  Spell ID: 63270
+    SHAMAN_MAJOR_GLYPH_OF_FERAL_SPIRIT               = 736,   // Level 60  Spell ID: 63271
+    SHAMAN_MAJOR_GLYPH_OF_RIPTIDE                    = 737,   // Level 60  Spell ID: 63273
+    SHAMAN_MAJOR_GLYPH_OF_EARTH_SHIELD               = 751,   // Level 50  Spell ID: 63279
+    SHAMAN_MAJOR_GLYPH_OF_TOTEM_OF_WRATH             = 752,   // Level 50  Spell ID: 63280
+    SHAMAN_MAJOR_GLYPH_OF_HEX                        = 753,   // Level 80  Spell ID: 63291
+    SHAMAN_MAJOR_GLYPH_OF_STONECLAW_TOTEM            = 754,   // Level 15  Spell ID: 63298
+    SHAMAN_MINOR_GLYPH_OF_ASTRAL_RECALL              = 470,   // Level 30  Spell ID: 58058
+    SHAMAN_MINOR_GLYPH_OF_RENEWED_LIFE               = 473,   // Level 30  Spell ID: 58059
+    SHAMAN_MINOR_GLYPH_OF_WATER_BREATHING            = 474,   // Level 22  Spell ID: 58055
+    SHAMAN_MINOR_GLYPH_OF_WATER_SHIELD               = 475,   // Level 20  Spell ID: 58063
+    SHAMAN_MINOR_GLYPH_OF_WATER_WALKING              = 476,   // Level 28  Spell ID: 58057
+    SHAMAN_MINOR_GLYPH_OF_GHOST_WOLF                 = 552,   // Level 16  Spell ID: 59289
+    SHAMAN_MINOR_GLYPH_OF_THUNDERSTORM               = 612,   // Level 70  Spell ID: 62132
+    WARLOCK_MAJOR_GLYPH_OF_INCINERATE                = 272,   // Unknown   Spell ID: 56242
+    WARLOCK_MAJOR_GLYPH_OF_CONFLAGRATE               = 273,   // Level 40  Spell ID: 56235
+    WARLOCK_MAJOR_GLYPH_OF_CORRUPTION                = 274,   // Level 15  Spell ID: 56218
+    WARLOCK_MAJOR_GLYPH_OF_CURSE_OF_AGONY            = 275,   // Level 15  Spell ID: 56241
+    WARLOCK_MAJOR_GLYPH_OF_DEATH_COIL                = 276,   // Level 42  Spell ID: 56232
+    WARLOCK_MAJOR_GLYPH_OF_FEAR                      = 277,   // Level 15  Spell ID: 56244
+    WARLOCK_MAJOR_GLYPH_OF_FELGUARD                  = 278,   // Level 50  Spell ID: 56246
+    WARLOCK_MAJOR_GLYPH_OF_FELHUNTER                 = 279,   // Level 30  Spell ID: 56249
+    WARLOCK_MAJOR_GLYPH_OF_HEALTH_FUNNEL             = 280,   // Level 15  Spell ID: 56238
+    WARLOCK_MAJOR_GLYPH_OF_HEALTHSTONE               = 281,   // Level 15  Spell ID: 56224
+    WARLOCK_MAJOR_GLYPH_OF_HOWL_OF_TERROR            = 282,   // Level 40  Spell ID: 56217
+    WARLOCK_MAJOR_GLYPH_OF_IMMOLATE                  = 283,   // Level 15  Spell ID: 56228
+    WARLOCK_MAJOR_GLYPH_OF_IMP                       = 284,   // Level 15  Spell ID: 56248
+    WARLOCK_MAJOR_GLYPH_OF_SEARING_PAIN              = 285,   // Level 18  Spell ID: 56226
+    WARLOCK_MAJOR_GLYPH_OF_SHADOW_BOLT               = 286,   // Level 15  Spell ID: 56240
+    WARLOCK_MAJOR_GLYPH_OF_SHADOWBURN                = 287,   // Level 20  Spell ID: 56229
+    WARLOCK_MAJOR_GLYPH_OF_SIPHON_LIFE               = 288,   // Level 30  Spell ID: 56216
+    WARLOCK_MAJOR_GLYPH_OF_SOULSTONE                 = 289,   // Level 18  Spell ID: 56231
+    WARLOCK_MAJOR_GLYPH_OF_SUCCUBUS                  = 290,   // Level 26  Spell ID: 56250
+    WARLOCK_MAJOR_GLYPH_OF_UNSTABLE_AFFLICTION       = 291,   // Level 50  Spell ID: 56233
+    WARLOCK_MAJOR_GLYPH_OF_VOIDWALKER                = 292,   // Level 15  Spell ID: 56247
+    WARLOCK_MAJOR_GLYPH_OF_HAUNT                     = 755,   // Level 60  Spell ID: 63302
+    WARLOCK_MAJOR_GLYPH_OF_METAMORPHOSIS             = 756,   // Level 60  Spell ID: 63303
+    WARLOCK_MAJOR_GLYPH_OF_CHAOS_BOLT                = 757,   // Level 60  Spell ID: 63304
+    WARLOCK_MAJOR_GLYPH_OF_DEMONIC_CIRCLE            = 758,   // Level 80  Spell ID: 63309
+    WARLOCK_MAJOR_GLYPH_OF_SHADOWFLAME               = 759,   // Level 75  Spell ID: 63310
+    WARLOCK_MAJOR_GLYPH_OF_LIFE_TAP                  = 760,   // Level 15  Spell ID: 63320
+    WARLOCK_MAJOR_GLYPH_OF_SOUL_LINK                 = 761,   // Level 20  Spell ID: 63312
+    WARLOCK_MAJOR_GLYPH_OF_QUICK_DECAY               = 911,   // Level 15  Spell ID: 70947
+    WARLOCK_MINOR_GLYPH_OF_UNENDING_BREATH           = 477,   // Level 15  Spell ID: 58079
+    WARLOCK_MINOR_GLYPH_OF_DRAIN_SOUL                = 478,   // Level 15  Spell ID: 58070
+    WARLOCK_MINOR_GLYPH_OF_KILROGG                   = 479,   // Level 22  Spell ID: 58081
+    WARLOCK_MINOR_GLYPH_OF_ENSLAVE_DEMON             = 481,   // Level 30  Spell ID: 58107
+    WARLOCK_MINOR_GLYPH_OF_SOULS                     = 482,   // Level 68  Spell ID: 58094
+    WARRIOR_MAJOR_GLYPH_OF_MORTAL_STRIKE             = 489,   // Level 40  Spell ID: 58368
+    WARRIOR_MAJOR_GLYPH_OF_BLOODTHIRST               = 490,   // Level 40  Spell ID: 58369
+    WARRIOR_MAJOR_GLYPH_OF_RAPID_CHARGE              = 491,   // Level 15  Spell ID: 58355
+    WARRIOR_MAJOR_GLYPH_OF_CLEAVING                  = 492,   // Level 20  Spell ID: 58366
+    WARRIOR_MAJOR_GLYPH_OF_DEVASTATE                 = 493,   // Level 40  Spell ID: 58388
+    WARRIOR_MAJOR_GLYPH_OF_EXECUTION                 = 494,   // Level 24  Spell ID: 58367
+    WARRIOR_MAJOR_GLYPH_OF_HAMSTRING                 = 495,   // Level 15  Spell ID: 58372
+    WARRIOR_MAJOR_GLYPH_OF_HEROIC_STRIKE             = 496,   // Level 15  Spell ID: 58357
+    WARRIOR_MAJOR_GLYPH_OF_INTERVENE                 = 497,   // Level 70  Spell ID: 58377
+    WARRIOR_MAJOR_GLYPH_OF_BARBARIC_INSULTS          = 498,   // Level 16  Spell ID: 58365
+    WARRIOR_MAJOR_GLYPH_OF_OVERPOWER                 = 499,   // Level 15  Spell ID: 58386
+    WARRIOR_MAJOR_GLYPH_OF_RENDING                   = 500,   // Level 15  Spell ID: 58385
+    WARRIOR_MAJOR_GLYPH_OF_REVENGE                   = 501,   // Level 15  Spell ID: 58364
+    WARRIOR_MAJOR_GLYPH_OF_BLOCKING                  = 502,   // Level 40  Spell ID: 58375
+    WARRIOR_MAJOR_GLYPH_OF_LAST_STAND                = 503,   // Level 20  Spell ID: 58376
+    WARRIOR_MAJOR_GLYPH_OF_SUNDER_ARMOR              = 504,   // Level 15  Spell ID: 58387
+    WARRIOR_MAJOR_GLYPH_OF_SWEEPING_STRIKES          = 505,   // Level 30  Spell ID: 58384
+    WARRIOR_MAJOR_GLYPH_OF_TAUNT                     = 506,   // Level 15  Spell ID: 58353
+    WARRIOR_MAJOR_GLYPH_OF_RESONATING_POWER          = 507,   // Level 15  Spell ID: 58356
+    WARRIOR_MAJOR_GLYPH_OF_VICTORY_RUSH              = 508,   // Level 62  Spell ID: 58382
+    WARRIOR_MAJOR_GLYPH_OF_WHIRLWIND                 = 509,   // Level 36  Spell ID: 58370
+    WARRIOR_MAJOR_GLYPH_OF_BLADESTORM                = 762,   // Level 60  Spell ID: 63324
+    WARRIOR_MAJOR_GLYPH_OF_SHOCKWAVE                 = 763,   // Level 60  Spell ID: 63325
+    WARRIOR_MAJOR_GLYPH_OF_VIGILANCE                 = 764,   // Level 40  Spell ID: 63326
+    WARRIOR_MAJOR_GLYPH_OF_ENRAGED_REGENERATION      = 765,   // Level 75  Spell ID: 63327
+    WARRIOR_MAJOR_GLYPH_OF_SPELL_REFLECTION          = 766,   // Level 64  Spell ID: 63328
+    WARRIOR_MAJOR_GLYPH_OF_SHIELD_WALL               = 767,   // Level 28  Spell ID: 63329
+    WARRIOR_MINOR_GLYPH_OF_BATTLE                    = 483,   // Level 15  Spell ID: 58095
+    WARRIOR_MINOR_GLYPH_OF_BLOODRAGE                 = 484,   // Level 15  Spell ID: 58096
+    WARRIOR_MINOR_GLYPH_OF_CHARGE                    = 485,   // Level 15  Spell ID: 58097
+    WARRIOR_MINOR_GLYPH_OF_MOCKING_BLOW              = 486,   // Level 16  Spell ID: 58099
+    WARRIOR_MINOR_GLYPH_OF_THUNDER_CLAP              = 487,   // Level 15  Spell ID: 58098
+    WARRIOR_MINOR_GLYPH_OF_ENDURING_VICTORY          = 488,   // Level 62  Spell ID: 58104
+    WARRIOR_MINOR_GLYPH_OF_COMMAND                   = 851,   // Level 68  Spell ID: 68164
+};
+
+/**
+ * So they're kept track of somewhere... but let's comment them out.
+   enum GlyphsUnknown
+   {
+    UNKNOWN_MAJOR_GLYPH_OF_NATURAL_FORCE             = 2,     // Unknown   Spell ID: 52084
+    UNKNOWN_UNKNOWN_GLYPH_CRUELTY                    = 21,    // Unknown   Spell ID: 12320
+    UNKNOWN_UNKNOWN_GLYPH_ANTICIPATION               = 22,    // Unknown   Spell ID: 12297
+    UNKNOWN_UNKNOWN_GLYPH_VENOMOUS_MANA              = 61,    // Unknown   Spell ID: 46831
+    UNKNOWN_MINOR_GLYPH_OF_NATURAL_FORCE             = 81,    // Unknown   Spell ID: 52084
+    UNKNOWN_UNKNOWN_GLYPH_GLYPH_OF_MOONFIRE          = 82,    // Unknown   Spell ID: 52085
+    UNKNOWN_MAJOR_                                   = 101,   // Unknown   Spell ID: NULL
+    UNKNOWN_UNKNOWN_GLYPH_COPY_OF_HOLY_BOLT          = 121,   // Unknown   Spell ID: 46487
+    UNKNOWN_MINOR_GLYPH_OF_THE_WHITE_BEAR            = 141,   // Unknown   Spell ID: 54292
+    UNKNOWN_MAJOR_GLYPH_OF_GROWLING                  = 163,   // Unknown   Spell ID: 54812
+    UNKNOWN_MINOR_GLYPH_OF_THE_RED_LYNX              = 182,   // Unknown   Spell ID: 54912
+    UNKNOWN_MAJOR_GLYPH_OF_LAVA                      = 214,   // Unknown   Spell ID: 55454
+    UNKNOWN_MAJOR_GLYPH_OF_MANA_TIDE                 = 227,   // Unknown   Spell ID: 55441
+    UNKNOWN_MAJOR_GLYPH_OF_MOLTEN_ARMOR              = 328,   // Unknown   Spell ID: 56382
+    UNKNOWN_MAJOR_GLYPH_OF_THE_HAWK                  = 363,   // Unknown   Spell ID: 56856
+    UNKNOWN_MINOR_GLYPH_OF_THE_FOREST_LYNX           = 436,   // Unknown   Spell ID: 58133
+    UNKNOWN_MINOR_GLYPH_OF_THE_BLACK_BEAR            = 438,   // Unknown   Spell ID: 58132
+    UNKNOWN_MINOR_GLYPH_OF_THE_BEAR_CUB              = 449,   // Unknown   Spell ID: 58136
+    UNKNOWN_MINOR_GLYPH_OF_THE_ARCTIC_WOLF           = 471,   // Unknown   Spell ID: 58135
+    UNKNOWN_MINOR_GLYPH_OF_THE_BLACK_WOLF            = 472,   // Unknown   Spell ID: 58134
+    UNKNOWN_MINOR_GLYPH_OF_CURSE_OF_EXHAUSION        = 480,   // Unknown   Spell ID: 58080
+    UNKNOWN_MINOR_GLYPH_OF_BLAST_WAVE                = 611,   // Unknown   Spell ID: 62126
+    UNKNOWN_MAJOR_GLYPH_OF_ENVENOM                   = 791,   // Unknown   Spell ID: 64199
+   };*/
+
+// TODO: replace this with mangos data... I mean this has GOT to be out there somewhere already
+//       and when you do, don't forget to change everywhere (including the sql file)
+// But in the meantime, value + 412 = TabId.
+enum ClassesCombatPets
+{
+    CLASS_PET_CUNNING  = -1,
+    CLASS_PET_FEROCITY = -2,
+    CLASS_PET_TENACITY = -3
+};
+
+// reasons for why pet tame may fail
+// in fact, these are also used elsewhere
+enum PetTameFailureReason
+{
+    PETTAME_INVALIDCREATURE         = 1,
+    PETTAME_TOOMANY                 = 2,
+    PETTAME_CREATUREALREADYOWNED    = 3,
+    PETTAME_NOTTAMEABLE             = 4,
+    PETTAME_ANOTHERSUMMONACTIVE     = 5,
+    PETTAME_UNITSCANTTAME           = 6,
+    PETTAME_NOPETAVAILABLE          = 7,                    // not used in taming
+    PETTAME_INTERNALERROR           = 8,
+    PETTAME_TOOHIGHLEVEL            = 9,
+    PETTAME_DEAD                    = 10,                   // not used in taming
+    PETTAME_NOTDEAD                 = 11,                   // not used in taming
+    PETTAME_CANTCONTROLEXOTIC       = 12,                   // 3.x
+    PETTAME_UNKNOWNERROR            = 13
+};
+
+enum TalentSpecPurpose
+{
+    TSP_NONE                        = 0x00000000,  // should probably error out?
+    TSP_PVE_TANK                    = 0x00000001,
+    TSP_PVE_DPS                     = 0x00000002,
+    TSP_PVE_LEVELING                = 0x00000004,
+    TSP_PVE_HEALING                 = 0x00000008,
+    TSP_PVE_INSTANCING              = 0x00000010,
+    TSP_PVE_RAID                    = 0x00000020,
+    TSP_PVE_ALL                     = 0x0000FFFF,  // Highly recommend AGAINST using this
+    TSP_PVP_TANK                    = 0x00010000,
+    TSP_PVP_DPS                     = 0x00020000,
+    TSP_PVP_LEVELING                = 0x00040000,
+    TSP_PVP_TWINK                   = 0x00080000,
+    TSP_PVP_HEALING                 = 0x00100000,
+    TSP_PVP_ARENA                   = 0x00200000,
+    TSP_PVP_ALL                     = 0xFFFF0000   // Highly recommend AGAINST using this
+};
+
+enum MainSpec
+{
+    MAGE_SPEC_FIRE              = 41,
+    MAGE_SPEC_FROST             = 61,
+    MAGE_SPEC_ARCANE            = 81,
+    WARRIOR_SPEC_ARMS           = 161,
+    WARRIOR_APEC_PROTECTION     = 163,
+    WARRIOR_SPEC_FURY           = 164,
+    ROGUE_SPEC_COMBAT           = 181,
+    ROGUE_SPEC_ASSASSINATION    = 182,
+    ROGUE_SPEC_SUBTELTY         = 183,
+    PRIEST_SPEC_DISCIPLINE      = 201,
+    PRIEST_SPEC_HOLY            = 202,
+    PRIEST_SPEC_SHADOW          = 203,
+    SHAMAN_SPEC_ELEMENTAL       = 261,
+    SHAMAN_SPEC_RESTORATION     = 262,
+    SHAMAN_SPEC_ENHANCEMENT     = 263,
+    DRUID_SPEC_FERAL            = 281,
+    DRUID_SPEC_RESTORATION      = 282,
+    DRUID_SPEC_BALANCE          = 283,
+    WARLOCK_SPEC_DESTRUCTION    = 301,
+    WARLOCK_SPEC_AFFLICTION     = 302,
+    WARLOCK_SPEC_DEMONOLOGY     = 303,
+    HUNTER_SPEC_BEASTMASTERY    = 361,
+    HUNTER_SPEC_SURVIVAL        = 362,
+    HUNTER_SPEC_MARKSMANSHIP    = 363,
+    PALADIN_SPEC_RETRIBUTION    = 381,
+    PALADIN_SPEC_HOLY           = 382,
+    PALADIN_SPEC_PROTECTION     = 383,
+    DEATHKNIGHT_SPEC_BLOOD      = 398,
+    DEATHKNIGHT_SPEC_FROST      = 399,
+    DEATHKNIGHT_SPEC_UNHOLY     = 400
+};
+
+struct TalentSpec
+{
+    std::string specName;
+    short specClass;
+    TalentSpecPurpose specPurpose;
+    uint16 talentId[71];
+    uint16 glyphIdMajor[3];
+    uint16 glyphIdMinor[3];
+};
+
+enum NotableItems
+{
+    // Skeleton Keys
+    SILVER_SKELETON_KEY = 15869,
+    GOLDEN_SKELETON_KEY = 15870,
+    TRUESILVER_SKELETON_KEY = 15871,
+    ARCANITE_SKELETON_KEY = 15872,
+    TITANIUM_SKELETON_KEY = 43853,
+    COBALT_SKELETON_KEY = 43854,
+    // Lock Charges
+    SMALL_SEAFORIUM_CHARGE = 4367,
+    LARGE_SEAFORIUM_CHARGE = 4398,
+    POWERFUL_SEAFORIUM_CHARGE = 18594,
+    ELEMENTAL_SEAFORIUM_CHARGE = 23819
+};
+
+class PlayerbotAI
+{
+    //friend class PlayerbotClassAI;
+public:
+    enum ScenarioType
+    {
+        SCENARIO_PVEEASY,
+        SCENARIO_PVEHARD,
+        SCENARIO_DUEL,
+        SCENARIO_PVPEASY,
+        SCENARIO_PVPHARD
+    };
+
+    enum CombatStyle
+    {
+        COMBAT_MELEE                = 0x01,             // class melee attacker
+        COMBAT_RANGED               = 0x02              // class is ranged attacker
+    };
+
+    // masters orders that should be obeyed by the AI during the updateAI routine
+    // the master will auto set the target of the bot
+    enum CombatOrderType
+    {
+        ORDERS_NONE                 = 0x00,             // no special orders given
+        ORDERS_TANK                 = 0x01,             // bind attackers by gaining threat
+        ORDERS_ASSIST               = 0x02,             // assist someone (dps type)
+        ORDERS_HEAL                 = 0x04,             // concentrate on healing (no attacks, only self defense)
+        ORDERS_NODISPEL             = 0x08,
+        ORDERS_PROTECT              = 0x10,             // combinable state: check if protectee is attacked
+        ORDERS_PASSIVE              = 0x20,             // bots do nothing
+        ORDERS_RESIST                = 0x40,                // resist a magic school(see below for types)
+        ORDERS_PRIMARY              = 0x0F,
+        ORDERS_SECONDARY            = 0xF0,
+        ORDERS_RESET                = 0xFF
+    };
+
+    enum ResistType
+    {
+        SCHOOL_NONE        = 0,
+        SCHOOL_FIRE        = 1,
+        SCHOOL_NATURE    = 2,
+        SCHOOL_FROST    = 3,
+        SCHOOL_SHADOW    = 4
+    };
+
+    enum CombatTargetType
+    {
+        TARGET_NORMAL               = 0x00,
+        TARGET_THREATEN             = 0x01
+    };
+
+    enum BotState
+    {
+        BOTSTATE_NORMAL,            // normal AI routines are processed
+        BOTSTATE_COMBAT,            // bot is in combat
+        BOTSTATE_DEAD,              // we are dead and wait for becoming ghost
+        BOTSTATE_DEADRELEASED,      // we released as ghost and wait to revive
+        BOTSTATE_LOOTING,           // looting mode, used just after combat
+        BOTSTATE_FLYING,            // bot is flying
+        BOTSTATE_ENCHANT,           // bot is enchanting
+        BOTSTATE_CRAFT,             // bot is crafting
+        BOTSTATE_TAME               // bot hunter taming
+    };
+
+    enum CollectionFlags
+    {
+        COLLECT_FLAG_NOTHING    = 0x00,     // skip looting of anything
+        COLLECT_FLAG_COMBAT     = 0x01,     // loot after combat
+        COLLECT_FLAG_QUEST      = 0x02,     // quest and needed items
+        COLLECT_FLAG_PROFESSION = 0x04,     // items related to skills
+        COLLECT_FLAG_LOOT       = 0x08,     // all loot on corpses
+        COLLECT_FLAG_SKIN       = 0x10,     // skin creatures if available
+        COLLECT_FLAG_NEAROBJECT = 0x20      // collect specified nearby object
+    };
+
+    enum MovementOrderType
+    {
+        MOVEMENT_NONE               = 0x00,
+        MOVEMENT_FOLLOW             = 0x01,
+        MOVEMENT_STAY               = 0x02
+    };
+
+    enum TaskFlags
+    {
+        NONE                        = 0x00,  // do nothing
+        SELL_ITEMS                  = 0x01,  // sell items
+        REPAIR_ITEMS                = 0x02,  // repair items
+        ADD_AUCTION                 = 0x03,  // add auction
+        REMOVE_AUCTION              = 0x04,  // remove auction
+        RESET_TALENTS               = 0x05,  // reset all talents
+        BANK_WITHDRAW               = 0x06,  // withdraw item from bank
+        BANK_DEPOSIT                = 0x07,  // deposit item in bank
+        LIST_QUEST                  = 0x08,  // list quests
+        END_QUEST                   = 0x09,  // turn in quests
+        TAKE_QUEST                  = 0x0A   // take quest
+    };
+
+    enum AnnounceFlags
+    {
+        NOTHING                     = 0x00,
+        INVENTORY_FULL              = 0x01,
+        CANT_AFFORD                 = 0x02,
+        CANT_USE_TOO_FAR            = 0x03
+    };
+
+    typedef std::pair<enum TaskFlags, uint32> taskPair;
+    typedef std::list<taskPair> BotTaskList;
+    typedef std::list<enum NPCFlags> BotNPCList;
+    typedef std::map<uint32, uint32> BotNeedItem;
+    typedef std::pair<uint32, uint32> talentPair;
+    typedef std::list<ObjectGuid> BotObjectList;
+    typedef std::list<uint32> BotEntryList;
+    typedef std::vector<uint32> BotTaxiNode;
+    typedef std::set<ObjectGuid> BotObjectSet;
+
+    // attacker query used in PlayerbotAI::FindAttacker()
+    enum ATTACKERINFOTYPE
+    {
+        AIT_NONE                    = 0x00,
+        AIT_LOWESTTHREAT            = 0x01,
+        AIT_HIGHESTTHREAT           = 0x02,
+        AIT_VICTIMSELF              = 0x04,
+        AIT_VICTIMNOTSELF           = 0x08      // !!! must use victim param in FindAttackers
+    };
+    struct AttackerInfo
+    {
+        Unit*    attacker;            // reference to the attacker
+        Unit*    victim;              // combatant's current victim
+        float threat;                 // own threat on this combatant
+        float threat2;                // highest threat not caused by bot
+        uint32 count;                 // number of units attacking
+        uint32 source;                // 1=bot, 2=master, 3=group
+    };
+    typedef std::map<ObjectGuid, AttackerInfo> AttackerInfoList;
+    typedef std::map<uint32, float> SpellRanges;
+
+    enum HELPERLINKABLES
+    {
+        HL_NONE,
+        HL_PROFESSION,
+        HL_ITEM,
+        HL_TALENT,
+        HL_SKILL,
+        HL_OPTION,
+        HL_PETAGGRO,
+        HL_QUEST,
+        HL_GAMEOBJECT,
+        HL_SPELL,
+        HL_TARGET,
+        HL_NAME,
+        HL_AUCTION,
+        HL_MAIL,
+        HL_RECIPE
+    };
+
+public:
+    PlayerbotAI(Player * const master, Player * const bot);
+    virtual ~PlayerbotAI();
+
+    // This is called from Unit.cpp and is called every second (I think)
+    void UpdateAI(const uint32 p_time);
+
+    // This is called from ChatHandler.cpp when there is an incoming message to the bot
+    // from a whisper or from the party channel
+    void HandleCommand(const std::string& text, Player& fromPlayer);
+
+    // This is called by WorldSession.cpp
+    // It provides a view of packets normally sent to the client.
+    // Since there is no client at the other end, the packets are dropped of course.
+    // For a list of opcodes that can be caught see Opcodes.cpp (SMSG_* opcodes only)
+    void HandleBotOutgoingPacket(const WorldPacket& packet);
+
+    // This is called by WorldSession.cpp
+    // when it detects that a bot is being teleported. It acknowledges to the server to complete the
+    // teleportation
+    void HandleTeleportAck();
+
+    // Returns what kind of situation we are in so the ai can react accordingly
+    ScenarioType GetScenarioType() { return m_ScenarioType; }
+
+    PlayerbotClassAI* GetClassAI() { return m_classAI; }
+    void ReloadAI();
+
+    // finds spell ID for matching substring args
+    // in priority of full text match, spells not taking reagents, and highest rank
+    uint32 getSpellId(const char* args, bool master = false) const;
+    uint32 getPetSpellId(const char* args) const;
+    // Initialize spell using rank 1 spell id
+    uint32 initSpell(uint32 spellId) const;
+    uint32 initPetSpell(uint32 spellIconId);
+
+    // extract mail ids from links
+    void extractMailIds(const std::string& text, std::list<uint32>& mailIds) const;
+
+    // extract quest ids from links
+    void extractQuestIds(const std::string& text, std::list<uint32>& questIds) const;
+
+    // extract auction ids from links
+    void extractAuctionIds(const std::string& text, std::list<uint32>& auctionIds) const;
+
+    // extracts talent ids to list
+    void extractTalentIds(const std::string& text, std::list<talentPair>& talentIds) const;
+
+    // extracts item ids from links
+    void extractItemIds(const std::string& text, std::list<uint32>& itemIds) const;
+
+    // extract spellid from links
+    void extractSpellId(const std::string& text, uint32 &spellId) const;
+
+    // extract spellids from links to list
+    void extractSpellIdList(const std::string& text, BotEntryList& m_spellsToLearn) const;
+
+    // extracts currency from a string as #g#s#c and returns the total in copper
+    uint32 extractMoney(const std::string& text) const;
+
+    // extracts gameobject info from link
+    void extractGOinfo(const std::string& text, BotObjectList& m_lootTargets) const;
+
+    // finds items in bots equipment and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+    // finds items in bots inventory and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+    // finds nearby game objects that are specified in m_collectObjects then adds them to the m_lootTargets list
+    void findNearbyGO();
+    // finds nearby creatures, whose UNIT_NPC_FLAGS match the flags specified in item list m_itemIds
+    void findNearbyCreature();
+
+    void GiveLevel(uint32 level);
+
+    // Error check the TS DB. Should only be used when admins want to verify their new TS input
+    uint32 TalentSpecDBContainsError();
+
+    // Get talent specs or counts thereof
+    uint32 GetTalentSpecsAmount();
+    uint32 GetTalentSpecsAmount(long specClass);
+    std::list<TalentSpec> GetTalentSpecs(long specClass);
+    TalentSpec GetTalentSpec(long specClass, long choice);
+    TalentSpec GetActiveTalentSpec() { return m_activeTalentSpec; }
+    void ClearActiveTalentSpec() { m_activeTalentSpec.specName = ""; m_activeTalentSpec.specClass = 0; m_activeTalentSpec.specPurpose = TSP_NONE; for (int i = 0; i < 71; i++) m_activeTalentSpec.talentId[i] = 0; for (int i = 0; i < 3; i++) { m_activeTalentSpec.glyphIdMajor[i] = 0; m_activeTalentSpec.glyphIdMinor[i] = 0; } }
+    void SetActiveTalentSpec(TalentSpec ts) { m_activeTalentSpec = ts; }
+    bool ApplyActiveTalentSpec();
+
+    void MakeSpellLink(const SpellEntry *sInfo, std::ostringstream &out);
+    void MakeWeaponSkillLink(const SpellEntry *sInfo, std::ostringstream &out, uint32 skillid);
+
+    // currently bots only obey commands from the master
+    bool canObeyCommandFrom(const Player& player) const;
+
+    // get current casting spell (will return NULL if no spell!)
+    Spell* GetCurrentSpell() const;
+
+    bool HasAura(uint32 spellId, const Unit& player) const;
+    bool HasAura(const char* spellName, const Unit& player) const;
+    bool HasAura(const char* spellName) const;
+
+    bool CanReceiveSpecificSpell(uint8 spec, Unit* target) const;
+    bool IsSingleFromSpellSpecificPerTargetPerCaster(SpellSpecific spellSpec1, SpellSpecific spellSpec2) const;
+
+    bool HasTool(uint32 TC);
+    bool HasSpellReagents(uint32 spellId);
+    void ItemCountInInv(uint32 itemid, uint32 &count);
+    uint32 GetSpellCharges(uint32 spellId);
+
+    uint8 GetHealthPercent(const Unit& target) const;
+    uint8 GetHealthPercent() const;
+    uint8 GetBaseManaPercent(const Unit& target) const;
+    uint8 GetBaseManaPercent() const;
+    uint8 GetManaPercent(const Unit& target) const;
+    uint8 GetManaPercent() const;
+    uint8 GetRageAmount(const Unit& target) const;
+    uint8 GetRageAmount() const;
+    uint8 GetEnergyAmount(const Unit& target) const;
+    uint8 GetEnergyAmount() const;
+    uint8 GetRunicPower(const Unit& target) const;
+    uint8 GetRunicPower() const;
+
+    Item* FindFood() const;
+    Item* FindDrink() const;
+    Item* FindBandage() const;
+    Item* FindPoison() const;
+    Item* FindItem(uint32 ItemId);
+    Item* FindItemInBank(uint32 ItemId);
+    Item* FindKeyForLockValue(uint32 reqSkillValue);
+    Item* FindBombForLockValue(uint32 reqSkillValue);
+    Item* FindConsumable(uint32 displayId) const;
+    uint8 _findItemSlot(Item* target);
+    bool CanStore();
+
+    // ******* Actions ****************************************
+    // Your handlers can call these actions to make the bot do things.
+    void TellMaster(std::string const& text) const;
+    void TellMaster(const char *fmt, ...) const;
+    void SendWhisper(std::string const& text, Player& player) const;
+    bool CastSpell(const char* args);
+    bool CastSpell(uint32 spellId);
+    bool CastSpell(uint32 spellId, Unit& target);
+    bool CastPetSpell(uint32 spellId, Unit* target = NULL);
+    bool Buff(uint32 spellId, Unit * target, void (*beforeCast)(Player *) = NULL);
+    bool SelfBuff(uint32 spellId);
+    bool IsInRange(Unit* Target, uint32 spellId);
+
+    void UseItem(Item *item, uint32 targetFlag, ObjectGuid targetGUID);
+    void UseItem(Item *item, uint8 targetInventorySlot);
+    void UseItem(Item *item, Unit *target);
+    void UseItem(Item *item);
+
+    void BotPlaySound(uint32 soundid);
+    void Announce(AnnounceFlags msg);
+
+    void EquipItem(Item* src_Item);
+    //bool Follow(Player& player);
+    uint32 AutoEquipPlug;               //switch for autoequip
+    uint32 SellWhite;                    //switch for white item auto sell
+    uint8 DistOverRide;
+    float gDist[2]; //gDist, gTemp vars are used for variable follow distance
+    float gTempDist;
+    float gTempDist2;
+    uint8 FollowAutoGo;
+    uint8 IsUpOrDown; //tracks variable follow distance
+    void _HandleCommandAutoEquip(std::string &text, Player &fromPlayer);
+    void SendNotEquipList(Player& player);
+    void FollowAutoReset(Player& /*player*/);
+    void AutoUpgradeEquipment(Player& /*player*/); // test for autoequip
+    void AutoEquipComparison(Item *pItem, Item *pItem2);
+    bool ItemStatComparison(const ItemTemplate *pProto, const ItemTemplate *pProto2);
+    void Feast();
+    void InterruptCurrentCastingSpell();
+    void GetCombatTarget(Unit* forcedTarged = 0);
+    void GetDuelTarget(Unit* forcedTarget);
+    Unit *GetCurrentTarget() { return m_targetCombat; }
+    void DoNextCombatManeuver();
+    void DoCombatMovement();
+    void SetIgnoreUpdateTime(uint8 t = 0) { m_ignoreAIUpdatesUntilTime = time(0) + t; }
+
+    Player *GetPlayerBot() const { return m_bot; }
+    Player *GetPlayer() const { return m_bot; }
+    //Player *GetMaster() const { return m_master; }
+
+    BotState GetState() { return m_botState; }
+    void SetState(BotState state);
+    void SetQuestNeedItems();
+    void SetQuestNeedCreatures();
+    void SendQuestNeedList();
+    bool IsInQuestItemList(uint32 itemid) { return m_needItemList.find(itemid) != m_needItemList.end(); }
+    bool IsInQuestCreatureList(uint32 id) { return m_needCreatureOrGOList.find(id) != m_needCreatureOrGOList.end(); }
+    bool IsItemUseful(uint32 itemid);
+    void SendOrders(Player& player);
+    //bool DoTeleport(WorldObject &obj);
+    void DoLoot();
+    void DoFlight();
+    void GetTaxi(ObjectGuid guid, BotTaxiNode& nodes);
+
+    bool HasCollectFlag(uint8 flag) { return m_collectionFlags & flag; }
+    void SetCollectFlag(uint8 flag)
+    {
+        if (HasCollectFlag(flag)) m_collectionFlags &= ~flag;
+        else m_collectionFlags |= flag;
+    }
+
+    uint32 EstRepairAll();
+    uint32 EstRepair(uint16 pos);
+
+    void AcceptQuest(Quest const *qInfo, Player *pGiver);
+    void TurnInQuests(WorldObject *questgiver);
+    void ListQuests(WorldObject* questgiver);
+    bool AddQuest(const uint32 entry, WorldObject* questgiver);
+
+    bool IsInCombat();
+    void UpdateAttackerInfo();
+    Unit* FindAttacker(ATTACKERINFOTYPE ait = AIT_NONE, Unit *victim = 0);
+    uint32 GetAttackerCount() { return m_attackerInfo.size(); }
+    void SetCombatOrderByStr(std::string str, Unit *target = 0);
+    void SetCombatOrder(CombatOrderType co, Unit *target = 0);
+    CombatOrderType GetCombatOrder() { return this->m_combatOrder; }
+    ResistType GetResistType() { return m_resistType; }
+    void SetMovementOrder(MovementOrderType mo, Unit *followTarget = 0);
+    MovementOrderType GetMovementOrder() { return this->m_movementOrder; }
+    void MovementReset();
+    void MovementClear();
+    bool IsMoving();
+
+    //void SetInFront(const Unit* obj);
+
+    void ItemLocalization(std::string& itemName, const uint32 itemID) const;
+    void QuestLocalization(std::string& questTitle, const uint32 questID) const;
+    void CreatureLocalization(std::string& creatureName, const uint32 entry) const;
+    void GameObjectLocalization(std::string& gameobjectName, const uint32 entry) const;
+
+    uint8 GetFreeBagSpace() const;
+    void SellGarbage(Player & /*plyer*/, bool listNonTrash = true, bool bDetailTrashSold = false, bool verbose = true);
+    void Sell(const uint32 itemid);
+    void Buy(ObjectGuid vendorguid, const uint32 itemid);
+    std::string DropItem(const uint32 itemid);
+    void AddAuction(const uint32 itemid, Creature* aCreature);
+    void ListAuctions();
+    bool RemoveAuction(const uint32 auctionid);
+    void Repair(const uint32 itemid, Creature* rCreature);
+    bool Talent(Creature* tCreature);
+    void InspectUpdate();
+    bool Withdraw(const uint32 itemid);
+    bool Deposit(const uint32 itemid);
+    void BankBalance();
+    std::string Cash(uint32 copper);
+    std::string AuctionResult(std::string subject, std::string body);
+
+    //TEMP PlayerbotMgr
+    void HandleMasterIncomingPacket(const WorldPacket& packet, WorldSession& session);
+
+    bool m_confDebugWhisper;
+private:
+    // config variables
+    uint32 m_confRestrictBotLevel;
+    uint32 m_confDisableBotsInRealm;
+    uint32 m_confMaxNumBots;
+    bool m_confDisableBots;
+    float m_confFollowDistance[2];
+    bool m_confCollectCombat;
+    bool m_confCollectQuest;
+    bool m_confCollectProfession;
+    bool m_confCollectLoot;
+    bool m_confCollectSkin;
+    bool m_confCollectObjects;
+    uint32 gConfigSellLevelDiff;
+    uint32 m_confCollectDistance;
+    uint32 m_confCollectDistanceMax;
+    bool m_confSellGarbage;
+
+    bool m_changeFaction;
+
+protected:
+    bool ValidateTalent(uint16 talent, long charClass);
+    bool ValidateGlyph(uint16 glyph, long charClass);
+    bool ValidateMajorGlyph(uint16 glyph, long charClass);
+    bool ValidateMinorGlyph(uint16 glyph, long charClass);
+
+private:
+    bool ExtractCommand(const std::string sLookingFor, std::string &text, bool bUseShort = false);
+    // outsource commands for code clarity
+    void _HandleCommandReset(std::string &text, Player &fromPlayer);
+    void _HandleCommandOrders(std::string &text, Player &fromPlayer);
+    void _HandleCommandFollow(std::string &text, Player &fromPlayer);
+    void _HandleCommandStay(std::string &text, Player &fromPlayer);
+    void _HandleCommandAttack(std::string &text, Player &fromPlayer);
+    void _HandleCommandCast(std::string &text, Player &fromPlayer);
+    void _HandleCommandSell(std::string &text, Player &fromPlayer);
+    void _HandleCommandBuy(std::string &text, Player &fromPlayer);
+    void _HandleCommandDrop(std::string &text, Player &fromPlayer);
+    void _HandleCommandRepair(std::string &text, Player &fromPlayer);
+    void _HandleCommandAuction(std::string &text, Player &fromPlayer);
+    void _HandleCommandMail(std::string &text, Player &fromPlayer);
+    void _HandleCommandBank(std::string &text, Player &fromPlayer);
+    void _HandleCommandTalent(std::string &text, Player &fromPlayer);
+    void _HandleCommandUse(std::string &text, Player &fromPlayer);
+    void _HandleCommandEquip(std::string &text, Player &fromPlayer);
+    void _HandleCommandFind(std::string &text, Player &fromPlayer);
+    void _HandleCommandGet(std::string &text, Player &fromPlayer);
+    void _HandleCommandCollect(std::string &text, Player &fromPlayer);
+    void _HandleCommandQuest(std::string &text, Player &fromPlayer);
+    void _HandleCommandCraft(std::string &text, Player &fromPlayer);
+    void _HandleCommandEnchant(std::string &text, Player &fromPlayer);
+    void _HandleCommandProcess(std::string &text, Player &fromPlayer);
+    void _HandleCommandPet(std::string &text, Player &fromPlayer);
+    void _HandleCommandSpells(std::string &text, Player &fromPlayer);
+    void _HandleCommandSurvey(std::string &text, Player &fromPlayer);
+    void _HandleCommandSkill(std::string &text, Player &fromPlayer);
+    void _HandleCommandStats(std::string &text, Player &fromPlayer);
+    void _HandleCommandHelp(std::string &text, Player &fromPlayer);
+    void _HandleCommandHelp(const char* szText, Player &fromPlayer) { std::string text = szText; _HandleCommandHelp(text, fromPlayer); }
+    void _HandleCommandGM(std::string &text, Player &fromPlayer);
+    std::string _HandleCommandHelpHelper(std::string sCommand, std::string sExplain, HELPERLINKABLES reqLink = HL_NONE, bool bReqLinkMultiples = false, bool bCommandShort = false);
+
+    // ****** Closed Actions ********************************
+    // These actions may only be called at special times.
+    // Trade methods are only applicable when the trade window is open
+    // and are only called from within HandleCommand.
+    bool TradeItem(const Item& item, int8 slot = -1);
+    bool TradeCopper(uint32 copper);
+
+    // Helper routines not needed by class AIs.
+    void UpdateAttackersForTarget(Unit *victim);
+
+    void _doSellItem(Item *item, std::ostringstream &report, std::ostringstream &canSell, uint32 &TotalCost, uint32 &TotalSold);
+    void MakeItemLink(const Item *item, std::ostringstream &out, bool IncludeQuantity = true);
+    void MakeItemText(const Item *item, std::ostringstream &out, bool IncludeQuantity = true);
+    void MakeItemLink(const ItemTemplate *item, std::ostringstream &out);
+
+    // it is safe to keep these back reference pointers because m_bot
+    // owns the "this" object and m_master owns m_bot. The owner always cleans up.
+    Player* const m_bot;
+    Player* const m_master;
+    PlayerbotClassAI* m_classAI;
+
+    // ignores AI updates until time specified
+    // no need to waste CPU cycles during casting etc
+    time_t m_ignoreAIUpdatesUntilTime;
+
+    CombatStyle m_combatStyle;
+    CombatOrderType m_combatOrder;
+    ResistType m_resistType;
+    MovementOrderType m_movementOrder;
+
+    TalentSpec m_activeTalentSpec;
+
+    ScenarioType m_ScenarioType;
+
+    // defines the state of behaviour of the bot
+    BotState m_botState;
+
+    // list of items, creatures or gameobjects needed to fullfill quests
+    BotNeedItem m_needItemList;
+    BotNeedItem m_needCreatureOrGOList;
+
+    // list of creatures we recently attacked and want to loot
+    BotNPCList m_findNPC;               // list of NPCs
+    BotTaskList m_tasks;                // list of tasks
+    BotObjectList m_lootTargets;        // list of targets
+    BotEntryList m_spellsToLearn;       // list of spells
+    ObjectGuid m_lootCurrent;               // current remains of interest
+    ObjectGuid m_lootPrev;                  // previous loot
+    BotEntryList m_collectObjects;      // object entries searched for in findNearbyGO
+    BotTaxiNode m_taxiNodes;            // flight node chain;
+    BotEntryList m_noToolList;          // list of required tools
+
+    uint8 m_collectionFlags;            // what the bot should look for to loot
+    //uint32 m_collectDist;               // distance to collect objects
+    bool m_inventory_full;
+    uint32 m_itemTarget;
+
+    time_t m_TimeDoneEating;
+    time_t m_TimeDoneDrinking;
+    uint32 m_CurrentlyCastingSpellId;
+    //bool m_IsFollowingMaster;
+
+    // if master commands bot to do something, store here until updateAI
+    // can do it
+    uint32 m_spellIdCommand;
+    ObjectGuid m_targetGuidCommand;
+    ObjectGuid m_taxiMaster;
+
+    BotObjectSet m_ignorePlayersChat;  // list of players that the bot will not respond to
+
+    AttackerInfoList m_attackerInfo;
+
+    bool m_targetChanged;
+    CombatTargetType m_targetType;
+
+    ObjectGuid m_targetCombatGUID;
+    Unit *m_targetCombat;       // current combat target
+    Unit *m_targetAssist;       // get new target by checking attacker list of assisted player
+    Unit *m_targetProtect;      // check
+
+    Unit *m_followTarget;       // whom to follow in non combat situation?
+
+    uint32 FISHING,
+           HERB_GATHERING,
+           MINING,
+           SKINNING,
+           ASPECT_OF_THE_MONKEY;
+
+    SpellRanges m_spellRangeMap;
+
+    float m_destX, m_destY, m_destZ; // latest coordinates for chase and point movement types
+
+};
+
+class PlayerbotClassAI
+{
+    friend class PlayerbotAI;
+public:
+    PlayerbotClassAI(Player * const master, Player * const bot, PlayerbotAI * const ai) : m_master(master), m_bot(bot), m_ai(ai) {}
+    virtual ~PlayerbotClassAI() {}
+
+    // all combat actions go here
+    virtual bool DoFirstCombatManeuver(Unit*) { return false; }
+    virtual void DoNextCombatManeuver(Unit*) {}
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    virtual void DoNonCombatActions() {}
+
+    // buff a specific player, usually a real PC who is not in group
+    virtual bool BuffPlayer(Player* /*target*/) { return false; }
+
+    float GetCombatDistance(const Unit* target) const;
+
+    //More generalized method than HasAura().  It looks for
+    //any rank of the spell and it doesn't care which
+    //spell effect you want.  If it has the spell aura than
+    //it returns true
+    bool HasAuraName(Unit *unit, std::string spell, ObjectGuid casterGuid = ObjectGuid::Empty) const;
+    bool HasAuraName(Unit *unit, uint32 spellId, ObjectGuid casterGuid = ObjectGuid::Empty) const;
+
+    // Utilities
+    Player* GetMaster() { return m_master; }
+    Player* GetPlayerBot() { return m_bot; }
+    PlayerbotAI* GetAI() { return m_ai; };
+
+
+private:
+    Player* m_master;
+    Player* m_bot;
+    PlayerbotAI* m_ai;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
new file mode 100644
index 0000000..244072b
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
@@ -0,0 +1,501 @@
+// a simple DK class by rrtn :)
+#include "PlayerbotDeathKnightAI.h"
+#include "Player.h"
+#include "Pet.h"
+
+PlayerbotDeathKnightAI::PlayerbotDeathKnightAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+
+    PLAGUE_STRIKE     = ai->initSpell(PLAGUE_STRIKE_1); // Unholy
+    DEATH_GRIP        = ai->initSpell(DEATH_GRIP_1);
+    DEATH_COIL        = ai->initSpell(DEATH_COIL_DEATH_KNIGHT_1);
+    DEATH_STRIKE      = ai->initSpell(DEATH_STRIKE_1);
+    UNHOLY_BLIGHT     = 0; // Passive
+    SCOURGE_STRIKE    = ai->initSpell(SCOURGE_STRIKE_1);
+    DEATH_AND_DECAY   = ai->initSpell(DEATH_AND_DECAY_1);
+    CORPSE_EXPLOSION  = ai->initSpell(CORPSE_EXPLOSION_1);
+    BONE_SHIELD       = ai->initSpell(BONE_SHIELD_1); // buffs
+    ANTI_MAGIC_SHELL  = ai->initSpell(ANTI_MAGIC_SHELL_1);
+    ANTI_MAGIC_ZONE   = ai->initSpell(ANTI_MAGIC_ZONE_1);
+    GHOUL_FRENZY      = ai->initSpell(GHOUL_FRENZY_1);
+    RAISE_DEAD        = ai->initSpell(RAISE_DEAD_1); // pets
+    SUMMON_GARGOYLE   = ai->initSpell(SUMMON_GARGOYLE_1);
+    ARMY_OF_THE_DEAD  = ai->initSpell(ARMY_OF_THE_DEAD_1);
+    ICY_TOUCH         = ai->initSpell(ICY_TOUCH_1); // Frost
+    OBLITERATE        = ai->initSpell(OBLITERATE_1);
+    HOWLING_BLAST     = ai->initSpell(HOWLING_BLAST_1);
+    FROST_STRIKE      = ai->initSpell(FROST_STRIKE_1);
+    CHAINS_OF_ICE     = ai->initSpell(CHAINS_OF_ICE_1);
+    RUNE_STRIKE       = ai->initSpell(RUNE_STRIKE_1);
+    ICY_CLUTCH        = 0; // No such spell
+    MIND_FREEZE       = ai->initSpell(MIND_FREEZE_1);
+    HUNGERING_COLD    = ai->initSpell(HUNGERING_COLD_1);
+    KILLING_MACHINE   = 0; // Passive
+    DEATHCHILL        = ai->initSpell(DEATHCHILL_1);
+    HORN_OF_WINTER    = ai->initSpell(HORN_OF_WINTER_1);
+    ICEBOUND_FORTITUDE = ai->initSpell(ICEBOUND_FORTITUDE_1);
+    EMPOWER_WEAPON    = ai->initSpell(EMPOWER_RUNE_WEAPON_1);
+    UNBREAKABLE_ARMOR = ai->initSpell(UNBREAKABLE_ARMOR_1);
+    BLOOD_STRIKE      = ai->initSpell(BLOOD_STRIKE_1); // Blood
+    PESTILENCE        = ai->initSpell(PESTILENCE_1);
+    STRANGULATE       = ai->initSpell(STRANGULATE_1);
+    BLOOD_BOIL        = ai->initSpell(BLOOD_BOIL_1);
+    HEART_STRIKE      = ai->initSpell(HEART_STRIKE_1);
+    DANCING_WEAPON    = ai->initSpell(DANCING_RUNE_WEAPON_1);
+    DARK_COMMAND      = ai->initSpell(DARK_COMMAND_1);
+    MARK_OF_BLOOD     = ai->initSpell(MARK_OF_BLOOD_1); // buffs
+    RUNE_TAP          = ai->initSpell(RUNE_TAP_1);
+    VAMPIRIC_BLOOD    = ai->initSpell(VAMPIRIC_BLOOD_1);
+    DEATH_PACT        = ai->initSpell(DEATH_PACT_1);
+    HYSTERIA          = ai->initSpell(HYSTERIA_1);
+    UNHOLY_PRESENCE   = ai->initSpell(UNHOLY_PRESENCE_1); // presence (TODO: better spell == presence)
+    FROST_PRESENCE    = ai->initSpell(FROST_PRESENCE_1);
+    BLOOD_PRESENCE    = ai->initSpell(BLOOD_PRESENCE_1);
+
+    RECENTLY_BANDAGED = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT          = ai->initSpell(ARCANE_TORRENT_DEATH_KNIGHT); // blood elf
+    GIFT_OF_THE_NAARU       = ai->initSpell(GIFT_OF_THE_NAARU_DEATH_KNIGHT); // draenei
+    STONEFORM               = ai->initSpell(STONEFORM_ALL); // dwarf
+    ESCAPE_ARTIST           = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    BLOOD_FURY              = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    WAR_STOMP               = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING              = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN    = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotDeathKnightAI::~PlayerbotDeathKnightAI() {}
+
+bool PlayerbotDeathKnightAI::DoFirstCombatManeuver(Unit* /*pTarget*/)
+{
+    return false;
+}
+
+void PlayerbotDeathKnightAI::DoNextCombatManeuver(Unit* pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(PLAGUE_STRIKE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    // DK Attacks: Unholy, Frost & Blood
+
+    // damage spells
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->GetVictim();
+    Pet *pet = m_bot->GetPet();
+    float dist = GetCombatDistance(pTarget);
+    std::ostringstream out;
+
+    switch (SpellSequence)
+    {
+        case SPELL_DK_UNHOLY:
+            if (UNHOLY_PRESENCE > 0)
+                (!m_bot->HasAura(UNHOLY_PRESENCE, ObjectGuid::Empty) && !m_bot->HasAura(BLOOD_PRESENCE, ObjectGuid::Empty) && !m_bot->HasAura(FROST_PRESENCE, ObjectGuid::Empty) && ai->CastSpell (UNHOLY_PRESENCE, *m_bot));
+
+            // check for BONE_SHIELD in combat
+            if (BONE_SHIELD > 0)
+                (!m_bot->HasAura(BONE_SHIELD, ObjectGuid::Empty) && !m_bot->HasAura(ARMY_OF_THE_DEAD, ObjectGuid::Empty) && ai->CastSpell (BONE_SHIELD, *m_bot));
+
+            if (ARMY_OF_THE_DEAD > 0 && ai->GetAttackerCount() >= 5 && LastSpellUnholyDK < 1)
+            {
+                ai->CastSpell(ARMY_OF_THE_DEAD);
+                out << " summoning Army of the Dead!";
+                if (ARMY_OF_THE_DEAD > 0 && m_bot->HasAura(ARMY_OF_THE_DEAD, ObjectGuid::Empty))
+                    ai->SetIgnoreUpdateTime(7);
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (PLAGUE_STRIKE > 0 && !pTarget->HasAura(PLAGUE_STRIKE, ObjectGuid::Empty) && LastSpellUnholyDK < 2)
+            {
+                ai->CastSpell(PLAGUE_STRIKE, *pTarget);
+                out << " Plague Strike";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_GRIP > 0 && !pTarget->HasAura(DEATH_GRIP, ObjectGuid::Empty) && LastSpellUnholyDK < 3)
+            {
+                ai->CastSpell(DEATH_GRIP, *pTarget);
+                out << " Death Grip";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_COIL > 0 && LastSpellUnholyDK < 4 && ai->GetRunicPower() >= 40)
+            {
+                ai->CastSpell(DEATH_COIL, *pTarget);
+                out << " Death Coil";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_STRIKE > 0 && !pTarget->HasAura(DEATH_STRIKE, ObjectGuid::Empty) && LastSpellUnholyDK < 5)
+            {
+                ai->CastSpell(DEATH_STRIKE, *pTarget);
+                out << " Death Strike";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (UNHOLY_BLIGHT > 0 && !pTarget->HasAura(UNHOLY_BLIGHT, ObjectGuid::Empty) && LastSpellUnholyDK < 6)
+            {
+                ai->CastSpell(UNHOLY_BLIGHT);
+                out << " Unholy Blight";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (SCOURGE_STRIKE > 0 && LastSpellUnholyDK < 7)
+            {
+                ai->CastSpell(SCOURGE_STRIKE, *pTarget);
+                out << " Scourge Strike";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_AND_DECAY > 0 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(DEATH_AND_DECAY, ObjectGuid::Empty) && LastSpellUnholyDK < 8)
+            {
+                ai->CastSpell(DEATH_AND_DECAY);
+                out << " Death and Decay";
+                ai->SetIgnoreUpdateTime(1);
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (SUMMON_GARGOYLE > 0 && !m_bot->HasAura(ARMY_OF_THE_DEAD, ObjectGuid::Empty) && !pTarget->HasAura(SUMMON_GARGOYLE, ObjectGuid::Empty) && LastSpellUnholyDK < 9 && ai->GetRunicPower() >= 60)
+            {
+                ai->CastSpell(SUMMON_GARGOYLE, *pTarget);
+                out << " summoning Gargoyle";
+                ai->SetIgnoreUpdateTime(2);
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (CORPSE_EXPLOSION > 0 && dist <= ATTACK_DISTANCE && LastSpellUnholyDK < 10)
+            {
+                ai->CastSpell(CORPSE_EXPLOSION, *pTarget);
+                out << " Corpse Explosion";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (ANTI_MAGIC_SHELL > 0 && pTarget->IsNonMeleeSpellCast(true) && !m_bot->HasAura(ANTI_MAGIC_SHELL, ObjectGuid::Empty) && LastSpellUnholyDK < 11 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(ANTI_MAGIC_SHELL, *m_bot);
+                out << " Anti-Magic Shell";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (ANTI_MAGIC_ZONE > 0 && pTarget->IsNonMeleeSpellCast(true) && !m_bot->HasAura(ANTI_MAGIC_SHELL, ObjectGuid::Empty) && LastSpellUnholyDK < 12)
+            {
+                ai->CastSpell(ANTI_MAGIC_ZONE, *m_bot);
+                out << " Anti-Magic Zone";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if ((!pet)
+                     && (RAISE_DEAD > 0 && !m_bot->HasAura(ARMY_OF_THE_DEAD, ObjectGuid::Empty) && LastSpellUnholyDK < 13))
+            {
+                ai->CastSpell(RAISE_DEAD);
+                out << " summoning Ghoul";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if ((pet)
+                     && (GHOUL_FRENZY > 0 && pVictim == pet && !pet->HasAura(GHOUL_FRENZY, ObjectGuid::Empty) && LastSpellUnholyDK < 14))
+            {
+                ai->CastSpell(GHOUL_FRENZY, *pet);
+                out << " casting Ghoul Frenzy on pet";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (LastSpellUnholyDK > 15)
+            {
+                LastSpellUnholyDK = 0;
+                SpellSequence = SPELL_DK_FROST;
+                break;
+            }
+
+            LastSpellUnholyDK = 0;
+
+        case SPELL_DK_FROST:
+            if (FROST_PRESENCE > 0)
+                (!m_bot->HasAura(FROST_PRESENCE, ObjectGuid::Empty) && !m_bot->HasAura(BLOOD_PRESENCE, ObjectGuid::Empty) && !m_bot->HasAura(UNHOLY_PRESENCE, ObjectGuid::Empty) && ai->CastSpell (FROST_PRESENCE, *m_bot));
+
+            if (DEATHCHILL > 0)
+                (!m_bot->HasAura(DEATHCHILL, ObjectGuid::Empty) && !m_bot->HasAura(KILLING_MACHINE, ObjectGuid::Empty) && ai->CastSpell (DEATHCHILL, *m_bot));
+            else if (KILLING_MACHINE > 0)
+                (!m_bot->HasAura(KILLING_MACHINE, ObjectGuid::Empty) && !m_bot->HasAura(DEATHCHILL, ObjectGuid::Empty) && ai->CastSpell (KILLING_MACHINE, *m_bot));
+
+            if (ICY_TOUCH > 0 && !pTarget->HasAura(ICY_TOUCH, ObjectGuid::Empty) && LastSpellFrostDK < 1)
+            {
+                ai->CastSpell(ICY_TOUCH, *pTarget);
+                out << " Icy Touch";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (OBLITERATE > 0 && LastSpellFrostDK < 2)
+            {
+                ai->CastSpell(OBLITERATE, *pTarget);
+                out << " Obliterate";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (FROST_STRIKE > 0 && LastSpellFrostDK < 3 && ai->GetRunicPower() >= 40)
+            {
+                ai->CastSpell(FROST_STRIKE, *pTarget);
+                out << " Frost Strike";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (HOWLING_BLAST > 0 && ai->GetAttackerCount() >= 3 && LastSpellFrostDK < 4)
+            {
+                ai->CastSpell(HOWLING_BLAST, *pTarget);
+                out << " Howling Blast";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (CHAINS_OF_ICE > 0 && !pTarget->HasAura(CHAINS_OF_ICE, ObjectGuid::Empty) && LastSpellFrostDK < 5)
+            {
+                ai->CastSpell(CHAINS_OF_ICE, *pTarget);
+                out << " Chains of Ice";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (RUNE_STRIKE > 0 && LastSpellFrostDK < 6 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(RUNE_STRIKE, *pTarget);
+                out << " Rune Strike";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (ICY_CLUTCH > 0 && !pTarget->HasAura(ICY_CLUTCH, ObjectGuid::Empty) && LastSpellFrostDK < 7)
+            {
+                ai->CastSpell(ICY_CLUTCH, *pTarget);
+                out << " Icy Clutch";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (ICEBOUND_FORTITUDE > 0 && ai->GetHealthPercent() < 50 && pVictim == m_bot && !m_bot->HasAura(ICEBOUND_FORTITUDE, ObjectGuid::Empty) && LastSpellFrostDK < 8 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(ICEBOUND_FORTITUDE, *m_bot);
+                out << " Icebound Fortitude";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (MIND_FREEZE > 0 && pTarget->IsNonMeleeSpellCast(true) && dist <= ATTACK_DISTANCE && LastSpellFrostDK < 9 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(MIND_FREEZE, *pTarget);
+                out << " Mind Freeze";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (HUNGERING_COLD > 0 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && LastSpellFrostDK < 10 && ai->GetRunicPower() >= 40)
+            {
+                ai->CastSpell(HUNGERING_COLD, *pTarget);
+                out << " Hungering Cold";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (EMPOWER_WEAPON > 0 && ai->GetRunicPower() < 20 && LastSpellFrostDK < 11)
+            {
+                ai->CastSpell(EMPOWER_WEAPON, *m_bot);
+                out << " Empower Rune Weapon";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (UNBREAKABLE_ARMOR > 0 && !m_bot->HasAura(UNBREAKABLE_ARMOR, ObjectGuid::Empty) && ai->GetHealthPercent() < 70 && pVictim == m_bot && LastSpellFrostDK < 12)
+            {
+                ai->CastSpell(UNBREAKABLE_ARMOR, *m_bot);
+                out << " Unbreakable Armor";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (LastSpellFrostDK > 13)
+            {
+                LastSpellFrostDK = 0;
+                SpellSequence = SPELL_DK_BLOOD;
+                break;
+            }
+
+            LastSpellFrostDK = 0;
+
+        case SPELL_DK_BLOOD:
+            if (BLOOD_PRESENCE > 0)
+                (!m_bot->HasAura(BLOOD_PRESENCE, ObjectGuid::Empty) && !m_bot->HasAura(UNHOLY_PRESENCE, ObjectGuid::Empty) && !m_bot->HasAura(FROST_PRESENCE, ObjectGuid::Empty) && ai->CastSpell (BLOOD_PRESENCE, *m_bot));
+
+            if (MARK_OF_BLOOD > 0 && !pTarget->HasAura(MARK_OF_BLOOD, ObjectGuid::Empty) && LastSpellBloodDK < 1)
+            {
+                ai->CastSpell(MARK_OF_BLOOD, *pTarget);
+                out << " Mark of Blood";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (BLOOD_STRIKE > 0 && LastSpellBloodDK < 2)
+            {
+                ai->CastSpell(BLOOD_STRIKE, *pTarget);
+                out << " Blood Strike";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK =  LastSpellBloodDK + 1;
+                break;
+            }
+            else if (PESTILENCE > 0 && dist <= ATTACK_DISTANCE && ai->GetAttackerCount() >= 3 && LastSpellBloodDK < 3)
+            {
+                ai->CastSpell(PESTILENCE, *pTarget);
+                out << " Pestilence";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (STRANGULATE > 0 && !pTarget->HasAura(STRANGULATE, ObjectGuid::Empty) && LastSpellBloodDK < 4)
+            {
+                ai->CastSpell(STRANGULATE, *pTarget);
+                out << " Strangulate";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (BLOOD_BOIL > 0 && ai->GetAttackerCount() >= 5 && dist <= ATTACK_DISTANCE && LastSpellBloodDK < 5)
+            {
+                ai->CastSpell(BLOOD_BOIL, *pTarget);
+                out << " Blood Boil";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (HEART_STRIKE > 0 && LastSpellBloodDK < 6)
+            {
+                ai->CastSpell(HEART_STRIKE, *pTarget);
+                out << " Heart Strike";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (VAMPIRIC_BLOOD > 0 && ai->GetHealthPercent() < 70 && !m_bot->HasAura(VAMPIRIC_BLOOD, ObjectGuid::Empty) && LastSpellBloodDK < 7)
+            {
+                ai->CastSpell(VAMPIRIC_BLOOD, *m_bot);
+                out << " Vampiric Blood";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (RUNE_TAP > 0 && ai->GetHealthPercent() < 70 && !m_bot->HasAura(VAMPIRIC_BLOOD, ObjectGuid::Empty) && LastSpellBloodDK < 8)
+            {
+                ai->CastSpell(RUNE_TAP, *m_bot);
+                out << " Rune Tap";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (HYSTERIA > 0 && ai->GetHealthPercent() > 25 && !m_bot->HasAura(HYSTERIA, ObjectGuid::Empty) && LastSpellBloodDK < 9)
+            {
+                ai->CastSpell(HYSTERIA, *m_bot);
+                out << " Hysteria";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (DANCING_WEAPON > 0 && !m_bot->HasAura(DANCING_WEAPON, ObjectGuid::Empty) && ai->GetRunicPower() >= 60 && LastSpellBloodDK < 10)
+            {
+                ai->CastSpell(DANCING_WEAPON, *pTarget);
+                out << " summoning Dancing Rune Weapon";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (DARK_COMMAND > 0 && ai->GetHealthPercent() > 50 && pVictim != m_bot && !pTarget->HasAura(DARK_COMMAND, ObjectGuid::Empty) && dist <= ATTACK_DISTANCE && LastSpellBloodDK < 11)
+            {
+                ai->CastSpell(DARK_COMMAND, *pTarget);
+                out << " Dark Command";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if ((pet)
+                     && (DEATH_PACT > 0 && ai->GetHealthPercent() < 50 && LastSpellBloodDK < 12 && ai->GetRunicPower() >= 40))
+            {
+                ai->CastSpell(DEATH_PACT, *pet);
+                out << " Death Pact (sacrifice pet)";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (LastSpellBloodDK > 13)
+            {
+                LastSpellBloodDK = 0;
+                SpellSequence = SPELL_DK_UNHOLY;
+                break;
+            }
+            else
+            {
+                LastSpellBloodDK = 0;
+                SpellSequence = SPELL_DK_UNHOLY;
+            }
+    }
+    if (ai->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+
+} // end DoNextCombatManeuver
+
+void PlayerbotDeathKnightAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    SpellSequence = SPELL_DK_UNHOLY;
+
+    // buff master with HORN_OF_WINTER
+    if (HORN_OF_WINTER > 0)
+        (!GetMaster()->HasAura(HORN_OF_WINTER, ObjectGuid::Empty) && ai->CastSpell (HORN_OF_WINTER, *GetMaster()));
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindFood();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, ObjectGuid::Empty) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
new file mode 100644
index 0000000..792ecdf
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
@@ -0,0 +1,100 @@
+#ifndef _PLAYERDEATHKNIGHTAI_H
+#define _PLAYERDEATHKNIGHTAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    SPELL_DK_UNHOLY,
+    SPELL_DK_FROST,
+    SPELL_DK_BLOOD
+};
+
+enum DeathKnightSpells
+{
+    ANTI_MAGIC_SHELL_1              = 48707,
+    ANTI_MAGIC_ZONE_1               = 51052,
+    ARMY_OF_THE_DEAD_1              = 42650,
+    BLOOD_BOIL_1                    = 48721,
+    BLOOD_PRESENCE_1                = 48266,
+    BLOOD_STRIKE_1                  = 45902,
+    BLOOD_TAP_1                     = 45529,
+    BONE_SHIELD_1                   = 49222,
+    CHAINS_OF_ICE_1                 = 45524,
+    CORPSE_EXPLOSION_1              = 49158,
+    DANCING_RUNE_WEAPON_1           = 49028,
+    DARK_COMMAND_1                  = 56222,
+    DEATH_AND_DECAY_1               = 43265,
+    DEATH_COIL_DEATH_KNIGHT_1       = 47541,
+    DEATH_GRIP_1                    = 49576,
+    DEATH_PACT_1                    = 48743,
+    DEATH_STRIKE_1                  = 49998,
+    DEATHCHILL_1                    = 49796,
+    EMPOWER_RUNE_WEAPON_1           = 47568,
+    FROST_PRESENCE_1                = 48263,
+    FROST_STRIKE_1                  = 49143,
+    GHOUL_FRENZY_1                  = 63560,
+    HEART_STRIKE_1                  = 55050,
+    HORN_OF_WINTER_1                = 57330,
+    HOWLING_BLAST_1                 = 49184,
+    HUNGERING_COLD_1                = 49203,
+    HYSTERIA_1                      = 49016,
+    ICEBOUND_FORTITUDE_1            = 48792,
+    ICY_TOUCH_1                     = 45477,
+    LICHBORNE_1                     = 49039,
+    MARK_OF_BLOOD_1                 = 49005,
+    MIND_FREEZE_1                   = 47528,
+    OBLITERATE_1                    = 49020,
+    PATH_OF_FROST_1                 = 3714,
+    PESTILENCE_1                    = 50842,
+    PLAGUE_STRIKE_1                 = 45462,
+    RAISE_ALLY_1                    = 61999,
+    RAISE_DEAD_1                    = 46584,
+    RUNE_STRIKE_1                   = 56815,
+    RUNE_TAP_1                      = 48982,
+    SCOURGE_STRIKE_1                = 55090,
+    STRANGULATE_1                   = 47476,
+    SUMMON_GARGOYLE_1               = 49206,
+    UNBREAKABLE_ARMOR_1             = 51271,
+    UNHOLY_PRESENCE_1               = 48265,
+    VAMPIRIC_BLOOD_1                = 55233
+};
+//class Player;
+
+class PlayerbotDeathKnightAI : PlayerbotClassAI
+{
+public:
+    PlayerbotDeathKnightAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotDeathKnightAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    //void BuffPlayer(Player *target);
+
+private:
+
+    // Unholy
+    uint32 BONE_SHIELD, PLAGUE_STRIKE, DEATH_GRIP, DEATH_COIL, DEATH_STRIKE, UNHOLY_BLIGHT, SCOURGE_STRIKE, DEATH_AND_DECAY, UNHOLY_PRESENCE, RAISE_DEAD, ARMY_OF_THE_DEAD, SUMMON_GARGOYLE, ANTI_MAGIC_SHELL, ANTI_MAGIC_ZONE, GHOUL_FRENZY, CORPSE_EXPLOSION;
+
+    // Frost
+    uint32 ICY_TOUCH, OBLITERATE, HOWLING_BLAST, FROST_STRIKE, CHAINS_OF_ICE, RUNE_STRIKE, ICY_CLUTCH, HORN_OF_WINTER, KILLING_MACHINE, FROST_PRESENCE, DEATHCHILL, ICEBOUND_FORTITUDE, MIND_FREEZE, EMPOWER_WEAPON, HUNGERING_COLD, UNBREAKABLE_ARMOR;
+
+    // Blood
+    uint32 BLOOD_STRIKE, PESTILENCE, STRANGULATE, BLOOD_BOIL, HEART_STRIKE, MARK_OF_BLOOD, BLOOD_PRESENCE, RUNE_TAP, VAMPIRIC_BLOOD, DEATH_PACT, DEATH_RUNE_MASTERY, HYSTERIA, DANCING_WEAPON, DARK_COMMAND;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellUnholyDK, LastSpellFrostDK, LastSpellBloodDK;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
new file mode 100644
index 0000000..b8321e8
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
@@ -0,0 +1,716 @@
+/*
+    Name    : PlayerbotDruidAI.cpp
+    Complete: maybe around 33%
+    Authors : rrtn, Natsukawa
+    Version : 0.42
+ */
+#include "PlayerbotDruidAI.h"
+#include "ObjectAccessor.h"
+#include "SpellAuras.h"
+#include "Player.h"
+#include "Group.h"
+#include "Pet.h"
+
+PlayerbotDruidAI::PlayerbotDruidAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    MOONFIRE                      = ai->initSpell(MOONFIRE_1); // attacks
+    STARFIRE                      = ai->initSpell(STARFIRE_1);
+    STARFALL                      = ai->initSpell(STARFALL_1);
+    WRATH                         = ai->initSpell(WRATH_1);
+    ROOTS                         = ai->initSpell(ENTANGLING_ROOTS_1);
+    INSECT_SWARM                  = ai->initSpell(INSECT_SWARM_1);
+    FORCE_OF_NATURE               = ai->initSpell(FORCE_OF_NATURE_1);
+    HURRICANE                     = ai->initSpell(HURRICANE_1);
+    MARK_OF_THE_WILD              = ai->initSpell(MARK_OF_THE_WILD_1); // buffs
+    GIFT_OF_THE_WILD              = ai->initSpell(GIFT_OF_THE_WILD_1);
+    THORNS                        = ai->initSpell(THORNS_1);
+    BARKSKIN                      = ai->initSpell(BARKSKIN_1);
+    INNERVATE                     = ai->initSpell(INNERVATE_1);
+    FAERIE_FIRE                   = ai->initSpell(FAERIE_FIRE_1); // debuffs
+    FAERIE_FIRE_FERAL             = ai->initSpell(FAERIE_FIRE_FERAL_1);
+    REJUVENATION                  = ai->initSpell(REJUVENATION_1); // heals
+    REGROWTH                      = ai->initSpell(REGROWTH_1);
+    WILD_GROWTH                   = ai->initSpell(WILD_GROWTH_1);
+    LIFEBLOOM                     = ai->initSpell(LIFEBLOOM_1);
+    NOURISH                       = ai->initSpell(NOURISH_1);
+    HEALING_TOUCH                 = ai->initSpell(HEALING_TOUCH_1);
+    SWIFTMEND                     = ai->initSpell(SWIFTMEND_1);
+    TRANQUILITY                   = ai->initSpell(TRANQUILITY_1);
+    REVIVE                        = ai->initSpell(REVIVE_1);
+    REMOVE_CURSE                  = ai->initSpell(REMOVE_CURSE_DRUID_1);
+    ABOLISH_POISON                = ai->initSpell(ABOLISH_POISON_1);
+    // Druid Forms
+    MOONKIN_FORM                  = ai->initSpell(MOONKIN_FORM_1);
+    DIRE_BEAR_FORM                = ai->initSpell(DIRE_BEAR_FORM_1);
+    BEAR_FORM                     = ai->initSpell(BEAR_FORM_1);
+    CAT_FORM                      = ai->initSpell(CAT_FORM_1);
+    TREE_OF_LIFE                  = ai->initSpell(TREE_OF_LIFE_1);
+    TRAVEL_FORM                   = ai->initSpell(TRAVEL_FORM_1);
+    // Cat Attack type's
+    RAKE                          = ai->initSpell(RAKE_1);
+    CLAW                          = ai->initSpell(CLAW_1); // 45
+    COWER                         = ai->initSpell(COWER_1); // 20
+    MANGLE                        = ai->initSpell(MANGLE_1); // 45
+    TIGERS_FURY                   = ai->initSpell(TIGERS_FURY_1);
+    // Cat Finishing Move's
+    RIP                           = ai->initSpell(RIP_1); // 30
+    FEROCIOUS_BITE                = ai->initSpell(FEROCIOUS_BITE_1); // 35
+    MAIM                          = ai->initSpell(MAIM_1); // 35
+    // Bear/Dire Bear Attacks & Buffs
+    BASH                          = ai->initSpell(BASH_1);
+    MAUL                          = ai->initSpell(MAUL_1); // 15
+    SWIPE                         = ai->initSpell(SWIPE_BEAR_1); // 20
+    DEMORALIZING_ROAR             = ai->initSpell(DEMORALIZING_ROAR_1); // 10
+    CHALLENGING_ROAR              = ai->initSpell(CHALLENGING_ROAR_1);
+    ENRAGE                        = ai->initSpell(ENRAGE_1);
+    GROWL                         = ai->initSpell(GROWL_1);
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    SHADOWMELD                    = ai->initSpell(SHADOWMELD_ALL);
+    WAR_STOMP                     = ai->initSpell(WAR_STOMP_ALL); // tauren
+}
+
+PlayerbotDruidAI::~PlayerbotDruidAI() {}
+
+bool PlayerbotDruidAI::DoFirstCombatManeuver(Unit* /*pTarget*/)
+{
+    return false;
+}
+
+bool PlayerbotDruidAI::HealTarget(Unit* target)
+{
+    PlayerbotAI* ai = GetAI();
+    uint8 hp = target->GetHealth() * 100 / target->GetMaxHealth();
+
+    //If spell exists and orders say we should be dispelling
+    if ((REMOVE_CURSE > 0 || ABOLISH_POISON > 0) && ai->GetCombatOrder() != PlayerbotAI::ORDERS_NODISPEL)
+    {
+        //This does something important(lol)
+        //Get a list of all the targets auras(spells affecting target)
+        Unit::AuraMap const& auras = target->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura *aura = itr->second;
+            if (aura->IsPassive()) continue;
+            if (aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+            if (aura->GetId() == 64844 || //Divine Hymn
+                aura->GetId() == 6346) // Fear Ward
+                continue;
+            DispelType dispel = DispelType(aura->GetSpellInfo()->Dispel);
+            if ((ABOLISH_POISON > 0 && dispel == DISPEL_POISON) ||
+                (REMOVE_CURSE > 0 && dispel == DISPEL_CURSE))
+            {
+                uint32 DISPEL = (REMOVE_CURSE > 0 && dispel == DISPEL_CURSE) ? REMOVE_CURSE : \
+                    (ABOLISH_POISON > 0 && dispel == DISPEL_POISON) ? ABOLISH_POISON : 0;
+                if (DISPEL)
+                {
+                    AuraApplication *aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+                    if (!aurApp)
+                        continue;
+                    if (!aurApp->IsPositive())
+                        ai->CastSpell(DISPEL, *target);
+                }
+            }
+        }
+    }
+
+    if (hp >= 70)
+        return false;
+
+    // Reset form if needed
+    GoBuffForm(GetPlayerBot());
+
+    if (hp < 70 && REJUVENATION > 0 && !target->HasAura(REJUVENATION) && ai->CastSpell(REJUVENATION, *target))
+        return true;
+
+    if (hp < 60 && LIFEBLOOM > 0 && !target->HasAura(LIFEBLOOM) && ai->CastSpell(LIFEBLOOM, *target))
+        return true;
+
+    if (hp < 55 && REGROWTH > 0 && !target->HasAura(REGROWTH) && ai->CastSpell(REGROWTH, *target))
+        return true;
+
+    if (hp < 50 && SWIFTMEND > 0 && (target->HasAura(REJUVENATION) || target->HasAura(REGROWTH)) && ai->CastSpell(SWIFTMEND, *target))
+        return true;
+
+    if (hp < 45 && WILD_GROWTH > 0 && !target->HasAura(WILD_GROWTH) && ai->CastSpell(WILD_GROWTH, *target))
+        return true;
+
+    if (hp < 30 && NOURISH > 0 && ai->CastSpell(NOURISH, *target))
+        return true;
+
+    if (hp < 25 && HEALING_TOUCH > 0 && ai->CastSpell(HEALING_TOUCH, *target))
+        return true;
+
+    return false;
+} // end HealTarget
+
+void PlayerbotDruidAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(MOONFIRE);
+            return;
+    }
+
+    //uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    //Player *m_bot = GetPlayerBot();
+    //Unit* pVictim = pTarget->GetVictim();
+
+    if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_HEAL)
+        SpellSequence = DruidHeal;
+    else if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST && CAT_FORM > 0)
+        SpellSequence = DruidCombat;
+    // No check for Dire Bear here: you must have Bear form to learn Dire Bear form.
+    else if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_TANK && BEAR_FORM > 0)
+        SpellSequence = DruidTank;
+    else
+        SpellSequence = DruidSpell;
+
+    switch (SpellSequence)
+    {
+        case DruidTank: // Its now a tank druid!
+            //ai->TellMaster("DruidTank");
+            _DoNextPVECombatManeuverBear(pTarget);
+            break;
+
+        case DruidSpell:
+            //ai->TellMaster("DruidSpell");
+            _DoNextPVECombatManeuverSpellDPS(pTarget);
+            break;
+
+        case DruidHeal:
+            //ai->TellMaster("DruidHeal");
+            _DoNextPVECombatManeuverHeal(pTarget);
+            break;
+
+        case DruidCombat:
+            //ai->TellMaster("DruidCombat");
+            _DoNextPVECombatManeuverMeleeDPS(pTarget);
+            break;
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotDruidAI::_DoNextPVECombatManeuverBear(Unit* pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    //uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->GetVictim();
+
+    // Face your enemy!
+    if (!m_bot->HasInArc(M_PI, pTarget))
+    {
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+        if (pVictim)
+            pVictim->Attack(pTarget, true);
+    }
+
+    // Try and go into [dire] bear form first
+    if (DIRE_BEAR_FORM > 0 && !m_bot->HasAura(DIRE_BEAR_FORM, ObjectGuid::Empty))
+        ai->CastSpell(DIRE_BEAR_FORM);
+    else if (BEAR_FORM > 0 && DIRE_BEAR_FORM == 0 && !m_bot->HasAura(DIRE_BEAR_FORM, ObjectGuid::Empty) && !m_bot->HasAura(BEAR_FORM, ObjectGuid::Empty))
+        ai->CastSpell(BEAR_FORM);
+    else if (DEMORALIZING_ROAR > 0 && (m_bot->HasAura(DIRE_BEAR_FORM, ObjectGuid::Empty) || m_bot->HasAura(BEAR_FORM, ObjectGuid::Empty)) && !pTarget->HasAura(DEMORALIZING_ROAR, ObjectGuid::Empty) && ai->GetRageAmount() >= 10)
+        ai->CastSpell(DEMORALIZING_ROAR, *pTarget);
+
+    // entire tank spell sequence is predicated on being in [dire] bear form. If not in it, exit (*before* going out of other forms)
+    if (!m_bot->HasAura(DIRE_BEAR_FORM) && !m_bot->HasAura(BEAR_FORM))
+        return _DoNextPVECombatManeuverMeleeDPS(pTarget); // bear = melee so...
+
+    // Impossible due to check above
+    // If still in cat/moonkin/tree form, go out of it
+    //if (m_bot->HasAura(CAT_FORM, ObjectGuid::Empty))
+    //    m_bot->RemoveAurasDueToSpell(CAT_FORM_1);
+    //if (m_bot->HasAura(MOONKIN_FORM, ObjectGuid::Empty))
+    //    m_bot->RemoveAurasDueToSpell(MOONKIN_FORM_1);
+    //if (m_bot->HasAura(TREE_OF_LIFE, ObjectGuid::Empty))
+    //    m_bot->RemoveAurasDueToSpell(TREE_OF_LIFE_1);
+
+    if (FAERIE_FIRE_FERAL > 0 && DruidSpellCombat < 1 && !pTarget->HasAura(FAERIE_FIRE_FERAL, ObjectGuid::Empty))
+    {
+        ai->CastSpell(FAERIE_FIRE, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (ENRAGE > 0 && DruidSpellCombat < 2 && !m_bot->HasAura(ENRAGE, ObjectGuid::Empty))
+    {
+        ai->CastSpell(ENRAGE, *m_bot);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (SWIPE > 0 && DruidSpellCombat < 3 && ai->GetRageAmount() >= 20)
+    {
+        ai->CastSpell(SWIPE, *pTarget);
+        DruidSpellCombat += 2;
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (MAUL > 0 && DruidSpellCombat < 4 && ai->GetRageAmount() >= 15)
+    {
+        ai->CastSpell(MAUL, *pTarget);
+        DruidSpellCombat += 2;
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (BASH > 0 && !pTarget->HasAura(BASH, ObjectGuid::Empty) && DruidSpellCombat < 5 && ai->GetRageAmount() >= 10)
+    {
+        ai->CastSpell(BASH, *pTarget);
+        DruidSpellCombat += 2;
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (CHALLENGING_ROAR > 0 && pVictim != m_bot && DruidSpellCombat < 6 && !pTarget->HasAura(CHALLENGING_ROAR, ObjectGuid::Empty) && !pTarget->HasAura(GROWL, ObjectGuid::Empty) && ai->GetRageAmount() >= 15)
+    {
+        ai->CastSpell(CHALLENGING_ROAR, *pTarget);
+        DruidSpellCombat += 2;
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (GROWL > 0 && pVictim != m_bot && DruidSpellCombat < 7 && !pTarget->HasAura(CHALLENGING_ROAR, ObjectGuid::Empty) && !pTarget->HasAura(GROWL, ObjectGuid::Empty))
+    {
+        ai->CastSpell(GROWL, *pTarget);
+        DruidSpellCombat += 2;
+        return;
+    }
+
+    DruidSpellCombat = 0;
+}
+
+void PlayerbotDruidAI::_DoNextPVECombatManeuverSpellDPS(Unit* pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    //uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->GetVictim();
+
+    if (MOONKIN_FORM > 0 && !m_bot->HasAura(MOONKIN_FORM, ObjectGuid::Empty))
+        ai->CastSpell (MOONKIN_FORM);
+
+    // NOTE: Tree of Life is beneficial to armor and Wrath - leave on if not in Moonkin (not talented or OutOfMana)
+    if (m_bot->HasAura(CAT_FORM, ObjectGuid::Empty))
+    {
+        m_bot->RemoveAurasDueToSpell(CAT_FORM_1);
+        //ai->TellMaster("FormClearCat");
+        return;
+    }
+    if (m_bot->HasAura(BEAR_FORM, ObjectGuid::Empty))
+    {
+        m_bot->RemoveAurasDueToSpell(BEAR_FORM_1);
+        //ai->TellMaster("FormClearBear");
+        return;
+    }
+    if (m_bot->HasAura(DIRE_BEAR_FORM, ObjectGuid::Empty))
+    {
+        m_bot->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
+        //ai->TellMaster("FormClearDireBear");
+        return;
+    }
+
+    if (FAERIE_FIRE > 0 && DruidSpellCombat < 1 && !pTarget->HasAura(FAERIE_FIRE, ObjectGuid::Empty) && ai->GetManaPercent() >= 8)
+    {
+        ai->CastSpell(FAERIE_FIRE, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (MOONFIRE > 0 && DruidSpellCombat < 2 && !pTarget->HasAura(MOONFIRE, ObjectGuid::Empty) && ai->GetManaPercent() >= 24)
+    {
+        ai->CastSpell(MOONFIRE, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (ROOTS > 0 && DruidSpellCombat < 3 && !pTarget->HasAura(ROOTS, ObjectGuid::Empty) && ai->GetManaPercent() >= 8)
+    {
+        ai->CastSpell(ROOTS, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (HURRICANE > 0 && ai->GetAttackerCount() >= 5 && DruidSpellCombat < 4 && ai->GetManaPercent() >= 91)
+    {
+        ai->CastSpell(HURRICANE, *pTarget);
+        ai->SetIgnoreUpdateTime(10);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (WRATH > 0 && DruidSpellCombat < 5 && ai->GetManaPercent() >= 13)
+    {
+        ai->CastSpell(WRATH, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (INSECT_SWARM > 0 && DruidSpellCombat < 6 && !pTarget->HasAura(INSECT_SWARM, ObjectGuid::Empty) && ai->GetManaPercent() >= 9)
+    {
+        ai->CastSpell(INSECT_SWARM, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (STARFIRE > 0 && DruidSpellCombat < 7 && ai->GetManaPercent() >= 18)
+    {
+        ai->CastSpell(STARFIRE, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (FORCE_OF_NATURE > 0 && DruidSpellCombat < 8 && ai->GetManaPercent() >= 12)
+    {
+        ai->CastSpell(FORCE_OF_NATURE);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (STARFALL > 0 && !m_bot->HasAura(STARFALL, ObjectGuid::Empty) && ai->GetAttackerCount() >= 3 && DruidSpellCombat < 9 && ai->GetManaPercent() >= 39)
+    {
+        ai->CastSpell(STARFALL, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (BARKSKIN > 0 && pVictim == m_bot && ai->GetHealthPercent() < 75 && DruidSpellCombat < 10 && !m_bot->HasAura(BARKSKIN, ObjectGuid::Empty))
+    {
+        ai->CastSpell(BARKSKIN, *m_bot);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (INNERVATE > 0 && ai->GetManaPercent() < 50 && DruidSpellCombat < 11 && !m_bot->HasAura(INNERVATE, ObjectGuid::Empty))
+    {
+        ai->CastSpell(INNERVATE, *m_bot);
+        return;
+    }
+
+    DruidSpellCombat = 0;
+}
+
+void PlayerbotDruidAI::_DoNextPVECombatManeuverMeleeDPS(Unit* pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    // True, bear form is set up for tanking but even then it's better DPS for levels 10-19 than humanoid form
+    if (CAT_FORM == 0 && BEAR_FORM > 0)
+        // but only go there if you can get into bear form. else stay here.
+        if (ai->CastSpell(BEAR_FORM))
+            return _DoNextPVECombatManeuverBear(pTarget);
+
+    //uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->GetVictim();
+
+    if (!m_bot->HasInArc(M_PI, pTarget))
+    {
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+        if (pVictim)
+            pVictim->Attack(pTarget, true);
+    }
+
+    if (CAT_FORM > 0 && !m_bot->HasAura(CAT_FORM, ObjectGuid::Empty))
+        if (!ai->CastSpell(CAT_FORM))
+        {
+            if (ai->GetManaPercent() < 30) // TODO: tweak this value. Pretty sure bear form mana Req is way less than 30% of base mana, let alone total mana
+                return;  // conserve mana
+            else
+                _DoNextPVECombatManeuverSpellDPS(pTarget);
+        }
+
+    // Commented out: Above should take care of it
+    //// Technically bear form is better than no form for melee druids levels 10-19.
+    //if (m_bot->HasAura(BEAR_FORM, ObjectGuid::Empty))
+    //{
+    //    m_bot->RemoveAurasDueToSpell(BEAR_FORM_1);
+    //    //ai->TellMaster("FormClearBear");
+    //    return;
+    //}
+    //if (m_bot->HasAura(DIRE_BEAR_FORM, ObjectGuid::Empty))
+    //{
+    //    m_bot->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
+    //    //ai->TellMaster("FormClearDireBear");
+    //    return;
+    //}
+    //if (m_bot->HasAura(MOONKIN_FORM, ObjectGuid::Empty))
+    //{
+    //    m_bot->RemoveAurasDueToSpell(MOONKIN_FORM_1);
+    //    //ai->TellMaster("FormClearMoonkin");
+    //    return;
+    //}
+
+    //if (COWER > 0 && m_bot->GetComboPoints() == 1 && ai->GetEnergyAmount() >= 20) // && HasAnyAggroWhereSecondAggroIsNotHealer()
+    //{
+    //    ai->CastSpell(COWER);
+    //    //ai->TellMaster("Cower");
+    //}
+    if (MAIM > 0 && m_bot->GetComboPoints() >= 1 && pTarget->IsNonMeleeSpellCast(true))
+    {
+        ai->CastSpell(MAIM, *pTarget);
+        //ai->TellMaster("SpellPreventing Maim");
+        return;
+    }
+
+    if (RAKE > 0 && m_bot->GetComboPoints() < 1 && ai->GetEnergyAmount() >= 40) // should be replaced by a check for the bleed effect it causes (along with Combo != 5)
+    {
+        ai->CastSpell(RAKE, *pTarget);
+        //ai->TellMaster("Rake");
+        return;
+    }
+    if (MANGLE > 0 && m_bot->GetComboPoints() == 1 && ai->GetEnergyAmount() >= 45)
+    {
+        ai->CastSpell(MANGLE, *pTarget);
+        //ai->TellMaster("Mangle");
+        return;
+    }
+    if (CLAW > 0 && m_bot->GetComboPoints() < 5 && ai->GetEnergyAmount() >= 45)
+    {
+        ai->CastSpell(CLAW, *pTarget);
+        //ai->TellMaster("Claw");
+        return;
+    }
+
+    if (m_bot->GetComboPoints() == 5)
+    {
+        if (RIP > 0 && pTarget->getClass() == CLASS_ROGUE && ai->GetEnergyAmount() >= 30)
+            ai->CastSpell(RIP, *pTarget);
+        else if (FEROCIOUS_BITE > 0 && ai->GetEnergyAmount() >= 35 &&
+                 (pTarget->getClass() == CLASS_HUNTER || pTarget->getClass() == CLASS_WARRIOR ||
+                  pTarget->getClass() == CLASS_PALADIN || pTarget->getClass() == CLASS_DEATH_KNIGHT))
+            ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+        else if (ai->GetEnergyAmount() >= 35)
+        {
+            //ai->TellMaster("Else Maim, Ferocious Bite or Rip.");
+            // MAIM must be first check, best option against other classes
+            if (MAIM > 0)
+                ai->CastSpell(MAIM, *pTarget);
+            else if (FEROCIOUS_BITE > 0)
+                ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+            else if (RIP > 0) // Fair enough, only needs 30 energy... but that means 35 is plenty
+                ai->CastSpell(RIP, *pTarget);
+        }
+        return;
+    }
+}
+
+void PlayerbotDruidAI::_DoNextPVECombatManeuverHeal(Unit* /*pTarget*/)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    Player* m_bot = GetPlayerBot();
+    //Unit* pVictim = pTarget->GetVictim();
+
+    if (TREE_OF_LIFE > 0 && !m_bot->HasAura(TREE_OF_LIFE, ObjectGuid::Empty))
+        ai->CastSpell(TREE_OF_LIFE, *m_bot);
+
+    if (m_bot->HasAura(CAT_FORM, ObjectGuid::Empty))
+    {
+        m_bot->RemoveAurasDueToSpell(CAT_FORM_1);
+        //ai->TellMaster("FormClearCat");
+        return;
+    }
+    if (m_bot->HasAura(BEAR_FORM, ObjectGuid::Empty))
+    {
+        m_bot->RemoveAurasDueToSpell(BEAR_FORM_1);
+        //ai->TellMaster("FormClearBear");
+        return;
+    }
+    if (m_bot->HasAura(DIRE_BEAR_FORM, ObjectGuid::Empty))
+    {
+        m_bot->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
+        //ai->TellMaster("FormClearDireBear");
+        return;
+    }
+    // spellcasting form, but disables healing spells so it's got to go
+    if (m_bot->HasAura(MOONKIN_FORM, ObjectGuid::Empty))
+    {
+        m_bot->RemoveAurasDueToSpell(MOONKIN_FORM_1);
+        //ai->TellMaster("FormClearMoonkin");
+        return;
+    }
+
+    if (ai->GetHealthPercent() <= 60)
+    {
+        HealTarget(m_bot);
+        return;
+    }
+    if (masterHP <= 50)
+    {
+        HealTarget(GetMaster());
+        return;
+    }
+    // TODO: err... what about the other teammates?
+
+    DruidSpellCombat = 0;
+}
+
+void PlayerbotDruidAI::DoNonCombatActions()
+{
+    Player* m_bot = GetPlayerBot();
+    Player* master = GetMaster();
+    if (!m_bot || !master)
+        return;
+
+    PlayerbotAI* ai = GetAI();
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (!pItem && INNERVATE > 0 && !m_bot->HasAura(INNERVATE) && ai->GetManaPercent() <= 20 && ai->CastSpell(INNERVATE, *m_bot))
+        return;
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, ObjectGuid::Empty) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // buff and heal master's group
+    if (master->GetGroup())
+    {
+        // Buff master with group buff
+        if (!master->duel)
+            if (master->IsAlive() && GIFT_OF_THE_WILD && ai->HasSpellReagents(GIFT_OF_THE_WILD) && ai->Buff(GIFT_OF_THE_WILD, master))
+                return;
+
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() ||
+                tPlayer->GetMap() != m_bot->GetMap() || tPlayer->GetDistance(m_bot) > 30)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == GetMaster())
+                continue;
+
+            // Resurrect member if needed
+            if (!tPlayer->IsAlive())
+            {
+                if (ai->CastSpell(REVIVE, *tPlayer))
+                {
+                    std::string msg = "Resurrecting ";
+                    msg += tPlayer->GetName();
+                    m_bot->Say(msg, LANG_UNIVERSAL);
+                    return;
+                }
+                else
+                    continue;
+            }
+            else
+            {
+                // buff and heal
+                if (BuffPlayer(tPlayer))
+                    return;
+
+                if (HealTarget(tPlayer))
+                    return;
+            }
+        }
+    }
+    else
+    {
+        if (master->duel)
+            return;
+
+        if (master->IsAlive())
+        {
+            if (BuffPlayer(master))
+                return;
+            if (HealTarget(master))
+                return;
+        }
+        else
+        if (ai->CastSpell(REVIVE, *master))
+            ai->TellMaster("Resurrecting you, Master.");
+    }
+
+    BuffPlayer(m_bot);
+} // end DoNonCombatActions
+
+bool PlayerbotDruidAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+
+    Pet * pet = target->GetPet();
+    if (pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
+    {
+        if (ai->Buff(MARK_OF_THE_WILD, pet, &(PlayerbotDruidAI::GoBuffForm)))
+            return true;
+        else if (ai->Buff(THORNS, pet, &(PlayerbotDruidAI::GoBuffForm)))
+            return true;
+    }
+
+    if (ai->Buff(MARK_OF_THE_WILD, target, &(PlayerbotDruidAI::GoBuffForm)))
+        return true;
+    else if (ai->Buff(THORNS, target, &(PlayerbotDruidAI::GoBuffForm)))
+        return true;
+    else
+        return false;
+}
+
+void PlayerbotDruidAI::GoBuffForm(Player *self)
+{
+    // RANK_1 spell ids used because this is a static method which does not have access to instance.
+    // There is only one rank for these spells anyway.
+    if (self->HasAura(CAT_FORM_1))
+        self->RemoveAurasDueToSpell(CAT_FORM_1);
+    if (self->HasAura(BEAR_FORM_1))
+        self->RemoveAurasDueToSpell(BEAR_FORM_1);
+    if (self->HasAura(DIRE_BEAR_FORM_1))
+        self->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
+    if (self->HasAura(MOONKIN_FORM_1))
+        self->RemoveAurasDueToSpell(MOONKIN_FORM_1);
+    if (self->HasAura(TRAVEL_FORM_1))
+        self->RemoveAurasDueToSpell(TRAVEL_FORM_1);
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
new file mode 100644
index 0000000..45102b4
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
@@ -0,0 +1,199 @@
+#ifndef _PLAYERBOTDRUIDAI_H
+#define _PLAYERBOTDRUIDAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    DruidCombat,
+    DruidTank,
+    DruidHeal,
+    DruidSpell
+};
+
+enum DruidSpells
+{
+    ABOLISH_POISON_1                = 2893,
+    AQUATIC_FORM_1                  = 1066,
+    BARKSKIN_1                      = 22812,
+    BASH_1                          = 5211,
+    BEAR_FORM_1                     = 5487,
+    BERSERK_1                       = 50334,
+    CAT_FORM_1                      = 768,
+    CHALLENGING_ROAR_1              = 5209,
+    CLAW_1                          = 1082,
+    COWER_1                         = 8998,
+    CURE_POISON_1                   = 8946,
+    CYCLONE_1                       = 33786,
+    DASH_1                          = 1850,
+    DEMORALIZING_ROAR_1             = 99,
+    DIRE_BEAR_FORM_1                = 9634,
+    ENRAGE_1                        = 5229,
+    ENTANGLING_ROOTS_1              = 339,
+    FAERIE_FIRE_1                   = 770,
+    FAERIE_FIRE_FERAL_1             = 16857,
+    FERAL_CHARGE_1                  = 49377,
+    FERAL_CHARGE_BEAR_1             = 16979,
+    FERAL_CHARGE_CAT_1              = 49376,
+    FEROCIOUS_BITE_1                = 22568,
+    FLIGHT_FORM_1                   = 33943,
+    FORCE_OF_NATURE_1               = 33831,
+    FRENZIED_REGENERATION_1         = 22842,
+    GIFT_OF_THE_WILD_1              = 21849,
+    GROWL_1                         = 6795,
+    HEALING_TOUCH_1                 = 5185,
+    HIBERNATE_1                     = 2637,
+    HURRICANE_1                     = 16914,
+    INNERVATE_1                     = 29166,
+    INSECT_SWARM_1                  = 5570,
+    LACERATE_1                      = 33745,
+    LIFEBLOOM_1                     = 33763,
+    MAIM_1                          = 22570,
+    MANGLE_1                        = 33917,
+    MANGLE_BEAR_1                   = 33878,
+    MANGLE_CAT_1                    = 33876,
+    MARK_OF_THE_WILD_1              = 1126,
+    MAUL_1                          = 6807,
+    MOONFIRE_1                      = 8921,
+    MOONKIN_FORM_1                  = 24858,
+    NATURES_GRASP_1                 = 16689,
+    NATURES_SWIFTNESS_DRUID_1       = 17116,
+    NOURISH_1                       = 50464,
+    POUNCE_1                        = 9005,
+    PROWL_1                         = 5215,
+    RAKE_1                          = 1822,
+    RAVAGE_1                        = 6785,
+    REBIRTH_1                       = 20484,
+    REGROWTH_1                      = 8936,
+    REJUVENATION_1                  = 774,
+    REMOVE_CURSE_DRUID_1            = 2782,
+    REVIVE_1                        = 50769,
+    RIP_1                           = 1079,
+    SAVAGE_ROAR_1                   = 52610,
+    SHRED_1                         = 5221,
+    SOOTHE_ANIMAL_1                 = 2908,
+    STARFALL_1                      = 48505,
+    STARFIRE_1                      = 2912,
+    SURVIVAL_INSTINCTS_1            = 61336,
+    SWIFTMEND_1                     = 18562,
+    SWIFT_FLIGHT_FORM_1             = 40120,
+    SWIPE_BEAR_1                    = 779,
+    SWIPE_CAT_1                     = 62078,
+    THORNS_1                        = 467,
+    TIGERS_FURY_1                   = 5217,
+    TRANQUILITY_1                   = 740,
+    TRAVEL_FORM_1                   = 783,
+    TREE_OF_LIFE_1                  = 33891,
+    TYPHOON_1                       = 50516,
+    WILD_GROWTH_1                   = 48438,
+    WRATH_1                         = 5176
+};
+
+//class Player;
+
+class PlayerbotDruidAI : PlayerbotClassAI
+{
+public:
+    PlayerbotDruidAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotDruidAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // Combat Maneuver helper functions
+    void _DoNextPVECombatManeuverBear(Unit* pTarget);
+    void _DoNextPVECombatManeuverSpellDPS(Unit* pTarget);
+    void _DoNextPVECombatManeuverMeleeDPS(Unit* pTarget);
+    void _DoNextPVECombatManeuverHeal(Unit* pTarget);
+
+    // Heals the target based off its hps
+    bool HealTarget (Unit *target);
+    // Callback method to reset shapeshift forms blocking buffs and heals
+    static void GoBuffForm(Player *self);
+
+    // druid cat/bear/dire bear/moonkin/tree of life forms
+    uint32 CAT_FORM,
+           BEAR_FORM,
+           DIRE_BEAR_FORM,
+           MOONKIN_FORM,
+           TREE_OF_LIFE,
+           TRAVEL_FORM;
+
+    // druid cat attacks
+    uint32 CLAW,
+           COWER,
+           TIGERS_FURY,
+           RAKE,
+           RIP,
+           FEROCIOUS_BITE,
+           MAIM,
+           MANGLE;
+
+    // druid bear/dire bear attacks & buffs
+    uint32 BASH,
+           MAUL,
+           SWIPE,
+           DEMORALIZING_ROAR,
+           CHALLENGING_ROAR,
+           GROWL,
+           ENRAGE,
+           FAERIE_FIRE_FERAL;
+
+    // druid caster DPS attacks & debuffs
+    uint32 MOONFIRE,
+           ROOTS,
+           WRATH,
+           STARFALL,
+           STARFIRE,
+           INSECT_SWARM,
+           FAERIE_FIRE,
+           FORCE_OF_NATURE,
+           HURRICANE;
+
+    // druid buffs
+    uint32 MARK_OF_THE_WILD,
+           GIFT_OF_THE_WILD,
+           THORNS,
+           INNERVATE,
+           BARKSKIN;
+
+    // druid heals
+    uint32 LIFEBLOOM,
+           REJUVENATION,
+           REGROWTH,
+           NOURISH,
+           HEALING_TOUCH,
+           WILD_GROWTH,
+           SWIFTMEND,
+           TRANQUILITY,
+           REVIVE,
+           REMOVE_CURSE,
+           ABOLISH_POISON;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, DruidSpellCombat;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
new file mode 100644
index 0000000..d8992f6
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
@@ -0,0 +1,395 @@
+// an improved Hunter by rrtn & Runsttren :)
+#include "PlayerbotHunterAI.h"
+#include "Player.h"
+#include "Pet.h"
+
+PlayerbotHunterAI::PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // PET CTRL
+    PET_SUMMON                    = ai->initSpell(CALL_PET_1);
+    PET_DISMISS                   = ai->initSpell(DISMISS_PET_1);
+    PET_REVIVE                    = ai->initSpell(REVIVE_PET_1);
+    PET_MEND                      = ai->initSpell(MEND_PET_1);
+    PET_FEED                      = 1539;
+
+    INTIMIDATION                  = ai->initSpell(INTIMIDATION_1); // (generic)
+
+    // PET SKILLS must be initialized by pets
+    SONIC_BLAST                   = 0; // bat
+    DEMORALIZING_SCREECH          = 0;
+    BAD_ATTITUDE                  = 0; // crocolisk
+    NETHER_SHOCK                  = 0;
+
+    // RANGED COMBAT
+    AUTO_SHOT                     = ai->initSpell(AUTO_SHOT_1);
+    HUNTERS_MARK                  = ai->initSpell(HUNTERS_MARK_1);
+    ARCANE_SHOT                   = ai->initSpell(ARCANE_SHOT_1);
+    CONCUSSIVE_SHOT               = ai->initSpell(CONCUSSIVE_SHOT_1);
+    DISTRACTING_SHOT              = ai->initSpell(DISTRACTING_SHOT_1);
+    MULTI_SHOT                    = ai->initSpell(MULTISHOT_1);
+    EXPLOSIVE_SHOT                = ai->initSpell(EXPLOSIVE_SHOT_1);
+    SERPENT_STING                 = ai->initSpell(SERPENT_STING_1);
+    SCORPID_STING                 = ai->initSpell(SCORPID_STING_1);
+    WYVERN_STING                  = ai->initSpell(WYVERN_STING_1);
+    VIPER_STING                   = ai->initSpell(VIPER_STING_1);
+    AIMED_SHOT                    = ai->initSpell(AIMED_SHOT_1);
+    STEADY_SHOT                   = ai->initSpell(STEADY_SHOT_1);
+    CHIMERA_SHOT                  = ai->initSpell(CHIMERA_SHOT_1);
+    VOLLEY                        = ai->initSpell(VOLLEY_1);
+    BLACK_ARROW                   = ai->initSpell(BLACK_ARROW_1);
+    KILL_SHOT                     = ai->initSpell(KILL_SHOT_1);
+
+    // MELEE
+    RAPTOR_STRIKE                 = ai->initSpell(RAPTOR_STRIKE_1);
+    WING_CLIP                     = ai->initSpell(WING_CLIP_1);
+    MONGOOSE_BITE                 = ai->initSpell(MONGOOSE_BITE_1);
+    DISENGAGE                     = ai->initSpell(DISENGAGE_1);
+    MISDIRECTION                  = ai->initSpell(MISDIRECTION_1);
+    DETERRENCE                    = ai->initSpell(DETERRENCE_1);
+
+    // TRAPS
+    BEAR_TRAP                     = 0; // non-player spell
+    FREEZING_TRAP                 = ai->initSpell(FREEZING_TRAP_1);
+    IMMOLATION_TRAP               = ai->initSpell(IMMOLATION_TRAP_1);
+    FROST_TRAP                    = ai->initSpell(FROST_TRAP_1);
+    EXPLOSIVE_TRAP                = ai->initSpell(EXPLOSIVE_TRAP_1);
+    ARCANE_TRAP                   = 0; // non-player spell
+    SNAKE_TRAP                    = ai->initSpell(SNAKE_TRAP_1);
+
+    // BUFFS
+    ASPECT_OF_THE_HAWK            = ai->initSpell(ASPECT_OF_THE_HAWK_1);
+    ASPECT_OF_THE_MONKEY          = ai->initSpell(ASPECT_OF_THE_MONKEY_1);
+    RAPID_FIRE                    = ai->initSpell(RAPID_FIRE_1);
+    TRUESHOT_AURA                 = ai->initSpell(TRUESHOT_AURA_1);
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT                = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
+    GIFT_OF_THE_NAARU             = ai->initSpell(GIFT_OF_THE_NAARU_HUNTER); // draenei
+    STONEFORM                     = ai->initSpell(STONEFORM_ALL); // dwarf
+    SHADOWMELD                    = ai->initSpell(SHADOWMELD_ALL);
+    BLOOD_FURY                    = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    WAR_STOMP                     = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING                    = ai->initSpell(BERSERKING_ALL); // troll
+
+    m_petSummonFailed = false;
+    m_rangedCombat = true;
+}
+
+PlayerbotHunterAI::~PlayerbotHunterAI() {}
+
+bool PlayerbotHunterAI::DoFirstCombatManeuver(Unit* /*pTarget*/)
+{
+    return false;
+}
+
+void PlayerbotHunterAI::DoNextCombatManeuver(Unit* pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(RAPTOR_STRIKE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    // Hunter
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->GetVictim();
+
+    // check for pet and heal if neccessary
+    Pet *pet = m_bot->GetPet();
+    if ((pet)
+        && (((float) pet->GetHealth() / (float) pet->GetMaxHealth()) < 0.5f)
+        && (PET_MEND > 0 && !pet->getDeathState() != ALIVE && pVictim != m_bot && !pet->HasAura(PET_MEND, ObjectGuid::Empty) && ai->GetManaPercent() >= 13 && ai->CastSpell(PET_MEND, *m_bot)))
+    {
+        ai->TellMaster("healing pet.");
+        return;
+    }
+    else if ((pet)
+             && (INTIMIDATION > 0 && pVictim == pet && !pet->HasAura(INTIMIDATION, ObjectGuid::Empty) && ai->CastSpell(INTIMIDATION, *m_bot)))
+        //ai->TellMaster( "casting intimidation." ); // if pet has aggro :)
+        return;
+
+    // racial traits
+    if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, ObjectGuid::Empty))
+        ai->CastSpell(BLOOD_FURY, *m_bot);
+    //ai->TellMaster( "Blood Fury." );
+    else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, ObjectGuid::Empty))
+        ai->CastSpell(BERSERKING, *m_bot);
+    //ai->TellMaster( "Berserking." );
+
+    // check if ranged combat is possible (set m_rangedCombat and switch auras
+    float dist = GetCombatDistance(pTarget);
+    //bool useAmmo = m_bot->GetAuraEffectsByType(SPELL_AURA_ABILITY_CONSUME_NO_AMMO).empty();
+    if ((dist <= ATTACK_DISTANCE/* || (!m_bot->GetUInt32Value(PLAYER_AMMO_ID) && useAmmo)*/) && m_rangedCombat)
+    {
+        // switch to melee combat (target in melee range, out of ammo)
+        m_rangedCombat = false;
+        //if (!m_bot->GetUInt32Value(PLAYER_AMMO_ID))
+        //    ai->TellMaster("Out of ammo!");
+        // become monkey (increases dodge chance)...
+        (ASPECT_OF_THE_MONKEY > 0 && !m_bot->HasAura(ASPECT_OF_THE_MONKEY, ObjectGuid::Empty) && ai->CastSpell(ASPECT_OF_THE_MONKEY, *m_bot));
+    }
+    else if (dist > ATTACK_DISTANCE && !m_rangedCombat)
+    {
+        // switch to ranged combat
+        m_rangedCombat = true;
+        // increase ranged attack power...
+        (ASPECT_OF_THE_HAWK > 0 && !m_bot->HasAura(ASPECT_OF_THE_HAWK, ObjectGuid::Empty) && ai->CastSpell(ASPECT_OF_THE_HAWK, *m_bot));
+    }
+    else if (m_rangedCombat && !m_bot->HasAura(ASPECT_OF_THE_HAWK, ObjectGuid::Empty))
+        // check if we have hawk aspect in ranged combat
+        (ASPECT_OF_THE_HAWK > 0 && ai->CastSpell(ASPECT_OF_THE_HAWK, *m_bot));
+    else if (!m_rangedCombat && !m_bot->HasAura(ASPECT_OF_THE_MONKEY, ObjectGuid::Empty))
+        // check if we have monkey aspect in melee combat
+        (ASPECT_OF_THE_MONKEY > 0 && ai->CastSpell(ASPECT_OF_THE_MONKEY, *m_bot));
+
+    // activate auto shot
+    if (AUTO_SHOT > 0 && m_rangedCombat && !m_bot->FindCurrentSpellBySpellId(AUTO_SHOT))
+        ai->CastSpell(AUTO_SHOT, *pTarget);
+    //ai->TellMaster( "started auto shot." );
+    else if (AUTO_SHOT > 0 && m_bot->FindCurrentSpellBySpellId(AUTO_SHOT))
+        m_bot->InterruptNonMeleeSpells(true, AUTO_SHOT);
+    //ai->TellMaster( "stopped auto shot." );
+
+    // damage spells
+    std::ostringstream out;
+    if (m_rangedCombat)
+    {
+        out << "Case Ranged";
+        if (HUNTERS_MARK > 0 && ai->GetManaPercent() >= 3 && !pTarget->HasAura(HUNTERS_MARK, ObjectGuid::Empty) && ai->CastSpell(HUNTERS_MARK, *pTarget))
+            out << " > Hunter's Mark";
+        else if (RAPID_FIRE > 0 && ai->GetManaPercent() >= 3 && !m_bot->HasAura(RAPID_FIRE, ObjectGuid::Empty) && ai->CastSpell(RAPID_FIRE, *m_bot))
+            out << " > Rapid Fire";
+        else if (MULTI_SHOT > 0 && ai->GetManaPercent() >= 13 && ai->GetAttackerCount() >= 3 && ai->CastSpell(MULTI_SHOT, *pTarget))
+            out << " > Multi-Shot";
+        else if (ARCANE_SHOT > 0 && ai->GetManaPercent() >= 7 && ai->CastSpell(ARCANE_SHOT, *pTarget))
+            out << " > Arcane Shot";
+        else if (CONCUSSIVE_SHOT > 0 && ai->GetManaPercent() >= 6 && !pTarget->HasAura(CONCUSSIVE_SHOT, ObjectGuid::Empty) && ai->CastSpell(CONCUSSIVE_SHOT, *pTarget))
+            out << " > Concussive Shot";
+        else if (EXPLOSIVE_SHOT > 0 && ai->GetManaPercent() >= 10 && !pTarget->HasAura(EXPLOSIVE_SHOT, ObjectGuid::Empty) && ai->CastSpell(EXPLOSIVE_SHOT, *pTarget))
+            out << " > Explosive Shot";
+        else if (VIPER_STING > 0 && ai->GetManaPercent() >= 8 && pTarget->GetPower(POWER_MANA) > 0 && ai->GetManaPercent() < 70 && !pTarget->HasAura(VIPER_STING, ObjectGuid::Empty) && ai->CastSpell(VIPER_STING, *pTarget))
+            out << " > Viper Sting";
+        else if (SERPENT_STING > 0 && ai->GetManaPercent() >= 13 && !pTarget->HasAura(SERPENT_STING, ObjectGuid::Empty) && !pTarget->HasAura(SCORPID_STING, ObjectGuid::Empty) &&  !pTarget->HasAura(VIPER_STING, ObjectGuid::Empty) && ai->CastSpell(SERPENT_STING, *pTarget))
+            out << " > Serpent Sting";
+        else if (SCORPID_STING > 0 && ai->GetManaPercent() >= 11 && !pTarget->HasAura(WYVERN_STING, ObjectGuid::Empty) && !pTarget->HasAura(SCORPID_STING, ObjectGuid::Empty) && !pTarget->HasAura(SERPENT_STING, ObjectGuid::Empty) && !pTarget->HasAura(VIPER_STING, ObjectGuid::Empty) && ai->CastSpell(SCORPID_STING, *pTarget))
+            out << " > Scorpid Sting";
+        else if (CHIMERA_SHOT > 0 && ai->GetManaPercent() >= 12 && ai->CastSpell(CHIMERA_SHOT, *pTarget))
+            out << " > Chimera Shot";
+        else if (VOLLEY > 0 && ai->GetManaPercent() >= 24 && ai->GetAttackerCount() >= 3 && ai->CastSpell(VOLLEY, *pTarget))
+            out << " > Volley";
+        else if (BLACK_ARROW > 0 && ai->GetManaPercent() >= 6 && !pTarget->HasAura(BLACK_ARROW, ObjectGuid::Empty) && ai->CastSpell(BLACK_ARROW, *pTarget))
+            out << " > Black Arrow";
+        else if (AIMED_SHOT > 0 && ai->GetManaPercent() >= 12 && ai->CastSpell(AIMED_SHOT, *pTarget))
+            out << " > Aimed Shot";
+        else if (STEADY_SHOT > 0 && ai->GetManaPercent() >= 5 && ai->CastSpell(STEADY_SHOT, *pTarget))
+            out << " > Steady Shot";
+        else if (KILL_SHOT > 0 && ai->GetManaPercent() >= 7 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.2 && ai->CastSpell(KILL_SHOT, *pTarget))
+            out << " > Kill Shot!";
+        else
+            out << " NONE!";
+    }
+    else
+    {
+        out << "Case Melee";
+        if (RAPTOR_STRIKE > 0 && ai->GetManaPercent() >= 6 && ai->CastSpell(RAPTOR_STRIKE, *pTarget))
+            out << " > Raptor Strike";
+        else if (EXPLOSIVE_TRAP > 0 && ai->GetManaPercent() >= 27 && !pTarget->HasAura(EXPLOSIVE_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(ARCANE_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(IMMOLATION_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(FROST_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(BEAR_TRAP, ObjectGuid::Empty) && ai->CastSpell(EXPLOSIVE_TRAP, *pTarget))
+            out << " > Explosive Trap";
+        else if (WING_CLIP > 0 && ai->GetManaPercent() >= 6 && !pTarget->HasAura(WING_CLIP, ObjectGuid::Empty) && ai->CastSpell(WING_CLIP, *pTarget))
+            out << " > Wing Clip";
+        else if (IMMOLATION_TRAP > 0 && ai->GetManaPercent() >= 13 && !pTarget->HasAura(IMMOLATION_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(ARCANE_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(EXPLOSIVE_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(FROST_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(BEAR_TRAP, ObjectGuid::Empty) && ai->CastSpell(IMMOLATION_TRAP, *pTarget))
+            out << " > Immolation Trap";
+        else if (MONGOOSE_BITE > 0 && ai->GetManaPercent() >= 4 && ai->CastSpell(MONGOOSE_BITE, *pTarget))
+            out << " > Mongoose Bite";
+        else if (FROST_TRAP > 0 && ai->GetManaPercent() >= 2 && !pTarget->HasAura(FROST_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(ARCANE_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(IMMOLATION_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(EXPLOSIVE_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(BEAR_TRAP, ObjectGuid::Empty) && ai->CastSpell(FROST_TRAP, *pTarget))
+            out << " > Frost Trap";
+        else if (ARCANE_TRAP > 0 && !pTarget->HasAura(ARCANE_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(BEAR_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(EXPLOSIVE_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(IMMOLATION_TRAP, ObjectGuid::Empty) && !pTarget->HasAura(FROST_TRAP, ObjectGuid::Empty) && ai->CastSpell(ARCANE_TRAP, *pTarget))
+            out << " > Arcane Trap";
+        else if (DETERRENCE > 0 && pVictim == m_bot && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.5 && !m_bot->HasAura(DETERRENCE, ObjectGuid::Empty) && ai->CastSpell(DETERRENCE, *m_bot))
+            out << " > Deterrence";
+        else if (m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura(WAR_STOMP, ObjectGuid::Empty) && ai->CastSpell(WAR_STOMP, *pTarget))
+            out << " > War Stomp";
+        else if (m_bot->getRace() == RACE_BLOODELF && !pTarget->HasAura(ARCANE_TORRENT, ObjectGuid::Empty) && ai->CastSpell(ARCANE_TORRENT, *pTarget))
+            out << " > Arcane Torrent";
+        else if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && ai->CastSpell(STONEFORM, *m_bot))
+            out << " > Stoneform";
+        else if (m_bot->getRace() == RACE_NIGHTELF && pVictim == m_bot && ai->GetHealthPercent() < 25 && !m_bot->HasAura(SHADOWMELD, ObjectGuid::Empty) && ai->CastSpell(SHADOWMELD, *m_bot))
+            out << " > Shadowmeld";
+        else if (m_bot->getRace() == RACE_DRAENEI && ai->GetHealthPercent() < 25 && !m_bot->HasAura(GIFT_OF_THE_NAARU, ObjectGuid::Empty) && ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot))
+            out << " > Gift of the Naaru";
+        else if ((pet && !pet->getDeathState() != ALIVE)
+                 && (MISDIRECTION > 0 && pVictim == m_bot && !m_bot->HasAura(MISDIRECTION, ObjectGuid::Empty) && ai->GetManaPercent() >= 9 && ai->CastSpell(MISDIRECTION, *pet)))
+            out << " > Misdirection";  // give threat to pet
+        /*else if( FREEZING_TRAP>0 && ai->GetManaPercent()>=5 && !pTarget->HasAura(FREEZING_TRAP, 0) && !pTarget->HasAura(ARCANE_TRAP, 0) && !pTarget->HasAura(EXPLOSIVE_TRAP, 0) && !pTarget->HasAura(BEAR_TRAP, 0) && !pTarget->HasAura(IMMOLATION_TRAP, 0) && !pTarget->HasAura(FROST_TRAP, 0) && ai->CastSpell(FREEZING_TRAP,*pTarget) )
+            out << " > Freezing Trap"; // this can trap your bots too
+           else if( BEAR_TRAP>0 && !pTarget->HasAura(BEAR_TRAP, 0) && !pTarget->HasAura(ARCANE_TRAP, 0) && !pTarget->HasAura(EXPLOSIVE_TRAP, 0) && !pTarget->HasAura(IMMOLATION_TRAP, 0) && !pTarget->HasAura(FROST_TRAP, 0) && ai->CastSpell(BEAR_TRAP,*pTarget) )
+            out << " > Bear Trap"; // this was just too annoying :)
+           else if( DISENGAGE>0 && pVictim && ai->GetManaPercent()>=5 && ai->CastSpell(DISENGAGE,*pTarget) )
+            out << " > Disengage!"; // attempt to return to ranged combat*/
+        else
+            out << " NONE!";
+    }
+    if (ai->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+} // end DoNextCombatManeuver
+
+void PlayerbotHunterAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    if (!ai)
+        return;
+
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // reset ranged combat state
+    if (!m_rangedCombat)
+        m_rangedCombat = true;
+
+    // buff group
+    if (TRUESHOT_AURA > 0)
+        (!m_bot->HasAura(TRUESHOT_AURA, ObjectGuid::Empty) && ai->CastSpell (TRUESHOT_AURA, *m_bot));
+
+    // buff myself
+    if (ASPECT_OF_THE_HAWK > 0)
+        (!m_bot->HasAura(ASPECT_OF_THE_HAWK, ObjectGuid::Empty) && ai->CastSpell (ASPECT_OF_THE_HAWK, *m_bot));
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, ObjectGuid::Empty) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+    else if (pItem == NULL && fItem == NULL && m_bot->getRace() == RACE_DRAENEI && !m_bot->HasAura(GIFT_OF_THE_NAARU, ObjectGuid::Empty) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I'm casting gift of the naaru.");
+        ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot);
+        return;
+    }
+
+    // check for pet
+    if (PET_SUMMON > 0 && !m_petSummonFailed && m_bot->GetPetGUID())
+    {
+        // we can summon pet, and no critical summon errors before
+        Pet *pet = m_bot->GetPet();
+        if (!pet)
+        {
+            // summon pet
+            if (PET_SUMMON > 0 && ai->CastSpell(PET_SUMMON, *m_bot))
+                ai->TellMaster("summoning pet.");
+            else
+            {
+                m_petSummonFailed = true;
+                ai->TellMaster("summon pet failed!");
+            }
+        }
+        else if (pet->getDeathState() != ALIVE)
+        {
+            // revive pet
+            if (PET_REVIVE > 0 && ai->GetManaPercent() >= 80 && ai->CastSpell(PET_REVIVE, *m_bot))
+                ai->TellMaster("reviving pet.");
+        }
+        else if (((float) pet->GetHealth() / (float) pet->GetMaxHealth()) < 0.5f)
+        {
+            // heal pet when health lower 50%
+            if (PET_MEND > 0 && !pet->getDeathState() != ALIVE && !pet->HasAura(PET_MEND, ObjectGuid::Empty) && ai->GetManaPercent() >= 13 && ai->CastSpell(PET_MEND, *m_bot))
+                ai->TellMaster("healing pet.");
+        }
+        else if (pet->GetHappinessState() != HAPPY) // if pet is hungry
+        {
+            Unit *caster = (Unit *) m_bot;
+            // list out items in main backpack
+            for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+            {
+                Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                    {
+                        // DEBUG_LOG ("[PlayerbotHunterAI]: DoNonCombatActions - Food for pet: %s",pItemProto->Name1);
+                        caster->CastSpell(caster, 51284, true); // pet feed visual
+                        uint32 count = 1; // number of items used
+                        int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                        m_bot->DestroyItemCount(pItem, count, true); // remove item from inventory
+                        m_bot->CastCustomSpell(m_bot, PET_FEED, &benefit, NULL, NULL, true); // feed pet
+                        ai->TellMaster("feeding pet.");
+                        ai->SetIgnoreUpdateTime(10);
+                        return;
+                    }
+                }
+            }
+            // list out items in other removable backpacks
+            for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+            {
+                const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                if (pBag)
+                    for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                    {
+                        Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                        if (pItem)
+                        {
+                            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                            if (!pItemProto)
+                                continue;
+
+                            if (pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                            {
+                                // DEBUG_LOG ("[PlayerbotHunterAI]: DoNonCombatActions - Food for pet: %s",pItemProto->Name1);
+                                caster->CastSpell(caster, 51284, true); // pet feed visual
+                                uint32 count = 1; // number of items used
+                                int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                                m_bot->DestroyItemCount(pItem, count, true); // remove item from inventory
+                                m_bot->CastCustomSpell(m_bot, PET_FEED, &benefit, NULL, NULL, true); // feed pet
+                                ai->TellMaster("feeding pet.");
+                                ai->SetIgnoreUpdateTime(10);
+                                return;
+                            }
+                        }
+                    }
+            }
+            if (pet->HasAura(PET_MEND, ObjectGuid::Empty) && !pet->HasAura(PET_FEED, ObjectGuid::Empty))
+                ai->TellMaster("..no pet food!");
+            ai->SetIgnoreUpdateTime(7);
+        }
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
new file mode 100644
index 0000000..388d203
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
@@ -0,0 +1,121 @@
+#ifndef _PLAYERHUNTERAI_H
+#define _PLAYERHUNTERAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    SPELL_HUNTER
+};
+
+enum HunterSpells
+{
+    ARCANE_SHOT_1                   = 3044,
+    ASPECT_OF_THE_BEAST_1           = 13161,
+    ASPECT_OF_THE_CHEETAH_1         = 5118,
+    ASPECT_OF_THE_DRAGONHAWK_1      = 61846,
+    ASPECT_OF_THE_HAWK_1            = 13165,
+    ASPECT_OF_THE_MONKEY_1          = 13163,
+    ASPECT_OF_THE_PACK_1            = 13159,
+    ASPECT_OF_THE_VIPER_1           = 34074,
+    ASPECT_OF_THE_WILD_1            = 20043,
+    AUTO_SHOT_1                     = 75,
+    BEAST_LORE_1                    = 1462,
+    CALL_PET_1                      = 883,
+    CALL_STABLED_PET_1              = 62757,
+    CONCUSSIVE_SHOT_1               = 5116,
+    DETERRENCE_1                    = 19263,
+    DISENGAGE_1                     = 781,
+    DISMISS_PET_1                   = 2641,
+    DISTRACTING_SHOT_1              = 20736,
+    EAGLE_EYE_1                     = 6197,
+    EXPLOSIVE_TRAP_1                = 13813,
+    EYES_OF_THE_BEAST_1             = 1002,
+    FEED_PET_1                      = 6991,
+    FEIGN_DEATH_1                   = 5384,
+    FLARE_1                         = 1543,
+    FREEZING_ARROW_1                = 60192,
+    FREEZING_TRAP_1                 = 1499,
+    FROST_TRAP_1                    = 13809,
+    HUNTERS_MARK_1                  = 1130,
+    IMMOLATION_TRAP_1               = 13795,
+    KILL_COMMAND_1                  = 34026,
+    KILL_SHOT_1                     = 53351,
+    MASTERS_CALL_1                  = 53271,
+    MEND_PET_1                      = 136,
+    MISDIRECTION_1                  = 34477,
+    MONGOOSE_BITE_1                 = 1495,
+    MULTISHOT_1                     = 2643,
+    RAPID_FIRE_1                    = 3045,
+    RAPTOR_STRIKE_1                 = 2973,
+    REVIVE_PET_1                    = 982,
+    SCARE_BEAST_1                   = 1513,
+    SCORPID_STING_1                 = 3043,
+    SERPENT_STING_1                 = 1978,
+    SNAKE_TRAP_1                    = 34600,
+    STEADY_SHOT_1                   = 56641,
+    TAME_BEAST_1                    = 1515,
+    TRACK_BEASTS_1                  = 1494,
+    TRACK_DEMONS_1                  = 19878,
+    TRACK_DRAGONKIN_1               = 19879,
+    TRACK_ELEMENTALS_1              = 19880,
+    TRACK_GIANTS_1                  = 19882,
+    TRACK_HIDDEN_1                  = 19885,
+    TRACK_HUMANOIDS_1               = 19883,
+    TRACK_UNDEAD_1                  = 19884,
+    TRANQUILIZING_SHOT_1            = 19801,
+    VIPER_STING_1                   = 3034,
+    VOLLEY_1                        = 1510,
+    WING_CLIP_1                     = 2974,
+    AIMED_SHOT_1                    = 19434,
+    BESTIAL_WRATH_1                 = 19574,
+    BLACK_ARROW_1                   = 3674,
+    CHIMERA_SHOT_1                  = 53209,
+    COUNTERATTACK_1                 = 19306,
+    EXPLOSIVE_SHOT_1                = 53301,
+    INTIMIDATION_1                  = 19577,
+    READINESS_1                     = 23989,
+    SCATTER_SHOT_1                  = 19503,
+    SILENCING_SHOT_1                = 34490,
+    TRUESHOT_AURA_1                 = 19506,
+    WYVERN_STING_1                  = 19386
+};
+
+//class Player;
+
+class PlayerbotHunterAI : PlayerbotClassAI
+{
+public:
+    PlayerbotHunterAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotHunterAI();
+    bool HasPet(Player* bot);
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    //void BuffPlayer(Player *target);
+
+private:
+    // Hunter
+    bool m_petSummonFailed;
+    bool m_rangedCombat;
+
+    uint32 PET_SUMMON, PET_DISMISS, PET_REVIVE, PET_MEND, PET_FEED, BAD_ATTITUDE, SONIC_BLAST, NETHER_SHOCK, DEMORALIZING_SCREECH, INTIMIDATION;
+    uint32 AUTO_SHOT, HUNTERS_MARK, ARCANE_SHOT, CONCUSSIVE_SHOT, DISTRACTING_SHOT, MULTI_SHOT, EXPLOSIVE_SHOT, SERPENT_STING, SCORPID_STING, VIPER_STING, WYVERN_STING, AIMED_SHOT, STEADY_SHOT, CHIMERA_SHOT, VOLLEY, BLACK_ARROW, KILL_SHOT;
+    uint32 RAPTOR_STRIKE, WING_CLIP, MONGOOSE_BITE, DISENGAGE, DETERRENCE;
+    uint32 BEAR_TRAP, FREEZING_TRAP, IMMOLATION_TRAP, FROST_TRAP, EXPLOSIVE_TRAP, ARCANE_TRAP, SNAKE_TRAP;
+    uint32 ASPECT_OF_THE_HAWK, ASPECT_OF_THE_MONKEY, RAPID_FIRE, TRUESHOT_AURA, MISDIRECTION;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
new file mode 100644
index 0000000..65ebf57
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
@@ -0,0 +1,473 @@
+#include "PlayerbotMageAI.h"
+#include "ObjectAccessor.h"
+#include "Player.h"
+#include "Group.h"
+#include "Pet.h"
+
+PlayerbotMageAI::PlayerbotMageAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    ARCANE_MISSILES         = ai->initSpell(ARCANE_MISSILES_1);
+    ARCANE_EXPLOSION        = ai->initSpell(ARCANE_EXPLOSION_1);
+    COUNTERSPELL            = ai->initSpell(COUNTERSPELL_1);
+    SLOW                    = ai->initSpell(SLOW_1);
+    ARCANE_BARRAGE          = ai->initSpell(ARCANE_BARRAGE_1);
+    ARCANE_BLAST            = ai->initSpell(ARCANE_BLAST_1);
+    ARCANE_POWER            = ai->initSpell(ARCANE_POWER_1);
+    DAMPEN_MAGIC            = ai->initSpell(DAMPEN_MAGIC_1);
+    AMPLIFY_MAGIC           = ai->initSpell(AMPLIFY_MAGIC_1);
+    MAGE_ARMOR              = ai->initSpell(MAGE_ARMOR_1);
+    MIRROR_IMAGE            = ai->initSpell(MIRROR_IMAGE_1);
+    ARCANE_INTELLECT        = ai->initSpell(ARCANE_INTELLECT_1);
+    ARCANE_BRILLIANCE       = ai->initSpell(ARCANE_BRILLIANCE_1);
+    DALARAN_INTELLECT       = ai->initSpell(DALARAN_INTELLECT_1);
+    DALARAN_BRILLIANCE      = ai->initSpell(DALARAN_BRILLIANCE_1);
+    MANA_SHIELD             = ai->initSpell(MANA_SHIELD_1);
+    CONJURE_WATER           = ai->initSpell(CONJURE_WATER_1);
+    CONJURE_FOOD            = ai->initSpell(CONJURE_FOOD_1);
+    FIREBALL                = ai->initSpell(FIREBALL_1);
+    FIRE_BLAST              = ai->initSpell(FIRE_BLAST_1);
+    FLAMESTRIKE             = ai->initSpell(FLAMESTRIKE_1);
+    SCORCH                  = ai->initSpell(SCORCH_1);
+    PYROBLAST               = ai->initSpell(PYROBLAST_1);
+    BLAST_WAVE              = ai->initSpell(BLAST_WAVE_1);
+    COMBUSTION              = ai->initSpell(COMBUSTION_1);
+    DRAGONS_BREATH          = ai->initSpell(DRAGONS_BREATH_1);
+    LIVING_BOMB             = ai->initSpell(LIVING_BOMB_1);
+    FROSTFIRE_BOLT          = ai->initSpell(FROSTFIRE_BOLT_1);
+    FIRE_WARD               = ai->initSpell(FIRE_WARD_1);
+    MOLTEN_ARMOR            = ai->initSpell(MOLTEN_ARMOR_1);
+    ICY_VEINS               = ai->initSpell(ICY_VEINS_1);
+    DEEP_FREEZE             = ai->initSpell(DEEP_FREEZE_1);
+    FROSTBOLT               = ai->initSpell(FROSTBOLT_1);
+    FROST_NOVA              = ai->initSpell(FROST_NOVA_1);
+    BLIZZARD                = ai->initSpell(BLIZZARD_1);
+    CONE_OF_COLD            = ai->initSpell(CONE_OF_COLD_1);
+    ICE_BARRIER             = ai->initSpell(ICE_BARRIER_1);
+    SUMMON_WATER_ELEMENTAL  = ai->initSpell(SUMMON_WATER_ELEMENTAL_1);
+    FROST_WARD              = ai->initSpell(FROST_WARD_1);
+    ICE_LANCE               = ai->initSpell(ICE_LANCE_1);
+    FROST_ARMOR             = ai->initSpell(FROST_ARMOR_1);
+    ICE_ARMOR               = ai->initSpell(ICE_ARMOR_1);
+    ICE_BLOCK               = ai->initSpell(ICE_BLOCK_1);
+    COLD_SNAP               = ai->initSpell(COLD_SNAP_1);
+
+    RECENTLY_BANDAGED       = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT          = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES); // blood elf
+    GIFT_OF_THE_NAARU       = ai->initSpell(GIFT_OF_THE_NAARU_MAGE); // draenei
+    ESCAPE_ARTIST           = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    BERSERKING              = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN    = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotMageAI::~PlayerbotMageAI() {}
+
+bool PlayerbotMageAI::DoFirstCombatManeuver(Unit* /*pTarget*/)
+{
+    return false;
+}
+
+void PlayerbotMageAI::DoNextCombatManeuver(Unit* pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (FIREBALL > 0)
+                ai->CastSpell(FIREBALL);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    // Damage Spells (primitive example)
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->GetVictim();
+    float dist = GetCombatDistance(pTarget);
+
+    switch (SpellSequence)
+    {
+        case SPELL_FROST:
+            if (ICY_VEINS > 0 && !m_bot->HasAura(ICY_VEINS, ObjectGuid::Empty) && LastSpellFrost < 1 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(ICY_VEINS, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (FROSTBOLT > 0 && LastSpellFrost < 2 && !pTarget->HasAura(FROSTBOLT, ObjectGuid::Empty) && ai->GetManaPercent() >= 16)
+            {
+                ai->CastSpell(FROSTBOLT, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (FROST_WARD > 0 && LastSpellFrost < 3 && !m_bot->HasAura(FROST_WARD, ObjectGuid::Empty) && ai->GetManaPercent() >= 19)
+            {
+                ai->CastSpell(FROST_WARD, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (FROST_NOVA > 0 && LastSpellFrost < 4 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(FROST_NOVA, ObjectGuid::Empty) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FROST_NOVA, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (ICE_LANCE > 0 && LastSpellFrost < 5 && ai->GetManaPercent() >= 7)
+            {
+                ai->CastSpell(ICE_LANCE, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (BLIZZARD > 0 && LastSpellFrost < 6 && ai->GetAttackerCount() >= 5 && ai->GetManaPercent() >= 89)
+            {
+                ai->CastSpell(BLIZZARD, *pTarget);
+                ai->SetIgnoreUpdateTime(8);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (CONE_OF_COLD > 0 && LastSpellFrost < 7 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(CONE_OF_COLD, ObjectGuid::Empty) && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(CONE_OF_COLD, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (DEEP_FREEZE > 0 && LastSpellFrost < 8 && pTarget->HasAura(AURA_STATE_FROZEN, ObjectGuid::Empty) && !pTarget->HasAura(DEEP_FREEZE, ObjectGuid::Empty) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(DEEP_FREEZE, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (ICE_BARRIER > 0 && LastSpellFrost < 9 && pVictim == m_bot && !m_bot->HasAura(ICE_BARRIER, ObjectGuid::Empty) && ai->GetHealthPercent() < 50 && ai->GetManaPercent() >= 30)
+            {
+                ai->CastSpell(ICE_BARRIER, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (SUMMON_WATER_ELEMENTAL > 0 && LastSpellFrost < 10 && ai->GetManaPercent() >= 16)
+            {
+                ai->CastSpell(SUMMON_WATER_ELEMENTAL);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (ICE_BLOCK > 0 && LastSpellFrost < 11 && pVictim == m_bot && !m_bot->HasAura(ICE_BLOCK, ObjectGuid::Empty) && ai->GetHealthPercent() < 30)
+            {
+                ai->CastSpell(ICE_BLOCK, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (COLD_SNAP > 0 && LastSpellFrost < 12)
+            {
+                ai->CastSpell(COLD_SNAP, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            LastSpellFrost = 0;
+        //SpellSequence = SPELL_FIRE;
+        //break;
+
+        case SPELL_FIRE:
+            if (FIRE_WARD > 0 && !m_bot->HasAura(FIRE_WARD, ObjectGuid::Empty) && LastSpellFire < 1 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(FIRE_WARD, *m_bot);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (COMBUSTION > 0 && !m_bot->HasAura(COMBUSTION, ObjectGuid::Empty) && LastSpellFire < 2)
+            {
+                ai->CastSpell(COMBUSTION, *m_bot);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FIREBALL > 0 && LastSpellFire < 3 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FIREBALL, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FIRE_BLAST > 0 && LastSpellFire < 4 && ai->GetManaPercent() >= 25)
+            {
+                ai->CastSpell(FIRE_BLAST, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FLAMESTRIKE > 0 && LastSpellFire < 5 && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(FLAMESTRIKE, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (SCORCH > 0 && LastSpellFire < 6 && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(SCORCH, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (PYROBLAST > 0 && LastSpellFire < 7 && !pTarget->HasAura(PYROBLAST, ObjectGuid::Empty) && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(PYROBLAST, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (BLAST_WAVE > 0 && LastSpellFire < 8 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 34)
+            {
+                ai->CastSpell(BLAST_WAVE, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (DRAGONS_BREATH > 0 && LastSpellFire < 9 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(DRAGONS_BREATH, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (LIVING_BOMB > 0 && LastSpellFire < 10 && !pTarget->HasAura(LIVING_BOMB, ObjectGuid::Empty) && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(LIVING_BOMB, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FROSTFIRE_BOLT > 0 && LastSpellFire < 11 && !pTarget->HasAura(FROSTFIRE_BOLT, ObjectGuid::Empty) && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell(FROSTFIRE_BOLT, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            LastSpellFire = 0;
+        //SpellSequence = SPELL_ARCANE;
+        //break;
+
+        case SPELL_ARCANE:
+            if (ARCANE_POWER > 0 && LastSpellArcane < 1 && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(ARCANE_POWER, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_MISSILES > 0 && LastSpellArcane < 2 && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(ARCANE_MISSILES, *pTarget);
+                ai->SetIgnoreUpdateTime(3);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_EXPLOSION > 0 && LastSpellArcane < 3 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(ARCANE_EXPLOSION, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (COUNTERSPELL > 0 && pTarget->IsNonMeleeSpellCast(true) && LastSpellArcane < 4 && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(COUNTERSPELL, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (SLOW > 0 && LastSpellArcane < 5 && !pTarget->HasAura(SLOW, ObjectGuid::Empty) && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell(SLOW, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_BARRAGE > 0 && LastSpellArcane < 6 && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(ARCANE_BARRAGE, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_BLAST > 0 && LastSpellArcane < 7 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(ARCANE_BLAST, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (MIRROR_IMAGE > 0 && LastSpellArcane < 8 && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(MIRROR_IMAGE);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (MANA_SHIELD > 0 && LastSpellArcane < 9 && ai->GetHealthPercent() < 70 && pVictim == m_bot && !m_bot->HasAura(MANA_SHIELD, ObjectGuid::Empty) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(MANA_SHIELD, *m_bot);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else
+            {
+                LastSpellArcane = 0;
+                SpellSequence = SPELL_FROST;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotMageAI::DoNonCombatActions()
+{
+    Player * m_bot = GetPlayerBot();
+    Player * master = GetMaster();
+
+    if (!m_bot || !master)
+        return;
+
+    SpellSequence = SPELL_FROST;
+    PlayerbotAI* ai = GetAI();
+
+    // Buff armor
+    if (MOLTEN_ARMOR)
+    {
+        if (ai->SelfBuff(MOLTEN_ARMOR))
+            return;
+    }
+    else if (MAGE_ARMOR)
+    {
+        if (ai->SelfBuff(MAGE_ARMOR))
+            return;
+    }
+    else if (ICE_ARMOR)
+    {
+        if (ai->SelfBuff(ICE_ARMOR))
+            return;
+    }
+    else if (FROST_ARMOR)
+        if (ai->SelfBuff(FROST_ARMOR))
+            return;
+
+    // buff master's group
+    if (master->GetGroup())
+    {
+        // Buff master with group buff...
+        if (!(master->duel && master->duel->initiator == master && master->duel->startTime != 0))
+            if (ARCANE_BRILLIANCE && master->getPowerType() == POWER_MANA && ai->HasSpellReagents(ARCANE_BRILLIANCE))
+                if (ai->Buff(ARCANE_BRILLIANCE, master))
+                    return;
+
+        // ...and check group for new members joined or resurrected, or just buff everyone if no group buff available
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() ||
+                tPlayer->GetMap() != m_bot->GetMap() || tPlayer->GetDistance(m_bot) > 30)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == master && tPlayer->duel->startTime != 0)
+                continue;
+
+            if (tPlayer->getPowerType() != POWER_MANA)
+                continue;
+
+            // buff
+            if (BuffPlayer(tPlayer))
+                return;
+        }
+
+    }
+    // There is no group, buff master
+    else if (master->IsAlive() && !(master->duel && master->duel->initiator == master && master->duel->startTime != 0))
+        if (BuffPlayer(master))
+            return;
+
+    // Buff self finally
+    if (BuffPlayer(m_bot))
+        return;
+
+    // conjure food & water
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem == NULL && CONJURE_WATER && ai->GetBaseManaPercent() >= 48)
+    {
+        ai->TellMaster("I'm conjuring some water.");
+        ai->CastSpell(CONJURE_WATER, *m_bot);
+        ai->SetIgnoreUpdateTime(3);
+        return;
+    }
+    else if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    pItem = ai->FindFood();
+
+    if (pItem == NULL && CONJURE_FOOD && ai->GetBaseManaPercent() >= 48)
+    {
+        ai->TellMaster("I'm conjuring some food.");
+        ai->CastSpell(CONJURE_FOOD, *m_bot);
+        ai->SetIgnoreUpdateTime(3);
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, ObjectGuid::Empty) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+} // end DoNonCombatActions
+
+bool PlayerbotMageAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+    Pet * pet = target->GetPet();
+
+    if ((pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE)) && pet->getPowerType() == POWER_MANA && ai->Buff(ARCANE_INTELLECT, pet))
+        return true;
+
+    if (ARCANE_INTELLECT)
+        return ai->Buff(ARCANE_INTELLECT, target);
+    else
+        return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotMageAI.h b/src/server/game/AI/PlayerBots/PlayerbotMageAI.h
new file mode 100644
index 0000000..c618473
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotMageAI.h
@@ -0,0 +1,163 @@
+#ifndef _PlayerbotMageAI_H
+#define _PlayerbotMageAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    SPELL_FROST,
+    SPELL_FIRE,
+    SPELL_ARCANE
+};
+
+enum MageSpells
+{
+    AMPLIFY_MAGIC_1                 = 1008,
+    ARCANE_BARRAGE_1                = 44425,
+    ARCANE_BLAST_1                  = 30451,
+    ARCANE_BRILLIANCE_1             = 23028,
+    ARCANE_EXPLOSION_1              = 1449,
+    ARCANE_INTELLECT_1              = 1459,
+    ARCANE_MISSILES_1               = 5143,
+    ARCANE_POWER_1                  = 12042,
+    BLAST_WAVE_1                    = 11113,
+    BLINK_1                         = 1953,
+    BLIZZARD_1                      = 10,
+    COLD_SNAP_1                     = 11958,
+    COMBUSTION_1                    = 11129,
+    CONE_OF_COLD_1                  = 120,
+    CONJURE_FOOD_1                  = 587,
+    CONJURE_MANA_GEM_1              = 759,
+    CONJURE_REFRESHMENT_1           = 42955,
+    CONJURE_WATER_1                 = 5504,
+    COUNTERSPELL_1                  = 2139,
+    DALARAN_BRILLIANCE_1            = 61316,
+    DALARAN_INTELLECT_1             = 61024,
+    DAMPEN_MAGIC_1                  = 604,
+    DEEP_FREEZE_1                   = 44572,
+    DRAGONS_BREATH_1                = 31661,
+    EVOCATION_1                     = 12051,
+    FIRE_BLAST_1                    = 2136,
+    FIRE_WARD_1                     = 543,
+    FIREBALL_1                      = 133,
+    FLAMESTRIKE_1                   = 2120,
+    FOCUS_MAGIC_1                   = 54646,
+    FROST_ARMOR_1                   = 168,
+    FROST_NOVA_1                    = 122,
+    FROST_WARD_1                    = 6143,
+    FROSTBOLT_1                     = 116,
+    FROSTFIRE_BOLT_1                = 44614,
+    ICE_ARMOR_1                     = 7302,
+    ICE_BARRIER_1                   = 11426,
+    ICE_BLOCK_1                     = 45438,
+    ICE_LANCE_1                     = 30455,
+    ICY_VEINS_1                     = 12472,
+    INVISIBILITY_1                  = 66,
+    LIVING_BOMB_1                   = 44457,
+    MAGE_ARMOR_1                    = 6117,
+    MANA_SHIELD_1                   = 1463,
+    MIRROR_IMAGE_1                  = 55342,
+    MOLTEN_ARMOR_1                  = 30482,
+    PRESENCE_OF_MIND_1              = 12043,
+    PYROBLAST_1                     = 11366,
+    REMOVE_CURSE_MAGE_1             = 475,
+    RITUAL_OF_REFRESHMENT_1         = 43987,
+    SCORCH_1                        = 2948,
+    SLOW_1                          = 31589,
+    SLOW_FALL_1                     = 130,
+    SPELLSTEAL_1                    = 30449,
+    SUMMON_WATER_ELEMENTAL_1        = 31687
+};
+//class Player;
+
+class PlayerbotMageAI : PlayerbotClassAI
+{
+public:
+    PlayerbotMageAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotMageAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // ARCANE
+    uint32 ARCANE_MISSILES,
+           ARCANE_EXPLOSION,
+           COUNTERSPELL,
+           SLOW,
+           ARCANE_BARRAGE,
+           ARCANE_BLAST,
+           MIRROR_IMAGE,
+           ARCANE_POWER;
+
+    // FIRE
+    uint32 FIREBALL,
+           FIRE_BLAST,
+           FLAMESTRIKE,
+           SCORCH,
+           PYROBLAST,
+           BLAST_WAVE,
+           COMBUSTION,
+           DRAGONS_BREATH,
+           LIVING_BOMB,
+           FROSTFIRE_BOLT,
+           FIRE_WARD;
+
+    // FROST
+    uint32 DEEP_FREEZE,
+           FROSTBOLT,
+           FROST_NOVA,
+           BLIZZARD,
+           ICY_VEINS,
+           CONE_OF_COLD,
+           ICE_BARRIER,
+           SUMMON_WATER_ELEMENTAL,
+           ICE_LANCE,
+           FROST_WARD,
+           ICE_BLOCK,
+           COLD_SNAP;
+
+    // buffs
+    uint32 FROST_ARMOR,
+           ICE_ARMOR,
+           MAGE_ARMOR,
+           MOLTEN_ARMOR,
+           ARCANE_INTELLECT,
+           ARCANE_BRILLIANCE,
+           DALARAN_INTELLECT,
+           DALARAN_BRILLIANCE,
+           MANA_SHIELD,
+           DAMPEN_MAGIC,
+           AMPLIFY_MAGIC;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence,
+           LastSpellArcane,
+           LastSpellFire,
+           LastSpellFrost,
+           CONJURE_WATER,
+           CONJURE_FOOD;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
new file mode 100644
index 0000000..9d32fff
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
@@ -0,0 +1,619 @@
+/*
+   Name    : PlayerbotPaladinAI.cpp
+   Complete: maybe around 27% :D
+   Author  : Natsukawa
+   Version : 0.35
+ */
+#include "PlayerbotPaladinAI.h"
+#include "ObjectAccessor.h"
+#include "SpellAuras.h"
+#include "Player.h"
+#include "Group.h"
+#include "Pet.h"
+
+PlayerbotPaladinAI::PlayerbotPaladinAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    RETRIBUTION_AURA              = ai->initSpell(RETRIBUTION_AURA_1);
+    CRUSADER_AURA                 = ai->initSpell(CRUSADER_AURA_1);
+    CRUSADER_STRIKE               = ai->initSpell(CRUSADER_STRIKE_1);
+    SEAL_OF_COMMAND               = ai->initSpell(SEAL_OF_COMMAND_1);
+    SEAL_OF_RIGHTEOUSNESS         = ai->initSpell(SEAL_OF_RIGHTEOUSNESS_1);
+    SEAL_OF_CORRUPTION            = ai->initSpell(SEAL_OF_CORRUPTION_1);
+    SEAL_OF_JUSTICE               = ai->initSpell(SEAL_OF_JUSTICE_1);
+    SEAL_OF_LIGHT                 = ai->initSpell(SEAL_OF_LIGHT_1);
+    SEAL_OF_VENGEANCE             = ai->initSpell(SEAL_OF_VENGEANCE_1);
+    SEAL_OF_WISDOM                = ai->initSpell(SEAL_OF_WISDOM_1);
+    JUDGEMENT_OF_LIGHT            = ai->initSpell(JUDGEMENT_OF_LIGHT_1);
+    JUDGEMENT_OF_WISDOM           = ai->initSpell(JUDGEMENT_OF_WISDOM_1);
+    JUDGEMENT_OF_JUSTICE          = ai->initSpell(JUDGEMENT_OF_JUSTICE_1);
+    DIVINE_STORM                  = ai->initSpell(DIVINE_STORM_1);
+    BLESSING_OF_MIGHT             = ai->initSpell(BLESSING_OF_MIGHT_1);
+    GREATER_BLESSING_OF_MIGHT     = ai->initSpell(GREATER_BLESSING_OF_MIGHT_1);
+    HAMMER_OF_WRATH               = ai->initSpell(HAMMER_OF_WRATH_1);
+    FLASH_OF_LIGHT                = ai->initSpell(FLASH_OF_LIGHT_1); // Holy
+    HOLY_LIGHT                    = ai->initSpell(HOLY_LIGHT_1);
+    HOLY_SHOCK                    = ai->initSpell(HOLY_SHOCK_1);
+    HOLY_WRATH                    = ai->initSpell(HOLY_WRATH_1);
+    DIVINE_FAVOR                  = ai->initSpell(DIVINE_FAVOR_1);
+    CONCENTRATION_AURA            = ai->initSpell(CONCENTRATION_AURA_1);
+    BLESSING_OF_WISDOM            = ai->initSpell(BLESSING_OF_WISDOM_1);
+    GREATER_BLESSING_OF_WISDOM    = ai->initSpell(GREATER_BLESSING_OF_WISDOM_1);
+    CONSECRATION                  = ai->initSpell(CONSECRATION_1);
+    AVENGING_WRATH                = ai->initSpell(AVENGING_WRATH_1);
+    LAY_ON_HANDS                  = ai->initSpell(LAY_ON_HANDS_1);
+    EXORCISM                      = ai->initSpell(EXORCISM_1);
+    SACRED_SHIELD                 = ai->initSpell(SACRED_SHIELD_1);
+    DIVINE_PLEA                   = ai->initSpell(DIVINE_PLEA_1);
+    BLESSING_OF_KINGS             = ai->initSpell(BLESSING_OF_KINGS_1);
+    GREATER_BLESSING_OF_KINGS     = ai->initSpell(GREATER_BLESSING_OF_KINGS_1);
+    BLESSING_OF_SANCTUARY         = ai->initSpell(BLESSING_OF_SANCTUARY_1);
+    GREATER_BLESSING_OF_SANCTUARY = ai->initSpell(GREATER_BLESSING_OF_SANCTUARY_1);
+    HAMMER_OF_JUSTICE             = ai->initSpell(HAMMER_OF_JUSTICE_1);
+    RIGHTEOUS_FURY                = ai->initSpell(RIGHTEOUS_FURY_1);
+    RIGHTEOUS_DEFENSE             = ai->initSpell(RIGHTEOUS_DEFENSE_1);
+    SHADOW_RESISTANCE_AURA        = ai->initSpell(SHADOW_RESISTANCE_AURA_1);
+    DEVOTION_AURA                 = ai->initSpell(DEVOTION_AURA_1);
+    FIRE_RESISTANCE_AURA          = ai->initSpell(FIRE_RESISTANCE_AURA_1);
+    FROST_RESISTANCE_AURA         = ai->initSpell(FROST_RESISTANCE_AURA_1);
+    HAND_OF_PROTECTION            = ai->initSpell(HAND_OF_PROTECTION_1);
+    DIVINE_PROTECTION             = ai->initSpell(DIVINE_PROTECTION_1);
+    DIVINE_INTERVENTION           = ai->initSpell(DIVINE_INTERVENTION_1);
+    DIVINE_SACRIFICE              = ai->initSpell(DIVINE_SACRIFICE_1);
+    DIVINE_SHIELD                 = ai->initSpell(DIVINE_SHIELD_1);
+    HOLY_SHIELD                   = ai->initSpell(HOLY_SHIELD_1);
+    AVENGERS_SHIELD               = ai->initSpell(AVENGERS_SHIELD_1);
+    HAND_OF_SACRIFICE             = ai->initSpell(HAND_OF_SACRIFICE_1);
+    SHIELD_OF_RIGHTEOUSNESS       = ai->initSpell(SHIELD_OF_RIGHTEOUSNESS_1);
+    REDEMPTION                    = ai->initSpell(REDEMPTION_1);
+    PURIFY                        = ai->initSpell(PURIFY_1);
+    CLEANSE                       = ai->initSpell(CLEANSE_1);
+
+    // Warrior auras
+    DEFENSIVE_STANCE              = 71;   //Def Stance
+    BERSERKER_STANCE              = 2458; //Ber Stance
+    BATTLE_STANCE                 = 2457; //Bat Stance
+
+    FORBEARANCE                   = 25771; // cannot be protected
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT                = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
+    GIFT_OF_THE_NAARU             = ai->initSpell(GIFT_OF_THE_NAARU_PALADIN); // draenei
+    STONEFORM                     = ai->initSpell(STONEFORM_ALL); // dwarf
+    EVERY_MAN_FOR_HIMSELF         = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+}
+
+PlayerbotPaladinAI::~PlayerbotPaladinAI() {}
+
+bool PlayerbotPaladinAI::DoFirstCombatManeuver(Unit* /*pTarget*/)
+{
+    return false;
+}
+
+bool PlayerbotPaladinAI::HealTarget(Unit* target)
+{
+    PlayerbotAI* ai = GetAI();
+    uint8 hp = target->GetHealth() * 100 / target->GetMaxHealth();
+
+    if (hp < 25 && ai->CastSpell(LAY_ON_HANDS, *target))
+        return true;
+
+    if (hp < 30 && ai->CastSpell(FLASH_OF_LIGHT, *target))
+        return true;
+
+    if (hp < 35 && ai->CastSpell(HOLY_SHOCK, *target))
+        return true;
+
+    if (hp < 40 && ai->CastSpell(HOLY_LIGHT, *target))
+        return true;
+
+    if (PURIFY > 0 && ai->GetCombatOrder() != PlayerbotAI::ORDERS_NODISPEL)
+    {
+        uint32 DISPEL = CLEANSE > 0 ? CLEANSE : PURIFY;
+        Unit::AuraMap const& auras = target->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura *aura = itr->second;
+            if (aura->IsPassive()) continue;
+            const SpellInfo* spellInfo = aura->GetSpellInfo();
+            if (spellInfo->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+            if (aura->GetId() == 64844 || //Divine Hymn
+                aura->GetId() == 6346) // Fear Ward
+                continue;
+            DispelType dispel = DispelType(spellInfo->Dispel);
+            if (dispel == DISPEL_POISON ||
+                dispel == DISPEL_DISEASE ||
+                (DISPEL == CLEANSE && dispel == DISPEL_MAGIC))
+            {
+                AuraApplication *aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+                if (!aurApp)
+                    continue;
+                if (!aurApp->IsPositive())
+                    if (ai->CastSpell(DISPEL, *target))//additional check for cd
+                        return true;
+            }
+        }
+    }
+
+    return false;
+} // end HealTarget
+
+void PlayerbotPaladinAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    Unit* pVictim = pTarget->GetVictim();
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (HAMMER_OF_JUSTICE > 0)
+                ai->CastSpell(HAMMER_OF_JUSTICE);
+            return;
+    }
+
+    // damage spells
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+    float dist = GetCombatDistance(pTarget);
+    std::ostringstream out;
+
+    //Shield master if low hp.
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    if (GetMaster()->IsAlive())
+        if (masterHP < 25 && HAND_OF_PROTECTION > 0 && !GetMaster()->HasAura(FORBEARANCE, ObjectGuid::Empty) && !GetMaster()->HasAura(HAND_OF_PROTECTION, ObjectGuid::Empty) && !GetMaster()->HasAura(DIVINE_PROTECTION, ObjectGuid::Empty) && !GetMaster()->HasAura(DIVINE_SHIELD, ObjectGuid::Empty))
+            ai->CastSpell(HAND_OF_PROTECTION, *GetMaster());
+
+    // heal group inside combat, but do not heal if tank
+    if (m_group && pVictim != m_bot)  // possible tank
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = ObjectAccessor::FindPlayer(itr->guid);
+            if (!m_groupMember || !m_groupMember->IsAlive())
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth() * 100 / m_groupMember->GetMaxHealth();
+            if (memberHP < 40 && ai->GetManaPercent() >= 40)  // do not heal bots without plenty of mana for master & self
+                if (HealTarget(m_groupMember))
+                    return;
+        }
+    }
+
+    if (RIGHTEOUS_FURY > 0 && !m_bot->HasAura(RIGHTEOUS_FURY, ObjectGuid::Empty) && ai->GetCombatOrder() == PlayerbotAI::ORDERS_TANK)
+        ai->CastSpell (RIGHTEOUS_FURY, *m_bot);
+
+    if (SHADOW_RESISTANCE_AURA > 0 && !m_bot->HasAura(SHADOW_RESISTANCE_AURA, ObjectGuid::Empty) && pTarget->getClass() == CLASS_WARLOCK)
+        ai->CastSpell (SHADOW_RESISTANCE_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, ObjectGuid::Empty) && pTarget->getClass() == CLASS_WARRIOR)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (FIRE_RESISTANCE_AURA > 0 && !m_bot->HasAura(FIRE_RESISTANCE_AURA, ObjectGuid::Empty) && pTarget->getClass() == CLASS_MAGE)
+        ai->CastSpell (FIRE_RESISTANCE_AURA, *m_bot);
+
+    if (RETRIBUTION_AURA > 0 && !m_bot->HasAura(RETRIBUTION_AURA, ObjectGuid::Empty) && pTarget->getClass() == CLASS_PRIEST)
+        ai->CastSpell (RETRIBUTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, ObjectGuid::Empty) && pTarget->getClass() == CLASS_SHAMAN)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, ObjectGuid::Empty) && pTarget->getClass() == CLASS_ROGUE)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, ObjectGuid::Empty) && pTarget->getClass() == CLASS_PALADIN)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (ai->GetHealthPercent() <= 40 || GetMaster()->GetHealth() <= GetMaster()->GetMaxHealth() * 0.4)
+        SpellSequence = Healing;
+    else
+        SpellSequence = Combat;
+
+    switch (SpellSequence)
+    {
+        case Combat:
+            if (JUDGEMENT_OF_LIGHT > 0 && !pTarget->HasAura(JUDGEMENT_OF_LIGHT, ObjectGuid::Empty) && CombatCounter < 1 && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell (JUDGEMENT_OF_LIGHT, *pTarget);
+                out << " Judgement of Light";
+                CombatCounter++;
+                break;
+            }
+            else if (SEAL_OF_COMMAND > 0 && !m_bot->HasAura(SEAL_OF_COMMAND, ObjectGuid::Empty) && CombatCounter < 2 && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell (SEAL_OF_COMMAND, *m_bot);
+                out << " Seal of Command";
+                CombatCounter++;
+                break;
+            }
+            else if (HAMMER_OF_JUSTICE > 0 && !pTarget->HasAura(HAMMER_OF_JUSTICE, ObjectGuid::Empty) && CombatCounter < 3 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell (HAMMER_OF_JUSTICE, *pTarget);
+                out << " Hammer of Justice";
+                CombatCounter++;
+                break;
+            }
+            else if (CRUSADER_STRIKE > 0 && CombatCounter < 4 && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell (CRUSADER_STRIKE, *pTarget);
+                out << " Crusader Strike";
+                CombatCounter++;
+                break;
+            }
+            else if (AVENGING_WRATH > 0 && CombatCounter < 5 && !m_bot->HasAura(AVENGING_WRATH, ObjectGuid::Empty) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell (AVENGING_WRATH, *m_bot);
+                out << " Avenging Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (SACRED_SHIELD > 0 && CombatCounter < 6 && pVictim == m_bot && ai->GetHealthPercent() < 70 && !m_bot->HasAura(SACRED_SHIELD, ObjectGuid::Empty) && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell (SACRED_SHIELD, *m_bot);
+                out << " Sacred Shield";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_STORM > 0 && CombatCounter < 7 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell (DIVINE_STORM, *pTarget);
+                out << " Divine Storm";
+                CombatCounter++;
+                break;
+            }
+            else if (HAMMER_OF_WRATH > 0 && CombatCounter < 8 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.20 && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell (HAMMER_OF_WRATH, *pTarget);
+                out << " Hammer of Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (HOLY_WRATH > 0 && CombatCounter < 9 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 24)
+            {
+                ai->CastSpell (HOLY_WRATH, *pTarget);
+                out << " Holy Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (HAND_OF_SACRIFICE > 0 && pVictim == GetMaster() && !GetMaster()->HasAura(HAND_OF_SACRIFICE, ObjectGuid::Empty) && CombatCounter < 10 && ai->GetManaPercent() >= 6)
+            {
+                ai->CastSpell (HAND_OF_SACRIFICE, *GetMaster());
+                out << " Hand of Sacrifice";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_PROTECTION > 0 && pVictim == m_bot && !m_bot->HasAura(FORBEARANCE, ObjectGuid::Empty) && ai->GetHealthPercent() < 30 && CombatCounter < 11 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell (DIVINE_PROTECTION, *m_bot);
+                out << " Divine Protection";
+                CombatCounter++;
+                break;
+            }
+            else if (RIGHTEOUS_DEFENSE > 0 && pVictim != m_bot && ai->GetHealthPercent() > 70 && CombatCounter < 12)
+            {
+                ai->CastSpell (RIGHTEOUS_DEFENSE, *pTarget);
+                out << " Righteous Defense";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_PLEA > 0 && !m_bot->HasAura(DIVINE_PLEA, ObjectGuid::Empty) && ai->GetManaPercent() < 50 && CombatCounter < 13)
+            {
+                ai->CastSpell (DIVINE_PLEA, *m_bot);
+                out << " Divine Plea";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_FAVOR > 0 && !m_bot->HasAura(DIVINE_FAVOR, ObjectGuid::Empty) && CombatCounter < 14)
+            {
+                ai->CastSpell (DIVINE_FAVOR, *m_bot);
+                out << " Divine Favor";
+                CombatCounter++;
+                break;
+            }
+            else if (CombatCounter > 15)
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("CombatCounter Reset");
+                break;
+            }
+            else
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("Counter = 0");
+                break;
+            }
+
+        case Healing:
+            if (ai->GetHealthPercent() <= 40)
+            {
+                HealTarget (m_bot);
+                out << " ...healing bot";
+                break;
+            }
+            if (masterHP <= 40)
+            {
+                HealTarget (GetMaster());
+                out << " ...healing master";
+                break;
+            }
+            else
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("Counter = 0");
+                break;
+            }
+    }
+    if (ai->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+
+    if (AVENGING_WRATH > 0 && !m_bot->HasAura(AVENGING_WRATH, ObjectGuid::Empty) && ai->GetManaPercent() >= 8)
+        ai->CastSpell(AVENGING_WRATH, *m_bot);
+
+    if (DIVINE_SHIELD > 0 && ai->GetHealthPercent() < 30 && pVictim == m_bot && !m_bot->HasAura(FORBEARANCE, ObjectGuid::Empty) && !m_bot->HasAura(DIVINE_SHIELD, ObjectGuid::Empty) && ai->GetManaPercent() >= 3)
+        ai->CastSpell(DIVINE_SHIELD, *m_bot);
+
+    if (DIVINE_SACRIFICE > 0 && ai->GetHealthPercent() > 50 && pVictim != m_bot && !m_bot->HasAura(DIVINE_SACRIFICE, ObjectGuid::Empty))
+        ai->CastSpell(DIVINE_SACRIFICE, *m_bot);
+}
+
+void PlayerbotPaladinAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // Buff myself
+    if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_TANK) ai->SelfBuff(RIGHTEOUS_FURY);
+    if (SEAL_OF_WISDOM > 0 && !m_bot->HasAura(SEAL_OF_WISDOM, ObjectGuid::Empty) && ai->GetManaPercent() <= 30)
+        ai->CastSpell(SEAL_OF_WISDOM, *m_bot);
+    else if (m_bot->HasAura(SEAL_OF_WISDOM, ObjectGuid::Empty) && ai->GetManaPercent() < 85)
+    { }
+    else if (SEAL_OF_LIGHT > 0 && !m_bot->HasAura(SEAL_OF_LIGHT, ObjectGuid::Empty) && ai->GetHealthPercent() < 40)
+        ai->CastSpell(SEAL_OF_LIGHT, *m_bot);
+    else if (SEAL_OF_RIGHTEOUSNESS > 0 && !m_bot->HasAura(SEAL_OF_RIGHTEOUSNESS, ObjectGuid::Empty))
+        ai->CastSpell(SEAL_OF_RIGHTEOUSNESS, *m_bot);
+    BuffPlayer(m_bot);
+
+    // Buff master
+    if (!GetMaster()->duel || !GetMaster()->duel->opponent)
+        BuffPlayer(GetMaster());
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 40)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check original
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 40)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, ObjectGuid::Empty) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // heal and buff group
+    if (GetMaster()->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() ||
+                tPlayer->GetMap() != m_bot->GetMap() || tPlayer->GetDistance(m_bot) > 30)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == GetMaster())
+                continue;
+
+            if (!tPlayer->IsAlive())
+            {
+                if (ai->CastSpell(REDEMPTION, *tPlayer))
+                {
+                    std::string msg = "Resurrecting ";
+                    msg += tPlayer->GetName();
+                    m_bot->Say(msg, LANG_UNIVERSAL);
+                    return;
+                }
+                else
+                    continue;
+            }
+
+            if (HealTarget(tPlayer))
+                return;
+
+            if (tPlayer != m_bot && tPlayer != GetMaster())
+                if (BuffPlayer(tPlayer))
+                    return;
+        }
+    }
+}
+
+bool PlayerbotPaladinAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+    //uint8 SPELL_BLESSING = 2; // See SpellSpecific enum in SpellMgr.h
+
+    Pet * pet = target->GetPet();
+    bool targetCanBeBlessed = ai->CanReceiveSpecificSpell(SPELL_BLESSING, target);
+    bool petCanBeBlessed = false;
+    if (pet)
+        petCanBeBlessed = ai->CanReceiveSpecificSpell(SPELL_BLESSING, pet);
+
+    if (!ai->CanReceiveSpecificSpell(SPELL_BLESSING, target) && !petCanBeBlessed)
+        return false;
+
+    if (HasAuraName(target, BLESSING_OF_WISDOM,             GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, BLESSING_OF_KINGS,              GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, BLESSING_OF_MIGHT,              GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, BLESSING_OF_SANCTUARY,          GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, GREATER_BLESSING_OF_WISDOM,     GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, GREATER_BLESSING_OF_KINGS,      GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, GREATER_BLESSING_OF_MIGHT,      GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, GREATER_BLESSING_OF_SANCTUARY,  GetPlayerBot()->GetGUID())
+    ) return false;
+
+    switch (target->getClass())
+    {
+        case CLASS_DRUID:
+        case CLASS_SHAMAN:
+        case CLASS_PALADIN:
+            if (targetCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_MIGHT, target))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, target))
+                    return true;
+                if (Bless(BLESSING_OF_WISDOM, target))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, target))
+                    return true;
+                else
+                    return false;
+            }
+            break;
+        case CLASS_DEATH_KNIGHT:
+        case CLASS_HUNTER:
+            if (targetCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_MIGHT, target))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, target))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, target))
+                    return true;
+                else
+                    return false;
+            }
+            if (petCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_MIGHT, pet))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, pet))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, pet))
+                    return true;
+            }
+            break;
+        case CLASS_ROGUE:
+        case CLASS_WARRIOR:
+            if (targetCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_MIGHT, target))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, target))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, target))
+                    return true;
+                else
+                    return false;
+            }
+            break;
+        case CLASS_WARLOCK:
+            if (targetCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_KINGS, target))
+                    return true;
+                if (Bless(BLESSING_OF_WISDOM, target))
+                    return true;
+                else
+                    return false;
+            }
+            if (petCanBeBlessed && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
+            {
+                if (pet->getPowerType() == POWER_MANA)
+                {
+                    if (Bless(BLESSING_OF_WISDOM, pet))
+                        return true;
+                }
+                else if (Bless(BLESSING_OF_MIGHT, pet))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, pet))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, pet))
+                    return true;
+            }
+            break;
+        case CLASS_PRIEST:
+        case CLASS_MAGE:
+            if (targetCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_WISDOM, target))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, target))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, target))
+                    return true;
+                else
+                    return false;
+            }
+            break;
+        default:
+            break;
+    }
+    return false;
+}
+
+bool PlayerbotPaladinAI::Bless(uint32 spellId, Unit *target)
+{
+    if (spellId == 0)
+        return false;
+
+    PlayerbotAI * ai = GetAI();
+
+    if (spellId == BLESSING_OF_MIGHT)
+    {
+        if (GREATER_BLESSING_OF_MIGHT && ai->HasSpellReagents(GREATER_BLESSING_OF_MIGHT) && ai->Buff(GREATER_BLESSING_OF_MIGHT, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+    else if (spellId == BLESSING_OF_WISDOM)
+    {
+        if (GREATER_BLESSING_OF_WISDOM && ai->HasSpellReagents(GREATER_BLESSING_OF_WISDOM) && ai->Buff(GREATER_BLESSING_OF_WISDOM, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+    else if (spellId == BLESSING_OF_KINGS)
+    {
+        if (GREATER_BLESSING_OF_KINGS && ai->HasSpellReagents(GREATER_BLESSING_OF_KINGS) && ai->Buff(GREATER_BLESSING_OF_KINGS, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+    else if (spellId == BLESSING_OF_SANCTUARY)
+    {
+        if (GREATER_BLESSING_OF_SANCTUARY && ai->HasSpellReagents(GREATER_BLESSING_OF_SANCTUARY) && ai->Buff(GREATER_BLESSING_OF_SANCTUARY, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+
+    // Should not happen, but let it be here
+    return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
new file mode 100644
index 0000000..c6fa9f9
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
@@ -0,0 +1,187 @@
+#ifndef _PlayerbotPaladinAI_H
+#define _PlayerbotPaladinAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    Combat,
+    Healing
+};
+
+enum PaladinSpells
+{
+    AURA_MASTERY_1                  = 31821,
+    AVENGERS_SHIELD_1               = 31935,
+    AVENGING_WRATH_1                = 31884,
+    BEACON_OF_LIGHT_1               = 53563,
+    BLESSING_OF_KINGS_1             = 20217,
+    BLESSING_OF_MIGHT_1             = 19740,
+    BLESSING_OF_SANCTUARY_1         = 20911,
+    BLESSING_OF_WISDOM_1            = 19742,
+    CLEANSE_1                       = 4987,
+    CONCENTRATION_AURA_1            = 19746,
+    CONSECRATION_1                  = 26573,
+    CRUSADER_AURA_1                 = 32223,
+    CRUSADER_STRIKE_1               = 35395,
+    DEVOTION_AURA_1                 = 465,
+    DIVINE_FAVOR_1                  = 20216,
+    DIVINE_ILLUMINATION_1           = 31842,
+    DIVINE_INTERVENTION_1           = 19752,
+    DIVINE_PLEA_1                   = 54428,
+    DIVINE_PROTECTION_1             = 498,
+    DIVINE_SACRIFICE_1              = 64205,
+    DIVINE_SHIELD_1                 = 642,
+    DIVINE_STORM_1                  = 53385,
+    EXORCISM_1                      = 879,
+    FIRE_RESISTANCE_AURA_1          = 19891,
+    FLASH_OF_LIGHT_1                = 19750,
+    FROST_RESISTANCE_AURA_1         = 19888,
+    GREATER_BLESSING_OF_KINGS_1     = 25898,
+    GREATER_BLESSING_OF_MIGHT_1     = 25782,
+    GREATER_BLESSING_OF_SANCTUARY_1 = 25899,
+    GREATER_BLESSING_OF_WISDOM_1    = 25894,
+    HAMMER_OF_JUSTICE_1             = 853,
+    HAMMER_OF_THE_RIGHTEOUS_1       = 53595,
+    HAMMER_OF_WRATH_1               = 24275,
+    HAND_OF_FREEDOM_1               = 1044,
+    HAND_OF_PROTECTION_1            = 1022,
+    HAND_OF_RECKONING_1             = 62124,
+    HAND_OF_SACRIFICE_1             = 6940,
+    HAND_OF_SALVATION_1             = 1038,
+    HOLY_LIGHT_1                    = 635,
+    HOLY_SHIELD_1                   = 20925,
+    HOLY_SHOCK_1                    = 20473,
+    HOLY_WRATH_1                    = 2812,
+    JUDGEMENT_OF_JUSTICE_1          = 53407,
+    JUDGEMENT_OF_LIGHT_1            = 20271,
+    JUDGEMENT_OF_WISDOM_1           = 53408,
+    LAY_ON_HANDS_1                  = 633,
+    PURIFY_1                        = 1152,
+    REDEMPTION_1                    = 7328,
+    REPENTANCE_1                    = 20066,
+    RETRIBUTION_AURA_1              = 7294,
+    RIGHTEOUS_DEFENSE_1             = 31789,
+    RIGHTEOUS_FURY_1                = 25780,
+    SACRED_SHIELD_1                 = 53601,
+    SEAL_OF_COMMAND_1               = 20375,
+    SEAL_OF_CORRUPTION_1            = 53736,
+    SEAL_OF_JUSTICE_1               = 20164,
+    SEAL_OF_LIGHT_1                 = 20165,
+    SEAL_OF_RIGHTEOUSNESS_1         = 21084,
+    SEAL_OF_VENGEANCE_1             = 31801,
+    SEAL_OF_WISDOM_1                = 20166,
+    SENSE_UNDEAD_1                  = 5502,
+    SHADOW_RESISTANCE_AURA_1        = 19876,
+    SHIELD_OF_RIGHTEOUSNESS_1       = 53600,
+    TURN_EVIL_1                     = 10326
+};
+//class Player;
+
+class PlayerbotPaladinAI : PlayerbotClassAI
+{
+public:
+    PlayerbotPaladinAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotPaladinAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // Heals the target based off its hps
+    bool HealTarget (Unit *target);
+    // Bless target using greater blessing if possible
+    bool Bless(uint32 spellId, Unit *target);
+
+    // Retribution
+    uint32 RETRIBUTION_AURA,
+           SEAL_OF_COMMAND,
+           JUDGEMENT_OF_LIGHT,
+           JUDGEMENT_OF_WISDOM,
+           GREATER_BLESSING_OF_WISDOM,
+           GREATER_BLESSING_OF_MIGHT,
+           BLESSING_OF_WISDOM,
+           BLESSING_OF_MIGHT,
+           HAMMER_OF_JUSTICE,
+           RIGHTEOUS_FURY,
+           CRUSADER_AURA,
+           CRUSADER_STRIKE,
+           AVENGING_WRATH,
+           DIVINE_STORM,
+           JUDGEMENT_OF_JUSTICE;
+
+    // Holy
+    uint32 FLASH_OF_LIGHT,
+           HOLY_LIGHT,
+           DIVINE_SHIELD,
+           HAMMER_OF_WRATH,
+           CONSECRATION,
+           CONCENTRATION_AURA,
+           DIVINE_FAVOR,
+           SACRED_SHIELD,
+           HOLY_SHOCK,
+           HOLY_WRATH,
+           LAY_ON_HANDS,
+           EXORCISM,
+           REDEMPTION,
+           DIVINE_PLEA,
+           SEAL_OF_CORRUPTION,
+           SEAL_OF_JUSTICE,
+           SEAL_OF_LIGHT,
+           SEAL_OF_RIGHTEOUSNESS,
+           SEAL_OF_VENGEANCE,
+           SEAL_OF_WISDOM,
+           PURIFY,
+           CLEANSE;
+
+    // Protection
+    uint32 GREATER_BLESSING_OF_KINGS,
+           BLESSING_OF_KINGS,
+           HAND_OF_PROTECTION,
+           SHADOW_RESISTANCE_AURA,
+           DEVOTION_AURA,
+           FIRE_RESISTANCE_AURA,
+           FROST_RESISTANCE_AURA,
+           DEFENSIVE_STANCE,
+           BERSERKER_STANCE,
+           BATTLE_STANCE,
+           DIVINE_SACRIFICE,
+           DIVINE_PROTECTION,
+           DIVINE_INTERVENTION,
+           HOLY_SHIELD,
+           AVENGERS_SHIELD,
+           RIGHTEOUS_DEFENSE,
+           BLESSING_OF_SANCTUARY,
+           GREATER_BLESSING_OF_SANCTUARY,
+           HAND_OF_SACRIFICE,
+           SHIELD_OF_RIGHTEOUSNESS;
+
+    // cannot be protected
+    uint32 FORBEARANCE;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, CombatCounter, HealCounter;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
new file mode 100644
index 0000000..03e6cc7
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
@@ -0,0 +1,483 @@
+#include "PlayerbotPriestAI.h"
+#include "ObjectAccessor.h"
+#include "SpellAuras.h"
+#include "Player.h"
+#include "Group.h"
+#include "Pet.h"
+
+PlayerbotPriestAI::PlayerbotPriestAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    RENEW                         = ai->initSpell(RENEW_1);
+    LESSER_HEAL                   = ai->initSpell(LESSER_HEAL_1);
+    FLASH_HEAL                    = ai->initSpell(FLASH_HEAL_1);
+    (FLASH_HEAL > 0) ? FLASH_HEAL : FLASH_HEAL = LESSER_HEAL;
+    HEAL                          = ai->initSpell(HEAL_1);
+    (HEAL > 0) ? HEAL : HEAL = FLASH_HEAL;
+    GREATER_HEAL                  = ai->initSpell(GREATER_HEAL_1);
+    (GREATER_HEAL > 0) ? GREATER_HEAL : GREATER_HEAL = HEAL;
+    RESURRECTION                  = ai->initSpell(RESURRECTION_1);
+    SMITE                         = ai->initSpell(SMITE_1);
+    MANA_BURN                     = ai->initSpell(MANA_BURN_1);
+    HOLY_NOVA                     = ai->initSpell(HOLY_NOVA_1);
+    HOLY_FIRE                     = ai->initSpell(HOLY_FIRE_1);
+    DESPERATE_PRAYER              = ai->initSpell(DESPERATE_PRAYER_1);
+    PRAYER_OF_HEALING             = ai->initSpell(PRAYER_OF_HEALING_1);
+    CIRCLE_OF_HEALING             = ai->initSpell(CIRCLE_OF_HEALING_1);
+    BINDING_HEAL                  = ai->initSpell(BINDING_HEAL_1);
+    PRAYER_OF_MENDING             = ai->initSpell(PRAYER_OF_MENDING_1);
+    CURE_DISEASE                  = ai->initSpell(CURE_DISEASE_1);
+
+    // SHADOW
+    FADE                          = ai->initSpell(FADE_1);
+    SHADOW_WORD_PAIN              = ai->initSpell(SHADOW_WORD_PAIN_1);
+    MIND_BLAST                    = ai->initSpell(MIND_BLAST_1);
+    SCREAM                        = ai->initSpell(PSYCHIC_SCREAM_1);
+    MIND_FLAY                     = ai->initSpell(MIND_FLAY_1);
+    DEVOURING_PLAGUE              = ai->initSpell(DEVOURING_PLAGUE_1);
+    SHADOW_PROTECTION             = ai->initSpell(SHADOW_PROTECTION_1);
+    VAMPIRIC_TOUCH                = ai->initSpell(VAMPIRIC_TOUCH_1);
+    PRAYER_OF_SHADOW_PROTECTION   = ai->initSpell(PRAYER_OF_SHADOW_PROTECTION_1);
+    SHADOWFIEND                   = ai->initSpell(SHADOWFIEND_1);
+    MIND_SEAR                     = ai->initSpell(MIND_SEAR_1);
+
+    // DISCIPLINE
+    PENANCE                       = ai->initSpell(PENANCE_1);
+    INNER_FIRE                    = ai->initSpell(INNER_FIRE_1);
+    POWER_WORD_SHIELD             = ai->initSpell(POWER_WORD_SHIELD_1);
+    POWER_WORD_FORTITUDE          = ai->initSpell(POWER_WORD_FORTITUDE_1);
+    PRAYER_OF_FORTITUDE           = ai->initSpell(PRAYER_OF_FORTITUDE_1);
+    FEAR_WARD                     = ai->initSpell(FEAR_WARD_1);
+    DIVINE_SPIRIT                 = ai->initSpell(DIVINE_SPIRIT_1);
+    PRAYER_OF_SPIRIT              = ai->initSpell(PRAYER_OF_SPIRIT_1);
+    MASS_DISPEL                   = ai->initSpell(MASS_DISPEL_1);
+    POWER_INFUSION                = ai->initSpell(POWER_INFUSION_1);
+    INNER_FOCUS                   = ai->initSpell(INNER_FOCUS_1);
+
+    RECENTLY_BANDAGED  = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT                = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
+    GIFT_OF_THE_NAARU             = ai->initSpell(GIFT_OF_THE_NAARU_PRIEST); // draenei
+    STONEFORM                     = ai->initSpell(STONEFORM_ALL); // dwarf
+    EVERY_MAN_FOR_HIMSELF         = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    SHADOWMELD                    = ai->initSpell(SHADOWMELD_ALL);
+    BERSERKING                    = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN          = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotPriestAI::~PlayerbotPriestAI() {}
+
+bool PlayerbotPriestAI::DoFirstCombatManeuver(Unit* /*pTarget*/)
+{
+    return false;
+}
+
+bool PlayerbotPriestAI::HealTarget(Unit* target)
+{
+    PlayerbotAI* ai = GetAI();
+    uint8 hp = target->GetHealth() * 100 / target->GetMaxHealth();
+    uint8 hpSelf = GetAI()->GetHealthPercent();
+
+    if (CURE_DISEASE > 0 && ai->GetCombatOrder() != PlayerbotAI::ORDERS_NODISPEL)
+    {
+        Unit::AuraMap const& auras = target->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura *aura = itr->second;
+            if (aura->IsPassive()) continue;
+            if (aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+            if (aura->GetId() == 64844 || //Divine Hymn
+                aura->GetId() == 6346) // Fear Ward
+                continue;
+            DispelType dispel = DispelType(aura->GetSpellInfo()->Dispel);
+            if (dispel != DISPEL_DISEASE)
+                continue;
+            AuraApplication *aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+            if (!aurApp)
+                continue;
+            if (!aurApp->IsPositive() && ai->CastSpell(CURE_DISEASE, *target))
+                return true;
+        }
+    }
+
+    if (hp >= 80)
+        return false;
+
+    if (hp < 30 && FLASH_HEAL > 0 && ai->CastSpell(FLASH_HEAL, *target))
+        return true;
+    else if (hp < 40 && GREATER_HEAL > 0 && ai->CastSpell(GREATER_HEAL, *target))
+        return true;
+    // Heals target AND self for equal amount
+    else if (hp < 60 && hpSelf < 80 && BINDING_HEAL > 0 && ai->CastSpell(BINDING_HEAL, *target))
+        return true;
+    else if (hp < 60 && HEAL > 0 && ai->CastSpell(HEAL, *target))
+        return true;
+    else if (hp < 80 && RENEW > 0 && !target->HasAura(RENEW) && ai->CastSpell(RENEW, *target))
+        return true;
+    else
+        return false;
+} // end HealTarget
+
+void PlayerbotPriestAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    Unit* pVictim = pTarget->GetVictim();
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            (ai->HasAura(SCREAM, *pTarget) && ai->GetHealthPercent() < 60 && ai->CastSpell(HEAL)) ||
+            ai->CastSpell(SHADOW_WORD_PAIN) ||
+            (ai->GetHealthPercent() < 80 && ai->CastSpell(RENEW)) ||
+            (GetCombatDistance(pTarget) <= 5 && ai->CastSpell(SCREAM)) ||
+            ai->CastSpell(MIND_BLAST) ||
+            (ai->GetHealthPercent() < 20 && ai->CastSpell(GREATER_HEAL)) ||
+            ai->CastSpell(SMITE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+
+    // Fade has nothing to do with health and everything to do with having aggro/threat
+    Unit *newTarget = ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE) (PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
+    if (newTarget && FADE > 0 && !m_bot->HasAura(FADE, ObjectGuid::Empty))
+    {
+        ai->TellMaster("I'm casting fade.");
+        ai->CastSpell(FADE, *m_bot);
+    }
+    // Heal myself
+    else if (ai->GetHealthPercent() < 25 && POWER_WORD_SHIELD > 0 && !m_bot->HasAura(POWER_WORD_SHIELD, ObjectGuid::Empty))
+    {
+        ai->TellMaster("I'm casting PW:S on myself.");
+        ai->CastSpell(POWER_WORD_SHIELD);
+    }
+    else if (ai->GetHealthPercent() < 35 && DESPERATE_PRAYER > 0)
+    {
+        ai->TellMaster("I'm casting desperate prayer.");
+        ai->CastSpell(DESPERATE_PRAYER, *m_bot);
+    }
+    else if (ai->GetHealthPercent() < 60 || (BINDING_HEAL == 0 && ai->GetHealthPercent() < 80))
+        HealTarget(m_bot);
+
+    // Heal master
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+    if (GetMaster()->IsAlive())
+    {
+        if (masterHP < 25 && POWER_WORD_SHIELD > 0 && !GetMaster()->HasAura(POWER_WORD_SHIELD, ObjectGuid::Empty))
+            ai->CastSpell(POWER_WORD_SHIELD, *(GetMaster()));
+        else if (masterHP < 25 || ((GetAI()->GetCombatOrder() & PlayerbotAI::ORDERS_HEAL) && masterHP < 80))
+            HealTarget(GetMaster());
+    }
+
+    // TODO: Prioritize group healing in some way. If 3 members (including master/self) should be healed, pick one of these:
+    // Group heal. Not really useful until a group check is available?
+    //else if (hp < 40 && PRAYER_OF_HEALING > 0 && ai->CastSpell(PRAYER_OF_HEALING, *target))
+    //    return true;
+    // Group heal. Not really useful until a group check is available?
+    //else if (hp < 50 && CIRCLE_OF_HEALING > 0 && ai->CastSpell(CIRCLE_OF_HEALING, *target))
+    //    return true;
+
+    // Heal group
+    if (m_group)
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = ObjectAccessor::FindPlayer(itr->guid);
+            if (!m_groupMember || !m_groupMember->IsAlive())
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth() * 100 / m_groupMember->GetMaxHealth();
+            if (memberHP < 25 && POWER_WORD_SHIELD > 0 && !m_groupMember->HasAura(POWER_WORD_SHIELD, ObjectGuid::Empty))
+                ai->CastSpell(POWER_WORD_SHIELD, *(GetMaster()));
+            else if (memberHP < 25 || ((GetAI()->GetCombatOrder() & PlayerbotAI::ORDERS_HEAL) && memberHP < 80))
+                HealTarget(m_groupMember);
+        }
+    }
+
+    if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_HEAL)
+        SpellSequence = SPELL_HOLY;
+    else if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST)
+        SpellSequence = SPELL_SHADOWMAGIC;
+    else
+        SpellSequence = SPELL_HOLY;
+
+    // Damage Spells
+    float dist = GetCombatDistance(pTarget);
+
+    switch (SpellSequence)
+    {
+        case SPELL_HOLY:
+            if (SMITE > 0 && LastSpellHoly < 1 && !pTarget->HasAura(SMITE, ObjectGuid::Empty) && ai->GetManaPercent() >= 17)
+            {
+                ai->CastSpell(SMITE, *pTarget);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (MANA_BURN > 0 && LastSpellHoly < 2 && pTarget->GetPower(POWER_MANA) > 0 && ai->GetManaPercent() < 70 && ai->GetManaPercent() >= 14)
+            {
+                //ai->TellMaster("I'm casting mana burn.");
+                ai->CastSpell(MANA_BURN, *pTarget);
+                ai->SetIgnoreUpdateTime(3);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (HOLY_NOVA > 0 && LastSpellHoly < 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 22)
+            {
+                //ai->TellMaster("I'm casting holy nova.");
+                ai->CastSpell(HOLY_NOVA);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (HOLY_FIRE > 0 && LastSpellHoly < 4 && !pTarget->HasAura(HOLY_FIRE, ObjectGuid::Empty) && ai->GetManaPercent() >= 13)
+            {
+                //ai->TellMaster("I'm casting holy fire.");
+                ai->CastSpell(HOLY_FIRE, *pTarget);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (PRAYER_OF_MENDING > 0 && LastSpellHoly < 5 && pVictim == GetMaster() && GetMaster()->GetHealth() <= GetMaster()->GetMaxHealth() * 0.7 && !GetMaster()->HasAura(PRAYER_OF_MENDING, ObjectGuid::Empty) && ai->GetManaPercent() >= 15)
+            {
+                //ai->TellMaster("I'm casting prayer of mending on master.");
+                ai->CastSpell(PRAYER_OF_MENDING, *GetMaster());
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else
+                LastSpellHoly = 0;
+
+            if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_NONE)
+                SpellSequence = SPELL_SHADOWMAGIC;
+            break;
+
+        case SPELL_SHADOWMAGIC:
+            if (SHADOW_WORD_PAIN > 0 && LastSpellShadowMagic < 1 && !pTarget->HasAura(SHADOW_WORD_PAIN, ObjectGuid::Empty) && ai->GetManaPercent() >= 25)
+            {
+                //ai->TellMaster("I'm casting pain.");
+                ai->CastSpell(SHADOW_WORD_PAIN, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (MIND_BLAST > 0 && LastSpellShadowMagic < 2 && ai->GetManaPercent() >= 19)
+            {
+                //ai->TellMaster("I'm casting mind blast.");
+                ai->CastSpell(MIND_BLAST, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (SCREAM > 0 && LastSpellShadowMagic < 3 && ai->GetAttackerCount() >= 3 && ai->GetManaPercent() >= 15)
+            {
+                ai->TellMaster("I'm casting scream.");
+                ai->CastSpell(SCREAM);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (MIND_FLAY > 0 && LastSpellShadowMagic < 4 && !pTarget->HasAura(MIND_FLAY, ObjectGuid::Empty) && ai->GetManaPercent() >= 10)
+            {
+                //ai->TellMaster("I'm casting mind flay.");
+                ai->CastSpell(MIND_FLAY, *pTarget);
+                ai->SetIgnoreUpdateTime(3);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (DEVOURING_PLAGUE > 0 && LastSpellShadowMagic < 5 && !pTarget->HasAura(DEVOURING_PLAGUE, ObjectGuid::Empty) && ai->GetManaPercent() >= 28)
+            {
+                ai->CastSpell(DEVOURING_PLAGUE, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (SHADOW_PROTECTION > 0 && LastSpellShadowMagic < 6 && ai->GetManaPercent() >= 60)
+            {
+                ai->CastSpell(SHADOW_PROTECTION, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (VAMPIRIC_TOUCH > 0 && LastSpellShadowMagic < 7 && !pTarget->HasAura(VAMPIRIC_TOUCH, ObjectGuid::Empty) && ai->GetManaPercent() >= 18)
+            {
+                ai->CastSpell(VAMPIRIC_TOUCH, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (SHADOWFIEND > 0 && LastSpellShadowMagic < 8)
+            {
+                ai->CastSpell(SHADOWFIEND);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (MIND_SEAR > 0 && LastSpellShadowMagic < 9 && ai->GetAttackerCount() >= 3 && ai->GetManaPercent() >= 28)
+            {
+                ai->CastSpell(MIND_SEAR, *pTarget);
+                ai->SetIgnoreUpdateTime(5);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else
+                LastSpellShadowMagic = 0;
+
+            if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_NONE || ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST)
+                SpellSequence = SPELL_DISCIPLINE;
+            break;
+
+        case SPELL_DISCIPLINE:
+            if (FEAR_WARD > 0 && LastSpellDiscipline < 1 && ai->GetManaPercent() >= 3)
+            {
+                //ai->TellMaster("I'm casting fear ward");
+                ai->CastSpell(FEAR_WARD, *(GetMaster()));
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (POWER_INFUSION > 0 && LastSpellDiscipline < 2 && ai->GetManaPercent() >= 16)
+            {
+                //ai->TellMaster("I'm casting power infusion");
+                ai->CastSpell(POWER_INFUSION, *(GetMaster()));
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (MASS_DISPEL > 0 && LastSpellDiscipline < 3 && ai->GetManaPercent() >= 33)
+            {
+                //ai->TellMaster("I'm casting mass dispel");
+                ai->CastSpell(MASS_DISPEL);
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (INNER_FOCUS > 0 && !m_bot->HasAura(INNER_FOCUS, ObjectGuid::Empty) && LastSpellDiscipline < 4)
+            {
+                //ai->TellMaster("I'm casting inner focus");
+                ai->CastSpell(INNER_FOCUS, *m_bot);
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (PENANCE > 0 && LastSpellDiscipline < 5 && ai->GetManaPercent() >= 16)
+            {
+                //ai->TellMaster("I'm casting PENANCE");
+                ai->CastSpell(PENANCE);
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else
+                LastSpellDiscipline = 0;
+
+            if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_NONE)
+                SpellSequence = SPELL_HOLY;
+            else if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST)
+                SpellSequence = SPELL_SHADOWMAGIC;
+            break;
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotPriestAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    Player * master = GetMaster();
+    if (!m_bot || !master)
+        return;
+
+    SpellSequence = SPELL_HOLY;
+
+    // selfbuff goes first
+    if (ai->SelfBuff(INNER_FIRE))
+        return;
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, ObjectGuid::Empty) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // buff and heal master's group
+    if (master->GetGroup())
+    {
+        // Buff master with group buffs
+        if (!master->duel && master->IsAlive())
+        {
+            if (PRAYER_OF_FORTITUDE && ai->HasSpellReagents(PRAYER_OF_FORTITUDE) && ai->Buff(PRAYER_OF_FORTITUDE, master))
+                return;
+
+            if (PRAYER_OF_SPIRIT && ai->HasSpellReagents(PRAYER_OF_SPIRIT) && ai->Buff(PRAYER_OF_SPIRIT, master))
+                return;
+
+            if (PRAYER_OF_SHADOW_PROTECTION && ai->HasSpellReagents(PRAYER_OF_SHADOW_PROTECTION) && ai->Buff(PRAYER_OF_SHADOW_PROTECTION, master))
+                return;
+        }
+
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() ||
+                tPlayer->GetMap() != m_bot->GetMap() || tPlayer->GetDistance(m_bot) > 30)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == GetMaster())
+                continue;
+
+            // first rezz em
+            if (!tPlayer->IsAlive())
+            {
+                if (ai->CastSpell(RESURRECTION, *tPlayer))
+                {
+                    std::string msg = "Resurrecting ";
+                    msg += tPlayer->GetName();
+                    m_bot->Say(msg, LANG_UNIVERSAL);
+                    return;
+                }
+                else
+                    continue;
+            }
+            else
+            {
+                // buff and heal
+                if (BuffPlayer(tPlayer))
+                    return;
+
+                if (HealTarget(tPlayer))
+                    return;
+            }
+        }
+    }
+    else
+    {
+        if (master->IsAlive() && !master->duel)
+        {
+            if (BuffPlayer(master))
+                return;
+            if (HealTarget(master))
+                return;
+        }
+        else if (ai->CastSpell(RESURRECTION, *master))
+            ai->TellMaster("Resurrecting you, Master.");
+    }
+
+    BuffPlayer(m_bot);
+} // end DoNonCombatActions
+
+bool PlayerbotPriestAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+    Pet * pet = target->GetPet();
+
+    if ((pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE)) && ai->Buff(POWER_WORD_FORTITUDE, pet))
+        return true;
+
+    if (ai->Buff(POWER_WORD_FORTITUDE, target))
+        return true;
+
+    if ((target->getClass() == CLASS_DRUID || target->getPowerType() == POWER_MANA) && ai->Buff(DIVINE_SPIRIT, target))
+        return true;
+
+    return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
new file mode 100644
index 0000000..3dad67e
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
@@ -0,0 +1,157 @@
+#ifndef _PLAYERBOTPRIESTAI_H
+#define _PLAYERBOTPRIESTAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    SPELL_HOLY,
+    SPELL_SHADOWMAGIC,
+    SPELL_DISCIPLINE
+};
+
+enum PriestSpells
+{
+    ABOLISH_DISEASE_1               = 552,
+    BINDING_HEAL_1                  = 32546,
+    BLESSED_HEALING_1               = 70772,
+    CIRCLE_OF_HEALING_1             = 34861,
+    CURE_DISEASE_1                  = 528,
+    DESPERATE_PRAYER_1              = 19236,
+    DEVOURING_PLAGUE_1              = 2944,
+    DISPEL_MAGIC_1                  = 527,
+    DISPERSION_1                    = 47585,
+    DIVINE_HYMN_1                   = 64843,
+    DIVINE_SPIRIT_1                 = 14752,
+    FADE_1                          = 586,
+    FEAR_WARD_1                     = 6346,
+    FLASH_HEAL_1                    = 2061,
+    GREATER_HEAL_1                  = 2060,
+    GUARDIAN_SPIRIT_1               = 47788,
+    HEAL_1                          = 2054,
+    HOLY_FIRE_1                     = 14914,
+    HOLY_NOVA_1                     = 15237,
+    HYMN_OF_HOPE_1                  = 64901,
+    INNER_FIRE_1                    = 588,
+    INNER_FOCUS_1                   = 14751,
+    LESSER_HEAL_1                   = 2050,
+    LEVITATE_1                      = 1706,
+    LIGHTWELL_1                     = 724,
+    MANA_BURN_1                     = 8129,
+    MASS_DISPEL_1                   = 32375,
+    MIND_BLAST_1                    = 8092,
+    MIND_CONTROL_1                  = 605,
+    MIND_FLAY_1                     = 15407,
+    MIND_SEAR_1                     = 48045,
+    MIND_SOOTHE_1                   = 453,
+    MIND_VISION_1                   = 2096,
+    PAIN_SUPPRESSION_1              = 33206,
+    PENANCE_1                       = 47540,
+    POWER_INFUSION_1                = 10060,
+    POWER_WORD_FORTITUDE_1          = 1243,
+    POWER_WORD_SHIELD_1             = 17,
+    PRAYER_OF_FORTITUDE_1           = 21562,
+    PRAYER_OF_HEALING_1             = 596,
+    PRAYER_OF_MENDING_1             = 33076,
+    PRAYER_OF_SHADOW_PROTECTION_1   = 27683,
+    PRAYER_OF_SPIRIT_1              = 27681,
+    PSYCHIC_HORROR_1                = 64044,
+    PSYCHIC_SCREAM_1                = 8122,
+    RENEW_1                         = 139,
+    RESURRECTION_1                  = 2006,
+    SHACKLE_UNDEAD_1                = 9484,
+    SHADOW_PROTECTION_1             = 976,
+    SHADOW_WORD_DEATH_1             = 32379,
+    SHADOW_WORD_PAIN_1              = 589,
+    SHADOWFIEND_1                   = 34433,
+    SHADOWFORM_1                    = 15473,
+    SILENCE_1                       = 15487,
+    SMITE_1                         = 585,
+    VAMPIRIC_EMBRACE_1              = 15286,
+    VAMPIRIC_TOUCH_1                = 34914
+};
+//class Player;
+
+class PlayerbotPriestAI : PlayerbotClassAI
+{
+public:
+    PlayerbotPriestAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotPriestAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // Heals the target based off its hps
+    bool HealTarget (Unit* target);
+
+    // holy
+    uint32 BINDING_HEAL,
+           CIRCLE_OF_HEALING,
+           CLEARCASTING,
+           DESPERATE_PRAYER,
+           FLASH_HEAL,
+           GREATER_HEAL,
+           HEAL,
+           HOLY_FIRE,
+           HOLY_NOVA,
+           LESSER_HEAL,
+           MANA_BURN,
+           PRAYER_OF_HEALING,
+           PRAYER_OF_MENDING,
+           RENEW,
+           RESURRECTION,
+           SMITE,
+           CURE_DISEASE;
+
+    // shadowmagic
+    uint32 FADE,
+           SHADOW_WORD_PAIN,
+           MIND_BLAST,
+           SCREAM,
+           MIND_FLAY,
+           DEVOURING_PLAGUE,
+           SHADOW_PROTECTION,
+           VAMPIRIC_TOUCH,
+           PRAYER_OF_SHADOW_PROTECTION,
+           SHADOWFIEND,
+           MIND_SEAR;
+
+    // discipline
+    uint32 POWER_WORD_SHIELD,
+           INNER_FIRE,
+           POWER_WORD_FORTITUDE,
+           PRAYER_OF_FORTITUDE,
+           FEAR_WARD,
+           POWER_INFUSION,
+           MASS_DISPEL,
+           PENANCE,
+           DIVINE_SPIRIT,
+           PRAYER_OF_SPIRIT,
+           INNER_FOCUS;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellHoly, LastSpellShadowMagic, LastSpellDiscipline;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
new file mode 100644
index 0000000..ef18a49
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
@@ -0,0 +1,345 @@
+/*
+   Name    : PlayerbotRogueAI.cpp
+   Complete: maybe around 28%
+   Author    : Natsukawa
+   Version : 0.37
+ */
+#include "PlayerbotRogueAI.h"
+#include "Player.h"
+
+PlayerbotRogueAI::PlayerbotRogueAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    SINISTER_STRIKE          = ai->initSpell(SINISTER_STRIKE_1);
+    BACKSTAB                 = ai->initSpell(BACKSTAB_1);
+    KICK                     = ai->initSpell(KICK_1);
+    FEINT                    = ai->initSpell(FEINT_1);
+    FAN_OF_KNIVES            = ai->initSpell(FAN_OF_KNIVES_1);
+    GOUGE                    = ai->initSpell(GOUGE_1);
+    SPRINT                   = ai->initSpell(SPRINT_1);
+
+    SHADOWSTEP               = ai->initSpell(SHADOWSTEP_1);
+    STEALTH                  = ai->initSpell(STEALTH_1);
+    VANISH                   = ai->initSpell(VANISH_1);
+    EVASION                  = ai->initSpell(EVASION_1);
+    CLOAK_OF_SHADOWS         = ai->initSpell(CLOAK_OF_SHADOWS_1);
+    HEMORRHAGE               = ai->initSpell(HEMORRHAGE_1);
+    GHOSTLY_STRIKE           = ai->initSpell(GHOSTLY_STRIKE_1);
+    SHADOW_DANCE             = ai->initSpell(SHADOW_DANCE_1);
+    BLIND                    = ai->initSpell(BLIND_1);
+    DISTRACT                 = ai->initSpell(DISTRACT_1);
+    PREPARATION              = ai->initSpell(PREPARATION_1);
+    PREMEDITATION            = ai->initSpell(PREMEDITATION_1);
+    PICK_POCKET              = ai->initSpell(PICK_POCKET_1);
+
+    EVISCERATE               = ai->initSpell(EVISCERATE_1);
+    KIDNEY_SHOT              = ai->initSpell(KIDNEY_SHOT_1);
+    SLICE_DICE               = ai->initSpell(SLICE_AND_DICE_1);
+    GARROTE                  = ai->initSpell(GARROTE_1);
+    EXPOSE_ARMOR             = ai->initSpell(EXPOSE_ARMOR_1);
+    RUPTURE                  = ai->initSpell(RUPTURE_1);
+    DISMANTLE                = ai->initSpell(DISMANTLE_1);
+    CHEAP_SHOT               = ai->initSpell(CHEAP_SHOT_1);
+    AMBUSH                   = ai->initSpell(AMBUSH_1);
+    MUTILATE                 = ai->initSpell(MUTILATE_1);
+
+    RECENTLY_BANDAGED   = 11196; // first aid check
+    // racial
+    ARCANE_TORRENT           = ai->initSpell(ARCANE_TORRENT_ROGUE);
+    STONEFORM                = ai->initSpell(STONEFORM_ALL); // dwarf
+    ESCAPE_ARTIST            = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF    = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    SHADOWMELD               = ai->initSpell(SHADOWMELD_ALL);
+    BLOOD_FURY               = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    BERSERKING               = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN     = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotRogueAI::~PlayerbotRogueAI() {}
+
+bool PlayerbotRogueAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+
+    if (STEALTH > 0 && !m_bot->HasAura(STEALTH, ObjectGuid::Empty) && ai->CastSpell(STEALTH, *m_bot))
+    {
+
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("First > Stealth (%d)", STEALTH);
+
+        m_bot->AddUnitState(UNIT_STATE_CHASE); // ensure that the bot does not use MoveChase(), as this doesn't seem to work with STEALTH
+
+        return true;
+    }
+    else if (m_bot->HasAura(STEALTH, ObjectGuid::Empty))
+    {
+        m_bot->GetMotionMaster()->MoveFollow(pTarget, 4.5f, m_bot->GetOrientation());
+        return false;
+    }
+    return false;
+}
+
+void PlayerbotRogueAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget)
+        return;
+
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+        {
+            if (SINISTER_STRIKE > 0)
+                ai->CastSpell(SINISTER_STRIKE);
+            return;
+        }
+        default:
+            break;
+    }
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->GetVictim();
+    float fTargetDist = GetCombatDistance(pTarget);
+
+    // TODO: make this work better...
+    /*if (pVictim)
+       {
+        if( pVictim!=m_bot && !m_bot->HasUnitState(UNIT_STATE_FOLLOW) && !pTarget->isInBackInMap(m_bot,10) ) {
+            GetAI()->TellMaster( "getting behind target" );
+            m_bot->GetMotionMaster()->Clear( true );
+            m_bot->GetMotionMaster()->MoveFollow( pTarget, 1, 2*M_PI );
+        }
+        else if( pVictim==m_bot && m_bot->HasUnitState(UNIT_STATE_FOLLOW) )
+        {
+            GetAI()->TellMaster( "chasing attacking target" );
+            m_bot->GetMotionMaster()->Clear( true );
+            m_bot->GetMotionMaster()->MoveChase( pTarget );
+        }
+       }*/
+
+    //Rouge like behaviour. ^^
+/*    if (VANISH > 0 && GetMaster()->isDead()) { //Causes the server to crash :( removed for now.
+        m_bot->AttackStop();
+        m_bot->RemoveAllAttackers();
+        ai->CastSpell(VANISH);
+   //        m_bot->RemoveAllSpellCooldown();
+        GetAI()->TellMaster("AttackStop, CombatStop, Vanish");
+    }*/
+
+    // decide what to do:
+    if (pVictim == m_bot && CLOAK_OF_SHADOWS > 0 && pVictim->HasAura(SPELL_AURA_PERIODIC_DAMAGE) && !m_bot->HasAura(CLOAK_OF_SHADOWS, ObjectGuid::Empty) && ai->CastSpell(CLOAK_OF_SHADOWS))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("CoS!");
+        return;
+    }
+    else if (m_bot->HasAura(STEALTH, ObjectGuid::Empty))
+        SpellSequence = RogueStealth;
+    else if (pTarget->IsNonMeleeSpellCast(true))
+        SpellSequence = RogueSpellPreventing;
+    else if (pVictim == m_bot && ai->GetHealthPercent() < 40)
+        SpellSequence = RogueThreat;
+    else
+        SpellSequence = RogueCombat;
+
+    // we fight in melee, target is not in range, skip the next part!
+    if (fTargetDist > ATTACK_DISTANCE)
+        return;
+
+    std::ostringstream out;
+    switch (SpellSequence)
+    {
+        case RogueStealth:
+            out << "Case Stealth";
+            if (PICK_POCKET > 0 && (pTarget->GetCreatureTypeMask() & CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) != 0 &&
+                !((Creature *) pTarget)->loot.loot_type == LOOT_PICKPOCKETING && ai->CastSpell(PICK_POCKET, *pTarget))
+                out << " > Pick Pocket";
+            else if (PREMEDITATION > 0 && ai->CastSpell(PREMEDITATION, *pTarget))
+                out << " > Premeditation";
+            else if (AMBUSH > 0 && ai->GetEnergyAmount() >= 60 && ai->CastSpell(AMBUSH, *pTarget))
+                out << " > Ambush";
+            else if (CHEAP_SHOT > 0 && !pTarget->HasAura(CHEAP_SHOT, ObjectGuid::Empty) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(CHEAP_SHOT, *pTarget))
+                out << " > Cheap Shot";
+            else if (GARROTE > 0 && ai->GetEnergyAmount() >= 50 && ai->CastSpell(GARROTE, *pTarget))
+                out << " > Garrote";
+            else
+                m_bot->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+            break;
+        case RogueThreat:
+            out << "Case Threat";
+            if (GOUGE > 0 && ai->GetEnergyAmount() >= 45 && !pTarget->HasAura(GOUGE, ObjectGuid::Empty) && ai->CastSpell(GOUGE, *pTarget))
+                out << " > Gouge";
+            else if (EVASION > 0 && ai->GetHealthPercent() <= 35 && !m_bot->HasAura(EVASION, ObjectGuid::Empty) && ai->CastSpell(EVASION))
+                out << " > Evasion";
+            else if (BLIND > 0 && ai->GetHealthPercent() <= 30 && !pTarget->HasAura(BLIND, ObjectGuid::Empty) && ai->GetEnergyAmount() >= 30 && ai->CastSpell(BLIND, *pTarget))
+                out << " > Blind";
+            else if (FEINT > 0 && ai->GetHealthPercent() <= 25 && ai->GetEnergyAmount() >= 20 && ai->CastSpell(FEINT))
+                out << " > Feint";
+            else if (VANISH > 0 && ai->GetHealthPercent() <= 20 && !m_bot->HasAura(FEINT, ObjectGuid::Empty) && ai->CastSpell(VANISH))
+                out << " > Vanish";
+            else if (PREPARATION > 0 && ai->CastSpell(PREPARATION))
+                out << " > Preparation";
+            else if (m_bot->getRace() == RACE_NIGHTELF && ai->GetHealthPercent() <= 15 && !m_bot->HasAura(SHADOWMELD, ObjectGuid::Empty) && ai->CastSpell(SHADOWMELD, *m_bot))
+                out << " > Shadowmeld";
+            else
+                out << " NONE!";
+            break;
+        case RogueSpellPreventing:
+            out << "Case Prevent";
+            if (KIDNEY_SHOT > 0 && ai->GetEnergyAmount() >= 25 && m_bot->GetComboPoints() >= 2 && ai->CastSpell(KIDNEY_SHOT, *pTarget))
+                out << " > Kidney Shot";
+            else if (KICK > 0 && ai->GetEnergyAmount() >= 25  && ai->CastSpell(KICK, *pTarget))
+                out << " > Kick";
+            else
+                out << " NONE!";
+            break;
+        case RogueCombat:
+        default:
+            out << "Case Combat";
+            if (m_bot->GetComboPoints() <= 4)
+            {
+                if (SHADOW_DANCE > 0 && !m_bot->HasAura(SHADOW_DANCE, ObjectGuid::Empty) && ai->CastSpell(SHADOW_DANCE, *m_bot))
+                    out << " > Shadow Dance";
+                else if (CHEAP_SHOT > 0 && m_bot->HasAura(SHADOW_DANCE, ObjectGuid::Empty) && !pTarget->HasAura(CHEAP_SHOT, ObjectGuid::Empty) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(CHEAP_SHOT, *pTarget))
+                    out << " > Cheap Shot";
+                else if (AMBUSH > 0 && m_bot->HasAura(SHADOW_DANCE, ObjectGuid::Empty) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(AMBUSH, *pTarget))
+                    out << " > Ambush";
+                else if (GARROTE > 0 && m_bot->HasAura(SHADOW_DANCE, ObjectGuid::Empty) && ai->GetEnergyAmount() >= 50 && ai->CastSpell(GARROTE, *pTarget))
+                    out << " > Garrote";
+                else if (BACKSTAB > 0 && pTarget->isInBackInMap(m_bot, 1) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(BACKSTAB, *pTarget))
+                    out << " > Backstab";
+                else if (MUTILATE > 0 && ai->GetEnergyAmount() >= 60 && ai->CastSpell(MUTILATE, *pTarget))
+                    out << " > Mutilate";
+                else if (SINISTER_STRIKE > 0 && ai->GetEnergyAmount() >= 45 && ai->CastSpell(SINISTER_STRIKE, *pTarget))
+                    out << " > Sinister Strike";
+                else if (GHOSTLY_STRIKE > 0 && ai->GetEnergyAmount() >= 40 && ai->CastSpell(GHOSTLY_STRIKE, *pTarget))
+                    out << " > Ghostly Strike";
+                else if (HEMORRHAGE > 0 && ai->GetEnergyAmount() >= 35 && ai->CastSpell(HEMORRHAGE, *pTarget))
+                    out << " > Hemorrhage";
+                else if (DISMANTLE > 0 && !pTarget->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(DISMANTLE, *pTarget))
+                    out << " > Dismantle";
+                else if (SHADOWSTEP > 0 && ai->GetEnergyAmount() >= 10 && ai->CastSpell(SHADOWSTEP, *pTarget))
+                    out << " > Shadowstep";
+                else if (m_bot->getRace() == RACE_BLOODELF && !pTarget->HasAura(ARCANE_TORRENT, ObjectGuid::Empty) && ai->CastSpell(ARCANE_TORRENT, *pTarget))
+                    out << " > Arcane Torrent";
+                else if ((m_bot->getRace() == RACE_HUMAN && m_bot->HasUnitState(UNIT_STATE_STUNNED)) || m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || (m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(EVERY_MAN_FOR_HIMSELF, *m_bot)))
+                    out << " > Every Man for Himself";
+                else if ((m_bot->getRace() == RACE_UNDEAD_PLAYER && m_bot->HasAuraType(SPELL_AURA_MOD_FEAR)) || (m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(WILL_OF_THE_FORSAKEN, *m_bot)))
+                    out << " > Will of the Forsaken";
+                else if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && ai->CastSpell(STONEFORM, *m_bot))
+                    out << " > Stoneform";
+                else if ((m_bot->getRace() == RACE_GNOME && m_bot->HasUnitState(UNIT_STATE_STUNNED)) || (m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) && ai->CastSpell(ESCAPE_ARTIST, *m_bot)))
+                    out << " > Escape Artist";
+                else if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, ObjectGuid::Empty) && ai->CastSpell(BLOOD_FURY, *m_bot))
+                    out << " > Blood Fury";
+                else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, ObjectGuid::Empty) && ai->CastSpell(BERSERKING, *m_bot))
+                    out << " > Berserking";
+                else
+                    out << " NONE!";
+            }
+            else
+            {
+                if (EVISCERATE > 0 && pTarget->getClass() == CLASS_ROGUE && ai->GetEnergyAmount() >= 35 && ai->CastSpell(EVISCERATE, *pTarget))
+                    out << " > Rogue Eviscerate";
+                else if (EVISCERATE > 0 && pTarget->getClass() == CLASS_DRUID && ai->GetEnergyAmount() >= 35 && ai->CastSpell(EVISCERATE, *pTarget))
+                    out << " > Druid Eviscerate";
+                else if (KIDNEY_SHOT > 0 && pTarget->getClass() == CLASS_SHAMAN && ai->GetEnergyAmount() >= 25 && ai->CastSpell(KIDNEY_SHOT, *pTarget))
+                    out << " > Shaman Kidney";
+                else if (SLICE_DICE > 0 && pTarget->getClass() == CLASS_WARLOCK && ai->GetEnergyAmount() >= 25 && ai->CastSpell(SLICE_DICE, *pTarget))
+                    out << " > Warlock Slice & Dice";
+                else if (SLICE_DICE > 0 && pTarget->getClass() == CLASS_HUNTER && ai->GetEnergyAmount() >= 25 && ai->CastSpell(SLICE_DICE, *pTarget))
+                    out << " > Hunter Slice & Dice";
+                else if (EXPOSE_ARMOR > 0 && pTarget->getClass() == CLASS_WARRIOR && !pTarget->HasAura(EXPOSE_ARMOR, ObjectGuid::Empty) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget))
+                    out << " > Warrior Expose Armor";
+                else if (EXPOSE_ARMOR > 0 && pTarget->getClass() == CLASS_PALADIN && !pTarget->HasAura(EXPOSE_ARMOR, ObjectGuid::Empty) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget))
+                    out << " > Paladin Expose Armor";
+                else if (EXPOSE_ARMOR > 0 && pTarget->getClass() == CLASS_DEATH_KNIGHT && !pTarget->HasAura(EXPOSE_ARMOR, ObjectGuid::Empty) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget))
+                    out << " > DK Expose Armor";
+                else if (RUPTURE > 0 && pTarget->getClass() == CLASS_MAGE && ai->GetEnergyAmount() >= 25 && ai->CastSpell(RUPTURE, *pTarget))
+                    out << " > Mage Rupture";
+                else if (RUPTURE > 0 && pTarget->getClass() == CLASS_PRIEST && ai->GetEnergyAmount() >= 25 && ai->CastSpell(RUPTURE, *pTarget))
+                    out << " > Priest Rupture";
+                else if (EVISCERATE > 0 && ai->GetEnergyAmount() >= 35 && ai->CastSpell(EVISCERATE, *pTarget))
+                    out << " > Eviscerate";
+                else
+                    out << " NONE!";
+            }
+            break;
+    }
+    if (ai->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+}
+
+// end DoNextCombatManeuver
+
+void PlayerbotRogueAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    if (!ai)
+        return;
+
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // remove stealth
+    if (m_bot->HasAura(STEALTH))
+        m_bot->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindFood();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, ObjectGuid::Empty) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // Search and apply poisons to weapons
+    // Mainhand ...
+    Item * poison, * weapon;
+    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        poison = ai->FindConsumable(INSTANT_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(WOUND_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(DEADLY_POISON_DISPLAYID);
+        if (poison)
+        {
+            ai->UseItem(poison, EQUIPMENT_SLOT_MAINHAND);
+            ai->SetIgnoreUpdateTime(5);
+        }
+    }
+    //... and offhand
+    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        poison = ai->FindConsumable(DEADLY_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(WOUND_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(INSTANT_POISON_DISPLAYID);
+        if (poison)
+        {
+            ai->UseItem(poison, EQUIPMENT_SLOT_OFFHAND);
+            ai->SetIgnoreUpdateTime(5);
+        }
+    }
+
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
new file mode 100644
index 0000000..8b955d8
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
@@ -0,0 +1,102 @@
+
+#ifndef _PlayerbotRogueAI_H
+#define _PlayerbotRogueAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    RogueCombat,
+    RogueSpellPreventing,
+    RogueThreat,
+    RogueStealth
+};
+
+enum RoguePoisonDisplayId
+{
+    DEADLY_POISON_DISPLAYID  = 13707,
+    INSTANT_POISON_DISPLAYID = 13710,
+    WOUND_POISON_DISPLAYID   = 37278
+};
+
+enum RogueSpells
+{
+    ADRENALINE_RUSH_1               = 13750,
+    AMBUSH_1                        = 8676,
+    BACKSTAB_1                      = 53,
+    BLADE_FLURRY_1                  = 13877,
+    BLIND_1                         = 2094,
+    CHEAP_SHOT_1                    = 1833,
+    CLOAK_OF_SHADOWS_1              = 31224,
+    COLD_BLOOD_1                    = 14177,
+    DEADLY_THROW_1                  = 26679,
+    DISARM_TRAP_1                   = 1842,
+    DISMANTLE_1                     = 51722,
+    DISTRACT_1                      = 1725,
+    ENVENOM_1                       = 32645,
+    EVASION_1                       = 5277,
+    EVISCERATE_1                    = 2098,
+    EXPOSE_ARMOR_1                  = 8647,
+    FAN_OF_KNIVES_1                 = 51723,
+    FEINT_1                         = 1966,
+    GARROTE_1                       = 703,
+    GHOSTLY_STRIKE_1                = 14278,
+    GOUGE_1                         = 1776,
+    HEMORRHAGE_1                    = 16511,
+    HUNGER_FOR_BLOOD_1              = 51662,
+    KICK_1                          = 1766,
+    KIDNEY_SHOT_1                   = 408,
+    KILLING_SPREE_1                 = 51690,
+    MUTILATE_1                      = 1329,
+    PICK_LOCK_1                     = 1804,
+    PICK_POCKET_1                   = 921,
+    PREMEDITATION_1                 = 14183,
+    PREPARATION_1                   = 14185,
+    RIPOSTE_1                       = 14251,
+    RUPTURE_1                       = 1943,
+    SAP_1                           = 6770,
+    SHADOW_DANCE_1                  = 51713,
+    SHADOWSTEP_1                    = 36554,
+    SHIV_1                          = 5938,
+    SINISTER_STRIKE_1               = 1752,
+    SLICE_AND_DICE_1                = 5171,
+    SPRINT_1                        = 2983,
+    STEALTH_1                       = 1784,
+    TRICKS_OF_THE_TRADE_1           = 57934,
+    VANISH_1                        = 1856
+};
+//class Player;
+
+class PlayerbotRogueAI : PlayerbotClassAI
+{
+public:
+    PlayerbotRogueAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotRogueAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+private:
+    // COMBAT
+    uint32 SINISTER_STRIKE, BACKSTAB, GOUGE, EVASION, SPRINT, KICK, FEINT, SHIV, FAN_OF_KNIVES;
+
+    // SUBTLETY
+    uint32 SHADOWSTEP, STEALTH, VANISH, HEMORRHAGE, BLIND, SHADOW_DANCE, PICK_POCKET, CLOAK_OF_SHADOWS, TRICK_TRADE, CRIPPLING_POISON, DEADLY_POISON, MIND_NUMBING_POISON, GHOSTLY_STRIKE, DISTRACT, PREPARATION, PREMEDITATION;
+
+    // ASSASSINATION
+    uint32 EVISCERATE, SLICE_DICE, GARROTE, EXPOSE_ARMOR, AMBUSH, RUPTURE, DISMANTLE, CHEAP_SHOT, KIDNEY_SHOT, MUTILATE, ENVENOM, DEADLY_THROW;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellCombat, LastSpellSubtlety, LastSpellAssassination, Aura;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
new file mode 100644
index 0000000..3c2f55c
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
@@ -0,0 +1,556 @@
+#include "PlayerbotShamanAI.h"
+#include "ObjectAccessor.h"
+#include "SpellAuras.h"
+#include "Player.h"
+#include "Group.h"
+
+PlayerbotShamanAI::PlayerbotShamanAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // restoration
+    CHAIN_HEAL               = ai->initSpell(CHAIN_HEAL_1);
+    HEALING_WAVE             = ai->initSpell(HEALING_WAVE_1);
+    LESSER_HEALING_WAVE      = ai->initSpell(LESSER_HEALING_WAVE_1);
+    RIPTIDE                  = ai->initSpell(RIPTIDE_1);
+    ANCESTRAL_SPIRIT         = ai->initSpell(ANCESTRAL_SPIRIT_1);
+    EARTH_SHIELD             = ai->initSpell(EARTH_SHIELD_1);
+    WATER_SHIELD             = ai->initSpell(WATER_SHIELD_1);
+    EARTHLIVING_WEAPON       = ai->initSpell(EARTHLIVING_WEAPON_1);
+    TREMOR_TOTEM             = ai->initSpell(TREMOR_TOTEM_1); // totems
+    HEALING_STREAM_TOTEM     = ai->initSpell(HEALING_STREAM_TOTEM_1);
+    MANA_SPRING_TOTEM        = ai->initSpell(MANA_SPRING_TOTEM_1);
+    MANA_TIDE_TOTEM          = ai->initSpell(MANA_TIDE_TOTEM_1);
+    CURE_TOXINS              = ai->initSpell(CURE_TOXINS_1);
+    CLEANSE_SPIRIT           = ai->initSpell(CLEANSE_SPIRIT_1);
+    // enhancement
+    FOCUSED                  = 0; // Focused what?
+    STORMSTRIKE              = ai->initSpell(STORMSTRIKE_1);
+    LAVA_LASH                = ai->initSpell(LAVA_LASH_1);
+    SHAMANISTIC_RAGE         = ai->initSpell(SHAMANISTIC_RAGE_1);
+    BLOODLUST                = ai->initSpell(BLOODLUST_1);
+    HEROISM                  = ai->initSpell(HEROISM_1);
+    FERAL_SPIRIT             = ai->initSpell(FERAL_SPIRIT_1);
+    LIGHTNING_SHIELD         = ai->initSpell(LIGHTNING_SHIELD_1);
+    ROCKBITER_WEAPON         = ai->initSpell(ROCKBITER_WEAPON_1);
+    FLAMETONGUE_WEAPON       = ai->initSpell(FLAMETONGUE_WEAPON_1);
+    FROSTBRAND_WEAPON        = ai->initSpell(FROSTBRAND_WEAPON_1);
+    WINDFURY_WEAPON          = ai->initSpell(WINDFURY_WEAPON_1);
+    STONESKIN_TOTEM          = ai->initSpell(STONESKIN_TOTEM_1); // totems
+    STRENGTH_OF_EARTH_TOTEM  = ai->initSpell(STRENGTH_OF_EARTH_TOTEM_1);
+    FROST_RESISTANCE_TOTEM   = ai->initSpell(FROST_RESISTANCE_TOTEM_1);
+    FLAMETONGUE_TOTEM        = ai->initSpell(FLAMETONGUE_TOTEM_1);
+    FIRE_RESISTANCE_TOTEM    = ai->initSpell(FIRE_RESISTANCE_TOTEM_1);
+    GROUNDING_TOTEM          = ai->initSpell(GROUNDING_TOTEM_1);
+    NATURE_RESISTANCE_TOTEM  = ai->initSpell(NATURE_RESISTANCE_TOTEM_1);
+    WIND_FURY_TOTEM          = ai->initSpell(WINDFURY_TOTEM_1);
+    STONESKIN_TOTEM          = ai->initSpell(STONESKIN_TOTEM_1);
+    WRATH_OF_AIR_TOTEM       = ai->initSpell(WRATH_OF_AIR_TOTEM_1);
+    EARTH_ELEMENTAL_TOTEM    = ai->initSpell(EARTH_ELEMENTAL_TOTEM_1);
+    // elemental
+    LIGHTNING_BOLT           = ai->initSpell(LIGHTNING_BOLT_1);
+    EARTH_SHOCK              = ai->initSpell(EARTH_SHOCK_1);
+    FLAME_SHOCK              = ai->initSpell(FLAME_SHOCK_1);
+    PURGE                    = ai->initSpell(PURGE_1);
+    WIND_SHOCK               = 0; //NPC spell
+    FROST_SHOCK              = ai->initSpell(FROST_SHOCK_1);
+    CHAIN_LIGHTNING          = ai->initSpell(CHAIN_LIGHTNING_1);
+    LAVA_BURST               = ai->initSpell(LAVA_BURST_1);
+    HEX                      = ai->initSpell(HEX_1);
+    STONECLAW_TOTEM          = ai->initSpell(STONECLAW_TOTEM_1); // totems
+    SEARING_TOTEM            = ai->initSpell(SEARING_TOTEM_1);
+    FIRE_NOVA_TOTEM          = 0; // NPC only spell, check FIRE_NOVA_1
+    MAGMA_TOTEM              = ai->initSpell(MAGMA_TOTEM_1);
+    EARTHBIND_TOTEM          = ai->initSpell(EARTHBIND_TOTEM_1);
+    TOTEM_OF_WRATH           = ai->initSpell(TOTEM_OF_WRATH_1);
+    FIRE_ELEMENTAL_TOTEM     = ai->initSpell(FIRE_ELEMENTAL_TOTEM_1);
+
+    RECENTLY_BANDAGED        = 11196; // first aid check
+
+    // racial
+    GIFT_OF_THE_NAARU        = ai->initSpell(GIFT_OF_THE_NAARU_SHAMAN); // draenei
+    BLOOD_FURY               = ai->initSpell(BLOOD_FURY_SHAMAN); // orc
+    WAR_STOMP                = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING               = ai->initSpell(BERSERKING_ALL); // troll
+}
+
+PlayerbotShamanAI::~PlayerbotShamanAI() {}
+
+bool PlayerbotShamanAI::DoFirstCombatManeuver(Unit* /*pTarget*/)
+{
+    return false;
+}
+
+void PlayerbotShamanAI::HealTarget(Unit & target, uint8 hp)
+{
+    PlayerbotAI* ai = GetAI();
+    //Player *m_bot = GetPlayerBot();
+
+    if (hp < 30 && HEALING_WAVE > 0 && ai->GetManaPercent() >= 32)
+        ai->CastSpell(HEALING_WAVE, target);
+    else if (hp < 45 && LESSER_HEALING_WAVE > 0 && ai->GetManaPercent() >= 19)
+        ai->CastSpell(LESSER_HEALING_WAVE, target);
+    else if (hp < 55 && RIPTIDE > 0 && !target.HasAura(RIPTIDE, ObjectGuid::Empty) && ai->GetManaPercent() >= 21)
+        ai->CastSpell(RIPTIDE, target);
+    else if (hp < 70 && CHAIN_HEAL > 0 && ai->GetManaPercent() >= 24)
+        ai->CastSpell(CHAIN_HEAL, target);
+    if (CURE_TOXINS > 0 && ai->GetCombatOrder() != PlayerbotAI::ORDERS_NODISPEL)
+    {
+        uint32 DISPEL = CLEANSE_SPIRIT > 0 ? CLEANSE_SPIRIT : CURE_TOXINS;
+        Unit::AuraMap const& auras = target.GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura *aura = itr->second;
+            if (aura->IsPassive()) continue;
+            if (aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+            if (aura->GetId() == 64844 || //Divine Hymn
+                aura->GetId() == 6346) // Fear Ward
+                continue;
+            DispelType dispel = DispelType(aura->GetSpellInfo()->Dispel);
+            if (dispel == DISPEL_POISON || dispel == DISPEL_DISEASE ||
+                (DISPEL == CLEANSE_SPIRIT && dispel == DISPEL_CURSE))
+            {
+                AuraApplication *aurApp = aura->GetApplicationOfTarget(target.GetGUID());
+                if (!aurApp)
+                    continue;
+                if (!aurApp->IsPositive())
+                    ai->CastSpell(DISPEL, target);
+            }
+        }
+    }
+    // end HealTarget
+}
+
+void PlayerbotShamanAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(LIGHTNING_BOLT);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+
+    // Heal myself
+    if (ai->GetHealthPercent() < 30 && ai->GetManaPercent() >= 32)
+        ai->CastSpell(HEALING_WAVE);
+    else if (ai->GetHealthPercent() < 50 && ai->GetManaPercent() >= 19)
+        ai->CastSpell(LESSER_HEALING_WAVE);
+    else if (ai->GetHealthPercent() < 70)
+        HealTarget (*m_bot, ai->GetHealthPercent());
+
+    // Heal master
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+    if (GetMaster()->IsAlive())
+    {
+        if (masterHP < 30 && ai->GetManaPercent() >= 32)
+            ai->CastSpell(HEALING_WAVE, *(GetMaster()));
+        else if (masterHP < 70)
+            HealTarget (*GetMaster(), masterHP);
+    }
+
+    // Heal group
+    if (m_group)
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = ObjectAccessor::FindPlayer(itr->guid);
+            if (!m_groupMember || !m_groupMember->IsAlive())
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth() * 100 / m_groupMember->GetMaxHealth();
+            if (memberHP < 30)
+                HealTarget(*m_groupMember, memberHP);
+        }
+    }
+
+    // Damage Spells
+
+    switch (SpellSequence)
+    {
+        case SPELL_ENHANCEMENT:
+            if (STRENGTH_OF_EARTH_TOTEM > 0 && LastSpellEnhancement == 1 && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(STRENGTH_OF_EARTH_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (STONESKIN_TOTEM > 0 && LastSpellEnhancement == 5 && (!m_bot->HasAura(STONESKIN_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(STONESKIN_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FOCUSED > 0 && LastSpellEnhancement == 2)
+            {
+                ai->CastSpell(FOCUSED, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FROST_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 10 && (!m_bot->HasAura(FROST_RESISTANCE_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(TOTEM_OF_WRATH, ObjectGuid::Empty)) && (!m_bot->HasAura(FLAMETONGUE_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FROST_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FLAMETONGUE_TOTEM > 0 && LastSpellEnhancement == 15 && (!m_bot->HasAura(FLAMETONGUE_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(TOTEM_OF_WRATH, ObjectGuid::Empty)) && (!m_bot->HasAura(FROST_RESISTANCE_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell(FLAMETONGUE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FIRE_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 20 && (!m_bot->HasAura(FIRE_RESISTANCE_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(HEALING_STREAM_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(MANA_SPRING_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FIRE_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (GROUNDING_TOTEM > 0 && LastSpellEnhancement == 25 && (!m_bot->HasAura(GROUNDING_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(WIND_FURY_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(GROUNDING_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (NATURE_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 30 && (!m_bot->HasAura(NATURE_RESISTANCE_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(GROUNDING_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(WIND_FURY_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(NATURE_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (WIND_FURY_TOTEM > 0 && LastSpellEnhancement == 35 && (!m_bot->HasAura(WIND_FURY_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(GROUNDING_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 11)
+            {
+                ai->CastSpell(WIND_FURY_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (STORMSTRIKE > 0 && LastSpellEnhancement == 4 && (!pTarget->HasAura(STORMSTRIKE, ObjectGuid::Empty)) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(STORMSTRIKE, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (LAVA_LASH > 0 && LastSpellEnhancement == 6 && ai->GetManaPercent() >= 4)
+            {
+                ai->CastSpell(LAVA_LASH, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FERAL_SPIRIT > 0 && LastSpellEnhancement == 7 && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell(FERAL_SPIRIT);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (WRATH_OF_AIR_TOTEM > 0 && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(GROUNDING_TOTEM, ObjectGuid::Empty)) && LastSpellEnhancement == 40)
+            {
+                ai->CastSpell(WRATH_OF_AIR_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (EARTH_ELEMENTAL_TOTEM > 0 && LastSpellEnhancement == 45 && ai->GetManaPercent() >= 24)
+            {
+                ai->CastSpell(EARTH_ELEMENTAL_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (BLOODLUST > 0 && LastSpellEnhancement == 8 && (!GetMaster()->HasAura(BLOODLUST, ObjectGuid::Empty)) && ai->GetManaPercent() >= 26)
+            {
+                ai->CastSpell(BLOODLUST);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (HEROISM > 0 && LastSpellEnhancement == 10 && (!GetMaster()->HasAura(HEROISM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 26)
+            {
+                ai->CastSpell(HEROISM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (SHAMANISTIC_RAGE > 0 && (!m_bot->HasAura(SHAMANISTIC_RAGE, ObjectGuid::Empty)) && LastSpellEnhancement == 11)
+            {
+                ai->CastSpell(SHAMANISTIC_RAGE, *m_bot);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (LastSpellEnhancement > 50)
+            {
+                LastSpellEnhancement = 1;
+                SpellSequence = SPELL_RESTORATION;
+                break;
+            }
+            LastSpellEnhancement = LastSpellEnhancement + 1;
+        //SpellSequence = SPELL_RESTORATION;
+        //break;
+
+        case SPELL_RESTORATION:
+            if (HEALING_STREAM_TOTEM > 0 && LastSpellRestoration < 3 && ai->GetHealthPercent() < 50 && (!m_bot->HasAura(HEALING_STREAM_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(MANA_SPRING_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 4)
+            {
+                ai->CastSpell(HEALING_STREAM_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration + 1;
+                break;
+            }
+            else if (MANA_SPRING_TOTEM > 0 && LastSpellRestoration < 4 && (!m_bot->HasAura(MANA_SPRING_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(HEALING_STREAM_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(MANA_SPRING_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration + 1;
+                break;
+            }
+            else if (MANA_TIDE_TOTEM > 0 && LastSpellRestoration < 5 && ai->GetManaPercent() < 50 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(MANA_TIDE_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration + 1;
+                break;
+            }
+            /*else if (TREMOR_TOTEM > 0 && LastSpellRestoration < 6 && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, 0)) && ai->GetManaPercent() >= 2)
+               {
+                ai->CastSpell(TREMOR_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration +1;
+                break;
+               }*/
+            else if (LastSpellRestoration > 6)
+            {
+                LastSpellRestoration = 0;
+                SpellSequence = SPELL_ELEMENTAL;
+                break;
+            }
+            LastSpellRestoration = LastSpellRestoration + 1;
+        //SpellSequence = SPELL_ELEMENTAL;
+        //break;
+
+        case SPELL_ELEMENTAL:
+            if (LIGHTNING_BOLT > 0 && LastSpellElemental == 1 && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(LIGHTNING_BOLT, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (SEARING_TOTEM > 0 && LastSpellElemental == 2 && (!pTarget->HasAura(SEARING_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(TOTEM_OF_WRATH, ObjectGuid::Empty)) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(SEARING_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (STONECLAW_TOTEM > 0 && ai->GetHealthPercent() < 51 && LastSpellElemental == 3 && (!pTarget->HasAura(STONECLAW_TOTEM, ObjectGuid::Empty)) && (!pTarget->HasAura(EARTHBIND_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(STONECLAW_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FLAME_SHOCK > 0 && LastSpellElemental == 4 && (!pTarget->HasAura(FLAME_SHOCK, ObjectGuid::Empty)) && ai->GetManaPercent() >= 22)
+            {
+                ai->CastSpell(FLAME_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (LAVA_BURST > 0 && LastSpellElemental == 5 && (pTarget->HasAura(FLAME_SHOCK, ObjectGuid::Empty)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(LAVA_BURST, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (MAGMA_TOTEM > 0 && LastSpellElemental == 6 && (!m_bot->HasAura(TOTEM_OF_WRATH, ObjectGuid::Empty)) && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(MAGMA_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (EARTHBIND_TOTEM > 0 && LastSpellElemental == 7 && (!pTarget->HasAura(EARTHBIND_TOTEM, ObjectGuid::Empty)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, ObjectGuid::Empty)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(EARTHBIND_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (EARTH_SHOCK > 0 && LastSpellElemental == 8 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(EARTH_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (PURGE > 0 && LastSpellElemental == 9 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(PURGE, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (WIND_SHOCK > 0 && LastSpellElemental == 10 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(WIND_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FIRE_NOVA_TOTEM > 0 && LastSpellElemental == 11 && ai->GetManaPercent() >= 33)
+            {
+                ai->CastSpell(FIRE_NOVA_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FROST_SHOCK > 0 && LastSpellElemental == 12 && (!pTarget->HasAura(FROST_SHOCK, ObjectGuid::Empty)) && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FROST_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (CHAIN_LIGHTNING > 0 && LastSpellElemental == 13 && ai->GetManaPercent() >= 33)
+            {
+                ai->CastSpell(CHAIN_LIGHTNING, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (TOTEM_OF_WRATH > 0 && LastSpellElemental == 14 && (!m_bot->HasAura(TOTEM_OF_WRATH, ObjectGuid::Empty)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(TOTEM_OF_WRATH);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FIRE_ELEMENTAL_TOTEM > 0 && LastSpellElemental == 15 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FIRE_ELEMENTAL_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            /*else if (HEX > 0 && LastSpellElemental == 16 && (!pTarget->HasAura(HEX, 0)) && ai->GetManaPercent() >= 3)
+               {
+                ai->CastSpell(HEX);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+               }*/
+            else if (LastSpellElemental > 16)
+            {
+                LastSpellElemental = 1;
+                SpellSequence = SPELL_ENHANCEMENT;
+                break;
+            }
+            else
+            {
+                LastSpellElemental = LastSpellElemental + 1;
+                SpellSequence = SPELL_ENHANCEMENT;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotShamanAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    SpellSequence = SPELL_ENHANCEMENT;
+
+    // buff master with EARTH_SHIELD
+    if (EARTH_SHIELD > 0)
+        (!GetMaster()->HasAura(EARTH_SHIELD, ObjectGuid::Empty) && ai->CastSpell(EARTH_SHIELD, *(GetMaster())));
+
+    // buff myself with WATER_SHIELD, LIGHTNING_SHIELD
+    if (WATER_SHIELD > 0)
+        (!m_bot->HasAura(WATER_SHIELD, ObjectGuid::Empty) && !m_bot->HasAura(LIGHTNING_SHIELD, ObjectGuid::Empty) && ai->CastSpell(WATER_SHIELD, *m_bot));
+    else if (LIGHTNING_SHIELD > 0)
+        (!m_bot->HasAura(LIGHTNING_SHIELD, ObjectGuid::Empty) && !m_bot->HasAura(WATER_SHIELD, ObjectGuid::Empty) && ai->CastSpell(LIGHTNING_SHIELD, *m_bot));
+/*
+       // buff myself weapon
+       if (ROCKBITER_WEAPON > 0)
+            (!m_bot->HasAura(ROCKBITER_WEAPON, 0) && !m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(WINDFURY_WEAPON, 0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, 0) && !m_bot->HasAura(FROSTBRAND_WEAPON, 0) && ai->CastSpell(ROCKBITER_WEAPON,*m_bot) );
+       else if (EARTHLIVING_WEAPON > 0)
+            (!m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, 0) && !m_bot->HasAura(FROSTBRAND_WEAPON, 0) && !m_bot->HasAura(ROCKBITER_WEAPON, 0) && ai->CastSpell(WINDFURY_WEAPON,*m_bot) );
+       else if (WINDFURY_WEAPON > 0)
+            (!m_bot->HasAura(WINDFURY_WEAPON, 0) && !m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, 0) && !m_bot->HasAura(FROSTBRAND_WEAPON, 0) && !m_bot->HasAura(ROCKBITER_WEAPON, 0) && ai->CastSpell(WINDFURY_WEAPON,*m_bot) );
+       else if (FLAMETONGUE_WEAPON > 0)
+            (!m_bot->HasAura(FLAMETONGUE_WEAPON, 0) && !m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(WINDFURY_WEAPON, 0) && !m_bot->HasAura(FROSTBRAND_WEAPON, 0) && !m_bot->HasAura(ROCKBITER_WEAPON, 0) && ai->CastSpell(FLAMETONGUE_WEAPON,*m_bot) );
+       else if (FROSTBRAND_WEAPON > 0)
+            (!m_bot->HasAura(FROSTBRAND_WEAPON, 0) && !m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(WINDFURY_WEAPON, 0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, 0) && !m_bot->HasAura(ROCKBITER_WEAPON, 0) && ai->CastSpell(FROSTBRAND_WEAPON,*m_bot) );
+ */
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, ObjectGuid::Empty) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // heal master's group
+    if (GetMaster()->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() ||
+                tPlayer->GetMap() != m_bot->GetMap() || tPlayer->GetDistance(m_bot) > 30)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == GetMaster())
+                continue;
+
+            // heal
+            (HealTarget(*tPlayer, tPlayer->GetHealth() * 100 / tPlayer->GetMaxHealth()));
+        }
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
new file mode 100644
index 0000000..72324ed
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
@@ -0,0 +1,119 @@
+#ifndef _PLAYERBOTSHAMANAI_H
+#define _PLAYERBOTSHAMANAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    SPELL_ENHANCEMENT,
+    SPELL_RESTORATION,
+    SPELL_ELEMENTAL
+};
+
+enum
+{
+    ANCESTRAL_SPIRIT_1              = 2008,
+    ASTRAL_RECALL_1                 = 556,
+    BLOODLUST_1                     = 2825,
+    CALL_OF_THE_ANCESTORS_1         = 66843,
+    CALL_OF_THE_ELEMENTS_1          = 66842,
+    CALL_OF_THE_SPIRITS_1           = 66844,
+    CHAIN_HEAL_1                    = 1064,
+    CHAIN_LIGHTNING_1               = 421,
+    CHAINED_HEAL_1                  = 70809,
+    CLEANSE_SPIRIT_1                = 51886,
+    CLEANSING_TOTEM_1               = 8170,
+    CURE_TOXINS_1                   = 526,
+    EARTH_ELEMENTAL_TOTEM_1         = 2062,
+    EARTH_SHIELD_1                  = 974,
+    EARTH_SHOCK_1                   = 8042,
+    EARTHBIND_TOTEM_1               = 2484,
+    EARTHLIVING_WEAPON_1            = 51730,
+    ELEMENTAL_MASTERY_1             = 16166,
+    FERAL_SPIRIT_1                  = 51533,
+    FIRE_ELEMENTAL_TOTEM_1          = 2894,
+    FIRE_NOVA_1                     = 1535,
+    FIRE_RESISTANCE_TOTEM_1         = 8184,
+    FLAME_SHOCK_1                   = 8050,
+    FLAMETONGUE_TOTEM_1             = 8227,
+    FLAMETONGUE_WEAPON_1            = 8024,
+    FROST_RESISTANCE_TOTEM_1        = 8181,
+    FROST_SHOCK_1                   = 8056,
+    FROSTBRAND_WEAPON_1             = 8033,
+    GHOST_WOLF_1                    = 2645,
+    GROUNDING_TOTEM_1               = 8177,
+    HEALING_STREAM_TOTEM_1          = 5394,
+    HEALING_WAVE_1                  = 331,
+    HEROISM_1                       = 32182,
+    HEX_1                           = 51514,
+    LAVA_BURST_1                    = 51505,
+    LAVA_LASH_1                     = 60103,
+    LESSER_HEALING_WAVE_1           = 8004,
+    LIGHTNING_BOLT_1                = 403,
+    LIGHTNING_SHIELD_1              = 324,
+    MAGMA_TOTEM_1                   = 8190,
+    MANA_SPRING_TOTEM_1             = 5675,
+    MANA_TIDE_TOTEM_1               = 16190,
+    NATURE_RESISTANCE_TOTEM_1       = 10595,
+    NATURES_SWIFTNESS_SHAMAN_1      = 16188,
+    PURGE_1                         = 370,
+    RIPTIDE_1                       = 61295,
+    ROCKBITER_WEAPON_1              = 8017,
+    SEARING_TOTEM_1                 = 3599,
+    SENTRY_TOTEM_1                  = 6495,
+    SHAMANISTIC_RAGE_1              = 30823,
+    STONECLAW_TOTEM_1               = 5730,
+    STONESKIN_TOTEM_1               = 8071,
+    STORMSTRIKE_1                   = 17364,
+    STRENGTH_OF_EARTH_TOTEM_1       = 8075,
+    THUNDERSTORM_1                  = 51490,
+    TIDAL_FORCE_1                   = 55198,
+    TOTEM_OF_WRATH_1                = 30706,
+    TOTEMIC_RECALL_1                = 36936,
+    TREMOR_TOTEM_1                  = 8143,
+    WATER_BREATHING_1               = 131,
+    WATER_SHIELD_1                  = 52127,
+    WATER_WALKING_1                 = 546,
+    WIND_SHEAR_1                    = 57994,
+    WINDFURY_TOTEM_1                = 8512,
+    WINDFURY_WEAPON_1               = 8232,
+    WRATH_OF_AIR_TOTEM_1            = 3738
+};
+//class Player;
+
+class PlayerbotShamanAI : PlayerbotClassAI
+{
+public:
+    PlayerbotShamanAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotShamanAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+private:
+    // Heals the target based off its hps
+    void HealTarget (Unit& target, uint8 hp);
+
+    // ENHANCEMENT
+    uint32 ROCKBITER_WEAPON, STONESKIN_TOTEM, LIGHTNING_SHIELD, FLAMETONGUE_WEAPON, STRENGTH_OF_EARTH_TOTEM, FOCUSED, FROSTBRAND_WEAPON, FROST_RESISTANCE_TOTEM, FLAMETONGUE_TOTEM, FIRE_RESISTANCE_TOTEM, WINDFURY_WEAPON, GROUNDING_TOTEM, NATURE_RESISTANCE_TOTEM, WIND_FURY_TOTEM, STORMSTRIKE, LAVA_LASH, SHAMANISTIC_RAGE, WRATH_OF_AIR_TOTEM, EARTH_ELEMENTAL_TOTEM, BLOODLUST, HEROISM, FERAL_SPIRIT;
+
+    // RESTORATION
+    uint32 HEALING_WAVE, LESSER_HEALING_WAVE, ANCESTRAL_SPIRIT, TREMOR_TOTEM, HEALING_STREAM_TOTEM, MANA_SPRING_TOTEM, CHAIN_HEAL, MANA_TIDE_TOTEM, EARTH_SHIELD, WATER_SHIELD, EARTHLIVING_WEAPON, RIPTIDE, CURE_TOXINS, CLEANSE_SPIRIT;
+
+    // ELEMENTAL
+    uint32 LIGHTNING_BOLT, EARTH_SHOCK, STONECLAW_TOTEM, FLAME_SHOCK, SEARING_TOTEM, PURGE, FIRE_NOVA_TOTEM, WIND_SHOCK, FROST_SHOCK, MAGMA_TOTEM, CHAIN_LIGHTNING, TOTEM_OF_WRATH, FIRE_ELEMENTAL_TOTEM, LAVA_BURST, EARTHBIND_TOTEM, HEX;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellEnhancement, LastSpellRestoration, LastSpellElemental;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
new file mode 100644
index 0000000..ed0a557
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
@@ -0,0 +1,570 @@
+#include "PlayerbotWarlockAI.h"
+#include "Player.h"
+#include "Pet.h"
+
+PlayerbotWarlockAI::PlayerbotWarlockAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // DESTRUCTION
+    SHADOW_BOLT           = ai->initSpell(SHADOW_BOLT_1);
+    IMMOLATE              = ai->initSpell(IMMOLATE_1);
+    INCINERATE            = ai->initSpell(INCINERATE_1);
+    SEARING_PAIN          = ai->initSpell(SEARING_PAIN_1);
+    CONFLAGRATE           = ai->initSpell(CONFLAGRATE_1);
+    SHADOWFURY            = ai->initSpell(SHADOWFURY_1);
+    CHAOS_BOLT            = ai->initSpell(CHAOS_BOLT_1);
+    SHADOWFLAME           = ai->initSpell(SHADOWFLAME_1);
+    HELLFIRE              = ai->initSpell(HELLFIRE_1);
+    RAIN_OF_FIRE          = ai->initSpell(RAIN_OF_FIRE_1);
+    SOUL_FIRE             = ai->initSpell(SOUL_FIRE_1); // soul shard spells
+    SHADOWBURN            = ai->initSpell(SHADOWBURN_1);
+    // CURSE
+    CURSE_OF_WEAKNESS     = ai->initSpell(CURSE_OF_WEAKNESS_1);
+    CURSE_OF_THE_ELEMENTS = ai->initSpell(CURSE_OF_THE_ELEMENTS_1);
+    CURSE_OF_AGONY        = ai->initSpell(CURSE_OF_AGONY_1);
+    CURSE_OF_EXHAUSTION   = ai->initSpell(CURSE_OF_EXHAUSTION_1);
+    CURSE_OF_TONGUES      = ai->initSpell(CURSE_OF_TONGUES_1);
+    CURSE_OF_DOOM         = ai->initSpell(CURSE_OF_DOOM_1);
+    // AFFLICTION
+    CORRUPTION            = ai->initSpell(CORRUPTION_1);
+    DRAIN_SOUL            = ai->initSpell(DRAIN_SOUL_1);
+    DRAIN_LIFE            = ai->initSpell(DRAIN_LIFE_1);
+    DRAIN_MANA            = ai->initSpell(DRAIN_MANA_1);
+    LIFE_TAP              = ai->initSpell(LIFE_TAP_1);
+    UNSTABLE_AFFLICTION   = ai->initSpell(UNSTABLE_AFFLICTION_1);
+    HAUNT                 = ai->initSpell(HAUNT_1);
+    SEED_OF_CORRUPTION    = ai->initSpell(SEED_OF_CORRUPTION_1);
+    DARK_PACT             = ai->initSpell(DARK_PACT_1);
+    HOWL_OF_TERROR        = ai->initSpell(HOWL_OF_TERROR_1);
+    FEAR                  = ai->initSpell(FEAR_1);
+    // DEMONOLOGY
+    DEMON_SKIN            = ai->initSpell(DEMON_SKIN_1);
+    DEMON_ARMOR           = ai->initSpell(DEMON_ARMOR_1);
+    DEMONIC_EMPOWERMENT   = ai->initSpell(DEMONIC_EMPOWERMENT_1);
+    FEL_ARMOR             = ai->initSpell(FEL_ARMOR_1);
+    SHADOW_WARD           = ai->initSpell(SHADOW_WARD_1);
+    SOULSHATTER           = ai->initSpell(SOULSHATTER_1);
+    SOUL_LINK             = ai->initSpell(SOUL_LINK_1);
+    SOUL_LINK_AURA        = 25228; // dummy aura applied, after spell SOUL_LINK
+    HEALTH_FUNNEL         = ai->initSpell(HEALTH_FUNNEL_1);
+    DETECT_INVISIBILITY   = ai->initSpell(DETECT_INVISIBILITY_1);
+    CREATE_FIRESTONE      = ai->initSpell(CREATE_FIRESTONE_1);
+    CREATE_HEALTHSTONE    = ai->initSpell(CREATE_HEALTHSTONE_1);
+    CREATE_SOULSTONE      = ai->initSpell(CREATE_SOULSTONE_1);
+    // demon summon
+    SUMMON_IMP            = ai->initSpell(SUMMON_IMP_1);
+    SUMMON_VOIDWALKER     = ai->initSpell(SUMMON_VOIDWALKER_1);
+    SUMMON_SUCCUBUS       = ai->initSpell(SUMMON_SUCCUBUS_1);
+    SUMMON_FELHUNTER      = ai->initSpell(SUMMON_FELHUNTER_1);
+    SUMMON_FELGUARD       = ai->initSpell(SUMMON_FELGUARD_1);
+    // demon skills should be initialized on demons
+    BLOOD_PACT            = 0; // imp skill
+    CONSUME_SHADOWS       = 0; // voidwalker skill
+    FEL_INTELLIGENCE      = 0; // felhunter skill
+
+    RECENTLY_BANDAGED     = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT        = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES); // blood elf
+    ESCAPE_ARTIST         = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    BLOOD_FURY            = ai->initSpell(BLOOD_FURY_WARLOCK); // orc
+    WILL_OF_THE_FORSAKEN  = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+
+    m_lastDemon = 0;
+    m_demonOfChoice = DEMON_IMP;
+    m_isTempImp = false;
+}
+
+PlayerbotWarlockAI::~PlayerbotWarlockAI() {}
+
+bool PlayerbotWarlockAI::DoFirstCombatManeuver(Unit* /*pTarget*/)
+{
+    return false;
+}
+
+void PlayerbotWarlockAI::DoNextCombatManeuver(Unit* pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+        {
+            if (SHADOW_BOLT > 0)
+                ai->CastSpell(SHADOW_BOLT);
+            return;
+        }
+        default:
+            break;
+    }
+
+    // ------- Non Duel combat ----------
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->GetVictim();
+    Pet *pet = m_bot->GetPet();
+
+    // Empower demon
+    if (pet && DEMONIC_EMPOWERMENT)
+        ai->CastSpell(DEMONIC_EMPOWERMENT);
+
+    // Use voidwalker sacrifice on low health if possible
+    if (ai->GetHealthPercent() < 50)
+        if (pet && pet->GetEntry() == DEMON_VOIDWALKER && SACRIFICE && !m_bot->HasAura(SACRIFICE))
+            ai->CastPetSpell(SACRIFICE);
+
+    // Use healthstone
+    if (ai->GetHealthPercent() < 30)
+    {
+        Item* healthStone = ai->FindConsumable(HEALTHSTONE_DISPLAYID);
+        if (healthStone)
+            ai->UseItem(healthStone);
+    }
+
+    // Damage Spells
+    switch (SpellSequence)
+    {
+        case SPELL_CURSES:
+            if (CURSE_OF_AGONY && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(SHADOWFLAME) && LastSpellCurse < 1)
+            {
+                ai->CastSpell(CURSE_OF_AGONY, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            else if (CURSE_OF_THE_ELEMENTS && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(CURSE_OF_WEAKNESS) && LastSpellCurse < 2)
+            {
+                ai->CastSpell(CURSE_OF_THE_ELEMENTS, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            else if (CURSE_OF_WEAKNESS && !pTarget->HasAura(CURSE_OF_WEAKNESS) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS) && LastSpellCurse < 3)
+            {
+                ai->CastSpell(CURSE_OF_WEAKNESS, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            else if (CURSE_OF_TONGUES && !pTarget->HasAura(CURSE_OF_TONGUES) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(CURSE_OF_WEAKNESS) && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS) && LastSpellCurse < 4)
+            {
+                ai->CastSpell(CURSE_OF_TONGUES, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            LastSpellCurse = 0;
+        //SpellSequence = SPELL_AFFLICTION;
+        //break;
+
+        case SPELL_AFFLICTION:
+            if (LIFE_TAP && LastSpellAffliction < 1 && ai->GetManaPercent() <= 50 && ai->GetHealthPercent() > 50)
+            {
+                ai->CastSpell(LIFE_TAP, *m_bot);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (CORRUPTION && !pTarget->HasAura(CORRUPTION) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(SEED_OF_CORRUPTION) && LastSpellAffliction < 2)
+            {
+                ai->CastSpell(CORRUPTION, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (DRAIN_SOUL && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.40 && !pTarget->HasAura(DRAIN_SOUL) && LastSpellAffliction < 3)
+            {
+                ai->CastSpell(DRAIN_SOUL, *pTarget);
+                //ai->SetIgnoreUpdateTime(15);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (DRAIN_LIFE && LastSpellAffliction < 4 && !pTarget->HasAura(DRAIN_SOUL) && !pTarget->HasAura(SEED_OF_CORRUPTION) && !pTarget->HasAura(DRAIN_LIFE) && !pTarget->HasAura(DRAIN_MANA) && ai->GetHealthPercent() <= 70)
+            {
+                ai->CastSpell(DRAIN_LIFE, *pTarget);
+                //ai->SetIgnoreUpdateTime(5);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (UNSTABLE_AFFLICTION && LastSpellAffliction < 5 && !pTarget->HasAura(UNSTABLE_AFFLICTION) && !pTarget->HasAura(SHADOWFLAME))
+            {
+                ai->CastSpell(UNSTABLE_AFFLICTION, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (HAUNT && LastSpellAffliction < 6 && !pTarget->HasAura(HAUNT))
+            {
+                ai->CastSpell(HAUNT, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (SEED_OF_CORRUPTION && !pTarget->HasAura(SEED_OF_CORRUPTION) && LastSpellAffliction < 7)
+            {
+                ai->CastSpell(SEED_OF_CORRUPTION, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (HOWL_OF_TERROR && !pTarget->HasAura(HOWL_OF_TERROR) && ai->GetAttackerCount() > 3 && LastSpellAffliction < 8)
+            {
+                ai->CastSpell(HOWL_OF_TERROR, *pTarget);
+                ai->TellMaster("casting howl of terror!");
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (FEAR && !pTarget->HasAura(FEAR) && pVictim == m_bot && ai->GetAttackerCount() >= 2 && LastSpellAffliction < 9)
+            {
+                ai->CastSpell(FEAR, *pTarget);
+                //ai->TellMaster("casting fear!");
+                //ai->SetIgnoreUpdateTime(1.5);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if ((pet)
+                     && (DARK_PACT > 0 && ai->GetManaPercent() <= 50 && LastSpellAffliction < 10 && pet->GetPower(POWER_MANA) > 0))
+            {
+                ai->CastSpell(DARK_PACT, *m_bot);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            LastSpellAffliction = 0;
+        //SpellSequence = SPELL_DESTRUCTION;
+        //break;
+
+        case SPELL_DESTRUCTION:
+            if (SHADOWFURY && LastSpellDestruction < 1 && !pTarget->HasAura(SHADOWFURY))
+            {
+                ai->CastSpell(SHADOWFURY, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SHADOW_BOLT && LastSpellDestruction < 2)
+            {
+                ai->CastSpell(SHADOW_BOLT, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (RAIN_OF_FIRE && LastSpellDestruction < 3 && ai->GetAttackerCount() >= 3)
+            {
+                ai->CastSpell(RAIN_OF_FIRE, *pTarget);
+                //ai->TellMaster("casting rain of fire!");
+                //ai->SetIgnoreUpdateTime(8);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SHADOWFLAME && !pTarget->HasAura(SHADOWFLAME) && LastSpellDestruction < 4)
+            {
+                ai->CastSpell(SHADOWFLAME, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (IMMOLATE && !pTarget->HasAura(IMMOLATE) && !pTarget->HasAura(SHADOWFLAME) && LastSpellDestruction < 5)
+            {
+                ai->CastSpell(IMMOLATE, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (CONFLAGRATE && LastSpellDestruction < 6)
+            {
+                ai->CastSpell(CONFLAGRATE, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (INCINERATE && LastSpellDestruction < 7)
+            {
+                ai->CastSpell(INCINERATE, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SEARING_PAIN && LastSpellDestruction < 8)
+            {
+                ai->CastSpell(SEARING_PAIN, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SOUL_FIRE && LastSpellDestruction < 9)
+            {
+                ai->CastSpell(SOUL_FIRE, *pTarget);
+                //ai->SetIgnoreUpdateTime(6);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (CHAOS_BOLT && LastSpellDestruction < 10)
+            {
+                ai->CastSpell(CHAOS_BOLT, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SHADOWBURN && LastSpellDestruction < 11 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.20 && !pTarget->HasAura(SHADOWBURN))
+            {
+                ai->CastSpell(SHADOWBURN, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (HELLFIRE && LastSpellDestruction < 12 && !m_bot->HasAura(HELLFIRE) && ai->GetAttackerCount() >= 5 && ai->GetHealthPercent() >= 50)
+            {
+                ai->CastSpell(HELLFIRE);
+                ai->TellMaster("casting hellfire!");
+                //ai->SetIgnoreUpdateTime(15);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else
+            {
+                LastSpellDestruction = 0;
+                SpellSequence = SPELL_CURSES;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotWarlockAI::DoNonCombatActions()
+{
+    SpellSequence = SPELL_CURSES;
+
+    PlayerbotAI *ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!ai || !m_bot)
+        return;
+
+    Pet *pet = m_bot->GetPet();
+
+    // Initialize pet spells
+    if (pet && pet->GetEntry() != m_lastDemon)
+    {
+        switch (pet->GetEntry())
+        {
+            case DEMON_IMP:
+            {
+                BLOOD_PACT       = ai->initPetSpell(BLOOD_PACT_ICON);
+                FIREBOLT         = ai->initPetSpell(FIREBOLT_ICON);
+                FIRE_SHIELD      = ai->initPetSpell(FIRE_SHIELD_ICON);
+                break;
+            }
+            case DEMON_VOIDWALKER:
+            {
+                CONSUME_SHADOWS  = ai->initPetSpell(CONSUME_SHADOWS_ICON);
+                SACRIFICE        = ai->initPetSpell(SACRIFICE_ICON);
+                SUFFERING        = ai->initPetSpell(SUFFERING_ICON);
+                TORMENT          = ai->initPetSpell(TORMENT_ICON);
+                break;
+            }
+            case DEMON_SUCCUBUS:
+            {
+                LASH_OF_PAIN     = ai->initPetSpell(LASH_OF_PAIN_ICON);
+                SEDUCTION        = ai->initPetSpell(SEDUCTION_ICON);
+                SOOTHING_KISS    = ai->initPetSpell(SOOTHING_KISS_ICON);
+                break;
+            }
+            case DEMON_FELHUNTER:
+            {
+                DEVOUR_MAGIC     = ai->initPetSpell(DEVOUR_MAGIC_ICON);
+                FEL_INTELLIGENCE = ai->initPetSpell(FEL_INTELLIGENCE_ICON);
+                SHADOW_BITE      = ai->initPetSpell(SHADOW_BITE_ICON);
+                SPELL_LOCK       = ai->initPetSpell(SPELL_LOCK_ICON);
+                break;
+            }
+            case DEMON_FELGUARD:
+            {
+                ANGUISH          = ai->initPetSpell(ANGUISH_ICON);
+                CLEAVE           = ai->initPetSpell(CLEAVE_ICON);
+                INTERCEPT        = ai->initPetSpell(INTERCEPT_ICON);
+                break;
+            }
+        }
+
+        m_lastDemon = pet->GetEntry();
+
+        if (!m_isTempImp)
+            m_demonOfChoice = pet->GetEntry();
+    }
+
+    // Destroy extra soul shards
+    uint8 shardCount = m_bot->GetItemCount(SOUL_SHARD, false, NULL);
+    uint8 freeSpace = ai->GetFreeBagSpace();
+    if (shardCount > MAX_SHARD_COUNT || (freeSpace == 0 && shardCount > 1))
+        m_bot->DestroyItemCount(SOUL_SHARD, shardCount > MAX_SHARD_COUNT ? shardCount - MAX_SHARD_COUNT : 1, true, false);
+
+    // buff myself DEMON_SKIN, DEMON_ARMOR, FEL_ARMOR
+    if (FEL_ARMOR)
+    {
+        if (ai->SelfBuff(FEL_ARMOR))
+            return;
+    }
+    else if (DEMON_ARMOR)
+    {
+        if (ai->SelfBuff(DEMON_ARMOR))
+            return;
+    }
+    else if (DEMON_SKIN)
+        if (ai->SelfBuff(DEMON_SKIN))
+            return;
+
+    // healthstone creation
+    if (CREATE_HEALTHSTONE && shardCount > 0)
+    {
+        Item* const healthStone = ai->FindConsumable(HEALTHSTONE_DISPLAYID);
+        if (!healthStone && ai->CastSpell(CREATE_HEALTHSTONE))
+            return;
+    }
+
+    // soulstone creation and use
+    if (CREATE_SOULSTONE)
+    {
+        Item* soulStone = ai->FindConsumable(SOULSTONE_DISPLAYID);
+        if (!soulStone)
+        {
+            if (shardCount > 0 && ai->CastSpell(CREATE_SOULSTONE))
+                return;
+        }
+        else
+        {
+            uint32 soulStoneSpell = soulStone->GetTemplate()->Spells[0].SpellId;
+            Player * master = GetMaster();
+            if (!master->HasAura(soulStoneSpell))
+            {
+                ai->UseItem(soulStone, master);
+                return;
+            }
+        }
+    }
+
+    // firestone creation and use
+    Item* const weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        Item* const stone = ai->FindConsumable(FIRESTONE_DISPLAYID);
+        if (!stone)
+        {
+            if (CREATE_FIRESTONE && shardCount > 0 && ai->CastSpell(CREATE_FIRESTONE))
+                return;
+        }
+        else
+        {
+            ai->UseItem(stone, EQUIPMENT_SLOT_MAINHAND);
+            return;
+        }
+    }
+
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    // mana check
+    if (pet && DARK_PACT && pet->GetPower(POWER_MANA) > 0 && ai->GetManaPercent() <= 50)
+        if (ai->CastSpell(DARK_PACT, *m_bot))
+            return;
+
+    if (LIFE_TAP && ai->GetManaPercent() <= 50 && ai->GetHealthPercent() > 50)
+        if (ai->CastSpell(LIFE_TAP, *m_bot))
+            return;
+
+    if (ai->GetManaPercent() < 25)
+    {
+        Item* pItem = ai->FindDrink();
+        if (pItem)
+        {
+            ai->TellMaster("I could use a drink.");
+            ai->UseItem(pItem);
+            return;
+        }
+    }
+
+    // hp check
+    if (ai->GetHealthPercent() < 30)
+    {
+        Item* pItem = ai->FindFood();
+        if (pItem)
+        {
+            ai->TellMaster("I could use some food.");
+            ai->UseItem(pItem);
+            return;
+        }
+    }
+
+    if (ai->GetHealthPercent() < 50 && !m_bot->HasAura(RECENTLY_BANDAGED))
+    {
+        Item* fItem = ai->FindBandage();
+        if (fItem)
+        {
+            ai->TellMaster("I could use first aid.");
+            ai->UseItem(fItem);
+            return;
+        }
+    }
+
+    //Heal Voidwalker
+    if (pet && pet->GetEntry() == DEMON_VOIDWALKER && CONSUME_SHADOWS && pet->GetHealthPct() < 75 && !pet->HasAura(CONSUME_SHADOWS))
+        ai->CastPetSpell(CONSUME_SHADOWS);
+
+    // Summon demon
+    if (!pet || m_isTempImp)
+    {
+        uint32 summonSpellId;
+        if (m_demonOfChoice != DEMON_IMP && shardCount > 0)
+        {
+            switch (m_demonOfChoice)
+            {
+                case DEMON_VOIDWALKER:
+                    summonSpellId = SUMMON_VOIDWALKER;
+                    break;
+                case DEMON_FELGUARD:
+                    summonSpellId = SUMMON_FELGUARD;
+                    break;
+                case DEMON_FELHUNTER:
+                    summonSpellId = SUMMON_FELHUNTER;
+                    break;
+                case DEMON_SUCCUBUS:
+                    summonSpellId = SUMMON_SUCCUBUS;
+                    break;
+                default:
+                    summonSpellId = 0;
+            }
+            if (ai->CastSpell(summonSpellId))
+            {
+                ai->TellMaster("Summoning favorite demon...");
+                m_isTempImp = false;
+                return;
+            }
+        }
+        else if (!pet && SUMMON_IMP && ai->CastSpell(SUMMON_IMP))
+        {
+            if (m_demonOfChoice != DEMON_IMP)
+                m_isTempImp = true;
+
+            ai->TellMaster("Summoning Imp...");
+            return;
+        }
+    }
+
+    // Soul link demon
+    if (pet && SOUL_LINK && !m_bot->HasAura(SOUL_LINK_AURA) && ai->CastSpell(SOUL_LINK, *m_bot))
+        return;
+
+    // Check demon buffs
+    if (pet && pet->GetEntry() == DEMON_IMP && BLOOD_PACT && !m_bot->HasAura(BLOOD_PACT) && ai->CastPetSpell(BLOOD_PACT))
+        return;
+
+    if (pet && pet->GetEntry() == DEMON_FELHUNTER && FEL_INTELLIGENCE && !m_bot->HasAura(FEL_INTELLIGENCE) && ai->CastPetSpell(FEL_INTELLIGENCE))
+        return;
+
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
new file mode 100644
index 0000000..a12023f
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
@@ -0,0 +1,250 @@
+#ifndef _PlayerbotWarlockAI_H
+#define _PlayerbotWarlockAI_H
+
+#include "PlayerbotAI.h"
+
+#define SOUL_SHARD 6265
+#define MAX_SHARD_COUNT 4 // Maximum soul shard count bot should keep
+
+enum
+{
+    SPELL_CURSES,
+    SPELL_AFFLICTION,
+    SPELL_DESTRUCTION,
+    SPELL_DEMONOLOGY
+};
+
+enum StoneDisplayId
+{
+    FIRESTONE_DISPLAYID   = 7409,
+    SPELLSTONE_DISPLAYID  = 13291,
+    SOULSTONE_DISPLAYID   = 6009,
+    HEALTHSTONE_DISPLAYID = 8026
+};
+
+enum DemonEntry
+{
+    DEMON_IMP        = 416,
+    DEMON_VOIDWALKER = 1860,
+    DEMON_SUCCUBUS   = 1863,
+    DEMON_FELHUNTER  = 417,
+    DEMON_FELGUARD   = 17252
+};
+
+enum DemonSpellIconIds
+{
+    // Imp
+    BLOOD_PACT_ICON       = 541,
+    FIREBOLT_ICON         = 18,
+    FIRE_SHIELD_ICON      = 16,
+    // Felguard
+    ANGUISH_ICON          = 173,
+    CLEAVE_ICON           = 277,
+    INTERCEPT_ICON        = 516,
+    // Felhunter
+    DEVOUR_MAGIC_ICON     = 47,
+    FEL_INTELLIGENCE_ICON = 1940,
+    SHADOW_BITE_ICON      = 2027,
+    SPELL_LOCK_ICON       = 77,
+    // Succubus
+    LASH_OF_PAIN_ICON     = 596,
+    SEDUCTION_ICON        = 48,
+    SOOTHING_KISS_ICON    = 694,
+    // Voidwalker
+    CONSUME_SHADOWS_ICON  = 207,
+    SACRIFICE_ICON        = 693,
+    SUFFERING_ICON        = 9,
+    TORMENT_ICON          = 173
+};
+
+enum WarlockSpells
+{
+    BANISH_1                        = 710,
+    CHALLENGING_HOWL_1              = 59671,
+    CHAOS_BOLT_1                    = 50796,
+    CONFLAGRATE_1                   = 17962,
+    CORRUPTION_1                    = 172,
+    CREATE_FIRESTONE_1              = 6366,
+    CREATE_HEALTHSTONE_1            = 6201,
+    CREATE_SOULSTONE_1              = 693,
+    CREATE_SPELLSTONE_1             = 2362,
+    CURSE_OF_AGONY_1                = 980,
+    CURSE_OF_DOOM_1                 = 603,
+    CURSE_OF_EXHAUSTION_1           = 18223,
+    CURSE_OF_THE_ELEMENTS_1         = 1490,
+    CURSE_OF_TONGUES_1              = 1714,
+    CURSE_OF_WEAKNESS_1             = 702,
+    DARK_PACT_1                     = 18220,
+    DEATH_COIL_WARLOCK_1            = 6789,
+    DEMON_ARMOR_1                   = 706,
+    DEMON_CHARGE_1                  = 54785,
+    DEMON_SKIN_1                    = 687,
+    DEMONIC_CIRCLE_SUMMON_1         = 48018,
+    DEMONIC_CIRCLE_TELEPORT_1       = 48020,
+    DEMONIC_EMPOWERMENT_1           = 47193,
+    DEMONIC_IMMOLATE_1              = 75445,
+    DETECT_INVISIBILITY_1           = 132,
+    DRAIN_LIFE_1                    = 689,
+    DRAIN_MANA_1                    = 5138,
+    DRAIN_SOUL_1                    = 1120,
+    ENSLAVE_DEMON_1                 = 1098,
+    EYE_OF_KILROGG_1                = 126,
+    FEAR_1                          = 5782,
+    FEL_ARMOR_1                     = 28176,
+    FEL_DOMINATION_1                = 18708,
+    HAUNT_1                         = 48181,
+    HEALTH_FUNNEL_1                 = 755,
+    HELLFIRE_1                      = 1949,
+    HOWL_OF_TERROR_1                = 5484,
+    IMMOLATE_1                      = 348,
+    IMMOLATION_AURA_1               = 50589,
+    INCINERATE_1                    = 29722,
+    INFERNO_1                       = 1122,
+    LIFE_TAP_1                      = 1454,
+    METAMORPHOSIS_1                 = 59672,
+    RAIN_OF_FIRE_1                  = 5740,
+    RITUAL_OF_DOOM_1                = 18540,
+    RITUAL_OF_SOULS_1               = 29893,
+    RITUAL_OF_SUMMONING_1           = 698,
+    SEARING_PAIN_1                  = 5676,
+    SEED_OF_CORRUPTION_1            = 27243,
+    SENSE_DEMONS_1                  = 5500,
+    SHADOW_BOLT_1                   = 686,
+    SHADOW_CLEAVE_1                 = 50581,
+    SHADOW_WARD_1                   = 6229,
+    SHADOWBURN_1                    = 17877,
+    SHADOWFLAME_1                   = 47897,
+    SHADOWFURY_1                    = 30283,
+    SOUL_FIRE_1                     = 6353,
+    SOUL_LINK_1                     = 19028,
+    SOULSHATTER_1                   = 29858,
+    SUMMON_FELGUARD_1               = 30146,
+    SUMMON_FELHUNTER_1              = 691,
+    SUMMON_IMP_1                    = 688,
+    SUMMON_SUCCUBUS_1               = 712,
+    SUMMON_VOIDWALKER_1             = 697,
+    UNENDING_BREATH_1               = 5697,
+    UNSTABLE_AFFLICTION_1           = 30108
+};
+
+//class Player;
+class PlayerbotWarlockAI : PlayerbotClassAI
+{
+public:
+    PlayerbotWarlockAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotWarlockAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    //void BuffPlayer(Player *target);
+
+private:
+
+    // CURSES
+    uint32 CURSE_OF_WEAKNESS,
+           CURSE_OF_AGONY,
+           CURSE_OF_EXHAUSTION,
+           CURSE_OF_TONGUES,
+           CURSE_OF_THE_ELEMENTS,
+           CURSE_OF_DOOM;
+
+    // AFFLICTION
+    uint32 CORRUPTION,
+           DRAIN_SOUL,
+           DRAIN_LIFE,
+           DRAIN_MANA,
+           LIFE_TAP,
+           UNSTABLE_AFFLICTION,
+           HAUNT,
+           SEED_OF_CORRUPTION,
+           DARK_PACT,
+           HOWL_OF_TERROR,
+           FEAR;
+
+    // DESTRUCTION
+    uint32 SHADOW_BOLT,
+           IMMOLATE,
+           INCINERATE,
+           SEARING_PAIN,
+           CONFLAGRATE,
+           SOUL_FIRE,
+           SHADOWFURY,
+           CHAOS_BOLT,
+           SHADOWFLAME,
+           HELLFIRE,
+           RAIN_OF_FIRE,
+           SHADOWBURN;
+
+    // DEMONOLOGY
+    uint32 DEMON_SKIN,
+           DEMON_ARMOR,
+           DEMONIC_EMPOWERMENT,
+           SHADOW_WARD,
+           FEL_ARMOR,
+           SOULSHATTER,
+           SOUL_LINK,
+           SOUL_LINK_AURA,
+           HEALTH_FUNNEL,
+           DETECT_INVISIBILITY,
+           CREATE_FIRESTONE,
+           CREATE_SOULSTONE,
+           CREATE_HEALTHSTONE;
+
+    // DEMON SUMMON
+    uint32 SUMMON_IMP,
+           SUMMON_VOIDWALKER,
+           SUMMON_SUCCUBUS,
+           SUMMON_FELHUNTER,
+           SUMMON_FELGUARD;
+
+    // DEMON SKILLS
+    uint32 BLOOD_PACT,
+           FIREBOLT,
+           FIRE_SHIELD,
+           ANGUISH,
+           CLEAVE,
+           INTERCEPT,
+           DEVOUR_MAGIC,
+           FEL_INTELLIGENCE,
+           SHADOW_BITE,
+           SPELL_LOCK,
+           LASH_OF_PAIN,
+           SEDUCTION,
+           SOOTHING_KISS,
+           CONSUME_SHADOWS,
+           SACRIFICE,
+           SUFFERING,
+           TORMENT;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence,
+           LastSpellCurse,
+           LastSpellAffliction,
+           LastSpellDestruction;
+
+    uint32 m_lastDemon;      // Last demon entry used for spell initialization
+    uint32 m_demonOfChoice;  // Preferred demon entry
+    bool m_isTempImp;        // True if imp summoned temporarily until soul shard acquired for demon of choice.
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
new file mode 100644
index 0000000..3bbd503
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
@@ -0,0 +1,354 @@
+/*
+   Name    : PlayerbotWarriorAI.cpp
+   Complete: maybe around 37%
+   Author  : Natsukawa
+   Version : 0.39
+ */
+#include "PlayerbotWarriorAI.h"
+#include "Player.h"
+
+PlayerbotWarriorAI::PlayerbotWarriorAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    BATTLE_STANCE           = ai->initSpell(BATTLE_STANCE_1); //ARMS
+    CHARGE                  = ai->initSpell(CHARGE_1); //ARMS
+    OVERPOWER               = ai->initSpell(OVERPOWER_1); // ARMS
+    HEROIC_STRIKE           = ai->initSpell(HEROIC_STRIKE_1); //ARMS
+    REND                    = ai->initSpell(REND_1); //ARMS
+    THUNDER_CLAP            = ai->initSpell(THUNDER_CLAP_1);  //ARMS
+    HAMSTRING               = ai->initSpell(HAMSTRING_1);  //ARMS
+    MOCKING_BLOW            = ai->initSpell(MOCKING_BLOW_1);  //ARMS
+    RETALIATION             = ai->initSpell(RETALIATION_1);  //ARMS
+    SWEEPING_STRIKES        = ai->initSpell(SWEEPING_STRIKES_1); //ARMS
+    MORTAL_STRIKE           = ai->initSpell(MORTAL_STRIKE_1);  //ARMS
+    BLADESTORM              = ai->initSpell(BLADESTORM_1);  //ARMS
+    HEROIC_THROW            = ai->initSpell(HEROIC_THROW_1);  //ARMS
+    SHATTERING_THROW        = ai->initSpell(SHATTERING_THROW_1);  //ARMS
+    BLOODRAGE               = ai->initSpell(BLOODRAGE_1); //PROTECTION
+    DEFENSIVE_STANCE        = ai->initSpell(DEFENSIVE_STANCE_1); //PROTECTION
+    DEVASTATE               = ai->initSpell(DEVASTATE_1); //PROTECTION
+    SUNDER_ARMOR            = ai->initSpell(SUNDER_ARMOR_1); //PROTECTION
+    TAUNT                   = ai->initSpell(TAUNT_1); //PROTECTION
+    SHIELD_BASH             = ai->initSpell(SHIELD_BASH_1); //PROTECTION
+    REVENGE                 = ai->initSpell(REVENGE_1); //PROTECTION
+    SHIELD_BLOCK            = ai->initSpell(SHIELD_BLOCK_1); //PROTECTION
+    DISARM                  = ai->initSpell(DISARM_1); //PROTECTION
+    SHIELD_WALL             = ai->initSpell(SHIELD_WALL_1); //PROTECTION
+    SHIELD_SLAM             = ai->initSpell(SHIELD_SLAM_1); //PROTECTION
+    VIGILANCE               = ai->initSpell(VIGILANCE_1); //PROTECTION
+    DEVASTATE               = ai->initSpell(DEVASTATE_1); //PROTECTION
+    SHOCKWAVE               = ai->initSpell(SHOCKWAVE_1); //PROTECTION
+    CONCUSSION_BLOW         = ai->initSpell(CONCUSSION_BLOW_1); //PROTECTION
+    SPELL_REFLECTION        = ai->initSpell(SPELL_REFLECTION_1); //PROTECTION
+    LAST_STAND              = ai->initSpell(LAST_STAND_1); //PROTECTION
+    BATTLE_SHOUT            = ai->initSpell(BATTLE_SHOUT_1); //FURY
+    DEMORALIZING_SHOUT      = ai->initSpell(DEMORALIZING_SHOUT_1); //FURY
+    CLEAVE                  = ai->initSpell(CLEAVE_1); //FURY
+    INTIMIDATING_SHOUT      = ai->initSpell(INTIMIDATING_SHOUT_1); //FURY
+    EXECUTE                 = ai->initSpell(EXECUTE_1); //FURY
+    CHALLENGING_SHOUT       = ai->initSpell(CHALLENGING_SHOUT_1); //FURY
+    SLAM                    = ai->initSpell(SLAM_1); //FURY
+    BERSERKER_STANCE        = ai->initSpell(BERSERKER_STANCE_1); //FURY
+    INTERCEPT               = ai->initSpell(INTERCEPT_1); //FURY
+    DEATH_WISH              = ai->initSpell(DEATH_WISH_1); //FURY
+    BERSERKER_RAGE          = ai->initSpell(BERSERKER_RAGE_1); //FURY
+    WHIRLWIND               = ai->initSpell(WHIRLWIND_1); //FURY
+    PUMMEL                  = ai->initSpell(PUMMEL_1); //FURY
+    BLOODTHIRST             = ai->initSpell(BLOODTHIRST_1); //FURY
+    RECKLESSNESS            = ai->initSpell(RECKLESSNESS_1); //FURY
+    RAMPAGE                 = 0; // passive
+    HEROIC_FURY             = ai->initSpell(HEROIC_FURY_1); //FURY
+    COMMANDING_SHOUT        = ai->initSpell(COMMANDING_SHOUT_1); //FURY
+    ENRAGED_REGENERATION    = ai->initSpell(ENRAGED_REGENERATION_1); //FURY
+    PIERCING_HOWL           = ai->initSpell(PIERCING_HOWL_1); //FURY
+
+    RECENTLY_BANDAGED       = 11196; // first aid check
+
+    // racial
+    GIFT_OF_THE_NAARU       = ai->initSpell(GIFT_OF_THE_NAARU_WARRIOR); // draenei
+    STONEFORM               = ai->initSpell(STONEFORM_ALL); // dwarf
+    ESCAPE_ARTIST           = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    SHADOWMELD              = ai->initSpell(SHADOWMELD_ALL); // night elf
+    BLOOD_FURY              = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    WAR_STOMP               = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING              = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN    = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+PlayerbotWarriorAI::~PlayerbotWarriorAI() {}
+
+bool PlayerbotWarriorAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    Player *m_bot = GetPlayerBot();
+    PlayerbotAI *ai = GetAI();
+    PlayerbotAI::CombatOrderType co = ai->GetCombatOrder();
+    float fTargetDist = GetCombatDistance(pTarget);
+
+    if ((co & PlayerbotAI::ORDERS_TANK) && DEFENSIVE_STANCE > 0 && !m_bot->HasAura(DEFENSIVE_STANCE, ObjectGuid::Empty) && ai->CastSpell(DEFENSIVE_STANCE))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("First > Defensive Stance (%d)", DEFENSIVE_STANCE);
+        return true;
+    }
+    else if ((co & PlayerbotAI::ORDERS_TANK) && TAUNT > 0 && m_bot->HasAura(DEFENSIVE_STANCE, ObjectGuid::Empty) && ai->CastSpell(TAUNT, *pTarget))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("First > Taunt (%d)", TAUNT);
+        return false;
+    }
+    else if (BATTLE_STANCE > 0 && !m_bot->HasAura(BATTLE_STANCE, ObjectGuid::Empty) && ai->CastSpell(BATTLE_STANCE))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("First > Battle Stance (%d)", BATTLE_STANCE);
+        return true;
+    }
+    else if (BATTLE_STANCE > 0 && CHARGE > 0 && m_bot->HasAura(BATTLE_STANCE, ObjectGuid::Empty))
+    {
+        if (fTargetDist < 8.0f)
+            return false;
+        else if (fTargetDist > 25.0f)
+            return true;
+        else if (CHARGE > 0 && ai->CastSpell(CHARGE, *pTarget))
+        {
+            float x, y, z;
+            pTarget->GetContactPoint(m_bot, x, y, z, 3.666666f);
+            m_bot->Relocate(x, y, z);
+
+            if (ai->m_confDebugWhisper)
+                ai->TellMaster("First > Charge (%d)", CHARGE);
+            return false;
+        }
+    }
+
+    return false;
+}
+
+void PlayerbotWarriorAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (HEROIC_STRIKE > 0)
+                ai->CastSpell(HEROIC_STRIKE);
+            return;
+    }
+    // ------- Non Duel combat ----------
+
+    // Damage Attacks
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->GetVictim();
+    //float fTargetDist = GetCombatDistance(pTarget);
+    PlayerbotAI::CombatOrderType co = ai->GetCombatOrder();
+
+    // decide what stance to use
+    if ((co & PlayerbotAI::ORDERS_TANK) && !m_bot->HasAura(DEFENSIVE_STANCE, ObjectGuid::Empty) && ai->CastSpell(DEFENSIVE_STANCE))
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("Stance > Defensive");
+        else if (!(co & PlayerbotAI::ORDERS_TANK) && !m_bot->HasAura(BATTLE_STANCE, ObjectGuid::Empty) && ai->CastSpell(BATTLE_STANCE))
+            if (ai->m_confDebugWhisper)
+                ai->TellMaster("Stance > Battle");
+
+    // get spell sequence
+    if (pTarget->IsNonMeleeSpellCast(true))
+        SpellSequence = WarriorSpellPreventing;
+    else if (m_bot->HasAura(BATTLE_STANCE, ObjectGuid::Empty))
+        SpellSequence = WarriorBattle;
+    else if (m_bot->HasAura(DEFENSIVE_STANCE, ObjectGuid::Empty))
+        SpellSequence = WarriorDefensive;
+    else if (m_bot->HasAura(BERSERKER_STANCE, ObjectGuid::Empty))
+        SpellSequence = WarriorBerserker;
+
+    // do shouts, berserker rage, etc...
+    if (BERSERKER_RAGE > 0 && !m_bot->HasAura(BERSERKER_RAGE, ObjectGuid::Empty) && ai->CastSpell(BERSERKER_RAGE))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("Pre > Berseker Rage");
+    }
+    else if (DEMORALIZING_SHOUT > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(DEMORALIZING_SHOUT, ObjectGuid::Empty) && ai->CastSpell(DEMORALIZING_SHOUT))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("Pre > Demoralizing Shout");
+    }
+    else if (BATTLE_SHOUT > 0 && ai->GetRageAmount() >= 10 && !m_bot->HasAura(BATTLE_SHOUT, ObjectGuid::Empty) && ai->CastSpell(BATTLE_SHOUT))
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("Pre > Battle Shout");
+
+    std::ostringstream out;
+    switch (SpellSequence)
+    {
+        case WarriorSpellPreventing:
+            out << "Case Prevent";
+            if (SHIELD_BASH > 0 && ai->GetRageAmount() >= 10 && ai->CastSpell(SHIELD_BASH, *pTarget))
+                out << " > Shield Bash";
+            else if (PUMMEL > 0 && ai->GetRageAmount() >= 10 && ai->CastSpell(PUMMEL, *pTarget))
+                out << " > Pummel";
+            else if (SPELL_REFLECTION > 0 && ai->GetRageAmount() >= 15 && !m_bot->HasAura(SPELL_REFLECTION, ObjectGuid::Empty) && ai->CastSpell(SPELL_REFLECTION, *m_bot))
+                out << " > Spell Reflection";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorBattle:
+            out << "Case Battle";
+            if (EXECUTE > 0 && ai->GetRageAmount() >= 15 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.2 && ai->CastSpell(EXECUTE, *pTarget))
+                out << " > Execute!";
+            else if (LAST_STAND > 0 && !m_bot->HasAura(LAST_STAND, ObjectGuid::Empty) && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.5 && ai->CastSpell(LAST_STAND, *m_bot))
+                out << " > Last Stand!";
+            else if (BLOODRAGE > 0 && ai->GetRageAmount() < 50 && !m_bot->HasAura(BLOODRAGE, ObjectGuid::Empty) && ai->CastSpell(BLOODRAGE, *m_bot))
+                out << " > Bloodrage";
+            else if (DEATH_WISH > 0 && ai->GetRageAmount() >= 10 && !m_bot->HasAura(DEATH_WISH, ObjectGuid::Empty) && ai->CastSpell(DEATH_WISH, *m_bot))
+                out << " > Death Wish";
+            else if (RETALIATION > 0 && pVictim == m_bot && ai->GetAttackerCount() >= 2 && !m_bot->HasAura(RETALIATION, ObjectGuid::Empty) && ai->CastSpell(RETALIATION, *m_bot))
+                out << " > Retaliation";
+            else if (DEMORALIZING_SHOUT > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(DEMORALIZING_SHOUT, ObjectGuid::Empty) && ai->CastSpell(DEMORALIZING_SHOUT, *pTarget))
+                out << " > Demoralizing Shout";
+            else if (SWEEPING_STRIKES > 0 && ai->GetRageAmount() >= 30 && ai->GetAttackerCount() >= 2 && !m_bot->HasAura(SWEEPING_STRIKES, ObjectGuid::Empty) && ai->CastSpell(SWEEPING_STRIKES, *m_bot))
+                out << " > Sweeping Strikes!";
+            else if (BLADESTORM > 0 && ai->GetRageAmount() >= 25 && pVictim == m_bot && !m_bot->HasAura(BLADESTORM, ObjectGuid::Empty) && ai->GetAttackerCount() >= 3 && ai->CastSpell(BLADESTORM, *pTarget))
+                out << " > Bladestorm!";
+            else if (MORTAL_STRIKE > 0 && ai->GetRageAmount() >= 30 && !pTarget->HasAura(MORTAL_STRIKE, ObjectGuid::Empty) && ai->CastSpell(MORTAL_STRIKE, *pTarget))
+                out << " > Mortal Strike";
+            else if (INTIMIDATING_SHOUT > 0 && ai->GetRageAmount() >= 25 && ai->GetAttackerCount() > 5 && ai->CastSpell(INTIMIDATING_SHOUT, *pTarget))
+                out << " > Intimidating Shout";
+            else if (THUNDER_CLAP > 0 && ai->GetRageAmount() >= 20 && pVictim == m_bot && !pTarget->HasAura(THUNDER_CLAP, ObjectGuid::Empty) && ai->CastSpell(THUNDER_CLAP, *pTarget))
+                out << " > Thunder Clap";
+            else if (ENRAGED_REGENERATION > 0 && ai->GetRageAmount() >= 15 && !m_bot->HasAura(BERSERKER_RAGE, ObjectGuid::Empty) && !m_bot->HasAura(ENRAGED_REGENERATION, ObjectGuid::Empty) && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.5 && ai->CastSpell(ENRAGED_REGENERATION, *m_bot))
+                out << " > Enraged Regeneration";
+            else if (SHOCKWAVE > 0 && ai->GetRageAmount() >= 15 && pVictim == m_bot && !pTarget->HasAura(WAR_STOMP, ObjectGuid::Empty) && !pTarget->HasAura(PIERCING_HOWL, ObjectGuid::Empty) && !pTarget->HasAura(SHOCKWAVE, ObjectGuid::Empty) && !pTarget->HasAura(CONCUSSION_BLOW, ObjectGuid::Empty) && ai->CastSpell(SHOCKWAVE, *pTarget))
+                out << " > Shockwave";
+            else if (REND > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(REND, ObjectGuid::Empty) && ai->CastSpell(REND, *pTarget))
+                out << " > Rend";
+            else if (HAMSTRING > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(HAMSTRING, ObjectGuid::Empty) && ai->CastSpell(HAMSTRING, *pTarget))
+                out << " > Hamstring";
+            else if (CHALLENGING_SHOUT > 0 && ai->GetRageAmount() >= 5 && pVictim != m_bot && ai->GetHealthPercent() > 25 && !pTarget->HasAura(MOCKING_BLOW, ObjectGuid::Empty) && !pTarget->HasAura(CHALLENGING_SHOUT, ObjectGuid::Empty) && ai->CastSpell(CHALLENGING_SHOUT, *pTarget))
+                out << " > Challenging Shout";
+            else if (BLOODTHIRST > 0 && ai->GetRageAmount() >= 20 && !m_bot->HasAura(BLOODTHIRST, ObjectGuid::Empty) && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.7 && ai->CastSpell(BLOODTHIRST, *pTarget))
+                out << " > Bloodthrist";
+            else if (CLEAVE > 0 && ai->GetRageAmount() >= 20 && ai->CastSpell(CLEAVE, *pTarget))
+                out << " > Cleave";
+            else if (HEROIC_STRIKE > 0 && ai->GetRageAmount() >= 15 && ai->CastSpell(HEROIC_STRIKE, *pTarget))
+                out << " > Heroic Strike";
+            else if (CONCUSSION_BLOW > 0 && ai->GetRageAmount() >= 15 && !pTarget->HasAura(WAR_STOMP, ObjectGuid::Empty) && !pTarget->HasAura(PIERCING_HOWL, ObjectGuid::Empty) && !pTarget->HasAura(SHOCKWAVE, ObjectGuid::Empty) && !pTarget->HasAura(CONCUSSION_BLOW, ObjectGuid::Empty) && ai->CastSpell(CONCUSSION_BLOW, *pTarget))
+                out << " > Concussion Blow";
+            else if (SLAM > 0 && ai->GetRageAmount() >= 15 && ai->CastSpell(SLAM, *pTarget))
+                out << " > Slam";
+            else if (PIERCING_HOWL > 0 && ai->GetRageAmount() >= 10 && ai->GetAttackerCount() >= 3 && !pTarget->HasAura(WAR_STOMP, ObjectGuid::Empty) && !pTarget->HasAura(PIERCING_HOWL, ObjectGuid::Empty) && !pTarget->HasAura(SHOCKWAVE, ObjectGuid::Empty) && !pTarget->HasAura(CONCUSSION_BLOW, ObjectGuid::Empty) && ai->CastSpell(PIERCING_HOWL, *pTarget))
+                out << " > Piercing Howl";
+            else if (MOCKING_BLOW > 0 && ai->GetRageAmount() >= 10 && pVictim != m_bot && ai->GetHealthPercent() > 25 && !pTarget->HasAura(MOCKING_BLOW, ObjectGuid::Empty) && !pTarget->HasAura(CHALLENGING_SHOUT, ObjectGuid::Empty) && ai->CastSpell(MOCKING_BLOW, *pTarget))
+                out << " > Mocking Blow";
+            else if (OVERPOWER > 0 && ai->GetRageAmount() >= 5 && ai->CastSpell(OVERPOWER, *pTarget))
+                out << " > Overpower";
+            else if (SUNDER_ARMOR > 0 && ai->CastSpell(SUNDER_ARMOR, *pTarget))
+                out << " > Sunder Armor";
+            else if (SHATTERING_THROW > 0 && !pTarget->HasAura(SHATTERING_THROW, ObjectGuid::Empty) && ai->CastSpell(SHATTERING_THROW, *pTarget))
+                out << " > Shattering Throw";
+            else if (HEROIC_THROW > 0 && ai->CastSpell(HEROIC_THROW, *pTarget))
+                out << " > Heroic Throw";
+            else if (m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura(WAR_STOMP, ObjectGuid::Empty) && !pTarget->HasAura(PIERCING_HOWL, ObjectGuid::Empty) && !pTarget->HasAura(SHOCKWAVE, ObjectGuid::Empty) && !pTarget->HasAura(CONCUSSION_BLOW, ObjectGuid::Empty) && ai->CastSpell(WAR_STOMP, *pTarget))
+                out << " > War Stomp";
+            else if (m_bot->getRace() == RACE_HUMAN && m_bot->HasUnitState(UNIT_STATE_STUNNED) || m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(EVERY_MAN_FOR_HIMSELF, *m_bot))
+                out << " > Every Man for Himself";
+            else if (m_bot->getRace() == RACE_UNDEAD_PLAYER && m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(WILL_OF_THE_FORSAKEN, *m_bot))
+                out << " > Will of the Forsaken";
+            else if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && ai->CastSpell(STONEFORM, *m_bot))
+                out << " > Stoneform";
+            else if (m_bot->getRace() == RACE_GNOME && m_bot->HasUnitState(UNIT_STATE_STUNNED) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) && ai->CastSpell(ESCAPE_ARTIST, *m_bot))
+                out << " > Escape Artist";
+            else if (m_bot->getRace() == RACE_NIGHTELF && pVictim == m_bot && ai->GetHealthPercent() < 25 && !m_bot->HasAura(SHADOWMELD, ObjectGuid::Empty) && ai->CastSpell(SHADOWMELD, *m_bot))
+                out << " > Shadowmeld";
+            else if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, ObjectGuid::Empty) && ai->CastSpell(BLOOD_FURY, *m_bot))
+                out << " > Blood Fury";
+            else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, ObjectGuid::Empty) && ai->CastSpell(BERSERKING, *m_bot))
+                out << " > Berserking";
+            else if (m_bot->getRace() == RACE_DRAENEI && ai->GetHealthPercent() < 25 && !m_bot->HasAura(GIFT_OF_THE_NAARU, ObjectGuid::Empty) && ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot))
+                out << " > Gift of the Naaru";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorDefensive:
+            out << "Case Defensive";
+            if (DISARM > 0 && ai->GetRageAmount() >= 15 && !pTarget->HasAura(DISARM, ObjectGuid::Empty) && ai->CastSpell(DISARM, *pTarget))
+                out << " > Disarm";
+            else if (SUNDER_ARMOR > 0 && ai->GetRageAmount() >= 15 && ai->CastSpell(SUNDER_ARMOR, *pTarget))
+                out << " > Sunder Armor";
+            else if (REVENGE > 0 && ai->GetRageAmount() >= 5 && ai->CastSpell(REVENGE, *pTarget))
+                out << " > Revenge";
+            else if (SHIELD_BLOCK > 0 && !m_bot->HasAura(SHIELD_BLOCK, ObjectGuid::Empty) && ai->CastSpell(SHIELD_BLOCK, *m_bot))
+                out << " > Shield Block";
+            else if (SHIELD_WALL > 0 && !m_bot->HasAura(SHIELD_WALL, ObjectGuid::Empty) && ai->CastSpell(SHIELD_WALL, *m_bot))
+                out << " > Shield Wall";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorBerserker:
+            out << "Case Berserker";
+            if (WHIRLWIND > 0 && ai->GetRageAmount() >= 25 && ai->CastSpell(WHIRLWIND, *pTarget))
+                out << " > Whirlwind";
+            out << " > NONE";
+            break;
+    }
+    if (ai->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+}
+
+void PlayerbotWarriorAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // TODO (by Runsttren): check if shout aura bot has is casted by this bot,
+    // otherwise cast other useful shout
+    // If the bot is protect talented, she/he needs stamina not attack power.
+    // With stance change can the shout change to.
+    // Inserted line to battle shout m_bot->HasAura( COMMANDING_SHOUT, ObjectGuid::Empty)
+    // Natsukawa
+    if (((COMMANDING_SHOUT > 0 && !m_bot->HasAura(COMMANDING_SHOUT, ObjectGuid::Empty)) ||
+         (BATTLE_SHOUT > 0 && !m_bot->HasAura(BATTLE_SHOUT, ObjectGuid::Empty))) &&
+        ai->GetRageAmount() < 10 && BLOODRAGE > 0 && !m_bot->HasAura(BLOODRAGE, ObjectGuid::Empty))
+        // we do have a useful shout, no rage coming but can cast bloodrage... do it
+        ai->CastSpell(BLOODRAGE, *m_bot);
+    else if (COMMANDING_SHOUT > 0 && !m_bot->HasAura(COMMANDING_SHOUT, ObjectGuid::Empty))
+        // use commanding shout now
+        ai->CastSpell(COMMANDING_SHOUT, *m_bot);
+    else if (BATTLE_SHOUT > 0 && !m_bot->HasAura(BATTLE_SHOUT, ObjectGuid::Empty) && !m_bot->HasAura(COMMANDING_SHOUT, ObjectGuid::Empty))
+        // use battle shout
+        ai->CastSpell(BATTLE_SHOUT, *m_bot);
+
+    // buff master with VIGILANCE
+    if (VIGILANCE > 0)
+        (!GetMaster()->HasAura(VIGILANCE, ObjectGuid::Empty) && ai->CastSpell(VIGILANCE, *GetMaster()));
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindFood();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, ObjectGuid::Empty) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+    else if (pItem == NULL && fItem == NULL && m_bot->getRace() == RACE_DRAENEI && !m_bot->HasAura(GIFT_OF_THE_NAARU, ObjectGuid::Empty) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I'm casting gift of the naaru.");
+        ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot);
+        return;
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h
new file mode 100644
index 0000000..5c003d7
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h
@@ -0,0 +1,103 @@
+#ifndef _PlayerbotWarriorAI_H
+#define _PlayerbotWarriorAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    WarriorSpellPreventing,
+    WarriorBattle,
+    WarriorDefensive,
+    WarriorBerserker
+};
+
+enum WarriorSpells
+{
+    BATTLE_SHOUT_1                  = 6673,
+    BATTLE_STANCE_1                 = 2457,
+    BERSERKER_RAGE_1                = 18499,
+    BERSERKER_STANCE_1              = 2458,
+    BLADESTORM_1                    = 46924,
+    BLOODRAGE_1                     = 2687,
+    BLOODTHIRST_1                   = 23881,
+    CHALLENGING_SHOUT_1             = 1161,
+    CHARGE_1                        = 100,
+    CLEAVE_1                        = 845,
+    COMMANDING_SHOUT_1              = 469,
+    CONCUSSION_BLOW_1               = 12809,
+    DEATH_WISH_1                    = 12292,
+    DEFENSIVE_STANCE_1              = 71,
+    DEMORALIZING_SHOUT_1            = 1160,
+    DEVASTATE_1                     = 20243,
+    DISARM_1                        = 676,
+    ENRAGED_REGENERATION_1          = 55694,
+    EXECUTE_1                       = 5308,
+    HAMSTRING_1                     = 1715,
+    HEROIC_FURY_1                   = 60970,
+    HEROIC_STRIKE_1                 = 78,
+    HEROIC_THROW_1                  = 57755,
+    INTERCEPT_1                     = 20252,
+    INTERVENE_1                     = 3411,
+    INTIMIDATING_SHOUT_1            = 5246,
+    LAST_STAND_1                    = 12975,
+    MOCKING_BLOW_1                  = 694,
+    MORTAL_STRIKE_1                 = 12294,
+    OVERPOWER_1                     = 7384,
+    PIERCING_HOWL_1                 = 12323,
+    PUMMEL_1                        = 6552,
+    RECKLESSNESS_1                  = 1719,
+    REND_1                          = 772,
+    RETALIATION_1                   = 20230,
+    REVENGE_1                       = 6572,
+    SHATTERING_THROW_1              = 64382,
+    SHIELD_BASH_1                   = 72,
+    SHIELD_BLOCK_1                  = 2565,
+    SHIELD_SLAM_1                   = 23922,
+    SHIELD_WALL_1                   = 871,
+    SHOCKWAVE_1                     = 46968,
+    SLAM_1                          = 1464,
+    SPELL_REFLECTION_1              = 23920,
+    SUNDER_ARMOR_1                  = 7386,
+    SWEEPING_STRIKES_1              = 12328,
+    TAUNT_1                         = 355,
+    THUNDER_CLAP_1                  = 6343,
+    VICTORY_RUSH_1                  = 34428,
+    VIGILANCE_1                     = 50720,
+    WHIRLWIND_1                     = 1680
+};
+
+//class Player;
+
+class PlayerbotWarriorAI : PlayerbotClassAI
+{
+public:
+    PlayerbotWarriorAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotWarriorAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+private:
+    // ARMS
+    uint32 BATTLE_STANCE, CHARGE, HEROIC_STRIKE, REND, THUNDER_CLAP, HAMSTRING, MOCKING_BLOW, RETALIATION, SWEEPING_STRIKES, MORTAL_STRIKE, BLADESTORM, HEROIC_THROW, SHATTERING_THROW;
+
+    // PROTECTION
+    uint32 DEFENSIVE_STANCE, BLOODRAGE, SUNDER_ARMOR, TAUNT, SHIELD_BASH, REVENGE, SHIELD_BLOCK, DISARM, SHIELD_WALL, SHIELD_SLAM, VIGILANCE, DEVASTATE, SHOCKWAVE, CONCUSSION_BLOW, SPELL_REFLECTION, LAST_STAND;
+
+    // FURY
+    uint32 BERSERKER_STANCE, BATTLE_SHOUT, DEMORALIZING_SHOUT, OVERPOWER, CLEAVE, INTIMIDATING_SHOUT, EXECUTE, CHALLENGING_SHOUT, SLAM, INTERCEPT, DEATH_WISH, BERSERKER_RAGE, WHIRLWIND, PUMMEL, BLOODTHIRST, RECKLESSNESS, RAMPAGE, HEROIC_FURY, COMMANDING_SHOUT, ENRAGED_REGENERATION, PIERCING_HOWL;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence;
+};
+
+#endif
diff --git a/src/server/game/Accounts/RBAC.h b/src/server/game/Accounts/RBAC.h
index 7fe503d..9e3ca64 100644
--- a/src/server/game/Accounts/RBAC.h
+++ b/src/server/game/Accounts/RBAC.h
@@ -707,7 +707,17 @@ enum RBACPermissions
     // 06
     // 07
     // 08
-    // 09
+    //NpcBot command permissions
+    RBAC_PERM_COMMAND_NPCBOT                                 = 1100,
+    RBAC_PERM_COMMAND_NPCBOT_ADD                             = 1101,
+    RBAC_PERM_COMMAND_NPCBOT_REMOVE                          = 1102,
+    RBAC_PERM_COMMAND_NPCBOT_RESET                           = 1103,
+    RBAC_PERM_COMMAND_NPCBOT_CMD                             = 1104,
+    RBAC_PERM_COMMAND_NPCBOT_DIST                            = 1105,
+    RBAC_PERM_COMMAND_NPCBOT_INFO                            = 1106,
+    RBAC_PERM_COMMAND_NPCBOT_HELPER                          = 1107,
+    RBAC_PERM_COMMAND_NPCBOT_REVIVE                          = 1108,
+    //end NpcBot
     // 10
     // 11
     // 12
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 6455e3a..8bc0e96 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -108,6 +108,8 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/NpcBots
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/PlayerBots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 6a994d6..6de3599 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -48,6 +48,9 @@
 #include "WorldPacket.h"
 #include "Transport.h"
 
+// npcbot
+#include "bot_ai.h"
+
 TrainerSpell const* TrainerSpellData::Find(uint32 spell_id) const
 {
     TrainerSpellMap::const_iterator itr = spellList.find(spell_id);
@@ -158,6 +161,15 @@ m_originalEntry(0), m_homePosition(), m_transportHomePosition(), m_creatureInfo(
     TriggerJustRespawned = false;
     m_isTempWorldObject = false;
     _focusSpell = NULL;
+
+    //bot
+    m_bot_owner = NULL;
+    m_creature_owner = NULL;
+    m_bots_pet = NULL;
+    m_bot_class = CLASS_NONE;
+    bot_AI = NULL;
+    m_canUpdate = true;
+    //end bot
 }
 
 Creature::~Creature()
@@ -239,6 +251,8 @@ void Creature::RemoveCorpse(bool setSpawnTime)
 {
     if (getDeathState() != CORPSE)
         return;
+    if (bot_AI)
+        return;
 
     m_corpseRemoveTime = time(NULL);
     setDeathState(DEAD);
@@ -446,6 +460,11 @@ bool Creature::UpdateEntry(uint32 entry, CreatureData const* data /*= nullptr*/)
 
 void Creature::Update(uint32 diff)
 {
+    //npcbot: update helper
+    if (!m_canUpdate && bot_AI)
+        return;
+    //end npcbot
+
     if (IsAIEnabled && TriggerJustRespawned)
     {
         TriggerJustRespawned = false;
@@ -1312,6 +1331,11 @@ void Creature::SetCanDualWield(bool value)
 
 void Creature::LoadEquipment(int8 id, bool force /*= true*/)
 {
+    //npcbot: prevent loading equipment for bots
+    if (GetEntry() >= BOT_ENTRY_BEGIN && GetEntry() <= BOT_ENTRY_END) //temp hack
+        return;
+    //end npcbot
+
     if (id == 0)
     {
         if (force)
@@ -2194,6 +2218,9 @@ void Creature::SetInCombatWithZone()
 
 uint32 Creature::GetShieldBlockValue() const                  //dunno mob block value
 {
+    if (bot_AI)
+        return bot_AI->GetShieldBlockValue();
+
     return (getLevel()/2 + uint32(GetStat(STAT_STRENGTH)/20));
 }
 
@@ -2681,6 +2708,173 @@ void Creature::StartPickPocketRefillTimer()
     _pickpocketLootRestore = time(NULL) + sWorld->getIntConfig(CONFIG_CREATURE_PICKPOCKET_REFILL);
 }
 
+uint8 Creature::GetBotClass() const
+{
+    switch (m_bot_class)
+    {
+        case DRUID_BEAR_FORM:
+        case DRUID_CAT_FORM:
+        //case TRAVEL:
+        //case FLY:
+            return CLASS_DRUID;
+        default:
+            return m_bot_class;
+    }
+}
+
+void Creature::SetIAmABot(bool bot)
+{
+    if (!bot)
+    {
+        bot_AI->UnsummonAll();
+        IsAIEnabled = false;
+        bot_AI = NULL;
+        SetGuidValue(UNIT_FIELD_CREATEDBY, ObjectGuid::Empty);
+    }
+}
+
+void Creature::SetBotsPetDied()
+{
+    if (!m_bots_pet)
+        return;
+
+    m_bots_pet->SetCharmerGUID(ObjectGuid::Empty);
+    m_bots_pet->SetCreatureOwner(NULL);
+    //m_bots_pet->GetBotPetAI()->SetCreatureOwner(NULL);
+    m_bots_pet->SetIAmABot(false);
+    m_bot_owner->SetMinion((Minion*)m_bots_pet, false);
+    m_bots_pet->CleanupsBeforeDelete();
+    m_bots_pet->AddObjectToRemoveList();
+    m_bots_pet = NULL;
+}
+
+uint8 Creature::GetBotRoles() const
+{
+    return bot_AI ? bot_AI->GetBotRoles() : 0;
+}
+
+void Creature::SetBotCommandState(CommandStates st, bool force)
+{
+    if (bot_AI && IsAIEnabled)
+        bot_AI->SetBotCommandState(st, force);
+}
+CommandStates Creature::GetBotCommandState() const
+{
+    return bot_AI ? bot_AI->GetBotCommandState() : COMMAND_ABANDON;
+}
+//Bot damage mods
+void Creature::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo);
+}
+void Creature::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+}
+void Creature::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+
+void Creature::ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierEffect(spellInfo, effect_index, value);
+}
+
+bool Creature::GetIAmABot() const
+{
+    return bot_AI && bot_AI->IsMinionAI();
+}
+
+bool Creature::GetIAmABotsPet() const
+{
+    return bot_AI && bot_AI->IsPetAI();
+}
+
+bot_minion_ai* Creature::GetBotMinionAI() const
+{
+    return IsAIEnabled && bot_AI && bot_AI->IsMinionAI() ? const_cast<bot_minion_ai*>(bot_AI->GetMinionAI()) : NULL;
+}
+
+bot_pet_ai* Creature::GetBotPetAI() const
+{
+    return IsAIEnabled && bot_AI && bot_AI->IsPetAI() ? const_cast<bot_pet_ai*>(bot_AI->GetPetAI()) : NULL;
+}
+
+void Creature::InitBotAI(bool asPet)
+{
+    ASSERT(!bot_AI);
+
+    if (asPet)
+        bot_AI = (bot_pet_ai*)AI();
+    else
+        bot_AI = (bot_minion_ai*)AI();
+}
+
+void Creature::SetBotShouldUpdateStats()
+{
+    if (bot_AI)
+        bot_AI->SetShouldUpdateStats();
+}
+
+void Creature::OnBotSummon(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotSummon(summon);
+}
+
+void Creature::OnBotDespawn(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotDespawn(summon);
+}
+
+void Creature::RemoveBotItemBonuses(uint8 slot)
+{
+    if (bot_AI)
+        bot_AI->RemoveItemBonuses(slot);
+}
+void Creature::ApplyBotItemBonuses(uint8 slot)
+{
+    if (bot_AI)
+        bot_AI->ApplyItemBonuses(slot);
+}
+bool Creature::CanUseOffHand() const
+{
+    return bot_AI && bot_AI->CanUseOffHand();
+}
+bool Creature::CanUseRanged() const
+{
+    return bot_AI && bot_AI->CanUseRanged();
+}
+bool Creature::CanEquip(ItemTemplate const* item, uint8 slot) const
+{
+    return bot_AI && bot_AI->CanEquip(item, slot);
+}
+bool Creature::Unequip(uint8 slot) const
+{
+    return bot_AI && bot_AI->Unequip(slot);
+}
+bool Creature::Equip(uint32 itemId, uint8 slot) const
+{
+    return bot_AI && bot_AI->Equip(itemId, slot);
+}
+bool Creature::ResetEquipment(uint8 slot) const
+{
+    return bot_AI && bot_AI->ResetEquipment(slot);
+}
+
+bool Creature::IsQuestBot() const
+{
+    return
+        m_creatureInfo->Entry >= 71000 && m_creatureInfo->Entry < 72000 &&
+        (m_creatureInfo->unit_flags2 & UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+}
+
 void Creature::SetTextRepeatId(uint8 textGroup, uint8 id)
 {
     CreatureTextRepeatIds& repeats = m_textRepeat[textGroup];
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index df83a2f..d521b05 100644
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -37,6 +37,11 @@ class Player;
 class SpellInfo;
 class WorldSession;
 
+// npcbot
+class bot_ai;
+class bot_minion_ai;
+class bot_pet_ai;
+
 enum CreatureFlagsExtra
 {
     CREATURE_FLAG_EXTRA_INSTANCE_BIND       = 0x00000001,       // creature kill bind instance with killer and killer's group
@@ -675,6 +680,46 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         void SetTextRepeatId(uint8 textGroup, uint8 id);
         void ClearTextRepeatGroup(uint8 textGroup);
 
+        //Bot commands
+        Player* GetBotOwner() const { return m_bot_owner; }
+        void SetBotOwner(Player* newowner) { m_bot_owner = newowner; }
+        Creature* GetCreatureOwner() const { return m_creature_owner; }
+        void SetCreatureOwner(Creature* newCreOwner) { m_creature_owner = newCreOwner; }
+        Creature* GetBotsPet() const { return m_bots_pet; }
+        void SetBotsPetDied();
+        void SetBotsPet(Creature* newpet) { /*ASSERT (!m_bots_pet);*/ m_bots_pet = newpet; }
+        void SetIAmABot(bool bot = true);
+        bool GetIAmABot() const;
+        bool GetIAmABotsPet() const;
+        void SetBotClass(uint8 myclass) { m_bot_class = myclass; }
+        uint8 GetBotClass() const;
+        uint8 GetBotRoles() const;
+        bot_ai* GetBotAI() const { return bot_AI; }
+        bot_minion_ai* GetBotMinionAI() const;
+        bot_pet_ai* GetBotPetAI() const;
+        void InitBotAI(bool asPet = false);
+        void SetBotCommandState(CommandStates st, bool force = false);
+        CommandStates GetBotCommandState() const;
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const;
+        void SetBotShouldUpdateStats();
+        void OnBotSummon(Creature* summon);
+        void OnBotDespawn(Creature* summon);
+        void SetCanUpdate(bool can) { m_canUpdate = can; }
+        void RemoveBotItemBonuses(uint8 slot);
+        void ApplyBotItemBonuses(uint8 slot);
+        bool CanUseOffHand() const;
+        bool CanUseRanged() const;
+        bool CanEquip(ItemTemplate const* item, uint8 slot) const;
+        bool Unequip(uint8 slot) const;
+        bool Equip(uint32 itemId, uint8 slot) const;
+        bool ResetEquipment(uint8 slot) const;
+        //advanced
+        bool IsQuestBot() const;
+        //End Bot commands
+
     protected:
         bool CreateFromProto(ObjectGuid::LowType guidlow, uint32 entry, CreatureData const* data = nullptr, uint32 vehId = 0);
         bool InitEntry(uint32 entry, CreatureData const* data = nullptr);
@@ -729,6 +774,15 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         bool CanAlwaysSee(WorldObject const* obj) const override;
 
     private:
+        //bot system
+        Player* m_bot_owner;
+        Creature* m_creature_owner;
+        Creature* m_bots_pet;
+        bot_ai* bot_AI;
+        uint8 m_bot_class;
+        bool m_canUpdate;
+        //end bot system
+
         void ForcedDespawn(uint32 timeMSToDespawn = 0);
         bool CheckNoGrayAggroConfig(uint32 playerLevel, uint32 creatureLevel) const; // No aggro from gray creatures
 
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index 4642244..17b9db8 100644
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -254,6 +254,14 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+    //npcbot
+    if (GetIAmABot() || GetIAmABotsPet())
+    {
+        //TC_LOG_ERROR("TempSummon::UnSummon(): Trying to unsummon Bot %s(owner: %s). Aborted", GetName(), GetBotOwner()->GetName());
+        return;
+    }
+    //end npcbots
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index e4d9e61..215ae6f 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -1857,6 +1857,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summoner);
             break;
         case UNIT_MASK_TOTEM:
+            //npcbot: totem emul step 1
+            if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+                summon = new Totem(properties, summoner->ToCreature()->GetBotOwner());
+            else
+            //end npcbot
             summon = new Totem(properties, summoner);
             break;
         case UNIT_MASK_MINION:
@@ -1878,6 +1883,12 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
     AddToMap(summon->ToCreature());
     summon->InitSummon();
 
+    //npcbot: totem emul step 2
+    if (mask == UNIT_MASK_TOTEM)
+        if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+            summoner->ToCreature()->OnBotSummon(summon);
+    //end npcbot
+
     //ObjectAccessor::UpdateObjectVisibility(summon);
 
     return summon;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index a54767b..1424820 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -88,7 +88,11 @@
 // 64
 // 65
 // 66
-// 67
+// Playerbot mod
+#include "PlayerbotAI.h"
+
+// NPCBot
+#include "bothelper.h"
 // 68
 // 69
 // 70
@@ -562,6 +566,18 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
             AddPct(xp, (*i)->GetAmount());
 
+        //npcbot 4.2.2.1. Apply NpcBot XP reduction
+        if (player->HaveBot() && player->GetNpcBotsCount() > 1)
+        {
+            if (uint8 xp_rate = player->GetNpcBotXpReduction())
+            {
+                int32 ratePct = 100 - (player->GetNpcBotsCount() - 1) * xp_rate;
+                ratePct = std::max<int32>(ratePct, 10); // minimum
+                //ratePct = std::min<int32>(ratePct, 100); // maximum // dead code
+                xp = xp * ratePct / 100;
+            }
+        }
+
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
         if (Pet* pet = player->GetPet())
@@ -912,6 +928,31 @@ Player::Player(WorldSession* session): Unit(true)
     m_timeSyncClient = 0;
     m_timeSyncServer = 0;
 
+    ///////////////////// Bot System ////////////////////////
+    //Playerbot mod
+    m_playerbotAI = NULL;
+    //npcbot
+    _botHlpr = NULL;
+    m_botTimer = 500;
+    m_botCreateTimer = 500;
+    m_bot = NULL;
+    m_enableNpcBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true);
+    m_followdist = sConfigMgr->GetIntDefault("Bot.BaseFollowDistance", 30);
+    m_maxNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.MaxNpcBots", 1), MAX_NPCBOTS);
+    uint8 maxcbots = sConfigMgr->GetIntDefault("Bot.MaxNpcBotsPerClass", 1);
+    m_maxClassNpcBots = maxcbots > 0 ? maxcbots : MAX_NPCBOTS;
+    m_xpReductionNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.XpReductionPercent", 0), 100);
+    m_enableNpcBotsArenas = sConfigMgr->GetBoolDefault("Bot.EnableInArenas", true);
+    m_enableNpcBotsBGs = sConfigMgr->GetBoolDefault("Bot.EnableInBGs", true);
+    m_enableNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.EnableInDungeons", true);
+    m_enableNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.EnableInRaids", true);
+    m_limitNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Dungeons", false);
+    m_limitNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Raids", false);
+    m_NpcBotsCost = sConfigMgr->GetIntDefault("Bot.Cost", 0);
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        m_botmap[i] = new NpcBotMap();
+    ///////////////////// End Bot System ////////////////////////
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
         m_powerFraction[i] = 0;
 
@@ -966,6 +1007,23 @@ Player::~Player()
     delete m_achievementMgr;
     delete m_reputationMgr;
 
+    //Playerbot mod: remove AI if exists
+    if (m_playerbotAI != NULL)
+    {
+        delete m_playerbotAI;
+        m_playerbotAI = NULL;
+    }
+    // NPCBot
+    if (_botHlpr)
+    {
+        delete _botHlpr;
+        _botHlpr = NULL;
+    }
+
+    //Npcbot mod: delete botmap
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        delete m_botmap[i];
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1927,7 +1985,20 @@ void Player::Update(uint32 p_time)
     // Prepatch by LordPsyan
     // 81
     // 82
-    // 83
+    //Playerbot mod: UpdateAI
+    if (m_playerbotAI != NULL)
+        m_playerbotAI->UpdateAI(p_time);
+
+    //NpcBot mod: Update
+    if (m_botTimer > 0)
+    {
+        if (p_time >= m_botTimer)
+            m_botTimer = 0;
+        else
+            m_botTimer -= p_time;
+    }
+    else
+        RefreshBot(p_time);
     // 84
     // 85
     // 86
@@ -2220,6 +2291,12 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         return false;
     }
 
+    // Playerbot mod: if this user has bots, tell them to stop following master
+    // so they don't try to follow the master after the master teleports
+    for (PlayerBotMap::const_iterator itr = GetSession()->GetPlayerBotsBegin(); itr != GetSession()->GetPlayerBotsEnd(); ++itr)
+        if (Player* botPlayer = itr->second)
+            botPlayer->GetMotionMaster()->Clear();
+
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
@@ -2328,6 +2405,13 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         if (!sMapMgr->CanPlayerEnter(mapid, this, false))
             return false;
 
+        //Npcbot mod: prevent crash on InstanceMap::DestroyInstance()... Unit::RemoveFromWorld()
+        //if last player being kicked out of instance while having npcbots
+        //we must remove creature Before it will be removed in Map::UnloadAll()
+        if (GetMapId() != mapid)
+            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+                RemoveBot(m_botmap[i]->m_guid);
+
         //I think this always returns true. Correct me if I am wrong.
         // If the map is not created, assume it is possible to enter it.
         // It will be created in the WorldPortAck.
@@ -2562,6 +2646,936 @@ void Player::RemoveFromWorld()
     }
 }
 
+void Player::RefreshBot(uint32 diff)
+{
+    if (m_botTimer > 0)
+        return;
+
+    if (IsInFlight())
+        m_botTimer = 3000;
+
+    if (!HaveBot())
+        return;
+
+    //BOT REVIVE SUPPORT part 2
+    //Revive timer condition (maybe we should check whole party?)
+    bool partyInCombat = IsInCombat();
+    if (!partyInCombat)
+    {
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        {
+            if (Creature* bot = m_botmap[i]->m_creature)
+            {
+                if (bot->IsInCombat())
+                {
+                    partyInCombat = true;
+                    break;
+                }
+                else if (Creature* pet = bot->GetBotsPet())
+                {
+                    if (pet->IsInCombat())
+                    {
+                        partyInCombat = true;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        ObjectGuid guid = m_botmap[i]->m_guid;
+        m_bot = m_botmap[i]->m_creature;
+
+        //BOT REVIVE SUPPORT part 2
+        //Do not allow bot to be revived if master is in battle
+        if (!partyInCombat)
+        {
+            if (m_botmap[i]->m_reviveTimer > diff)
+            {
+                if (!IsInCombat())
+                    m_botmap[i]->m_reviveTimer -= diff;
+            }
+            else if (m_botmap[i]->m_reviveTimer > 0)
+                m_botmap[i]->m_reviveTimer = 0;
+        }
+
+        if (!m_bot || !m_bot->IsInWorld())
+            continue;
+
+        //!!!BOT UPDATE HELPER!!!
+        m_bot->SetCanUpdate(true);
+        m_bot->IsAIEnabled = true;
+
+        //BOT REVIVE SUPPORT part 3
+        //Revive bot if possible
+        if (m_botmap[i]->m_reviveTimer == 0)
+        {
+            if (m_bot->isDead() && IsAlive() && !IsInCombat() && !InArena() && !IsInFlight() &&
+                !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH) &&
+                !HasInvisibilityAura() && !HasStealthAura())
+            {
+                CreateBot(0, 0, 0, true); //revive
+                continue;
+            }
+
+            //delay next attempt
+            m_botmap[i]->m_reviveTimer = 500;
+        }
+
+        //BOT MUST DIE SUPPORT
+        if (IsInFlight() || !GetGroup() || !GetGroup()->IsMember(m_bot->GetGUID()))//even if bot is dead
+        {
+            RemoveBot(guid, !IsInFlight());
+            continue;
+        }
+
+        //TELEPORT SUPPORT
+        if (!IsInFlight() && IsAlive() && (m_bot->IsAlive() || m_bot->GetMapId() != GetMapId() || RestrictBots()))
+        {
+            if (m_bot->GetMapId() != GetMapId() || RestrictBots())
+            {
+                RemoveBot(guid);
+                continue;
+            }
+            else if (m_bot->GetBotCommandState() != COMMAND_STAY)
+            {
+                if (GetDistance(m_bot) > SIZE_OF_GRIDS)
+                {
+                    ////This thing is not confirmed to be stable
+                    //m_bot->SetOwnerGUID(0);
+                    //m_bot->RemoveFromWorld();
+                    //m_bot->Relocate(this);
+                    ////Creature::AddToWorld(): Skip AIM_Initialize();
+                    //if (m_bot->GetZoneScript())
+                    //    m_bot->GetZoneScript()->OnCreatureCreate(m_bot);
+                    //ObjectAccessor::AddObject(m_bot);
+                    //m_bot->ToUnit()->AddToWorld();
+                    //m_bot->SetOwnerGUID(GetGUID());
+
+                    //This thing is unsafe
+                    m_bot->SetBotsPetDied();
+                    m_bot->OnBotDespawn(NULL);
+                    m_bot->InterruptNonMeleeSpells(true);
+                    m_bot->AttackStop();
+                    m_bot->RemoveAllAttackers();
+                    m_bot->DeleteThreatList();
+                    m_bot->ClearInCombat();
+
+                    m_bot->RemoveNotOwnSingleTargetAuras();
+                    //m_bot->RemoveAllGameObjects();
+                    //m_bot->RemoveAllDynObjects();
+                    //m_bot->ExitVehicle();
+                    //m_bot->UnsummonAllTotems();
+                    //m_bot->RemoveAllControlled();
+                    m_bot->RemoveAreaAurasDueToLeaveWorld();
+                    m_bot->DestroyForNearbyPlayers();
+                    m_bot->ClearUpdateMask(true);
+                    //ObjectAccessor::RemoveObject(m_bot);
+                    m_bot->Relocate(this);
+                    //ObjectAccessor::AddObject(m_bot);
+                    m_bot->ToUnit()->AddToWorld();
+                }
+            }
+        }
+
+        //Update bots manually and prevent from normal updates
+        //This will update bot's AI
+        m_bot->Update(diff);
+        m_bot->SetCanUpdate(false);
+
+        //Update bot's pet manually and prevent from normal updates
+        //This will update pet's AI
+        if (Creature* pet = m_bot->GetBotsPet())
+        {
+            pet->SetCanUpdate(true);
+            pet->IsAIEnabled = true;
+            pet->Update(diff);
+            pet->SetCanUpdate(false);
+        }
+
+        m_bot = NULL;
+    }//end for botmap
+
+    //BOT CREATION/RECREATION SUPPORT
+    if (m_botCreateTimer > diff)
+        m_botCreateTimer -= diff;
+    else
+    {
+        m_botCreateTimer = 250;
+
+        if (!IsInFlight() && IsAlive() && !IsInCombat() && GetBotMustBeCreated() && !RestrictBots())
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+                if (m_botmap[pos]->m_entry != 0 && m_botmap[pos]->m_guid == 0)
+                    CreateBot(m_botmap[pos]->m_entry, m_botmap[pos]->m_race, m_botmap[pos]->m_class);
+    }
+}
+
+void Player::SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, uint32 *equips)
+{
+    if (m_enableNpcBots == false)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact your administration.");
+        ClearBotMustBeCreated(ObjectGuid::Empty, 0, true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry == 0)
+        {
+            m_botmap[pos]->m_guid = ObjectGuid::Empty;//we need it to make sure Player::CreateBot will find this slot
+            m_botmap[pos]->m_entry = m_entry;
+            m_botmap[pos]->m_race = m_race;
+            m_botmap[pos]->m_class = m_class;
+
+            for (uint8 i = 0; i != 18; ++i)
+                m_botmap[pos]->equips[i] = equips[i];
+
+            break;
+        }
+    }
+}
+
+bool Player::GetBotMustBeCreated()
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry != 0 &&
+            (m_botmap[pos]->m_guid == 0 || !ObjectAccessor::FindConnectedPlayer(m_botmap[pos]->m_guid)))
+        {
+            m_botmap[pos]->m_guid = ObjectGuid::Empty;
+            return true;
+        }
+    }
+    return false;
+}
+
+void Player::ClearBotMustBeCreated(ObjectGuid guidOrSlot, bool guid, bool fully)
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if ((guid == true && m_botmap[pos]->m_guid == guidOrSlot) ||
+            (guid == false && pos == guidOrSlot) ||
+            fully)
+        {
+            m_botmap[pos]->m_guid = ObjectGuid::Empty;
+            m_botmap[pos]->m_entry = 0;
+            m_botmap[pos]->m_race = 0;
+            m_botmap[pos]->m_class = 0;
+            m_botmap[pos]->m_creature = NULL;
+
+            for (uint8 i = 0; i != 18; ++i)
+                m_botmap[pos]->equips[i] = 0;
+
+            if (!fully)
+                break;
+        }
+    }
+}
+
+void Player::RemoveBot(ObjectGuid guid, bool final, bool eraseFromDB)
+{
+    if (guid == 0) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        if (m_botmap[i]->m_guid == guid)
+        {
+            m_bot = m_botmap[i]->m_creature;
+            break;
+        }
+    }
+/* Find solution
+    if (!m_bot)
+        m_bot = ObjectAccessor::GetObjectInWorld(guid, (Creature*)NULL);*/
+    if (m_bot)
+    {
+        //do not disband group unless not in dungeon or forced or on logout (Check WorldSession::LogoutPlayer())
+        Group* gr = GetGroup();
+        if (gr && gr->IsMember(guid))
+        {
+            if (gr->GetMembersCount() > 2 || /*!GetMap()->Instanceable() || */(final && eraseFromDB))
+                gr->RemoveMember(guid);
+            else //just cleanup
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_MEMBER);
+                stmt->setUInt32(0, guid.GetCounter());
+                CharacterDatabase.Execute(stmt);
+            }
+        }
+
+        m_bot->SetBotsPetDied();
+        m_bot->OnBotDespawn(NULL);
+        m_bot->SetCharmerGUID(ObjectGuid::Empty);
+        //m_bot->SetBotOwner(NULL);
+        m_bot->SetIAmABot(false);
+        SetMinion((Minion*)m_bot, false);
+        m_bot->CleanupsBeforeDelete();
+        m_bot->AddObjectToRemoveList();
+
+        if (final)//on logout or by command
+        {
+            ClearBotMustBeCreated(guid);
+            if (eraseFromDB)//by command
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_ACTIVE);
+                stmt->setUInt8(0, uint8(0));
+                stmt->setUInt32(1, GetGUID().GetCounter());
+                stmt->setUInt32(2, m_bot->GetEntry());
+                CharacterDatabase.Execute(stmt);
+                //CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u' AND `entry` = '%u'", GetGUID().GetCounter(), m_bot->GetEntry());
+            }
+        }
+        else
+        {
+            ModifyMoney(int64(GetNpcBotCost())); //temp restore money before retake
+
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            {
+                if (m_botmap[pos]->m_guid == guid)
+                {
+                    m_botmap[pos]->m_guid = ObjectGuid::Empty;//reset guid so it can be set during recreation
+                    m_botmap[pos]->m_creature = NULL;
+                }
+            }
+        }
+        m_bot = NULL;
+    }
+}
+
+void Player::CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool revive)
+{
+    if (IsBeingTeleported() || IsInFlight()) return; //don't create bot yet
+    if (isDead() && !revive) return; //not to revive by command so abort
+    if (IsInCombat()) return;
+
+    if (m_bot != NULL && revive)
+    {
+        m_bot->SetHealth(m_bot->GetCreateHealth() / 6);//~15% of base health
+        if (m_bot->getPowerType() == POWER_MANA)
+            m_bot->SetPower(POWER_MANA, m_bot->GetCreateMana());
+        SetUInt32Value(UNIT_NPC_FLAGS, m_bot->GetCreatureTemplate()->npcflag);
+        ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
+        m_bot->setDeathState(ALIVE);
+        m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+        return;
+    }
+    if (m_enableNpcBots == false && revive == false)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact administration.");
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(ObjectGuid::Empty, pos, false);
+        return;
+    }
+    if (!botentry || !botrace || !botclass)
+    {
+        TC_LOG_ERROR("entities.player", "ERROR! CreateBot(): player %s (%u) trying to create bot with entry = %u, race = %u, class = %u, ignored", GetName().c_str(), GetGUID().GetCounter(), botentry, botrace, botclass);
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(ObjectGuid::Empty, pos, false);
+        return;
+    }
+    //npcbot counter is already increased in SetBotMustBeCreated()
+    if (GetNpcBotsCount() > GetMaxNpcBots())
+    {
+        ChatHandler ch(GetSession());
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(ObjectGuid::Empty, pos, false);
+        ch.PSendSysMessage("Youre exceed max npcbots");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    //instance limit check
+    if ((m_limitNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) || (m_limitNpcBotsRaids && GetMap()->IsRaid()))
+    {
+        InstanceMap* map = (InstanceMap*)GetMap();
+        uint32 count = 0;
+        Map::PlayerList const& plMap = map->GetPlayers();
+        for (Map::PlayerList::const_iterator itr = plMap.begin(); itr != plMap.end(); ++itr)
+            if (Player* player = itr->GetSource())
+                count += (1 + player->GetNpcBotsCount());
+
+        //check "more" cuz current bot is queued and we are to choose to remove it or not
+        if (count > map->GetMaxPlayers())
+        {
+            ChatHandler ch(GetSession());
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+                if (m_botmap[pos]->m_entry == botentry)
+                    ClearBotMustBeCreated(ObjectGuid::Empty, pos, false);
+            ch.PSendSysMessage("Instance players limit exceed");
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+    if (GetGroup() && GetGroup()->isRaidGroup() && GetGroup()->IsFull())
+    {
+        ChatHandler ch(GetSession());
+        ch.PSendSysMessage("Your group is Full!");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_entry == botentry)
+            if (m_botmap[pos]->m_reviveTimer != 0)
+                return;
+
+    m_bot = SummonCreature(botentry, *this);
+
+    //check if we have free slot
+    bool _set = false;
+    uint8 slot = 0;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry == botentry && m_botmap[pos]->m_guid == 0)
+        {
+            m_botmap[pos]->m_guid = m_bot->GetGUID();
+            m_botmap[pos]->m_creature = m_bot;//this will save some time but we need guid as well
+            slot = pos;
+            _set = true;
+            break;
+        }
+    }
+    if (!_set)
+    {
+        TC_LOG_ERROR("entities.player", "character %s (%u) is failed to create npcbot! Removing all bots", GetName().c_str(), GetGUID().GetCounter());
+
+        m_bot->CombatStop();
+        m_bot->CleanupsBeforeDelete();
+        m_bot->AddObjectToRemoveList();
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            RemoveBot(m_botmap[pos]->m_guid, true);
+        ClearBotMustBeCreated(ObjectGuid::Empty, false, true);
+        return;
+    }
+
+    m_bot->SetBotOwner(this);
+
+    m_bot->SetGuidValue(UNIT_FIELD_CREATEDBY, GetGUID());
+    SetMinion((Minion*)m_bot, true);
+    m_bot->CombatStop();
+    m_bot->DeleteThreatList();
+    m_bot->AddUnitTypeMask(UNIT_MASK_MINION);
+
+    m_bot->SetByteValue(UNIT_FIELD_BYTES_0, 0, botrace);
+    m_bot->setFaction(getFaction());
+    m_bot->SetLevel(getLevel());
+    m_bot->SetBotClass(botclass);
+    m_bot->AIM_Initialize();
+    m_bot->InitBotAI();
+    m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    InitBotEquips(m_bot);
+
+    //entry is unique for each master's bot so clean it up just in case
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+    uint8 i = 0;
+    stmt->setUInt32(i++, GetGUID().GetCounter());
+    stmt->setUInt32(i++, botentry);
+    stmt->setUInt8(i++, botrace);
+    stmt->setUInt8(i++, botclass);
+    stmt->setUInt8(i++, m_bot->GetBotRoles());
+
+    for (uint8 j = 0; j != 18; ++j)
+        stmt->setUInt32(i++, m_botmap[slot]->equips[j]);
+
+    stmt->setUInt8(i++, uint8(1)); //active
+    CharacterDatabase.Execute(stmt);
+
+    //If we have a group, just add bot
+    if (Group* gr = GetGroup())
+    {
+        if (!gr->IsFull())
+        {
+            if (!gr->AddMember((Player*)m_bot))
+                RemoveBot(m_bot->GetGUID(), true);
+        }
+        else if (!gr->isRaidGroup()) //non-raid group is full
+        {
+            gr->ConvertToRaid();
+            if (!gr->AddMember((Player*)m_bot))
+                RemoveBot(m_bot->GetGUID(), true);
+        }
+        else //raid group is full
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+    else
+    {
+        gr = new Group;
+        if (!gr->Create(this))
+        {
+            delete gr;
+            return;
+        }
+        sGroupMgr->AddGroup(gr);
+        if (!gr->AddMember((Player*)m_bot))
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+
+    if (uint32 cost = GetNpcBotCost())
+        ModifyMoney(-(int32(cost)));
+
+    if (Group* gr = GetGroup())
+    {
+        Group::MemberSlotList const a = gr->GetMemberSlots();
+        //try to remove 'absent' bots
+        for (Group::member_citerator itr = a.begin(); itr != a.end(); ++itr)
+        {
+            if (itr->guid == 0)
+                continue;
+            if (itr->guid.IsPlayer())
+                continue;
+            if (!ObjectAccessor::FindConnectedPlayer(itr->guid))
+                gr->RemoveMember(itr->guid);
+        }
+    }
+} //end Player::CreateBot
+
+uint8 Player::GetNpcBotsCount() const
+{
+    uint8 bots = 0;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_entry != 0)
+            ++bots;
+    return bots;
+}
+
+uint8 Player::GetMaxNpcBots() const
+{
+    return (GetSession()->GetSecurity() == SEC_PLAYER) ? m_maxNpcBots : MAX_NPCBOTS;
+}
+
+bool Player::HaveBot() const
+{
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_entry != 0)
+            return true;
+    return false;
+}
+
+void Player::SendBotCommandState(Creature* cre, CommandStates state)
+{
+    if (!cre) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_creature == cre)
+            cre->SetBotCommandState(state, true);
+}
+//finds bot's slot into master's botmap
+int8 Player::GetNpcBotSlot(ObjectGuid guid) const
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_guid == guid)
+            return pos;
+
+    return -1;
+}
+
+void Player::SetNpcBotDied(ObjectGuid guid)
+{
+    if (!guid) return;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_guid == guid)
+        {
+            m_botmap[pos]->m_reviveTimer = 15000;
+            break;
+        }
+}
+
+//This is called from script_bot_giver.cpp
+std::list<std::string>* Player::GetCharacterList()
+{
+    QueryResult results = CharacterDatabase.PQuery("SELECT name FROM characters WHERE account = '%u' AND guid != '%u'", m_session->GetAccountId(), GetGUID().GetCounter());
+
+    if (!results) return NULL;
+    std::string plName;
+    std::list<std::string>* names = new std::list<std::string>;
+    do
+    {
+        Field* fields = results->Fetch();
+        plName = fields[0].GetString();
+        //if (plName.compare(GetName()) == 0) continue;
+        if (ObjectAccessor::FindPlayerByName(plName)) continue;
+        names->insert(names->end(), plName);
+    } while(results->NextRow());
+    return names;
+}
+
+bool Player::RestrictBots() const
+{
+    return
+        (!m_enableNpcBotsBGs && GetMap()->IsBattleground()) ||
+        (!m_enableNpcBotsArenas && GetMap()->IsBattleArena()) ||
+        (!m_enableNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) ||
+        (!m_enableNpcBotsRaids && GetMap()->IsRaid());
+}
+
+uint32 Player::GetNpcBotCost() const
+{
+    return m_NpcBotsCost ? uint32((m_NpcBotsCost / 80.f) * getLevel()) : 0;
+}
+
+std::string Player::GetNpcBotCostStr() const
+{
+    std::ostringstream money;
+
+    if (uint32 cost = GetNpcBotCost())
+    {
+        uint32 gold = uint32(cost / 10000);
+        cost -= (gold * 10000);
+        uint32 silver = uint32(cost / 100);
+        cost -= (silver * 100);
+
+        if (gold != 0)
+            money << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver != 0)
+            money << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        if (cost)
+            money << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+    }
+    return money.str();
+}
+
+//NPCbot base setup
+void Player::CreateNPCBot(uint8 bot_class)
+{
+    //check if we have too many bots of that class
+    if (HaveBot())
+    {
+        uint8 count = 0;
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            if (m_botmap[i]->m_class == bot_class)
+                ++count;
+        if (count >= m_maxClassNpcBots)
+        {
+            //SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+            ChatHandler ch(GetSession());
+            ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, m_maxClassNpcBots);
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+
+    //check if player cannot afford a bot
+    if (GetMoney() < GetNpcBotCost())
+    {
+        ChatHandler ch(GetSession());
+        std::string str = "You don't have enough money (";
+        str += GetNpcBotCostStr();
+        str += ")!";
+        ch.SendSysMessage(str.c_str());
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_TEMPLATE);
+    std::ostringstream classStr;
+
+    switch (bot_class)
+    {
+        case CLASS_ROGUE:
+            classStr << "rogue_bot";        break;
+        case CLASS_PRIEST:
+            classStr << "priest_bot";       break;
+        case CLASS_DRUID:
+            classStr << "druid_bot";        break;
+        case CLASS_SHAMAN:
+            classStr << "shaman_bot";       break;
+        case CLASS_MAGE:
+            classStr << "mage_bot";         break;
+        case CLASS_WARLOCK:
+            classStr << "warlock_bot";      break;
+        case CLASS_WARRIOR:
+            classStr << "warrior_bot";      break;
+        case CLASS_PALADIN:
+            classStr << "paladin_bot";      break;
+        case CLASS_HUNTER:
+            classStr << "hunter_bot";       break;
+        case CLASS_DEATH_KNIGHT:
+            classStr << "death_knight_bot"; break;
+        default:
+            ChatHandler ch(GetSession());
+            ch.PSendSysMessage("ERROR! unknown bot_class %u", bot_class);
+            ch.SetSentErrorMessage(true);
+            TC_LOG_ERROR("entities.player", "Player::CreateNPCBot() player %u(%s) tried to create bot of unknown/unsupported class %u!", GetGUID().GetCounter(), GetName().c_str(), bot_class);
+            return;
+    }
+
+    uint8 index = 0;
+    stmt->setString(index++, classStr.str());
+    stmt->setUInt8(index++, bot_class);
+
+    //maybe we should remove this check? ;�
+    switch (getRace())
+    {
+        case RACE_NONE:
+        case RACE_HUMAN:
+        case RACE_DWARF:
+        case RACE_NIGHTELF:
+        case RACE_GNOME:
+        case RACE_DRAENEI:
+            stmt->setUInt8(index++, uint8(1));
+            stmt->setUInt8(index++, uint8(3));
+            stmt->setUInt8(index++, uint8(4));
+            stmt->setUInt8(index++, uint8(7));
+            stmt->setUInt8(index++, uint8(11));
+            break;
+
+        case RACE_ORC:
+        case RACE_UNDEAD_PLAYER:
+        case RACE_TAUREN:
+        case RACE_TROLL:
+        case RACE_BLOODELF:
+            stmt->setUInt8(index++, uint8(2));
+            stmt->setUInt8(index++, uint8(5));
+            stmt->setUInt8(index++, uint8(6));
+            stmt->setUInt8(index++, uint8(8));
+            stmt->setUInt8(index++, uint8(10));
+            break;
+    }
+
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+    if (!result)
+    {
+        TC_LOG_FATAL("entities.player", "Player::CreateNPCBot() CANNOT create bot of class %u, not found in DB!", bot_class);
+        return;
+    }
+
+    uint32 entry = 0;
+    uint32 bot_race = 0;
+
+    //find a bot to add
+    //first check randomly selected bot, second check any bot we can add
+    typedef std::list< std::pair<uint32, uint8> > NpcBotsDataTemplate;
+    NpcBotsDataTemplate npcBotsData;
+    do
+    {
+        Field* fields = result->Fetch();
+        uint32 temp_entry = fields[0].GetUInt32();
+        uint8 temp_race = fields[1].GetUInt8();
+        npcBotsData.push_back(std::pair<uint32, uint8>(temp_entry, temp_race));
+    }
+    while (result->NextRow());
+
+    uint32 m_rand = urand(1, uint32(result->GetRowCount()));
+    uint32 tmp_rand = 1;
+    std::list< std::pair<uint32, uint8> >::const_iterator itr = npcBotsData.begin();
+    bool haveSameBot = false;
+    bool moveback = false;
+    bool forcedCheck = false;
+    bool secondCheck = false;
+    while (true)
+    {
+        if (itr == npcBotsData.end()) //end of list is reached (selected bot is checked)
+        {
+            moveback = true;
+            --itr; //tmp_rand is not needed anymore
+            continue;
+        }
+        if (moveback && itr == npcBotsData.begin()) //search is finished, nothing found
+            break;
+        if (tmp_rand == m_rand || haveSameBot)
+        {
+            bool canAdd = true;
+            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            {
+                if (m_botmap[i]->m_entry == itr->first)
+                {
+                    haveSameBot = true;
+                    canAdd = false;
+                    if (!secondCheck)
+                        forcedCheck = true;
+                    secondCheck = true;
+                    break;
+                }
+            }
+            if (canAdd)
+            {
+                entry = itr->first;
+                bot_race = itr->second;
+                break;
+            }
+            if (forcedCheck)
+            {
+                itr = npcBotsData.begin(); //reset searcher pos
+                forcedCheck = false;
+                continue;
+            }
+        }
+        //move through
+        if (moveback)
+            --itr;
+        else
+        {
+            ++itr;
+            ++tmp_rand;
+        }
+    }
+
+    if (!entry || !bot_race)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("No more bots of this class available");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    uint32 equips[18];
+    for (uint8 i = 0; i != 18; ++i)
+        equips[i] = 0;
+
+    //"SELECT equipMhEx, equipOhEx, equipRhEx FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_SYNCH
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP);
+    stmt->setUInt32(0, GetGUID().GetCounter());
+    stmt->setUInt32(1, entry);
+    result = CharacterDatabase.Query(stmt);
+    if (result)
+    {
+        Field* field = result->Fetch();
+        for (uint8 i = 0; i != 18; ++i)
+            equips[i] = field[i].GetUInt32();
+    }
+
+    SetBotMustBeCreated(entry, bot_race, bot_class, equips);
+}
+
+void Player::InitBotEquips(Creature* bot)
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(bot->GetEntry(), id);
+
+    uint8 slot = 0;
+    //Load stored equipment if any
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_creature == bot)
+        {
+            slot = pos;
+
+            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0, m_botmap[pos]->equips[0]);
+            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, m_botmap[pos]->equips[1]);
+            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, m_botmap[pos]->equips[2]);
+
+            if (uint32 mh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0))
+            {
+                if (!einfo || einfo->ItemEntry[0] != mh)
+                {
+                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(mh))
+                    {
+                        bot->SetAttackTime(BASE_ATTACK, proto->Delay);
+                        bot->ApplyBotItemBonuses(0);
+                    }
+                }
+            }
+            if (uint32 oh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1))
+            {
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(oh))
+                {
+                    if (!einfo || einfo->ItemEntry[1] != oh)
+                        bot->ApplyBotItemBonuses(1);
+
+                    if (proto->Class == ITEM_CLASS_WEAPON)
+                    {
+                        bot->SetAttackTime(OFF_ATTACK, proto->Delay);
+                        bot->SetCanDualWield(true);
+                    }
+                    else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    {
+                        if (bot->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                            const_cast<CreatureTemplate*>(bot->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+                    }
+                }
+            }
+            if (uint32 rh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2))
+            {
+                if (!einfo || einfo->ItemEntry[2] != rh)
+                {
+                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(rh))
+                    {
+                        bot->SetAttackTime(RANGED_ATTACK, proto->Delay);
+                        bot->ApplyBotItemBonuses(2);
+                    }
+                }
+            }
+
+            for (uint8 i = 3; i != 18; ++i)
+                bot->ApplyBotItemBonuses(i);
+
+            break;
+        }
+    }
+
+    //Load remaining items as defaults
+    if (einfo)
+    {
+        for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+        {
+            if (bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i) == 0 && einfo->ItemEntry[i] != 0)
+            {
+                bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+                if (i == 1) //off-hand
+                {
+                    if (einfo->ItemEntry[i] != 0 && bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i) == einfo->ItemEntry[i])
+                    {
+                        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[i]))
+                        {
+                            if (proto->Class == ITEM_CLASS_WEAPON)
+                            {
+                                bot->SetAttackTime(OFF_ATTACK, bot->GetBotClass() == CLASS_ROGUE ? 1400 : 1800);
+                                bot->SetCanDualWield(true);
+                            }
+                            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                            {
+                                if (bot->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                                    const_cast<CreatureTemplate*>(bot->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        //while creating new bot he has no equips but equip template so write these to bot map
+        m_botmap[slot]->equips[0] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0);
+        m_botmap[slot]->equips[1] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1);
+        m_botmap[slot]->equips[2] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2);
+    }
+}
+
+uint32 Player::GetBotEquip(Creature* bot, uint8 slot) const
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_creature == bot)
+            return m_botmap[pos]->equips[slot];
+
+    return 0;
+}
+
+void Player::UpdateBotEquips(Creature* bot, uint8 slot, uint32 itemId)
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_creature == bot)
+        {
+            m_botmap[pos]->equips[slot] = itemId;
+
+            //Commit to DB
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_EQUIP);
+            uint8 i;
+            for (i = 0; i != 18; ++i)
+                stmt->setUInt32(i, m_botmap[pos]->equips[i]);
+
+            stmt->setUInt32(18, GetGUID().GetCounter());
+            stmt->setUInt32(19, m_botmap[pos]->m_entry);
+            CharacterDatabase.Execute(stmt);
+
+            break;
+        }
+    }
+}
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2839,7 +3853,10 @@ Creature* Player::GetNPCIfCanInteractWith(ObjectGuid guid, uint32 npcflagmask)
 
     // not unfriendly/hostile
     if (creature->GetReactionTo(this) <= REP_UNFRIENDLY)
+    {
+    if (!creature->IsQuestBot())
         return NULL;
+    }
 
     // not too far
     if (!creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index ad29637..21de542 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -56,6 +56,14 @@ class UpdateMask;
 
 struct CharacterCustomizeInfo;
 
+// Playerbot mod
+class PlayerbotAI;
+
+// NpcBot mod
+struct NpcBotMap;
+#define MAX_NPCBOTS 39
+class BotHelper;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2317,7 +2325,57 @@ class Player : public Unit, public GridObject<Player>
     // 08
     // 09
     // 10
-    // 11
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        // Playerbot mod:
+        void SetPlayerbotAI(PlayerbotAI* ai) { m_playerbotAI = ai; }
+        PlayerbotAI* GetPlayerbotAI() const { return m_playerbotAI; }
+        void SetBotDeathTimer() { m_deathTimer = 0; }
+        std::list<std::string>* GetCharacterList();
+        PlayerTalentMap* GetTalents(uint8 spec) { return m_talents[spec]; }
+        void chompAndTrim(std::string& str);
+        bool getNextQuestId(const std::string& pString, unsigned int& pStartPos, unsigned int& pId);
+        void skill(std::list<uint32>& m_spellsToLearn);
+        void MakeTalentGlyphLink(std::ostringstream &out);
+        bool requiredQuests(const char* pQuestIdString);
+        PlayerMails::reverse_iterator GetMailRBegin() { return m_mail.rbegin();}
+        PlayerMails::reverse_iterator GetMailREnd() { return m_mail.rend();}
+        void UpdateMail();
+        uint32 GetSpec();
+
+        //adds
+        void SetBotTeam(Team team) { if (m_playerbotAI != NULL) m_team = team; }
+
+        void SetBotHelper(BotHelper* hlpr) { ASSERT (!_botHlpr); _botHlpr = hlpr; }
+        BotHelper* GetBotHelper() const { return _botHlpr; }
+        void RefreshBot(uint32 p_time);
+        void CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool revive = false);
+        void CreateNPCBot(uint8 botclass);
+        int8 GetNpcBotSlot(ObjectGuid guid) const;
+        void SendBotCommandState(Creature* cre, CommandStates state);
+        bool HaveBot() const;
+        void RemoveBot(ObjectGuid guid, bool final = false, bool eraseFromDB = true);
+        void SetBot(Creature* cre) { m_bot = cre; }
+        uint8 GetNpcBotsCount() const;
+        void SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, uint32 *equips);
+        void ClearBotMustBeCreated(ObjectGuid value, bool guid = true, bool fully = false);
+        bool GetBotMustBeCreated();
+        uint8 GetBotFollowDist() const { return m_followdist; }
+        void SetBotFollowDist(int8 dist) { m_followdist = dist; }
+        void SetNpcBotDied(ObjectGuid guid);
+        NpcBotMap const* GetBotMap(uint8 pos) const { return m_botmap[pos]; }
+        uint8 GetMaxNpcBots() const;
+        uint8 GetNpcBotXpReduction() const { return m_xpReductionNpcBots; }
+        bool RestrictBots() const;
+        uint32 GetNpcBotCost() const;
+        std::string GetNpcBotCostStr() const;
+        void InitBotEquips(Creature* bot);
+        void UpdateBotEquips(Creature* bot, uint8 slot, uint32 itemId);
+        uint32 GetBotEquip(Creature* bot, uint8 slot) const;
+        /*********************************************************/
+        /***                 END BOT SYSTEM                    ***/
+        /*********************************************************/
     // 12
     // 13
     // 14
@@ -2585,6 +2643,33 @@ class Player : public Unit, public GridObject<Player>
         bool m_needsZoneUpdate;
 
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        //Playerbot mod
+        PlayerbotAI* m_playerbotAI;
+        //npcbot
+        BotHelper* _botHlpr;
+        Creature* m_bot;
+        int8 m_followdist;
+        uint8 m_maxNpcBots;
+        uint8 m_maxClassNpcBots;
+        uint8 m_xpReductionNpcBots;
+        bool m_enableNpcBots;
+        bool m_enableNpcBotsArenas;
+        bool m_enableNpcBotsBGs;
+        bool m_enableNpcBotsDungeons;
+        bool m_enableNpcBotsRaids;
+        bool m_limitNpcBotsDungeons;
+        bool m_limitNpcBotsRaids;
+        uint32 m_NpcBotsCost;
+        uint32 m_botTimer;
+        uint32 m_botCreateTimer;
+        NpcBotMap* m_botmap[MAX_NPCBOTS];
+        /*********************************************************/
+        /***                END BOT SYSTEM                     ***/
+        /*********************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Totem/Totem.cpp b/src/server/game/Entities/Totem/Totem.cpp
index 85ee51a..f54793a 100644
--- a/src/server/game/Entities/Totem/Totem.cpp
+++ b/src/server/game/Entities/Totem/Totem.cpp
@@ -142,6 +142,13 @@ void Totem::UnSummon(uint32 msTime)
         }
     }
 
+    //npcbot: send SummonedCreatureDespawn()
+    if (GetCreatorGUID().IsCreature())
+        if (Unit* bot = ObjectAccessor::FindConnectedPlayer(GetCreatorGUID()))
+            if (bot->ToCreature()->GetIAmABot())
+                bot->ToCreature()->OnBotDespawn(this);
+    //end npcbot
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index fb27fea..5214083 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -24,6 +24,7 @@
 #include "SpellAuras.h"
 #include "SpellAuraEffects.h"
 #include "World.h"
+#include "WorldSession.h"
 
 inline bool _ModifyUInt32(bool apply, uint32& baseValue, int32& amount)
 {
@@ -216,6 +217,10 @@ bool Player::UpdateAllStats()
     RecalculateRating(CR_ARMOR_PENETRATION);
     UpdateAllResistances();
 
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (Creature* bot = GetBotMap(i)->_Cre())
+            bot->SetBotShouldUpdateStats();
+
     return true;
 }
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 6b234df..8253307 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -344,6 +344,17 @@ void Unit::Update(uint32 p_time)
                 m_CombatTimer -= p_time;
         }
     }
+    // update combat timer also for npcbots
+    if (IsInCombat() && GetTypeId() == TYPEID_UNIT && !GetVictim() && (ToCreature()->GetIAmABot() || ToCreature()->GetIAmABotsPet()))
+    {
+        if (m_HostileRefManager.isEmpty())
+        {
+            if (m_CombatTimer <= p_time)
+                ClearInCombat();
+            else
+                m_CombatTimer -= p_time;
+        }
+    }
 
     // not implemented before 3.0.2
     if (uint32 base_att = getAttackTimer(BASE_ATTACK))
@@ -581,6 +592,12 @@ uint32 Unit::DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDam
         if (pet && pet->IsAlive())
             pet->AI()->OwnerAttackedBy(this);
 
+        // NpcBot mod: also signal owned npcbots
+        for (ControlList::const_iterator itr = victim->ToPlayer()->m_Controlled.begin(); itr != victim->ToPlayer()->m_Controlled.end(); ++itr)
+            if (Creature* cre = (*itr)->ToCreature())
+                if (cre->GetIAmABot() && cre->IsAIEnabled)
+                    cre->AI()->OwnerAttackedBy(this);
+
         if (victim->ToPlayer()->GetCommandStatus(CHEAT_GOD))
             return 0;
     }
@@ -999,6 +1016,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_RANGED:
             case SPELL_DAMAGE_CLASS_MELEE:
             {
+            //Npcbot mod: apply bot damage mods
+            if (Creature* bot = ToCreature())
+                if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                    bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
+
                 // Physical Damage
                 if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
                 {
@@ -1056,6 +1078,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_NONE:
             case SPELL_DAMAGE_CLASS_MAGIC:
             {
+            //Npcbot mod: apply bot damage mods
+            if (Creature* bot = ToCreature())
+                if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                    bot->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
+
                 // If crit add critical bonus
                 if (crit)
                 {
@@ -1173,6 +1200,11 @@ void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* dam
     // Script Hook For CalculateMeleeDamage -- Allow scripts to change the Damage pre class mitigation calculations
     sScriptMgr->ModifyMeleeDamage(damageInfo->target, damageInfo->attacker, damage);
 
+    //Npcbot mod: apply bot damage mods
+    if (Creature* bot = ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo);
+
     // Calculate armor reduction
     if (IsDamageReducedByArmor((SpellSchoolMask)(damageInfo->damageSchoolMask)))
     {
@@ -10485,6 +10517,7 @@ float Unit::GetUnitSpellCriticalChance(Unit* victim, SpellInfo const* spellProto
     //! Mobs can't crit with spells. Player Totems can
     //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
     if (GetGUID().IsCreatureOrVehicle() && !(IsTotem() && GetOwnerGUID().IsPlayer()) && GetEntry() != 15438)
+        if (!ToCreature()->GetIAmABot())
         return 0.0f;
 
     // not critting spell
@@ -13281,6 +13314,11 @@ bool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, f
             break;
     }
 
+    if (Player* master = ToPlayer())
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            if (Creature* bot = master->GetBotMap(i)->_Cre())
+                bot->SetBotShouldUpdateStats();
+
     return true;
 }
 
@@ -16736,6 +16774,182 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form) const
                 break;
         }
     }
+    else if (ToCreature() && ToCreature()->GetIAmABot())
+    {
+        Player const *player = ToCreature()->GetBotOwner();
+        //let's make druids alike for each player
+        switch (form)
+        {
+            case FORM_CAT:
+                // Based on master's Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 7: // Violet
+                        case 8:
+                            return 29405;
+                        case 3: // Light Blue
+                            return 29406;
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29407;
+                        case 4: // White
+                            return 29408;
+                        default: // original - Dark Blue
+                            return 892;
+                    }
+                }
+                // Based on master's Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male master
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 12: // White
+                            case 13:
+                            case 14:
+                            case 18: // Completly White
+                                return 29409;
+                            case 9: // Light Brown
+                            case 10:
+                            case 11:
+                                return 29410;
+                            case 6: // Brown
+                            case 7:
+                            case 8:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3: // Dark Grey
+                            case 4:
+                            case 5:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                    // Female master
+                    else switch (skinColor)
+                    {
+                        case 10: // White
+                            return 29409;
+                        case 6: // Light Brown
+                        case 7:
+                            return 29410;
+                        case 4: // Brown
+                        case 5:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 892;
+                else
+                    return 8571;
+            case FORM_DIREBEAR:
+            case FORM_BEAR:
+                // Based on Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29413; // 29415?
+                        case 6: // Dark Blue
+                            return 29414;
+                        case 4: // White
+                            return 29416;
+                        case 3: // Light Blue
+                            return 29417;
+                        default: // original - Violet
+                            return 2281;
+                    }
+                }
+                // Based on Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                            case 2:
+                                return 29418;
+                            case 3: // White
+                            case 4:
+                            case 5:
+                            case 12:
+                            case 13:
+                            case 14:
+                                return 29419;
+                            case 9: // Light Brown/Grey
+                            case 10:
+                            case 11:
+                            case 15:
+                            case 16:
+                            case 17:
+                                return 29420;
+                            case 18: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                    // Female
+                    else switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                            return 29418;
+                        case 2: // White
+                        case 3:
+                            return 29419;
+                        case 6: // Light Brown/Grey
+                        case 7:
+                        case 8:
+                        case 9:
+                            return 29420;
+                        case 10: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 2281;
+                else
+                    return 2289;
+            case FORM_FLIGHT:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 20857;
+                return 20872;
+            case FORM_FLIGHT_EPIC:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 21243;
+                return 21244;
+            default:
+                break;
+        }
+    }
 
     uint32 modelid = 0;
     SpellShapeshiftEntry const* formEntry = sSpellShapeshiftStore.LookupEntry(form);
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 622ed02..645db89 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -7868,6 +7868,82 @@ SkillRangeType GetSkillRangeType(SkillRaceClassInfoEntry const* rcEntry)
     return SKILL_RANGE_LEVEL;
 }
 
+void ObjectMgr::LoadCreatureOutfits()
+{
+    uint32 oldMSTime = getMSTime();
+
+    _creatureOutfitStore.clear();                           // for reload case (test only)
+
+    //                                                 0     1      2      3     4     5       6           7
+    QueryResult result = WorldDatabase.Query("SELECT entry, race, gender, skin, face, hair, haircolor, facialhair, "
+        //8       9        10    11     12     13    14     15     16     17     18
+        "head, shoulders, body, chest, waist, legs, feet, wrists, hands, back, tabard FROM creature_template_outfits");
+
+    if (!result)
+    {
+        TC_LOG_ERROR("server.loading", ">> Loaded 0 creature outfits. DB table `creature_template_outfits` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 i = 0;
+        uint32 entry     = fields[i++].GetUInt32();
+
+        if (!GetCreatureTemplate(entry))
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits`, but not in `creature_template`!", entry);
+            continue;
+        }
+
+        CreatureOutfit co; // const, shouldnt be changed after saving
+        co.race          = fields[i++].GetUInt8();
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(co.race);
+        if (!rEntry)
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has incorrect race (%u).", entry, uint32(co.race));
+            continue;
+        }
+        co.gender        = fields[i++].GetUInt8();
+        // Set correct displayId
+        switch (co.gender)
+        {
+            case GENDER_FEMALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_f;
+                break;
+            case GENDER_MALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_m;
+                break;
+            default:
+                TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has invalid gender %u", entry, uint32(co.gender));
+                continue;
+        }
+        _creatureTemplateStore[entry].Modelid2 = 0;
+        _creatureTemplateStore[entry].Modelid3 = 0;
+        _creatureTemplateStore[entry].Modelid4 = 0;
+        _creatureTemplateStore[entry].unit_flags2 |= UNIT_FLAG2_MIRROR_IMAGE; // Needed so client requests mirror packet
+
+        co.skin          = fields[i++].GetUInt8();
+        co.face          = fields[i++].GetUInt8();
+        co.hair          = fields[i++].GetUInt8();
+        co.haircolor     = fields[i++].GetUInt8();
+        co.facialhair    = fields[i++].GetUInt8();
+        for (uint32 j = 0; j != MAX_CREATURE_OUTFIT_DISPLAYS; ++j)
+            co.outfit[j] = fields[i+j].GetUInt32();
+
+        _creatureOutfitStore[entry] = co;
+
+        ++count;
+    }
+    while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u creature outfits in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
 void ObjectMgr::LoadGameTele()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 396be44..0cbf04f 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -136,6 +136,21 @@ struct GameTele
 
 typedef std::unordered_map<uint32, GameTele > GameTeleContainer;
 
+#define MAX_CREATURE_OUTFIT_DISPLAYS 11
+struct CreatureOutfit
+{
+    uint8 race;
+    uint8 gender;
+    uint8 face;
+    uint8 skin;
+    uint8 hair;
+    uint8 facialhair;
+    uint8 haircolor;
+    uint32 outfit[MAX_CREATURE_OUTFIT_DISPLAYS];
+};
+
+typedef std::unordered_map<uint32, CreatureOutfit > CreatureOutfitContainer;
+
 enum ScriptsType
 {
     SCRIPTS_FIRST = 1,
@@ -1034,6 +1049,7 @@ class ObjectMgr
 
         void LoadNPCSpellClickSpells();
 
+        void LoadCreatureOutfits();
         void LoadGameTele();
 
         void LoadGossipMenu();
@@ -1248,6 +1264,8 @@ class ObjectMgr
         bool AddGameTele(GameTele& data);
         bool DeleteGameTele(std::string const& name);
 
+        CreatureOutfitContainer const& GetCreatureOutfitMap() const { return _creatureOutfitStore; }
+
         TrainerSpellData const* GetNpcTrainerSpells(uint32 entry) const
         {
             CacheTrainerSpellContainer::const_iterator  iter = _cacheTrainerSpellStore.find(entry);
@@ -1399,6 +1417,8 @@ class ObjectMgr
         PageTextContainer _pageTextStore;
         InstanceTemplateContainer _instanceTemplateStore;
 
+        CreatureOutfitContainer _creatureOutfitStore;
+
     private:
         void LoadScripts(ScriptsType type);
         void LoadQuestRelationsHelper(QuestRelations& map, QuestRelationsReverse* reverseMap, std::string const& table, bool starter, bool go);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 5f50015..3f547f6 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -104,6 +104,9 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    if (leader->HaveBot()) //player + npcbot so set to free-for-all on create
+        m_lootMethod = FREE_FOR_ALL;
+    else
     if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
 
@@ -298,6 +301,7 @@ bool Group::AddLeaderInvite(Player* player)
 void Group::RemoveInvite(Player* player)
 {
     if (player)
+    if (player->GetGUID().IsPlayer())
     {
         m_invitees.erase(player);
         player->SetGroupInvite(NULL);
@@ -363,6 +367,8 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
+    if (player->GetGUID().IsPlayer())
+    {
     player->SetGroupInvite(NULL);
     if (player->GetGroup())
     {
@@ -378,6 +384,7 @@ bool Group::AddMember(Player* player)
     InstanceGroupBind* bind = GetBoundInstance(player);
     if (bind && bind->save->GetInstanceId() == player->GetInstanceId())
         player->m_InstanceValid = true;
+    }
 
     if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
     {
@@ -402,6 +409,10 @@ bool Group::AddMember(Player* player)
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
+    if (player->GetGUID().IsPlayer())
+    {
+    if (player->GetGUID().IsPlayer())
+    {
     if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
     {
         // reset the new member's instances, unless he is currently in one of them
@@ -423,6 +434,7 @@ bool Group::AddMember(Player* player)
             }
         }
     }
+    }
     player->SetGroupUpdateFlag(GROUP_UPDATE_FULL);
     UpdatePlayerOutOfRange(player);
 
@@ -477,6 +489,7 @@ bool Group::AddMember(Player* player)
 
     if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
         m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    }
 
     return true;
 }
@@ -600,6 +613,9 @@ bool Group::RemoveMember(ObjectGuid guid, const RemoveMethod& method /*= GROUP_R
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot
+        if (GetMembersCount() < ((isBGGroup() || isLFGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index b814ab0..5981d71 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -323,6 +323,9 @@ class Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        //Bot
+        ObjectGuid const *GetTargetIcons() const { return m_targetIcons; }
+
     protected:
         bool _setMembersGroup(ObjectGuid guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index c3fe967..b375811 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -47,6 +47,10 @@
 #include "WorldSession.h"
 
 
+//bot
+#include "Config.h"
+#include "PlayerbotAI.h"
+
 class LoginQueryHolder : public SQLQueryHolder
 {
     private:
@@ -997,7 +1001,32 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     // Prepatch by LordPsyan
     // 01
     // 02
-    // 03
+    if (sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true))
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOTS);
+        stmt->setUInt32(0, pCurrChar->GetGUID().GetCounter());
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+        if (result)
+        {
+            uint32 m_bot_entry = 0;
+            uint8 m_bot_race = 0;
+            uint8 m_bot_class = 0;
+            uint32 equips[18];
+            do
+            {
+                Field* fields = result->Fetch();
+                m_bot_entry = fields[0].GetUInt32();
+                m_bot_race = fields[1].GetUInt8();
+                m_bot_class = fields[2].GetInt8();
+                for (uint8 i = 0; i != 18; ++i)
+                    equips[i] = fields[i + 4].GetUInt32();
+
+                if (m_bot_entry && m_bot_race && m_bot_class)
+                    pCurrChar->SetBotMustBeCreated(m_bot_entry, m_bot_race, m_bot_class, equips);
+
+            } while (result->NextRow());
+        }
+    }
     // 04
     // 05
     // 06
@@ -1020,12 +1049,74 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     // End of prepatch
     delete holder;
 }
-    // Prepatch by LordPsyan
-    // 01
-    // 02
-    // 03
-    // 04
-    // 05
+
+//Playerbot mod: is different from the normal
+//HandlePlayerLoginCallback in that it sets up the bot's
+//world session and also stores the pointer to the bot player
+//in the master's world session m_playerBots map
+void WorldSession::HandlePlayerBotLogin(SQLQueryHolder* holder)
+{
+    if (!holder) return;
+
+    LoginQueryHolder* lqh = (LoginQueryHolder*)holder;
+
+    if (!lqh || !lqh->GetAccountId()) // Probably excessively verbose..
+    {
+        //sLog->outError("Excessively verbose Playerbot error checkpoint #1 hit. Please report this error immediately.");
+        if (holder) delete holder;
+        return;
+    }
+
+    WorldSession* masterSession = sWorld->FindSession(lqh->GetAccountId());
+
+    if (!masterSession) // Probably excessively verbose..
+    {
+        //sLog->outError("Excessively verbose Playerbot error checkpoint #2 hit. Please report this error immediately.");
+        if (holder) delete holder;
+        return;
+    }
+
+    //This WorldSession is owned by the bot player object
+    //it will deleted in the Player class constructor for Playerbots
+    //only
+    WorldSession* botSession = new WorldSession(lqh->GetAccountId(), "", NULL, masterSession->GetSecurity(), masterSession->Expansion(), 0, masterSession->GetSessionDbcLocale(), 0, false);
+
+    if (!botSession) // Probably excessively verbose..
+    {
+        //sLog->outError("Excessively verbose Playerbot error checkpoint #3 hit. Please report this error immediately.");
+        if (holder) delete holder;
+        return;
+    }
+
+    ObjectGuid guid = lqh->GetGuid();
+    if (!guid) // Probably excessively verbose..
+    {
+        //sLog->outError("Excessively verbose Playerbot error checkpoint #4 hit. Please report this error immediately.");
+        if (holder) delete holder;
+        if (botSession) delete botSession;
+        return;
+    }
+
+    botSession->HandlePlayerLogin(lqh);
+    Player* const botPlayer = botSession->GetPlayer();
+
+    if (!botPlayer) // Probably excessively verbose..
+    {
+        //sLog->outError("Excessively verbose Playerbot error checkpoint #5 hit. Please report this error immediately.");
+        //if (holder) delete holder; //already deleted in HandlePlayerLogin
+        if (botSession) delete botSession;
+        return;
+    }
+
+    //give the bot some AI, object is owned by the player class
+    PlayerbotAI* ai = new PlayerbotAI(masterSession->GetPlayer(), botPlayer);
+    botPlayer->SetPlayerbotAI(ai);
+
+    //tell the world session that they now manage this new bot
+    (masterSession->m_playerBots)[guid] = botPlayer;
+
+    botSession->m_master = masterSession->GetPlayer();
+}
     // 06
     // 07
     // 08
@@ -1064,6 +1155,57 @@ void WorldSession::HandleSetFactionCheat(WorldPacket& /*recvData*/)
     GetPlayer()->GetReputationMgr().SendStates();
 }
 
+//Playerbot mod - add new player bot for this master. This definition must
+//appear in this file because it utilizes the CharacterHandler class
+//which isn't accessible outside this file
+void WorldSession::AddPlayerBot(ObjectGuid playerGuid)
+{
+    //has bot already been added?
+    if (GetPlayerBot(playerGuid) != 0) return;
+
+    ChatHandler ch = ChatHandler(this);
+
+    //check if bots are enabled
+    if (sConfigMgr->GetBoolDefault("Bot.EnablePlayerBots", true) == false)
+    {
+        ch.SendSysMessage("PlayerBot System is currently disabled. Please contact administration.");
+        return;
+    }
+    //check if max playerbots are exceeded
+    uint8 count = m_playerBots.size();//0;
+    uint8 MaxPlayerbots = sConfigMgr->GetIntDefault("Bot.MaxPlayerbots", 9);
+    if (count >= MaxPlayerbots)
+    {
+        ch.PSendSysMessage("You have reached the maximum number of Player Bots allowed (%u).", MaxPlayerbots);
+        return;
+    }
+    //check level difference
+    uint8 maxDiff = abs(sConfigMgr->GetIntDefault("Bot.MaxLevelDiff", 79));
+    uint8 diff = 0;
+    QueryResult result = CharacterDatabase.PQuery("SELECT level FROM characters WHERE guid = '%u'", playerGuid.GetCounter());
+    if (result)
+    {
+        uint8 botlevel = (*result)[0].GetUInt8();
+        diff = abs(botlevel - GetPlayer()->getLevel());
+        if (diff > maxDiff)
+        {
+            const char* expr = GetPlayer()->getLevel() > botlevel ? "low" : "high";
+            ch.PSendSysMessage("This player is too %s level! (max difference: %u)", expr, maxDiff);
+            return;
+        }
+    }
+
+    LoginQueryHolder* holder = new LoginQueryHolder(GetAccountId(), playerGuid);
+
+    if (!holder->Initialize())
+    {
+        delete holder; //delete all unprocessed queries
+        return;
+    }
+    _charBotLoginCallback = CharacterDatabase.DelayQueryHolder(holder);
+    ch.PSendSysMessage("Bot added successfully.");
+}
+
 void WorldSession::HandleTutorialFlag(WorldPacket& recvData)
 {
     uint32 data;
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index e9c3cea..9a32d31 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -45,7 +45,8 @@
 // 64
 // 65
 // 66
-// 67
+//Playerbot mod
+#include "PlayerbotAI.h"
 // 68
 // 69
 // 70
@@ -291,7 +292,7 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             }
 
             Player* receiver = ObjectAccessor::FindConnectedPlayerByName(to);
-            if (!receiver || (lang != LANG_ADDON && !receiver->isAcceptWhispers() && receiver->GetSession()->HasPermission(rbac::RBAC_PERM_CAN_FILTER_WHISPERS) && !receiver->IsInWhisperWhiteList(sender->GetGUID())))
+            if (!receiver)
             {
                 SendPlayerNotFoundNotice(to);
                 return;
@@ -320,6 +321,17 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 (HasPermission(rbac::RBAC_PERM_CAN_FILTER_WHISPERS) && !sender->isAcceptWhispers() && !sender->IsInWhisperWhiteList(receiver->GetGUID())))
                 sender->AddWhisperWhiteList(receiver->GetGUID());
 
+            //Playerbot mod: handle whispered command to bot
+            if (receiver->GetPlayerbotAI())
+            {
+                if (lang != LANG_ADDON)
+                    receiver->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else
+            //end Playerbot mod
+
             GetPlayer()->Whisper(msg, Language(lang), receiver);
         } break;
         case CHAT_MSG_PARTY:
@@ -339,6 +351,23 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
+            //Playerbot mod: broadcast message to bot members
+            for (GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+
+                if (player && player->GetPlayerbotAI() && (msg.find("help", 0) != -1))
+                {
+                    //only whispered commands should be handled
+                    //so in party chat accept only help request
+                    player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());//send help
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                    break;//only once
+                }
+            }
+            //end Playerbot mod
+
             WorldPacket data;
             ChatHandler::BuildChatPacket(data, ChatMsg(type), Language(lang), sender, NULL, msg);
             group->BroadcastPacket(&data, false, group->GetMemberGroup(GetPlayer()->GetGUID()));
diff --git a/src/server/game/Handlers/GroupHandler.cpp b/src/server/game/Handlers/GroupHandler.cpp
index 30764fe..c1c3879 100644
--- a/src/server/game/Handlers/GroupHandler.cpp
+++ b/src/server/game/Handlers/GroupHandler.cpp
@@ -300,6 +300,13 @@ void WorldSession::HandleGroupUninviteGuidOpcode(WorldPacket& recvData)
 
     if (grp->IsMember(guid))
     {
+        Player* player = ObjectAccessor::FindPlayer(guid);
+        if (player && player->GetPlayerbotAI())
+        {
+            if (Player* master = player->GetSession()->m_master)
+                master->GetSession()->LogoutPlayerBot(guid);
+        }
+        else
         Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK, GetPlayer()->GetGUID(), reason.c_str());
         return;
     }
@@ -345,6 +352,13 @@ void WorldSession::HandleGroupUninviteOpcode(WorldPacket& recvData)
 
     if (ObjectGuid guid = grp->GetMemberGUID(membername))
     {
+        Player* player = ObjectAccessor::FindPlayer(guid);
+        if (player && player->GetPlayerbotAI())
+        {
+            if (Player* master = player->GetSession()->m_master)
+                master->GetSession()->LogoutPlayerBot(guid);
+        }
+        else
         Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK, GetPlayer()->GetGUID());
         return;
     }
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index 2eebbfc..3b0bee8 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -46,6 +46,9 @@
 #include "Battlefield.h"
 #include "BattlefieldMgr.h"
 
+//Bot
+#include "bothelper.h"
+
 void WorldSession::HandleRepopRequestOpcode(WorldPacket& recvData)
 {
     TC_LOG_DEBUG("network", "WORLD: Recvd CMSG_REPOP_REQUEST Message");
@@ -111,6 +114,16 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             return;
         }
     }
+    //Bot
+    else if (guid.IsPlayer())
+    {
+        if (guid != _player->GetGUID())
+        {
+            TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) not found.", uint32(guid.GetCounter()));
+            return;
+        }
+    }
+    //end Bot
     else if (guid.IsGameObject())
     {
         go = _player->GetMap()->GetGameObject(guid);
@@ -148,6 +161,17 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             if (!sScriptMgr->OnGossipSelectCode(_player, unit, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str()))
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
+        //Bot
+        else if (guid == _player->GetGUID())
+        {
+            if (!_player->GetBotHelper())
+            {
+                TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip select.", uint32(guid.GetCounter()));
+                return;
+            }
+            //_player->GetBotHelper()->OnCodedGossipSelect(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str());
+        }
+        //end Bot
         else
         {
             go->AI()->GossipSelectCode(_player, menuId, gossipListId, code.c_str());
@@ -163,6 +187,17 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             if (!sScriptMgr->OnGossipSelect(_player, unit, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId)))
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
+        //Bot
+        else if (guid == _player->GetGUID())
+        {
+            if (!_player->GetBotHelper())
+            {
+                TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip select.", uint32(guid.GetCounter()));
+                return;
+            }
+            _player->GetBotHelper()->OnGossipSelect(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId));
+        }
+        //end Bot
         else
         {
             go->AI()->GossipSelect(_player, menuId, gossipListId);
diff --git a/src/server/game/Handlers/NPCHandler.cpp b/src/server/game/Handlers/NPCHandler.cpp
index f8d7f73..b39b34a 100644
--- a/src/server/game/Handlers/NPCHandler.cpp
+++ b/src/server/game/Handlers/NPCHandler.cpp
@@ -36,6 +36,9 @@
 #include "CreatureAI.h"
 #include "SpellInfo.h"
 
+//Bot
+#include "bothelper.h"
+
 enum StableResultCode
 {
     STABLE_ERR_MONEY        = 0x01,                         // "you don't have enough money"
@@ -292,6 +295,36 @@ void WorldSession::HandleGossipHelloOpcode(WorldPacket& recvData)
     ObjectGuid guid;
     recvData >> guid;
 
+    //Bot
+    if (guid == _player->GetGUID())
+    {
+        if (!_player->GetBotHelper())
+        {
+            TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip hello.", uint32(guid.GetCounter()));
+            return;
+        }
+        _player->GetBotHelper()->OnGossipHello(_player);
+        return;
+    }
+    else if (guid.IsCreature())
+    {
+        if (Creature* qBot = ObjectAccessor::GetCreatureOrPetOrVehicle(*_player, guid))
+        {
+            if (qBot->IsQuestBot() &&
+                (_player->IsAlive() || qBot->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_GHOST) &&
+                (qBot->IsAlive() || (qBot->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_DEAD_INTERACT)))
+            {
+                if (!sScriptMgr->OnGossipHello(_player, qBot))
+                {
+                    TC_LOG_ERROR("network", "WORLD: HandleGossipHelloOpcode - qBot %s (Entry: %u) returned false on gossip hello.",
+                        qBot->GetName().c_str(), qBot->GetEntry());
+                }
+                return;
+            }
+        }
+    }
+    //end Bot
+
     Creature* unit = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
     if (!unit)
     {
diff --git a/src/server/game/Handlers/QuestHandler.cpp b/src/server/game/Handlers/QuestHandler.cpp
index fd7c443..5d4c64e 100644
--- a/src/server/game/Handlers/QuestHandler.cpp
+++ b/src/server/game/Handlers/QuestHandler.cpp
@@ -30,6 +30,8 @@
 #include "Battleground.h"
 #include "ScriptMgr.h"
 #include "GameObjectAI.h"
+// Playerbot mod:
+#include "PlayerbotAI.h"
 
 void WorldSession::HandleQuestgiverStatusQueryOpcode(WorldPacket& recvData)
 {
@@ -587,8 +589,13 @@ void WorldSession::HandlePushQuestToParty(WorldPacket& recvPacket)
             receiver->PlayerTalkClass->SendQuestGiverRequestItems(quest, sender->GetGUID(), receiver->CanCompleteRepeatableQuest(quest), true);
         else
         {
+            if (_player->GetPlayerbotAI())
+                _player->GetPlayerbotAI()->AcceptQuest(quest, _player);
+            else
+            {
             receiver->SetDivider(sender->GetGUID());
             receiver->PlayerTalkClass->SendQuestGiverQuestDetails(quest, sender->GetGUID(), true);
+            }
         }
     }
 }
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index 0f0640e..ba3abf2 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -583,6 +583,36 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
     if (!unit)
         return;
 
+    //bot
+    if (unit->ToCreature())
+    {
+        CreatureOutfitContainer const& outfits = sObjectMgr->GetCreatureOutfitMap();
+        CreatureOutfitContainer::const_iterator it = outfits.find(unit->GetEntry());
+        if (it != outfits.end())
+        {
+            WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+            data << ObjectGuid(guid);
+            data << uint32(unit->GetNativeDisplayId()); // displayId
+            data << uint8(it->second.race);             // race
+            data << uint8(it->second.gender);           // gender
+            data << uint8(unit->getClass());            // class
+            data << uint8(it->second.skin);             // skin
+            data << uint8(it->second.face);             // face
+            data << uint8(it->second.hair);             // hair
+            data << uint8(it->second.haircolor);        // haircolor
+            data << uint8(it->second.facialhair);       // facialhair
+            data << uint32(0);                          // guildId
+
+            // item displays
+            for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
+                data << uint32(it->second.outfit[i]);
+
+            SendPacket(&data);
+            return;
+        }
+    }
+    //end bot
+
     if (!unit->HasAuraType(SPELL_AURA_CLONE_CASTER))
         return;
 
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 6fbef75..9d5d689 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -2794,7 +2794,10 @@ uint32 Map::GetPlayersCountExceptGMs() const
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
         if (!itr->GetSource()->IsGameMaster())
+        {
             ++count;
+            count += itr->GetSource()->GetNpcBotsCount();
+        }
     return count;
 }
 
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 4ea8583..84f1fec 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1510,7 +1510,23 @@ void AddBattlegroundScripts()
 // start97
 // start98
 // start99
-// start100
+// Old NPCBots
+void AddSC_death_knight_bot();
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_script_bot_commands();
+void AddSC_script_bot_giver();
+
+//advanced
+void AddSC_BotQuests_chapter1();
+//end Bots
 // start101
 // start102
 // start103
@@ -1636,7 +1652,22 @@ void AddCustomScripts()
 // end97
 // end98
 // end99
-// end100
+    // Old NPCBots
+    AddSC_death_knight_bot();
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_script_bot_commands();
+    AddSC_script_bot_giver();
+    //advanced
+    AddSC_BotQuests_chapter1();
+    //end Bots
 // end101
 // end102
 // end103
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index b1a043c..9ea2491 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -43,6 +43,8 @@
 #include "WardenWin.h"
 #include "MoveSpline.h"
 #include "WardenMac.h"
+//Playerbot mod
+#include "PlayerbotAI.h"
 
 #include <zlib.h>
 
@@ -189,6 +191,10 @@ ObjectGuid::LowType WorldSession::GetGUIDLow() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket* packet)
 {
+    //Playerbot mod: send packet to bot AI
+    if (GetPlayer() && GetPlayer()->GetPlayerbotAI())
+        GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+
     if (!m_Socket)
         return;
 
@@ -264,9 +270,10 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 
     ///- Before we process anything:
     /// If necessary, kick the player from the character select screen
+/*
     if (IsConnectionIdle())
         m_Socket->CloseSocket();
-
+*/
     ///- Retrieve packets from the receive queue and call the appropriate handlers
     /// not process packets if socket already closed
     WorldPacket* packet = NULL;
@@ -322,6 +329,17 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
                             (this->*opHandle.handler)(*packet);
                             LogUnprocessedTail(packet);
                         }
+                        // Playerbot mod: if this player has bots let the
+                        // botAI see the masters packet
+                        if (!m_playerBots.empty())
+                        {
+                            for (PlayerBotMap::const_iterator itr = m_playerBots.begin(); itr != m_playerBots.end(); ++itr)
+                            {
+                                if (Player* bot = itr->second)
+                                    bot->GetPlayerbotAI()->HandleMasterIncomingPacket(*packet, *this);
+                            }
+                        }
+
                         // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
                         break;
                     case STATUS_LOGGEDIN_OR_RECENTLY_LOGGOUT:
@@ -417,6 +435,28 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
         if (m_Socket && GetPlayer() && _warden)
             _warden->Update();
 
+        // Playerbot mod - Process player bot packets
+        // The PlayerbotAI class adds to the packet queue to simulate a real player
+        // since Playerbots are known to the World obj only by its master's WorldSession object
+        // we need to process all master's bot's packets.
+        for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+        {
+            Player* const botPlayer = itr->second;
+            WorldSession* const pBotWorldSession = botPlayer->GetSession();
+            if (botPlayer->IsBeingTeleportedFar())
+                pBotWorldSession->HandleMoveWorldportAckOpcode();
+            else if (botPlayer->IsInWorld())
+            {
+                WorldPacket* packet;
+                while (pBotWorldSession->_recvQueue.next(packet))
+                {
+                    OpcodeHandler& opHandle = opcodeTable[packet->GetOpcode()];
+                    (pBotWorldSession->*opHandle.handler)(*packet);
+                    delete packet;
+                }
+            }
+        }
+
         ///- Cleanup socket pointer if need
         if (m_Socket && !m_Socket->IsOpen())
         {
@@ -437,6 +477,30 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool save)
 {
+    if (!_player)
+    {
+        return;
+    }
+
+    if (_player->IsMounted()) _player->Dismount();
+
+    uint8 nBotCount = 0;
+    if (_player)
+    {
+        //remove npcbots but do not delete from DB so they can be reacqured on next login
+        for (uint8 i = 0; i != _player->GetMaxNpcBots(); ++i)
+        {
+            if (_player->GetBotMap(i)->_Guid())
+            {
+                _player->RemoveBot(_player->GetBotMap(i)->_Guid(), true, false);
+                ++nBotCount;
+            }
+        }
+    }
+    // Playerbot mod: log out all player bots owned by this toon
+    while (!m_playerBots.empty())
+        LogoutPlayerBot(m_playerBots.begin()->first);
+
     // finish pending transfers before starting the logout
     while (_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -538,6 +602,9 @@ void WorldSession::LogoutPlayer(bool save)
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
         if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+            //bot d) if has no NpcBots or not in instance (trying to save instance)
+            if (nBotCount == 0 || !_player->GetMap()->Instanceable())
+            //end bot
             _player->RemoveFromGroup();
 
         //! Send update to group and reset stored max enchanting level
@@ -676,6 +743,33 @@ void WorldSession::SendAuthWaitQue(uint32 position)
     }
 }
 
+//Playerbot mod: logs out a Playerbot.
+void WorldSession::LogoutPlayerBot(ObjectGuid guid)
+{
+    Player* pPlayerBot = GetPlayerBot(guid);
+
+    if (pPlayerBot) //log out any playbots I have
+    {
+        pPlayerBot->CombatStop();
+        // remove from group
+        Player::RemoveFromGroup(pPlayerBot->GetGroup(), pPlayerBot->GetGUID());
+
+        WorldSession* pPlayerBotWorldSession = pPlayerBot->GetSession();
+        pPlayerBotWorldSession->m_master = NULL;
+        m_playerBots.erase(guid); //deletes bot player ptr inside this WorldSession PlayerBotMap
+        pPlayerBotWorldSession->LogoutPlayer(true); //this will delete the bot Player object and PlayerbotAI object
+        delete pPlayerBotWorldSession; //finally delete the bot's WorldSession
+        pPlayerBotWorldSession = NULL;
+    }
+}
+
+//Playerbot mod: Gets a player bot Player object for this WorldSession master
+Player* WorldSession::GetPlayerBot(ObjectGuid playerGuid) const
+{
+    PlayerBotMap::const_iterator it = m_playerBots.find(playerGuid);
+    return(it == m_playerBots.end()) ? 0 : it->second;
+}
+
 void WorldSession::LoadAccountData(PreparedQueryResult result, uint32 mask)
 {
     for (uint32 i = 0; i < NUM_ACCOUNT_DATA_TYPES; ++i)
@@ -1140,6 +1234,13 @@ void WorldSession::ProcessQueryCallbacks()
         HandlePlayerLogin((LoginQueryHolder*)param);
     }
 
+    //! HandlePlayerBotLogin
+if (_charBotLoginCallback.valid() && _charBotLoginCallback.wait_for(std::chrono::seconds(0)) == std::future_status::ready)
+    {
+        SQLQueryHolder* param = _charBotLoginCallback.get();
+        HandlePlayerBotLogin((SQLQueryHolder*)param);
+    }
+
     //! HandleAddFriendOpcode
     if (_addFriendCallback.IsReady())
     {
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index af2d2d2..635ba4b 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -245,6 +245,34 @@ struct PacketCounter
     uint32 amountCounter;
 };
 
+//Playerbot mod
+typedef std::unordered_map<ObjectGuid, Player*> PlayerBotMap;
+
+//npcbot
+struct NpcBotMap
+{
+    friend class Player;
+    protected:
+        NpcBotMap() : m_guid(), m_entry(0), m_race(0), m_class(0), m_creature(NULL), m_reviveTimer(0)
+        {
+            for (uint8 i = 0; i != 18; ++i)
+                equips[i] = 0;
+        }
+        ObjectGuid m_guid;
+        uint32 m_entry;
+        uint8  m_race;
+        uint8  m_class;
+        Creature* m_creature;
+        uint32 m_reviveTimer;
+        uint32 equips[18];
+
+    public:
+        ObjectGuid _Guid() const { return m_guid; }
+        Creature* _Cre() const { return m_creature; }
+        uint32 const getEquips(uint8 slot) const { return equips[slot]; }
+};
+//end bot mods
+
 /// Player session in the World
 class WorldSession
 {
@@ -252,6 +280,16 @@ class WorldSession
         WorldSession(uint32 id, std::string&& name, std::shared_ptr<WorldSocket> sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter);
         ~WorldSession();
 
+        //Playerbot mod
+        void AddPlayerBot(ObjectGuid guid);
+        void LogoutPlayerBot(ObjectGuid guid);
+        Player* GetPlayerBot(ObjectGuid guid) const;
+        PlayerBotMap m_playerBots;
+        PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return m_playerBots.begin(); }
+        PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return m_playerBots.end();   }
+        Player* m_master;
+        //end Playerbot mod
+
         bool PlayerLoading() const { return m_playerLoading; }
         bool PlayerLogout() const { return m_playerLogout; }
         bool PlayerLogoutWithSave() const { return m_playerLogout && m_playerSave; }
@@ -451,6 +489,7 @@ class WorldSession
         void HandlePlayerLoginOpcode(WorldPacket& recvPacket);
         void HandleCharEnum(PreparedQueryResult result);
         void HandlePlayerLogin(LoginQueryHolder * holder);
+        void HandlePlayerBotLogin(SQLQueryHolder * holder);
         void HandleCharFactionOrRaceChange(WorldPacket& recvData);
         void SendCharCreate(ResponseCodes result);
         void SendCharDelete(ResponseCodes result);
@@ -963,6 +1002,8 @@ class WorldSession
         void HandleEnterPlayerVehicle(WorldPacket& data);
         void HandleUpdateProjectilePosition(WorldPacket& recvPacket);
         void HandleUpdateMissileTrajectory(WorldPacket& recvPacket);
+        // Playerbot
+        QueryResultHolderFuture _charBotLoginCallback;
 
     private:
         void InitializeQueryCallbackParameters();
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index a47ca53..9b13324 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -1553,6 +1553,9 @@ void World::SetInitialWorldSettings()
     TC_LOG_INFO("server.loading", "Loading Creature templates...");
     sObjectMgr->LoadCreatureTemplates();
 
+    TC_LOG_INFO("server.loading", "Loading Creature template outfits...");     // must be after LoadCreatureTemplates
+    sObjectMgr->LoadCreatureOutfits();
+
     TC_LOG_INFO("server.loading", "Loading Equipment templates...");           // must be after LoadCreatureTemplates
     sObjectMgr->LoadEquipmentTemplates();
 
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index 0914089..c30f100 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -574,6 +574,7 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load() override
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -616,6 +617,8 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Player* caster = GetCaster()->ToPlayer();
+                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot())
+                    caster = (Player*)GetCaster();
                 if (Unit* target = GetExplTargetUnit())
                     if (!caster->IsFriendlyTo(target) && !caster->IsValidAttackTarget(target))
                         return SPELL_FAILED_BAD_TARGETS;
@@ -757,6 +760,7 @@ class spell_pri_renew : public SpellScriptLoader
 
             bool Load() override
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 4d2f9d6..cbb192a 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -3441,6 +3441,214 @@ PacketSpoof.BanDuration = 86400
 #
 ###################################################################################################
 
+###################################################################################################
+################################## BOTS CONFIGURATION ############################################
+###################################################################################################
+# PLAYERBOT CONFIGURATION
+#
+#    Bot.EnablePlayerBots
+#        Disable the bot command and bot menu
+#        Default: 1 - enable
+#                       0 - disable
+
+Bot.EnablePlayerBots = 1
+
+#    Bot.FollowDistanceMin
+#    Bot.FollowDistanceMax
+#        Min. and max. follow distance for bots
+#        Default: 0.5 / 2.0
+
+Bot.FollowDistanceMin = 0.5
+Bot.FollowDistanceMax = 1.0
+
+#    Bot.DebugWhisper
+#        Enable debug output by whispering master
+#        Default: 0 - off
+#                 1 - on
+
+Bot.DebugWhisper = 0
+
+#    Bot.MaxPlayerbots
+#        Limits the number of bots per account (Max 9)
+#        Default: 9
+
+Bot.MaxPlayerbots = 9
+
+#    Bot.MaxLevelDiff
+#        Maximum level difference between summoner and bot
+#        Default: 79
+
+Bot.MaxLevelDiff = 79
+
+#    Bot.Collect.Combat
+#    Bot.Collect.Quest
+#    Bot.Collect.Profession
+#    Bot.Collect.Loot
+#    Bot.Collect.Skin
+#    Bot.Collect.Objects
+#        Enable collection options for after combat, quest items, profession, all loot, skin, or nearby objects
+#                 0 - off
+#        Default: 1 - on
+
+Bot.Collect.Combat = 1
+Bot.Collect.Quest = 1
+Bot.Collect.Profession = 1
+Bot.Collect.Loot = 1
+Bot.Collect.Skin = 1
+Bot.Collect.Objects = 1
+
+#    Bot.Collect.Distance
+#        Default distance that bots will search within for collection.
+#        Default: 25 (cannot be more than DistanceMax)
+#
+#    Bot.Collect.DistanceMax
+#        Maximum distance that can be configured for bots to collect objects. Allowing a higher
+#        distance could increase processor usage for object searching.
+#                 1-100
+#        Default: 30
+
+Bot.Collect.Distance = 25
+Bot.Collect.DistanceMax = 30
+
+#    Bot.SellGarbage
+#        Allow bots to automatically sell all [GRAY|POOR] quality items as the player activates vendor
+#        Default: 0 - off
+#                 1 - on
+
+Bot.SellGarbage = 0
+
+#    Bot.SellAll.LevelDiff
+#         If 'sell all' command is given prior to selling, bots will sell all low level white items.. this number is the number
+#         of levels LOWER than the bots level the Item must be before bot will sell it.
+#         Default: 10 (10 levels lower than the bot) Don't set to 0 or they'll sell everything! *SellGarbage must be set to 1 to use this*
+
+Bot.SellAll.LevelDiff = 10
+
+#    Bot.LootMethod
+#        Type of loot method
+#        Default: 2
+#        0 = Free for all
+#        1 = Round robin
+#        2 = Master loot
+#        3 = Group loot
+#        4 = Need before greed
+
+Bot.LootMethod = 2
+
+#    Bot.ChangeFaction
+#        Change bot's faction on login (thy will restore their faction of logout)
+#        Default = 1
+#        0 = false - Do not change
+#        1 = true - Bot and his npcbots will change their faction to master's
+
+Bot.ChangeFaction = 1
+
+#
+###################################################################################################
+
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#     Bot.EnableNpcBots
+#        Enable NpcBot system
+#        Default: 1 - enable
+#                       0 - disable
+
+Bot.EnableNpcBots = 1
+
+#    Bot.MaxNpcBots
+#        Maximum number of Npc Bots allowed per character (disabled for GM accounts)
+#        Default: 1
+#        Recomended: 4
+#        Max: 9
+#        Absolute Max: 39
+
+Bot.MaxNpcBots = 1
+
+#    Bot.MaxNpcBotsPerClass
+#        Maximum Npc Bots of each class allowed per character
+#        If set to 0, no restriction
+#        Default: 1
+
+Bot.MaxNpcBotsPerClass = 1
+
+#    Bot.BaseFollowDistance
+#        Default follow distance set at login
+#        Default: 30
+
+Bot.BaseFollowDistance = 30
+
+#    Bot.XpReductionPercent
+#        Since bot party can be pretty large, it can become an exploit to farm xp so you can reduce xp gain here
+#        PERCENT of  'XP.KILL'  reward reduction from each Npc Bots used (Starting with second)
+#        Example:
+#            You have 3 bots, xp reduction is 20 then reduction will be ((3-1)*20) = 40%; 60% exp gained only
+#        Note: Minimum xp rate will be 10%
+#        Min: 0
+#        Max: 90
+#        Default: 0
+
+Bot.XpReductionPercent = 0
+
+#    Bot.HealTargetIconsMask
+#        Icon number bitmask which bots are using to search for additional targets to heal (out of party)
+#        1 - Star
+#        2 - Circle
+#        4 - Diamond
+#        8 - Triangle
+#        16 - Moon
+#        32 - Square
+#        64 - Cross
+#        128 - Skull
+#        Example: to check Star, Triangle and Square we need 1832 = 41
+#        Note that many creatures cannot accept heal
+#        Min: 0 (Disable)
+#        Max: 255 (Any Icon)
+#        Default: 8 (Triangle)
+
+Bot.HealTargetIconsMask = 8
+
+#    Bot.DamageMult
+#        Myltiplier for bot's damage dealt. Allows to balance bots' compared to players' damage
+#        Any damage done by bots will be modified
+#        Range: 0.01 - 10.0
+#        Default: 1.0
+
+Bot.DamageMult.Melee = 1.0
+Bot.DamageMult.Spell = 1.0
+
+#    Bot.EnableIn... Arenas/BGs/Dungeons/Raids
+#        Allows to restrict bots usage in PvE and/or PvP
+#        Default: true for all
+
+Bot.EnableInArenas = 1
+Bot.EnableInBGs = 1
+Bot.EnableInDungeons = 1
+Bot.EnableInRaids = 1
+
+#    Bot.InstanceLimit... Dungeons/Raids
+#        If set to 1 will apply instance players limitation to bots
+#        Default: false for all
+
+Bot.InstanceLimit.Dungeons = 0
+Bot.InstanceLimit.Raids = 0
+
+#    Bot.Cost
+#        Bot recruitment cost (in copper)
+#        Note: this value is set for lvl 80 characters. Cost will be reduced for lower levels
+#        Default: 0
+
+Bot.Cost = 0
+
+#    Bot.PvP
+#        If set to 0 bots will not attack  players or other bots
+#        Default: 1
+
+Bot.PvP = 1
+
+#
+###################################################################################################
+
 #
 # Prepatch by LordPsyan.
 # See http://www.realmsofwarcraft.com/bb for forums and information.
-- 
2.1.4

